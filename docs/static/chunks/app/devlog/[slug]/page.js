/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/devlog/[slug]/page"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fdevlog%2Fpages%2FDevlog.tsx%22%2C%22ids%22%3A%5B%22Devlog%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fmdx%2Fcomponents%2FCode.tsx%22%2C%22ids%22%3A%5B%22Code%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fmdx%2Finline%2Fcode.tsx%22%2C%22ids%22%3A%5B%22Code%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fkatex%400.16.33%2Fnode_modules%2Fkatex%2Fdist%2Fkatex.min.css%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fdevlog%2Fpages%2FDevlog.tsx%22%2C%22ids%22%3A%5B%22Devlog%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fmdx%2Fcomponents%2FCode.tsx%22%2C%22ids%22%3A%5B%22Code%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fmdx%2Finline%2Fcode.tsx%22%2C%22ids%22%3A%5B%22Code%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fkatex%400.16.33%2Fnode_modules%2Fkatex%2Fdist%2Fkatex.min.css%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./modules/devlog/pages/Devlog.tsx */ \"(app-pages-browser)/./modules/devlog/pages/Devlog.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./modules/mdx/components/Code.tsx */ \"(app-pages-browser)/./modules/mdx/components/Code.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./modules/mdx/inline/code.tsx */ \"(app-pages-browser)/./modules/mdx/inline/code.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/.pnpm/katex@0.16.33/node_modules/katex/dist/katex.min.css */ \"(app-pages-browser)/./node_modules/.pnpm/katex@0.16.33/node_modules/katex/dist/katex.min.css\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZzYXRoaXJhJTJGUHJvamVjdHMlMkZncm90dG8lMkZtb2R1bGVzJTJGZGV2bG9nJTJGcGFnZXMlMkZEZXZsb2cudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyRGV2bG9nJTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGc2F0aGlyYSUyRlByb2plY3RzJTJGZ3JvdHRvJTJGbW9kdWxlcyUyRm1keCUyRmNvbXBvbmVudHMlMkZDb2RlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMkNvZGUlMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZzYXRoaXJhJTJGUHJvamVjdHMlMkZncm90dG8lMkZtb2R1bGVzJTJGbWR4JTJGaW5saW5lJTJGY29kZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJDb2RlJTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGc2F0aGlyYSUyRlByb2plY3RzJTJGZ3JvdHRvJTJGbm9kZV9tb2R1bGVzJTJGLnBucG0lMkZrYXRleCU0MDAuMTYuMzMlMkZub2RlX21vZHVsZXMlMkZrYXRleCUyRmRpc3QlMkZrYXRleC5taW4uY3NzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsNExBQStIO0FBQy9IO0FBQ0EsNExBQTZIO0FBQzdIO0FBQ0Esb0xBQXlIO0FBQ3pIO0FBQ0EsMFFBQTBJIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJEZXZsb2dcIl0gKi8gXCIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbW9kdWxlcy9kZXZsb2cvcGFnZXMvRGV2bG9nLnRzeFwiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiQ29kZVwiXSAqLyBcIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9tb2R1bGVzL21keC9jb21wb25lbnRzL0NvZGUudHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJDb2RlXCJdICovIFwiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL21vZHVsZXMvbWR4L2lubGluZS9jb2RlLnRzeFwiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9rYXRleEAwLjE2LjMzL25vZGVfbW9kdWxlcy9rYXRleC9kaXN0L2thdGV4Lm1pbi5jc3NcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fdevlog%2Fpages%2FDevlog.tsx%22%2C%22ids%22%3A%5B%22Devlog%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fmdx%2Fcomponents%2FCode.tsx%22%2C%22ids%22%3A%5B%22Code%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fmdx%2Finline%2Fcode.tsx%22%2C%22ids%22%3A%5B%22Code%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fkatex%400.16.33%2Fnode_modules%2Fkatex%2Fdist%2Fkatex.min.css%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/buffer/index.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/buffer/index.js ***!
  \************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixF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LFVBQVUsTUFBTSxlQUFlLCtCQUErQixLQUFLLGtCQUFrQixNQUFNLGtDQUFrQyw4QkFBOEIsVUFBVSxjQUFjLGVBQWUsV0FBVywrQ0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs2NzU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw3MjpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi92YXIgZj10KDY3NSk7dmFyIG49dCg3ODMpO3ZhciBpPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO3IuQnVmZmVyPUJ1ZmZlcjtyLlNsb3dCdWZmZXI9U2xvd0J1ZmZlcjtyLklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBvPTIxNDc0ODM2NDc7ci5rTWF4TGVuZ3RoPW87QnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dHlwZWRBcnJheVN1cHBvcnQoKTtpZighQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQmJnR5cGVvZiBjb25zb2xlIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgXCIrXCJgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKX1mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTt2YXIgcj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihlLHIpO3JldHVybiBlLmZvbygpPT09NDJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXR9fSk7ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGUpe2lmKGU+byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQnVmZmVyKGUscix0KXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX1yZXR1cm4gYWxsb2NVbnNhZmUoZSl9cmV0dXJuIGZyb20oZSxyLHQpfUJ1ZmZlci5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGZyb20oZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZyb21TdHJpbmcoZSxyKX1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGU9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmKGlzSW5zdGFuY2UoZSxTaGFyZWRBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXZhciBmPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYoZiE9bnVsbCYmZiE9PWUpe3JldHVybiBCdWZmZXIuZnJvbShmLHIsdCl9dmFyIG49ZnJvbU9iamVjdChlKTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBCdWZmZXIuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9QnVmZmVyLmZyb209ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBmcm9tKGUscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsVWludDhBcnJheSk7ZnVuY3Rpb24gYXNzZXJ0U2l6ZShlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKX1lbHNlIGlmKGU8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9fWZ1bmN0aW9uIGFsbG9jKGUscix0KXthc3NlcnRTaXplKGUpO2lmKGU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoZSl9aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGVvZiB0PT09XCJzdHJpbmdcIj9jcmVhdGVCdWZmZXIoZSkuZmlsbChyLHQpOmNyZWF0ZUJ1ZmZlcihlKS5maWxsKHIpfXJldHVybiBjcmVhdGVCdWZmZXIoZSl9QnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gYWxsb2MoZSxyLHQpfTtmdW5jdGlvbiBhbGxvY1Vuc2FmZShlKXthc3NlcnRTaXplKGUpO3JldHVybiBjcmVhdGVCdWZmZXIoZTwwPzA6Y2hlY2tlZChlKXwwKX1CdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtCdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07ZnVuY3Rpb24gZnJvbVN0cmluZyhlLHIpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8cj09PVwiXCIpe3I9XCJ1dGY4XCJ9aWYoIUJ1ZmZlci5pc0VuY29kaW5nKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcil9dmFyIHQ9Ynl0ZUxlbmd0aChlLHIpfDA7dmFyIGY9Y3JlYXRlQnVmZmVyKHQpO3ZhciBuPWYud3JpdGUoZSxyKTtpZihuIT09dCl7Zj1mLnNsaWNlKDAsbil9cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbUFycmF5TGlrZShlKXt2YXIgcj1lLmxlbmd0aDwwPzA6Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7Zm9yKHZhciBmPTA7ZjxyO2YrPTEpe3RbZl09ZVtmXSYyNTV9cmV0dXJuIHR9ZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGUscix0KXtpZihyPDB8fGUuYnl0ZUxlbmd0aDxyKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX1pZihlLmJ5dGVMZW5ndGg8cisodHx8MCkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfXZhciBmO2lmKHI9PT11bmRlZmluZWQmJnQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSl9ZWxzZSBpZih0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUscil9ZWxzZXtmPW5ldyBVaW50OEFycmF5KGUscix0KX1PYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn1mdW5jdGlvbiBmcm9tT2JqZWN0KGUpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7dmFyIHI9Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7aWYodC5sZW5ndGg9PT0wKXtyZXR1cm4gdH1lLmNvcHkodCwwLDAscik7cmV0dXJuIHR9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe2lmKHR5cGVvZiBlLmxlbmd0aCE9PVwibnVtYmVyXCJ8fG51bWJlcklzTmFOKGUubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKX1yZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlLnR5cGU9PT1cIkJ1ZmZlclwiJiZBcnJheS5pc0FycmF5KGUuZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUuZGF0YSl9fWZ1bmN0aW9uIGNoZWNrZWQoZSl7aWYoZT49byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIFwiK1wic2l6ZTogMHhcIitvLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKX1yZXR1cm4gZXwwfWZ1bmN0aW9uIFNsb3dCdWZmZXIoZSl7aWYoK2UhPWUpe2U9MH1yZXR1cm4gQnVmZmVyLmFsbG9jKCtlKX1CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoZSl7cmV0dXJuIGUhPW51bGwmJmUuX2lzQnVmZmVyPT09dHJ1ZSYmZSE9PUJ1ZmZlci5wcm90b3R5cGV9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCk7aWYoaXNJbnN0YW5jZShyLFVpbnQ4QXJyYXkpKXI9QnVmZmVyLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZSl8fCFCdWZmZXIuaXNCdWZmZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKX1pZihlPT09cilyZXR1cm4gMDt2YXIgdD1lLmxlbmd0aDt2YXIgZj1yLmxlbmd0aDtmb3IodmFyIG49MCxpPU1hdGgubWluKHQsZik7bjxpOysrbil7aWYoZVtuXSE9PXJbbl0pe3Q9ZVtuXTtmPXJbbl07YnJlYWt9fWlmKHQ8ZilyZXR1cm4tMTtpZihmPHQpcmV0dXJuIDE7cmV0dXJuIDB9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbiBjb25jYXQoZSxyKXtpZighQXJyYXkuaXNBcnJheShlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aWYoZS5sZW5ndGg9PT0wKXtyZXR1cm4gQnVmZmVyLmFsbG9jKDApfXZhciB0O2lmKHI9PT11bmRlZmluZWQpe3I9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyKz1lW3RdLmxlbmd0aH19dmFyIGY9QnVmZmVyLmFsbG9jVW5zYWZlKHIpO3ZhciBuPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7dmFyIGk9ZVt0XTtpZihpc0luc3RhbmNlKGksVWludDhBcnJheSkpe2k9QnVmZmVyLmZyb20oaSl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihpKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aS5jb3B5KGYsbik7bis9aS5sZW5ndGh9cmV0dXJuIGZ9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoZSxyKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3JldHVybiBlLmxlbmd0aH1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcikpe3JldHVybiBlLmJ5dGVMZW5ndGh9aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfXZhciB0PWUubGVuZ3RoO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighZiYmdD09PTApcmV0dXJuIDA7dmFyIG49ZmFsc2U7Zm9yKDs7KXtzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFRvQnl0ZXMoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0KjI7Y2FzZVwiaGV4XCI6cmV0dXJuIHQ+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRUb0J5dGVzKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pe3JldHVybiBmPy0xOnV0ZjhUb0J5dGVzKGUpLmxlbmd0aH1yPShcIlwiK3IpLnRvTG93ZXJDYXNlKCk7bj10cnVlfX19QnVmZmVyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtmdW5jdGlvbiBzbG93VG9TdHJpbmcoZSxyLHQpe3ZhciBmPWZhbHNlO2lmKHI9PT11bmRlZmluZWR8fHI8MCl7cj0wfWlmKHI+dGhpcy5sZW5ndGgpe3JldHVyblwiXCJ9aWYodD09PXVuZGVmaW5lZHx8dD50aGlzLmxlbmd0aCl7dD10aGlzLmxlbmd0aH1pZih0PD0wKXtyZXR1cm5cIlwifXQ+Pj49MDtyPj4+PTA7aWYodDw9cil7cmV0dXJuXCJcIn1pZighZSllPVwidXRmOFwiO3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4U2xpY2UodGhpcyxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4U2xpY2UodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMscix0KTtkZWZhdWx0OmlmKGYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKTtmPXRydWV9fX1CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoZSxyLHQpe3ZhciBmPWVbcl07ZVtyXT1lW3RdO2VbdF09Zn1CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz0yKXtzd2FwKHRoaXMscixyKzEpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbiBzd2FwMzIoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz00KXtzd2FwKHRoaXMscixyKzMpO3N3YXAodGhpcyxyKzEscisyKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9OCl7c3dhcCh0aGlzLHIscis3KTtzd2FwKHRoaXMscisxLHIrNik7c3dhcCh0aGlzLHIrMixyKzUpO3N3YXAodGhpcyxyKzMscis0KX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGU9PT0wKXJldHVyblwiXCI7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsZSk7cmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoZSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih0aGlzPT09ZSlyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxlKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7dmFyIGU9XCJcIjt2YXIgdD1yLklOU1BFQ1RfTUFYX0JZVEVTO2U9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpO2lmKHRoaXMubGVuZ3RoPnQpZSs9XCIgLi4uIFwiO3JldHVyblwiPEJ1ZmZlciBcIitlK1wiPlwifTtpZihpKXtCdWZmZXIucHJvdG90eXBlW2ldPUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdH1CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIsdCxmLG4pe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSl7ZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKHI9PT11bmRlZmluZWQpe3I9MH1pZih0PT09dW5kZWZpbmVkKXt0PWU/ZS5sZW5ndGg6MH1pZihmPT09dW5kZWZpbmVkKXtmPTB9aWYobj09PXVuZGVmaW5lZCl7bj10aGlzLmxlbmd0aH1pZihyPDB8fHQ+ZS5sZW5ndGh8fGY8MHx8bj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYoZj49biYmcj49dCl7cmV0dXJuIDB9aWYoZj49bil7cmV0dXJuLTF9aWYocj49dCl7cmV0dXJuIDF9cj4+Pj0wO3Q+Pj49MDtmPj4+PTA7bj4+Pj0wO2lmKHRoaXM9PT1lKXJldHVybiAwO3ZhciBpPW4tZjt2YXIgbz10LXI7dmFyIHU9TWF0aC5taW4oaSxvKTt2YXIgYT10aGlzLnNsaWNlKGYsbik7dmFyIHM9ZS5zbGljZShyLHQpO2Zvcih2YXIgaD0wO2g8dTsrK2gpe2lmKGFbaF0hPT1zW2hdKXtpPWFbaF07bz1zW2hdO2JyZWFrfX1pZihpPG8pcmV0dXJuLTE7aWYobzxpKXJldHVybiAxO3JldHVybiAwfTtmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihlLHIsdCxmLG4pe2lmKGUubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PTB9ZWxzZSBpZih0PjIxNDc0ODM2NDcpe3Q9MjE0NzQ4MzY0N31lbHNlIGlmKHQ8LTIxNDc0ODM2NDgpe3Q9LTIxNDc0ODM2NDh9dD0rdDtpZihudW1iZXJJc05hTih0KSl7dD1uPzA6ZS5sZW5ndGgtMX1pZih0PDApdD1lLmxlbmd0aCt0O2lmKHQ+PWUubGVuZ3RoKXtpZihuKXJldHVybi0xO2Vsc2UgdD1lLmxlbmd0aC0xfWVsc2UgaWYodDwwKXtpZihuKXQ9MDtlbHNlIHJldHVybi0xfWlmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cj1CdWZmZXIuZnJvbShyLGYpfWlmKEJ1ZmZlci5pc0J1ZmZlcihyKSl7aWYoci5sZW5ndGg9PT0wKXtyZXR1cm4tMX1yZXR1cm4gYXJyYXlJbmRleE9mKGUscix0LGYsbil9ZWxzZSBpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9ciYyNTU7aWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT1cImZ1bmN0aW9uXCIpe2lmKG4pe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSxyLHQpfWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSxyLHQpfX1yZXR1cm4gYXJyYXlJbmRleE9mKGUsW3JdLHQsZixuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pe3ZhciBpPTE7dmFyIG89ZS5sZW5ndGg7dmFyIHU9ci5sZW5ndGg7aWYoZiE9PXVuZGVmaW5lZCl7Zj1TdHJpbmcoZikudG9Mb3dlckNhc2UoKTtpZihmPT09XCJ1Y3MyXCJ8fGY9PT1cInVjcy0yXCJ8fGY9PT1cInV0ZjE2bGVcInx8Zj09PVwidXRmLTE2bGVcIil7aWYoZS5sZW5ndGg8Mnx8ci5sZW5ndGg8Mil7cmV0dXJuLTF9aT0yO28vPTI7dS89Mjt0Lz0yfX1mdW5jdGlvbiByZWFkKGUscil7aWYoaT09PTEpe3JldHVybiBlW3JdfWVsc2V7cmV0dXJuIGUucmVhZFVJbnQxNkJFKHIqaSl9fXZhciBhO2lmKG4pe3ZhciBzPS0xO2ZvcihhPXQ7YTxvO2ErKyl7aWYocmVhZChlLGEpPT09cmVhZChyLHM9PT0tMT8wOmEtcykpe2lmKHM9PT0tMSlzPWE7aWYoYS1zKzE9PT11KXJldHVybiBzKml9ZWxzZXtpZihzIT09LTEpYS09YS1zO3M9LTF9fX1lbHNle2lmKHQrdT5vKXQ9by11O2ZvcihhPXQ7YT49MDthLS0pe3ZhciBoPXRydWU7Zm9yKHZhciBjPTA7Yzx1O2MrKyl7aWYocmVhZChlLGErYykhPT1yZWFkKHIsYykpe2g9ZmFsc2U7YnJlYWt9fWlmKGgpcmV0dXJuIGF9fXJldHVybi0xfUJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24gaW5jbHVkZXMoZSxyLHQpe3JldHVybiB0aGlzLmluZGV4T2YoZSxyLHQpIT09LTF9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCx0cnVlKX07QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsZmFsc2UpfTtmdW5jdGlvbiBoZXhXcml0ZShlLHIsdCxmKXt0PU51bWJlcih0KXx8MDt2YXIgbj1lLmxlbmd0aC10O2lmKCFmKXtmPW59ZWxzZXtmPU51bWJlcihmKTtpZihmPm4pe2Y9bn19dmFyIGk9ci5sZW5ndGg7aWYoZj5pLzIpe2Y9aS8yfWZvcih2YXIgbz0wO288ZjsrK28pe3ZhciB1PXBhcnNlSW50KHIuc3Vic3RyKG8qMiwyKSwxNik7aWYobnVtYmVySXNOYU4odSkpcmV0dXJuIG87ZVt0K29dPXV9cmV0dXJuIG99ZnVuY3Rpb24gdXRmOFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfWZ1bmN0aW9uIGFzY2lpV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiBsYXRpbjFXcml0ZShlLHIsdCxmKXtyZXR1cm4gYXNjaWlXcml0ZShlLHIsdCxmKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiB1Y3MyV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShlLHIsdCxmKXtpZihyPT09dW5kZWZpbmVkKXtmPVwidXRmOFwiO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYodD09PXVuZGVmaW5lZCYmdHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZihpc0Zpbml0ZShyKSl7cj1yPj4+MDtpZihpc0Zpbml0ZSh0KSl7dD10Pj4+MDtpZihmPT09dW5kZWZpbmVkKWY9XCJ1dGY4XCJ9ZWxzZXtmPXQ7dD11bmRlZmluZWR9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIil9dmFyIG49dGhpcy5sZW5ndGgtcjtpZih0PT09dW5kZWZpbmVkfHx0Pm4pdD1uO2lmKGUubGVuZ3RoPjAmJih0PDB8fHI8MCl8fHI+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIil9aWYoIWYpZj1cInV0ZjhcIjt2YXIgaT1mYWxzZTtmb3IoOzspe3N3aXRjaChmKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHVjczJXcml0ZSh0aGlzLGUscix0KTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpO2Y9KFwiXCIrZikudG9Mb3dlckNhc2UoKTtpPXRydWV9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGUscix0KXtpZihyPT09MCYmdD09PWUubGVuZ3RoKXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUpfWVsc2V7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHIsdCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoZSxyLHQpe3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7dmFyIGY9W107dmFyIG49cjt3aGlsZShuPHQpe3ZhciBpPWVbbl07dmFyIG89bnVsbDt2YXIgdT1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG4rdTw9dCl7dmFyIGEscyxoLGM7c3dpdGNoKHUpe2Nhc2UgMTppZihpPDEyOCl7bz1pfWJyZWFrO2Nhc2UgMjphPWVbbisxXTtpZigoYSYxOTIpPT09MTI4KXtjPShpJjMxKTw8NnxhJjYzO2lmKGM+MTI3KXtvPWN9fWJyZWFrO2Nhc2UgMzphPWVbbisxXTtzPWVbbisyXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTJ8KGEmNjMpPDw2fHMmNjM7aWYoYz4yMDQ3JiYoYzw1NTI5Nnx8Yz41NzM0Mykpe289Y319YnJlYWs7Y2FzZSA0OmE9ZVtuKzFdO3M9ZVtuKzJdO2g9ZVtuKzNdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihoJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxOHwoYSY2Myk8PDEyfChzJjYzKTw8NnxoJjYzO2lmKGM+NjU1MzUmJmM8MTExNDExMil7bz1jfX19fWlmKG89PT1udWxsKXtvPTY1NTMzO3U9MX1lbHNlIGlmKG8+NjU1MzUpe28tPTY1NTM2O2YucHVzaChvPj4+MTAmMTAyM3w1NTI5Nik7bz01NjMyMHxvJjEwMjN9Zi5wdXNoKG8pO24rPXV9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShmKX12YXIgdT00MDk2O2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShlKXt2YXIgcj1lLmxlbmd0aDtpZihyPD11KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSl9dmFyIHQ9XCJcIjt2YXIgZj0wO3doaWxlKGY8cil7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShmLGYrPXUpKX1yZXR1cm4gdH1mdW5jdGlvbiBhc2NpaVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dJjEyNyl9cmV0dXJuIGZ9ZnVuY3Rpb24gbGF0aW4xU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0pfXJldHVybiBmfWZ1bmN0aW9uIGhleFNsaWNlKGUscix0KXt2YXIgZj1lLmxlbmd0aDtpZighcnx8cjwwKXI9MDtpZighdHx8dDwwfHx0PmYpdD1mO3ZhciBuPVwiXCI7Zm9yKHZhciBpPXI7aTx0OysraSl7bis9c1tlW2ldXX1yZXR1cm4gbn1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoZSxyLHQpe3ZhciBmPWUuc2xpY2Uocix0KTt2YXIgbj1cIlwiO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSs9Mil7bis9U3RyaW5nLmZyb21DaGFyQ29kZShmW2ldK2ZbaSsxXSoyNTYpfXJldHVybiBufUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2UoZSxyKXt2YXIgdD10aGlzLmxlbmd0aDtlPX5+ZTtyPXI9PT11bmRlZmluZWQ/dDp+fnI7aWYoZTwwKXtlKz10O2lmKGU8MCllPTB9ZWxzZSBpZihlPnQpe2U9dH1pZihyPDApe3IrPXQ7aWYocjwwKXI9MH1lbHNlIGlmKHI+dCl7cj10fWlmKHI8ZSlyPWU7dmFyIGY9dGhpcy5zdWJhcnJheShlLHIpO09iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfTtmdW5jdGlvbiBjaGVja09mZnNldChlLHIsdCl7aWYoZSUxIT09MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24gcmVhZFVJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uIHJlYWRVSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCl7Y2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKX12YXIgZj10aGlzW2UrLS1yXTt2YXIgbj0xO3doaWxlKHI+MCYmKG4qPTI1Nikpe2YrPXRoaXNbZSstLXJdKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OH07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDw4fHRoaXNbZSsxXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybih0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSt0aGlzW2UrM10qMTY3NzcyMTZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXSoxNjc3NzIxNisodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24gcmVhZEludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufW4qPTEyODtpZihmPj1uKWYtPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24gcmVhZEludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj1yO3ZhciBuPTE7dmFyIGk9dGhpc1tlKy0tZl07d2hpbGUoZj4wJiYobio9MjU2KSl7aSs9dGhpc1tlKy0tZl0qbn1uKj0xMjg7aWYoaT49bilpLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24gcmVhZEludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW2VdJjEyOCkpcmV0dXJuIHRoaXNbZV07cmV0dXJuKDI1NS10aGlzW2VdKzEpKi0xfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbiByZWFkRmxvYXRMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSw1Miw4KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24gcmVhZERvdWJsZUJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDUyLDgpfTtmdW5jdGlvbiBjaGVja0ludChlLHIsdCxmLG4saSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPm58fHI8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPTE7dmFyIG89MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsrbzx0JiYoaSo9MjU2KSl7dGhpc1tyK29dPWUvaSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPXQtMTt2YXIgbz0xO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXt0aGlzW3IraV09ZS9vJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24gd3JpdGVVSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMjU1LDApO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24gd3JpdGVVSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3IrM109ZT4+PjI0O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlVUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbiB3cml0ZUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPTA7dmFyIG89MTt2YXIgdT0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytpPHQmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraS0xXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9dC0xO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2krMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMTI3LC0xMjgpO2lmKGU8MCllPTI1NStlKzE7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24gd3JpdGVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrM109ZT4+PjI0O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7aWYoZTwwKWU9NDI5NDk2NzI5NStlKzE7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChlLHIsdCxmLG4saSl7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB3cml0ZUZsb2F0KGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpfW4ud3JpdGUoZSxyLHQsZiwyMyw0KTtyZXR1cm4gdCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscixmYWxzZSx0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKX1uLndyaXRlKGUscix0LGYsNTIsOCk7cmV0dXJuIHQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsZmFsc2UsdCl9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGUscix0LGYpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZighdCl0PTA7aWYoIWYmJmYhPT0wKWY9dGhpcy5sZW5ndGg7aWYocj49ZS5sZW5ndGgpcj1lLmxlbmd0aDtpZighcilyPTA7aWYoZj4wJiZmPHQpZj10O2lmKGY9PT10KXJldHVybiAwO2lmKGUubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHI8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpfWlmKHQ8MHx8dD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoZjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZj50aGlzLmxlbmd0aClmPXRoaXMubGVuZ3RoO2lmKGUubGVuZ3RoLXI8Zi10KXtmPWUubGVuZ3RoLXIrdH12YXIgbj1mLXQ7aWYodGhpcz09PWUmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT09XCJmdW5jdGlvblwiKXt0aGlzLmNvcHlXaXRoaW4ocix0LGYpfWVsc2UgaWYodGhpcz09PWUmJnQ8ciYmcjxmKXtmb3IodmFyIGk9bi0xO2k+PTA7LS1pKXtlW2krcl09dGhpc1tpK3RdfX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheSh0LGYpLHIpfXJldHVybiBufTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbChlLHIsdCxmKXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3I9MDt0PXRoaXMubGVuZ3RofWVsc2UgaWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD10aGlzLmxlbmd0aH1pZihmIT09dW5kZWZpbmVkJiZ0eXBlb2YgZiE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpfWlmKHR5cGVvZiBmPT09XCJzdHJpbmdcIiYmIUJ1ZmZlci5pc0VuY29kaW5nKGYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZil9aWYoZS5sZW5ndGg9PT0xKXt2YXIgbj1lLmNoYXJDb2RlQXQoMCk7aWYoZj09PVwidXRmOFwiJiZuPDEyOHx8Zj09PVwibGF0aW4xXCIpe2U9bn19fWVsc2UgaWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtlPWUmMjU1fWVsc2UgaWYodHlwZW9mIGU9PT1cImJvb2xlYW5cIil7ZT1OdW1iZXIoZSl9aWYocjwwfHx0aGlzLmxlbmd0aDxyfHx0aGlzLmxlbmd0aDx0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKX1pZih0PD1yKXtyZXR1cm4gdGhpc31yPXI+Pj4wO3Q9dD09PXVuZGVmaW5lZD90aGlzLmxlbmd0aDp0Pj4+MDtpZighZSllPTA7dmFyIGk7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtmb3IoaT1yO2k8dDsrK2kpe3RoaXNbaV09ZX19ZWxzZXt2YXIgbz1CdWZmZXIuaXNCdWZmZXIoZSk/ZTpCdWZmZXIuZnJvbShlLGYpO3ZhciB1PW8ubGVuZ3RoO2lmKHU9PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpfWZvcihpPTA7aTx0LXI7KytpKXt0aGlzW2krcl09b1tpJXVdfX1yZXR1cm4gdGhpc307dmFyIGE9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBiYXNlNjRjbGVhbihlKXtlPWUuc3BsaXQoXCI9XCIpWzBdO2U9ZS50cmltKCkucmVwbGFjZShhLFwiXCIpO2lmKGUubGVuZ3RoPDIpcmV0dXJuXCJcIjt3aGlsZShlLmxlbmd0aCU0IT09MCl7ZT1lK1wiPVwifXJldHVybiBlfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKGUscil7cj1yfHxJbmZpbml0eTt2YXIgdDt2YXIgZj1lLmxlbmd0aDt2YXIgbj1udWxsO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZjsrK28pe3Q9ZS5jaGFyQ29kZUF0KG8pO2lmKHQ+NTUyOTUmJnQ8NTczNDQpe2lmKCFuKXtpZih0PjU2MzE5KXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKG8rMT09PWYpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW49dDtjb250aW51ZX1pZih0PDU2MzIwKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtuPXQ7Y29udGludWV9dD0obi01NTI5Njw8MTB8dC01NjMyMCkrNjU1MzZ9ZWxzZSBpZihuKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KX1uPW51bGw7aWYodDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO2kucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7aS5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO2kucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztpLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9fXJldHVybiBpfWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhlKXt2YXIgcj1bXTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl7ci5wdXNoKGUuY2hhckNvZGVBdCh0KSYyNTUpfXJldHVybiByfWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKGUscil7dmFyIHQsZixuO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXtpZigoci09Mik8MClicmVhazt0PWUuY2hhckNvZGVBdChvKTtmPXQ+Pjg7bj10JTI1NjtpLnB1c2gobik7aS5wdXNoKGYpfXJldHVybiBpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoZSl7cmV0dXJuIGYudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oZSkpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoZSxyLHQsZil7Zm9yKHZhciBuPTA7bjxmOysrbil7aWYobit0Pj1yLmxlbmd0aHx8bj49ZS5sZW5ndGgpYnJlYWs7cltuK3RdPWVbbl19cmV0dXJuIG59ZnVuY3Rpb24gaXNJbnN0YW5jZShlLHIpe3JldHVybiBlIGluc3RhbmNlb2Ygcnx8ZSE9bnVsbCYmZS5jb25zdHJ1Y3RvciE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWU9PT1yLm5hbWV9ZnVuY3Rpb24gbnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfXZhciBzPWZ1bmN0aW9uKCl7dmFyIGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7dmFyIHI9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciB0PTA7dDwxNjsrK3Qpe3ZhciBmPXQqMTY7Zm9yKHZhciBuPTA7bjwxNjsrK24pe3JbZituXT1lW3RdK2Vbbl19fXJldHVybiByfSgpfSw3ODM6ZnVuY3Rpb24oZSxyKXtcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5yLnJlYWQ9ZnVuY3Rpb24oZSxyLHQsZixuKXt2YXIgaSxvO3ZhciB1PW4qOC1mLTE7dmFyIGE9KDE8PHUpLTE7dmFyIHM9YT4+MTt2YXIgaD0tNzt2YXIgYz10P24tMTowO3ZhciBsPXQ/LTE6MTt2YXIgcD1lW3IrY107Yys9bDtpPXAmKDE8PC1oKS0xO3A+Pj0taDtoKz11O2Zvcig7aD4wO2k9aSoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fW89aSYoMTw8LWgpLTE7aT4+PS1oO2grPWY7Zm9yKDtoPjA7bz1vKjI1NitlW3IrY10sYys9bCxoLT04KXt9aWYoaT09PTApe2k9MS1zfWVsc2UgaWYoaT09PWEpe3JldHVybiBvP05hTjoocD8tMToxKSpJbmZpbml0eX1lbHNle289bytNYXRoLnBvdygyLGYpO2k9aS1zfXJldHVybihwPy0xOjEpKm8qTWF0aC5wb3coMixpLWYpfTtyLndyaXRlPWZ1bmN0aW9uKGUscix0LGYsbixpKXt2YXIgbyx1LGE7dmFyIHM9aSo4LW4tMTt2YXIgaD0oMTw8cyktMTt2YXIgYz1oPj4xO3ZhciBsPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7dmFyIHA9Zj8wOmktMTt2YXIgeT1mPzE6LTE7dmFyIGc9cjwwfHxyPT09MCYmMS9yPDA/MTowO3I9TWF0aC5hYnMocik7aWYoaXNOYU4ocil8fHI9PT1JbmZpbml0eSl7dT1pc05hTihyKT8xOjA7bz1ofWVsc2V7bz1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTtpZihyKihhPU1hdGgucG93KDIsLW8pKTwxKXtvLS07YSo9Mn1pZihvK2M+PTEpe3IrPWwvYX1lbHNle3IrPWwqTWF0aC5wb3coMiwxLWMpfWlmKHIqYT49Mil7bysrO2EvPTJ9aWYobytjPj1oKXt1PTA7bz1ofWVsc2UgaWYobytjPj0xKXt1PShyKmEtMSkqTWF0aC5wb3coMixuKTtvPW8rY31lbHNle3U9cipNYXRoLnBvdygyLGMtMSkqTWF0aC5wb3coMixuKTtvPTB9fWZvcig7bj49ODtlW3QrcF09dSYyNTUscCs9eSx1Lz0yNTYsbi09OCl7fW89bzw8bnx1O3MrPW47Zm9yKDtzPjA7ZVt0K3BdPW8mMjU1LHArPXksby89MjU2LHMtPTgpe31lW3QrcC15XXw9ZyoxMjh9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgZj1yW3RdO2lmKGYhPT11bmRlZmluZWQpe3JldHVybiBmLmV4cG9ydHN9dmFyIG49clt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDcyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={413:(e,r,t)=>{var n=t(916);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},916:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(413);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs0MTM6KGUscix0KT0+e3ZhciBuPXQoOTE2KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDkxNjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNDEzKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/katex@0.16.33/node_modules/katex/dist/katex.min.css":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/katex@0.16.33/node_modules/katex/dist/katex.min.css ***!
  \********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"d6bb48bdf86c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9rYXRleEAwLjE2LjMzL25vZGVfbW9kdWxlcy9rYXRleC9kaXN0L2thdGV4Lm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL2thdGV4QDAuMTYuMzMvbm9kZV9tb2R1bGVzL2thdGV4L2Rpc3Qva2F0ZXgubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImQ2YmI0OGJkZjg2Y1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/katex@0.16.33/node_modules/katex/dist/katex.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./modules/devlog/components/ContentHeader.tsx":
/*!*****************************************************!*\
  !*** ./modules/devlog/components/ContentHeader.tsx ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentHeader: () => (/* binding */ ContentHeader)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _modules_layout_fonts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/modules/layout/fonts */ \"(app-pages-browser)/./modules/layout/fonts.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! animejs */ \"(app-pages-browser)/./node_modules/.pnpm/animejs@4.1.4/node_modules/animejs/lib/anime.esm.js\");\n/* __next_internal_client_entry_do_not_use__ ContentHeader auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst ContentHeader = (props)=>{\n    _s();\n    const titleRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ContentHeader.useEffect\": ()=>{\n            if (titleRef.current) {\n                animejs__WEBPACK_IMPORTED_MODULE_3__.text.split(titleRef.current, {\n                    lines: {\n                        wrap: 'clip'\n                    }\n                }).addEffect({\n                    \"ContentHeader.useEffect\": (param)=>{\n                        let { lines } = param;\n                        return (0,animejs__WEBPACK_IMPORTED_MODULE_3__.animate)(lines, {\n                            y: {\n                                to: [\n                                    '100%',\n                                    '0%'\n                                ]\n                            },\n                            duration: 750,\n                            ease: 'out(3)',\n                            delay: (0,animejs__WEBPACK_IMPORTED_MODULE_3__.stagger)(200)\n                        });\n                    }\n                }[\"ContentHeader.useEffect\"]);\n            }\n        }\n    }[\"ContentHeader.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: \"w-full px-4 lg:w-3/5 gap-4 my-8 lg:flex \",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"lg:w-1/2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        ref: titleRef,\n                        className: \"text-4xl lg:text-5xl font-medium mb-6 \".concat(_modules_layout_fonts__WEBPACK_IMPORTED_MODULE_1__.redHatMono.className),\n                        children: props.title\n                    }, void 0, false, {\n                        fileName: \"/Users/sathira/Projects/grotto/modules/devlog/components/ContentHeader.tsx\",\n                        lineNumber: 33,\n                        columnNumber: 5\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-2xl text-zinc-700 mb-6\",\n                        children: props.description\n                    }, void 0, false, {\n                        fileName: \"/Users/sathira/Projects/grotto/modules/devlog/components/ContentHeader.tsx\",\n                        lineNumber: 39,\n                        columnNumber: 5\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/devlog/components/ContentHeader.tsx\",\n                lineNumber: 32,\n                columnNumber: 4\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                className: \"select-none rounded-md lg:w-1/2 aspect-video object-cover\",\n                src: \"/content/\".concat(props.slug, \"/assets/main.jpg\"),\n                alt: props.title\n            }, void 0, false, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/devlog/components/ContentHeader.tsx\",\n                lineNumber: 42,\n                columnNumber: 4\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/sathira/Projects/grotto/modules/devlog/components/ContentHeader.tsx\",\n        lineNumber: 31,\n        columnNumber: 3\n    }, undefined);\n};\n_s(ContentHeader, \"5158MNnKrLHubdR68HBro4P03NI=\");\n_c = ContentHeader;\nvar _c;\n$RefreshReg$(_c, \"ContentHeader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL21vZHVsZXMvZGV2bG9nL2NvbXBvbmVudHMvQ29udGVudEhlYWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFb0Q7QUFDVjtBQUNPO0FBUTFDLE1BQU1NLGdCQUFnQixDQUFDQzs7SUFDN0IsTUFBTUMsV0FBV04sNkNBQU1BLENBQXFCO0lBRTVDRCxnREFBU0E7bUNBQUM7WUFDVCxJQUFJTyxTQUFTQyxPQUFPLEVBQUU7Z0JBQ3JCTCx5Q0FBSUEsQ0FBQ00sS0FBSyxDQUFDRixTQUFTQyxPQUFPLEVBQUU7b0JBQzVCRSxPQUFPO3dCQUFFQyxNQUFNO29CQUFPO2dCQUN2QixHQUNDQyxTQUFTOytDQUFDOzRCQUFDLEVBQUVGLEtBQUssRUFBRTsrQkFBS1IsZ0RBQU9BLENBQUNRLE9BQU87NEJBQ3hDRyxHQUFHO2dDQUFFQyxJQUFJO29DQUFDO29DQUFRO2lDQUFLOzRCQUFDOzRCQUN4QkMsVUFBVTs0QkFDVkMsTUFBTTs0QkFDTkMsT0FBT2IsZ0RBQU9BLENBQUM7d0JBQ2hCOzs7WUFDRDtRQUNEO2tDQUFHLEVBQUU7SUFFTCxxQkFDQyw4REFBQ2M7UUFBUUMsV0FBVTs7MEJBQ2xCLDhEQUFDQztnQkFBSUQsV0FBVTs7a0NBQ2QsOERBQUNFO3dCQUNBQyxLQUFLZjt3QkFDTFksV0FBVyx5Q0FBOEQsT0FBckJwQiw2REFBVUEsQ0FBQ29CLFNBQVM7a0NBRXZFYixNQUFNaUIsS0FBSzs7Ozs7O2tDQUViLDhEQUFDQzt3QkFBRUwsV0FBVTtrQ0FBK0JiLE1BQU1tQixXQUFXOzs7Ozs7Ozs7Ozs7MEJBRzlELDhEQUFDQztnQkFDQVAsV0FBVTtnQkFDVlEsS0FBSyxZQUF1QixPQUFYckIsTUFBTXNCLElBQUksRUFBQztnQkFDNUJDLEtBQUt2QixNQUFNaUIsS0FBSzs7Ozs7Ozs7Ozs7O0FBSXBCLEVBQUU7R0FwQ1dsQjtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL21vZHVsZXMvZGV2bG9nL2NvbXBvbmVudHMvQ29udGVudEhlYWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHJlZEhhdE1vbm8gfSBmcm9tIFwiQC9tb2R1bGVzL2xheW91dC9mb250c1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGFuaW1hdGUsIHRleHQsIHN0YWdnZXIgfSBmcm9tIFwiYW5pbWVqc1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuXHRzbHVnOiBzdHJpbmc7XG5cdHRpdGxlOiBzdHJpbmc7XG5cdGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBDb250ZW50SGVhZGVyID0gKHByb3BzOiBQcm9wcykgPT4ge1xuXHRjb25zdCB0aXRsZVJlZiA9IHVzZVJlZjxIVE1MSGVhZGluZ0VsZW1lbnQ+KG51bGwpO1xuXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKHRpdGxlUmVmLmN1cnJlbnQpIHtcblx0XHRcdHRleHQuc3BsaXQodGl0bGVSZWYuY3VycmVudCwge1xuXHRcdFx0XHRsaW5lczogeyB3cmFwOiAnY2xpcCcgfSxcblx0XHRcdH0pXG5cdFx0XHQuYWRkRWZmZWN0KCh7IGxpbmVzIH0pID0+IGFuaW1hdGUobGluZXMsIHtcblx0XHRcdFx0eTogeyB0bzogWycxMDAlJywgJzAlJ10gfSxcblx0XHRcdFx0ZHVyYXRpb246IDc1MCxcblx0XHRcdFx0ZWFzZTogJ291dCgzKScsXG5cdFx0XHRcdGRlbGF5OiBzdGFnZ2VyKDIwMCksXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9LCBbXSk7XG5cblx0cmV0dXJuIChcblx0XHQ8c2VjdGlvbiBjbGFzc05hbWU9XCJ3LWZ1bGwgcHgtNCBsZzp3LTMvNSBnYXAtNCBteS04IGxnOmZsZXggXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImxnOnctMS8yXCI+XG5cdFx0XHRcdDxoMVxuXHRcdFx0XHRcdHJlZj17dGl0bGVSZWZ9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtgdGV4dC00eGwgbGc6dGV4dC01eGwgZm9udC1tZWRpdW0gbWItNiAke3JlZEhhdE1vbm8uY2xhc3NOYW1lfWB9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7cHJvcHMudGl0bGV9XG5cdFx0XHRcdDwvaDE+XG5cdFx0XHRcdDxwIGNsYXNzTmFtZT1cInRleHQtMnhsIHRleHQtemluYy03MDAgbWItNlwiPntwcm9wcy5kZXNjcmlwdGlvbn08L3A+XG5cdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PGltZ1xuXHRcdFx0XHRjbGFzc05hbWU9XCJzZWxlY3Qtbm9uZSByb3VuZGVkLW1kIGxnOnctMS8yIGFzcGVjdC12aWRlbyBvYmplY3QtY292ZXJcIlxuXHRcdFx0XHRzcmM9e2AvY29udGVudC8ke3Byb3BzLnNsdWd9L2Fzc2V0cy9tYWluLmpwZ2B9XG5cdFx0XHRcdGFsdD17cHJvcHMudGl0bGV9XG5cdFx0XHQvPlxuXHRcdDwvc2VjdGlvbj5cblx0KTtcbn07XG4iXSwibmFtZXMiOlsicmVkSGF0TW9ubyIsInVzZUVmZmVjdCIsInVzZVJlZiIsImFuaW1hdGUiLCJ0ZXh0Iiwic3RhZ2dlciIsIkNvbnRlbnRIZWFkZXIiLCJwcm9wcyIsInRpdGxlUmVmIiwiY3VycmVudCIsInNwbGl0IiwibGluZXMiLCJ3cmFwIiwiYWRkRWZmZWN0IiwieSIsInRvIiwiZHVyYXRpb24iLCJlYXNlIiwiZGVsYXkiLCJzZWN0aW9uIiwiY2xhc3NOYW1lIiwiZGl2IiwiaDEiLCJyZWYiLCJ0aXRsZSIsInAiLCJkZXNjcmlwdGlvbiIsImltZyIsInNyYyIsInNsdWciLCJhbHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./modules/devlog/components/ContentHeader.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./modules/devlog/components/ScrollGuide.tsx":
/*!***************************************************!*\
  !*** ./modules/devlog/components/ScrollGuide.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollGuide: () => (/* binding */ ScrollGuide)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! animejs */ \"(app-pages-browser)/./node_modules/.pnpm/animejs@4.1.4/node_modules/animejs/lib/anime.esm.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst ScrollGuide = ()=>{\n    _s();\n    const guideRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [activeIndex, setActiveIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [pageHeight, setPageHeight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Calculate page height and update on resize\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ScrollGuide.useEffect\": ()=>{\n            const updatePageHeight = {\n                \"ScrollGuide.useEffect.updatePageHeight\": ()=>{\n                    const documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n                    setPageHeight(documentHeight);\n                }\n            }[\"ScrollGuide.useEffect.updatePageHeight\"];\n            updatePageHeight();\n            window.addEventListener(\"resize\", updatePageHeight);\n            return ({\n                \"ScrollGuide.useEffect\": ()=>window.removeEventListener(\"resize\", updatePageHeight)\n            })[\"ScrollGuide.useEffect\"];\n        }\n    }[\"ScrollGuide.useEffect\"], []);\n    // Track active section based on scroll position (divide page into 10 parts)\n    const handleScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ScrollGuide.useCallback[handleScroll]\": ()=>{\n            if (pageHeight === 0) return;\n            const scrollPosition = window.scrollY;\n            const windowHeight = window.innerHeight;\n            const maxScrollPosition = pageHeight - windowHeight;\n            // Calculate which section (0-9) we're currently in\n            const scrollPercentage = scrollPosition / maxScrollPosition;\n            const currentSection = Math.min(Math.floor(scrollPercentage * 10), 9);\n            setActiveIndex(currentSection);\n        }\n    }[\"ScrollGuide.useCallback[handleScroll]\"], [\n        pageHeight\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ScrollGuide.useEffect\": ()=>{\n            window.addEventListener(\"scroll\", handleScroll);\n            handleScroll(); // Initial check\n            return ({\n                \"ScrollGuide.useEffect\": ()=>window.removeEventListener(\"scroll\", handleScroll)\n            })[\"ScrollGuide.useEffect\"];\n        }\n    }[\"ScrollGuide.useEffect\"], [\n        handleScroll\n    ]);\n    // Handle bar click to scroll to specific section\n    const handleBarClick = (index)=>{\n        if (pageHeight === 0) return;\n        const windowHeight = window.innerHeight;\n        const maxScrollPosition = pageHeight - windowHeight;\n        const targetScrollPosition = index / 10 * maxScrollPosition;\n        window.scrollTo({\n            top: targetScrollPosition,\n            behavior: \"smooth\"\n        });\n    };\n    // Animate color and scale transitions with animejs\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ScrollGuide.useEffect\": ()=>{\n            if (!guideRef.current) return;\n            const bars = guideRef.current.querySelectorAll(\".scroll-guide-bar\");\n            bars.forEach({\n                \"ScrollGuide.useEffect\": (bar, idx)=>{\n                    let targetColor = \"#e5e7eb\"; // gray-300\n                    let targetScale = 1;\n                    if (idx === activeIndex) {\n                        targetColor = \"#14b8a6\"; // teal-500\n                        targetScale = 1.1;\n                    } else if (Math.abs(idx - activeIndex) === 1 || Math.abs(idx - activeIndex) === 2) {\n                        targetColor = \"#2dd4bf\"; // teal-300\n                        targetScale = 1.05;\n                    }\n                    (0,animejs__WEBPACK_IMPORTED_MODULE_2__.animate)(bar, {\n                        backgroundColor: targetColor,\n                        scale: targetScale,\n                        duration: 700,\n                        easing: \"easeInOutQuart\",\n                        delay: (0,animejs__WEBPACK_IMPORTED_MODULE_2__.stagger)(30, {\n                            start: 0\n                        })\n                    });\n                }\n            }[\"ScrollGuide.useEffect\"]);\n        }\n    }[\"ScrollGuide.useEffect\"], [\n        activeIndex\n    ]);\n    // Don't render if page height not calculated yet\n    if (pageHeight === 0) return null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: guideRef,\n        className: \"fixed right-6 top-1/4 flex flex-col gap-3 z-50\",\n        style: {\n            pointerEvents: \"auto\"\n        },\n        \"data-active-index\": activeIndex,\n        children: Array.from({\n            length: 10\n        }, (_, idx)=>{\n            // Initial color for SSR/hydration, will be animated by animejs\n            let barColor = \"bg-gray-200\";\n            if (idx === activeIndex) {\n                barColor = \"bg-teal-500\";\n            } else if (Math.abs(idx - activeIndex) === 1 || Math.abs(idx - activeIndex) === 2) {\n                barColor = \"bg-teal-200\";\n            }\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                type: \"button\",\n                onClick: ()=>handleBarClick(idx),\n                \"data-index\": idx,\n                className: \"scroll-guide-bar w-10 h-2 cursor-pointer \".concat(barColor),\n                \"aria-label\": \"Scroll to \".concat((idx + 1) * 10, \"% of page\"),\n                title: \"\".concat((idx + 1) * 10, \"% of page\")\n            }, \"scroll-guide-bar-\".concat(// biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n            idx), false, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/devlog/components/ScrollGuide.tsx\",\n                lineNumber: 114,\n                columnNumber: 6\n            }, undefined);\n        })\n    }, void 0, false, {\n        fileName: \"/Users/sathira/Projects/grotto/modules/devlog/components/ScrollGuide.tsx\",\n        lineNumber: 96,\n        columnNumber: 3\n    }, undefined);\n};\n_s(ScrollGuide, \"Oz0G72u6icZ1VPOY57Ey1+XhAic=\");\n_c = ScrollGuide;\nvar _c;\n$RefreshReg$(_c, \"ScrollGuide\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL21vZHVsZXMvZGV2bG9nL2NvbXBvbmVudHMvU2Nyb2xsR3VpZGUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDaUU7QUFDdEI7QUFFcEMsTUFBTU0sY0FBd0I7O0lBQ3BDLE1BQU1DLFdBQVdOLDZDQUFNQSxDQUFpQjtJQUN4QyxNQUFNLENBQUNPLGFBQWFDLGVBQWUsR0FBR1AsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDUSxZQUFZQyxjQUFjLEdBQUdULCtDQUFRQSxDQUFDO0lBRTdDLDZDQUE2QztJQUM3Q0YsZ0RBQVNBO2lDQUFDO1lBQ1QsTUFBTVk7MERBQW1CO29CQUN4QixNQUFNQyxpQkFBaUJDLEtBQUtDLEdBQUcsQ0FDOUJDLFNBQVNDLElBQUksQ0FBQ0MsWUFBWSxFQUMxQkYsU0FBU0MsSUFBSSxDQUFDRSxZQUFZLEVBQzFCSCxTQUFTSSxlQUFlLENBQUNDLFlBQVksRUFDckNMLFNBQVNJLGVBQWUsQ0FBQ0YsWUFBWSxFQUNyQ0YsU0FBU0ksZUFBZSxDQUFDRCxZQUFZO29CQUV0Q1IsY0FBY0U7Z0JBQ2Y7O1lBRUFEO1lBQ0FVLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVYO1lBRWxDO3lDQUFPLElBQU1VLE9BQU9FLG1CQUFtQixDQUFDLFVBQVVaOztRQUNuRDtnQ0FBRyxFQUFFO0lBRUwsNEVBQTRFO0lBQzVFLE1BQU1hLGVBQWV0QixrREFBV0E7aURBQUM7WUFDaEMsSUFBSU8sZUFBZSxHQUFHO1lBRXRCLE1BQU1nQixpQkFBaUJKLE9BQU9LLE9BQU87WUFDckMsTUFBTUMsZUFBZU4sT0FBT08sV0FBVztZQUN2QyxNQUFNQyxvQkFBb0JwQixhQUFha0I7WUFFdkMsbURBQW1EO1lBQ25ELE1BQU1HLG1CQUFtQkwsaUJBQWlCSTtZQUMxQyxNQUFNRSxpQkFBaUJsQixLQUFLbUIsR0FBRyxDQUFDbkIsS0FBS29CLEtBQUssQ0FBQ0gsbUJBQW1CLEtBQUs7WUFFbkV0QixlQUFldUI7UUFDaEI7Z0RBQUc7UUFBQ3RCO0tBQVc7SUFFZlYsZ0RBQVNBO2lDQUFDO1lBQ1RzQixPQUFPQyxnQkFBZ0IsQ0FBQyxVQUFVRTtZQUNsQ0EsZ0JBQWdCLGdCQUFnQjtZQUVoQzt5Q0FBTyxJQUFNSCxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVQzs7UUFDbkQ7Z0NBQUc7UUFBQ0E7S0FBYTtJQUVqQixpREFBaUQ7SUFDakQsTUFBTVUsaUJBQWlCLENBQUNDO1FBQ3ZCLElBQUkxQixlQUFlLEdBQUc7UUFFdEIsTUFBTWtCLGVBQWVOLE9BQU9PLFdBQVc7UUFDdkMsTUFBTUMsb0JBQW9CcEIsYUFBYWtCO1FBQ3ZDLE1BQU1TLHVCQUF1QixRQUFTLEtBQU1QO1FBRTVDUixPQUFPZ0IsUUFBUSxDQUFDO1lBQ2ZDLEtBQUtGO1lBQ0xHLFVBQVU7UUFDWDtJQUNEO0lBRUEsbURBQW1EO0lBQ25EeEMsZ0RBQVNBO2lDQUFDO1lBQ1QsSUFBSSxDQUFDTyxTQUFTa0MsT0FBTyxFQUFFO1lBQ3ZCLE1BQU1DLE9BQU9uQyxTQUFTa0MsT0FBTyxDQUFDRSxnQkFBZ0IsQ0FBQztZQUMvQ0QsS0FBS0UsT0FBTzt5Q0FBQyxDQUFDQyxLQUFLQztvQkFDbEIsSUFBSUMsY0FBYyxXQUFXLFdBQVc7b0JBQ3hDLElBQUlDLGNBQWM7b0JBQ2xCLElBQUlGLFFBQVF0QyxhQUFhO3dCQUN4QnVDLGNBQWMsV0FBVyxXQUFXO3dCQUNwQ0MsY0FBYztvQkFDZixPQUFPLElBQ05sQyxLQUFLbUMsR0FBRyxDQUFDSCxNQUFNdEMsaUJBQWlCLEtBQ2hDTSxLQUFLbUMsR0FBRyxDQUFDSCxNQUFNdEMsaUJBQWlCLEdBQy9CO3dCQUNEdUMsY0FBYyxXQUFXLFdBQVc7d0JBQ3BDQyxjQUFjO29CQUNmO29CQUNBNUMsZ0RBQU9BLENBQUN5QyxLQUFLO3dCQUNaSyxpQkFBaUJIO3dCQUNqQkksT0FBT0g7d0JBQ1BJLFVBQVU7d0JBQ1ZDLFFBQVE7d0JBQ1JDLE9BQU9qRCxnREFBT0EsQ0FBQyxJQUFJOzRCQUFFa0QsT0FBTzt3QkFBRTtvQkFDL0I7Z0JBQ0Q7O1FBQ0Q7Z0NBQUc7UUFBQy9DO0tBQVk7SUFFaEIsaURBQWlEO0lBQ2pELElBQUlFLGVBQWUsR0FBRyxPQUFPO0lBRTdCLHFCQUNDLDhEQUFDOEM7UUFDQUMsS0FBS2xEO1FBQ0xtRCxXQUFVO1FBQ1ZDLE9BQU87WUFBRUMsZUFBZTtRQUFPO1FBQy9CQyxxQkFBbUJyRDtrQkFFbEJzRCxNQUFNQyxJQUFJLENBQUM7WUFBRUMsUUFBUTtRQUFHLEdBQUcsQ0FBQ0MsR0FBR25CO1lBQy9CLCtEQUErRDtZQUMvRCxJQUFJb0IsV0FBVztZQUNmLElBQUlwQixRQUFRdEMsYUFBYTtnQkFDeEIwRCxXQUFXO1lBQ1osT0FBTyxJQUNOcEQsS0FBS21DLEdBQUcsQ0FBQ0gsTUFBTXRDLGlCQUFpQixLQUNoQ00sS0FBS21DLEdBQUcsQ0FBQ0gsTUFBTXRDLGlCQUFpQixHQUMvQjtnQkFDRDBELFdBQVc7WUFDWjtZQUNBLHFCQUNDLDhEQUFDQztnQkFLQUMsTUFBSztnQkFDTEMsU0FBUyxJQUFNbEMsZUFBZVc7Z0JBQzlCd0IsY0FBWXhCO2dCQUNaWSxXQUFXLDRDQUFxRCxPQUFUUTtnQkFDdkRLLGNBQVksYUFBNEIsT0FBZixDQUFDekIsTUFBTSxLQUFLLElBQUc7Z0JBQ3hDMEIsT0FBTyxHQUFrQixPQUFmLENBQUMxQixNQUFNLEtBQUssSUFBRztlQVRwQixvQkFHSixPQUZBLDhEQUE4RDtZQUM5REE7Ozs7O1FBVUo7Ozs7OztBQUdILEVBQUU7R0E3SFd4QztLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL21vZHVsZXMvZGV2bG9nL2NvbXBvbmVudHMvU2Nyb2xsR3VpZGUudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgYW5pbWF0ZSwgc3RhZ2dlciB9IGZyb20gXCJhbmltZWpzXCI7XG5cbmV4cG9ydCBjb25zdCBTY3JvbGxHdWlkZTogUmVhY3QuRkMgPSAoKSA9PiB7XG5cdGNvbnN0IGd1aWRlUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcblx0Y29uc3QgW2FjdGl2ZUluZGV4LCBzZXRBY3RpdmVJbmRleF0gPSB1c2VTdGF0ZSgwKTtcblx0Y29uc3QgW3BhZ2VIZWlnaHQsIHNldFBhZ2VIZWlnaHRdID0gdXNlU3RhdGUoMCk7XG5cblx0Ly8gQ2FsY3VsYXRlIHBhZ2UgaGVpZ2h0IGFuZCB1cGRhdGUgb24gcmVzaXplXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3QgdXBkYXRlUGFnZUhlaWdodCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGRvY3VtZW50SGVpZ2h0ID0gTWF0aC5tYXgoXG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuXHRcdFx0XHRkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCxcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCxcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCxcblx0XHRcdCk7XG5cdFx0XHRzZXRQYWdlSGVpZ2h0KGRvY3VtZW50SGVpZ2h0KTtcblx0XHR9O1xuXG5cdFx0dXBkYXRlUGFnZUhlaWdodCgpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZVBhZ2VIZWlnaHQpO1xuXG5cdFx0cmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZVBhZ2VIZWlnaHQpO1xuXHR9LCBbXSk7XG5cblx0Ly8gVHJhY2sgYWN0aXZlIHNlY3Rpb24gYmFzZWQgb24gc2Nyb2xsIHBvc2l0aW9uIChkaXZpZGUgcGFnZSBpbnRvIDEwIHBhcnRzKVxuXHRjb25zdCBoYW5kbGVTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG5cdFx0aWYgKHBhZ2VIZWlnaHQgPT09IDApIHJldHVybjtcblxuXHRcdGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gd2luZG93LnNjcm9sbFk7XG5cdFx0Y29uc3Qgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXHRcdGNvbnN0IG1heFNjcm9sbFBvc2l0aW9uID0gcGFnZUhlaWdodCAtIHdpbmRvd0hlaWdodDtcblxuXHRcdC8vIENhbGN1bGF0ZSB3aGljaCBzZWN0aW9uICgwLTkpIHdlJ3JlIGN1cnJlbnRseSBpblxuXHRcdGNvbnN0IHNjcm9sbFBlcmNlbnRhZ2UgPSBzY3JvbGxQb3NpdGlvbiAvIG1heFNjcm9sbFBvc2l0aW9uO1xuXHRcdGNvbnN0IGN1cnJlbnRTZWN0aW9uID0gTWF0aC5taW4oTWF0aC5mbG9vcihzY3JvbGxQZXJjZW50YWdlICogMTApLCA5KTtcblxuXHRcdHNldEFjdGl2ZUluZGV4KGN1cnJlbnRTZWN0aW9uKTtcblx0fSwgW3BhZ2VIZWlnaHRdKTtcblxuXHR1c2VFZmZlY3QoKCkgPT4ge1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCk7XG5cdFx0aGFuZGxlU2Nyb2xsKCk7IC8vIEluaXRpYWwgY2hlY2tcblxuXHRcdHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVTY3JvbGwpO1xuXHR9LCBbaGFuZGxlU2Nyb2xsXSk7XG5cblx0Ly8gSGFuZGxlIGJhciBjbGljayB0byBzY3JvbGwgdG8gc3BlY2lmaWMgc2VjdGlvblxuXHRjb25zdCBoYW5kbGVCYXJDbGljayA9IChpbmRleDogbnVtYmVyKSA9PiB7XG5cdFx0aWYgKHBhZ2VIZWlnaHQgPT09IDApIHJldHVybjtcblxuXHRcdGNvbnN0IHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblx0XHRjb25zdCBtYXhTY3JvbGxQb3NpdGlvbiA9IHBhZ2VIZWlnaHQgLSB3aW5kb3dIZWlnaHQ7XG5cdFx0Y29uc3QgdGFyZ2V0U2Nyb2xsUG9zaXRpb24gPSAoaW5kZXggLyAxMCkgKiBtYXhTY3JvbGxQb3NpdGlvbjtcblxuXHRcdHdpbmRvdy5zY3JvbGxUbyh7XG5cdFx0XHR0b3A6IHRhcmdldFNjcm9sbFBvc2l0aW9uLFxuXHRcdFx0YmVoYXZpb3I6IFwic21vb3RoXCIsXG5cdFx0fSk7XG5cdH07XG5cblx0Ly8gQW5pbWF0ZSBjb2xvciBhbmQgc2NhbGUgdHJhbnNpdGlvbnMgd2l0aCBhbmltZWpzXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKCFndWlkZVJlZi5jdXJyZW50KSByZXR1cm47XG5cdFx0Y29uc3QgYmFycyA9IGd1aWRlUmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvckFsbChcIi5zY3JvbGwtZ3VpZGUtYmFyXCIpO1xuXHRcdGJhcnMuZm9yRWFjaCgoYmFyLCBpZHgpID0+IHtcblx0XHRcdGxldCB0YXJnZXRDb2xvciA9IFwiI2U1ZTdlYlwiOyAvLyBncmF5LTMwMFxuXHRcdFx0bGV0IHRhcmdldFNjYWxlID0gMTtcblx0XHRcdGlmIChpZHggPT09IGFjdGl2ZUluZGV4KSB7XG5cdFx0XHRcdHRhcmdldENvbG9yID0gXCIjMTRiOGE2XCI7IC8vIHRlYWwtNTAwXG5cdFx0XHRcdHRhcmdldFNjYWxlID0gMS4xO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0TWF0aC5hYnMoaWR4IC0gYWN0aXZlSW5kZXgpID09PSAxIHx8XG5cdFx0XHRcdE1hdGguYWJzKGlkeCAtIGFjdGl2ZUluZGV4KSA9PT0gMlxuXHRcdFx0KSB7XG5cdFx0XHRcdHRhcmdldENvbG9yID0gXCIjMmRkNGJmXCI7IC8vIHRlYWwtMzAwXG5cdFx0XHRcdHRhcmdldFNjYWxlID0gMS4wNTtcblx0XHRcdH1cblx0XHRcdGFuaW1hdGUoYmFyLCB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogdGFyZ2V0Q29sb3IsXG5cdFx0XHRcdHNjYWxlOiB0YXJnZXRTY2FsZSxcblx0XHRcdFx0ZHVyYXRpb246IDcwMCxcblx0XHRcdFx0ZWFzaW5nOiBcImVhc2VJbk91dFF1YXJ0XCIsXG5cdFx0XHRcdGRlbGF5OiBzdGFnZ2VyKDMwLCB7IHN0YXJ0OiAwIH0pLFxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0sIFthY3RpdmVJbmRleF0pO1xuXG5cdC8vIERvbid0IHJlbmRlciBpZiBwYWdlIGhlaWdodCBub3QgY2FsY3VsYXRlZCB5ZXRcblx0aWYgKHBhZ2VIZWlnaHQgPT09IDApIHJldHVybiBudWxsO1xuXG5cdHJldHVybiAoXG5cdFx0PGRpdlxuXHRcdFx0cmVmPXtndWlkZVJlZn1cblx0XHRcdGNsYXNzTmFtZT1cImZpeGVkIHJpZ2h0LTYgdG9wLTEvNCBmbGV4IGZsZXgtY29sIGdhcC0zIHotNTBcIlxuXHRcdFx0c3R5bGU9e3sgcG9pbnRlckV2ZW50czogXCJhdXRvXCIgfX1cblx0XHRcdGRhdGEtYWN0aXZlLWluZGV4PXthY3RpdmVJbmRleH1cblx0XHQ+XG5cdFx0XHR7QXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgfSwgKF8sIGlkeCkgPT4ge1xuXHRcdFx0XHQvLyBJbml0aWFsIGNvbG9yIGZvciBTU1IvaHlkcmF0aW9uLCB3aWxsIGJlIGFuaW1hdGVkIGJ5IGFuaW1lanNcblx0XHRcdFx0bGV0IGJhckNvbG9yID0gXCJiZy1ncmF5LTIwMFwiO1xuXHRcdFx0XHRpZiAoaWR4ID09PSBhY3RpdmVJbmRleCkge1xuXHRcdFx0XHRcdGJhckNvbG9yID0gXCJiZy10ZWFsLTUwMFwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdE1hdGguYWJzKGlkeCAtIGFjdGl2ZUluZGV4KSA9PT0gMSB8fFxuXHRcdFx0XHRcdE1hdGguYWJzKGlkeCAtIGFjdGl2ZUluZGV4KSA9PT0gMlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRiYXJDb2xvciA9IFwiYmctdGVhbC0yMDBcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdGtleT17YHNjcm9sbC1ndWlkZS1iYXItJHtcblx0XHRcdFx0XHRcdFx0Ly8gYmlvbWUtaWdub3JlIGxpbnQvc3VzcGljaW91cy9ub0FycmF5SW5kZXhLZXk6IDxleHBsYW5hdGlvbj5cblx0XHRcdFx0XHRcdFx0aWR4XG5cdFx0XHRcdFx0XHR9YH1cblx0XHRcdFx0XHRcdHR5cGU9XCJidXR0b25cIlxuXHRcdFx0XHRcdFx0b25DbGljaz17KCkgPT4gaGFuZGxlQmFyQ2xpY2soaWR4KX1cblx0XHRcdFx0XHRcdGRhdGEtaW5kZXg9e2lkeH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17YHNjcm9sbC1ndWlkZS1iYXIgdy0xMCBoLTIgY3Vyc29yLXBvaW50ZXIgJHtiYXJDb2xvcn1gfVxuXHRcdFx0XHRcdFx0YXJpYS1sYWJlbD17YFNjcm9sbCB0byAkeyhpZHggKyAxKSAqIDEwfSUgb2YgcGFnZWB9XG5cdFx0XHRcdFx0XHR0aXRsZT17YCR7KGlkeCArIDEpICogMTB9JSBvZiBwYWdlYH1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQpO1xuXHRcdFx0fSl9XG5cdFx0PC9kaXY+XG5cdCk7XG59O1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJhbmltYXRlIiwic3RhZ2dlciIsIlNjcm9sbEd1aWRlIiwiZ3VpZGVSZWYiLCJhY3RpdmVJbmRleCIsInNldEFjdGl2ZUluZGV4IiwicGFnZUhlaWdodCIsInNldFBhZ2VIZWlnaHQiLCJ1cGRhdGVQYWdlSGVpZ2h0IiwiZG9jdW1lbnRIZWlnaHQiLCJNYXRoIiwibWF4IiwiZG9jdW1lbnQiLCJib2R5Iiwic2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50SGVpZ2h0Iiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVTY3JvbGwiLCJzY3JvbGxQb3NpdGlvbiIsInNjcm9sbFkiLCJ3aW5kb3dIZWlnaHQiLCJpbm5lckhlaWdodCIsIm1heFNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsUGVyY2VudGFnZSIsImN1cnJlbnRTZWN0aW9uIiwibWluIiwiZmxvb3IiLCJoYW5kbGVCYXJDbGljayIsImluZGV4IiwidGFyZ2V0U2Nyb2xsUG9zaXRpb24iLCJzY3JvbGxUbyIsInRvcCIsImJlaGF2aW9yIiwiY3VycmVudCIsImJhcnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImJhciIsImlkeCIsInRhcmdldENvbG9yIiwidGFyZ2V0U2NhbGUiLCJhYnMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzY2FsZSIsImR1cmF0aW9uIiwiZWFzaW5nIiwiZGVsYXkiLCJzdGFydCIsImRpdiIsInJlZiIsImNsYXNzTmFtZSIsInN0eWxlIiwicG9pbnRlckV2ZW50cyIsImRhdGEtYWN0aXZlLWluZGV4IiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImJhckNvbG9yIiwiYnV0dG9uIiwidHlwZSIsIm9uQ2xpY2siLCJkYXRhLWluZGV4IiwiYXJpYS1sYWJlbCIsInRpdGxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./modules/devlog/components/ScrollGuide.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./modules/devlog/pages/Devlog.tsx":
/*!*****************************************!*\
  !*** ./modules/devlog/pages/Devlog.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Devlog: () => (/* binding */ Devlog)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _modules_devlog_components_ContentHeader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/modules/devlog/components/ContentHeader */ \"(app-pages-browser)/./modules/devlog/components/ContentHeader.tsx\");\n/* harmony import */ var _modules_devlog_components_ScrollGuide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/modules/devlog/components/ScrollGuide */ \"(app-pages-browser)/./modules/devlog/components/ScrollGuide.tsx\");\n/* harmony import */ var _modules_layout_fonts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/modules/layout/fonts */ \"(app-pages-browser)/./modules/layout/fonts.ts\");\n/* __next_internal_client_entry_do_not_use__ Devlog auto */ \n\n\n\nconst Devlog = (props)=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"flex flex-col items-center relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_modules_devlog_components_ScrollGuide__WEBPACK_IMPORTED_MODULE_2__.ScrollGuide, {}, void 0, false, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/devlog/pages/Devlog.tsx\",\n                lineNumber: 17,\n                columnNumber: 4\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_modules_devlog_components_ContentHeader__WEBPACK_IMPORTED_MODULE_1__.ContentHeader, {\n                slug: props.slug,\n                title: props.title,\n                description: props.description\n            }, void 0, false, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/devlog/pages/Devlog.tsx\",\n                lineNumber: 18,\n                columnNumber: 4\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                className: \"w-full px-4 lg:w-1/2 my-8 text-lg \".concat(_modules_layout_fonts__WEBPACK_IMPORTED_MODULE_3__.redHatText.className),\n                children: props.children\n            }, void 0, false, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/devlog/pages/Devlog.tsx\",\n                lineNumber: 23,\n                columnNumber: 4\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/sathira/Projects/grotto/modules/devlog/pages/Devlog.tsx\",\n        lineNumber: 16,\n        columnNumber: 3\n    }, undefined);\n};\n_c = Devlog;\nvar _c;\n$RefreshReg$(_c, \"Devlog\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL21vZHVsZXMvZGV2bG9nL3BhZ2VzL0RldmxvZy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRTBFO0FBQ0o7QUFDbEI7QUFTN0MsTUFBTUcsU0FBUyxDQUFDQztJQUN0QixxQkFDQyw4REFBQ0M7UUFBS0MsV0FBVzs7MEJBQ2hCLDhEQUFDTCwrRUFBV0E7Ozs7OzBCQUNaLDhEQUFDRCxtRkFBYUE7Z0JBQ2JPLE1BQU1ILE1BQU1HLElBQUk7Z0JBQ2hCQyxPQUFPSixNQUFNSSxLQUFLO2dCQUNsQkMsYUFBYUwsTUFBTUssV0FBVzs7Ozs7OzBCQUUvQiw4REFBQ0M7Z0JBQ0FKLFdBQVcscUNBQTBELE9BQXJCSiw2REFBVUEsQ0FBQ0ksU0FBUzswQkFFbkVGLE1BQU1PLFFBQVE7Ozs7Ozs7Ozs7OztBQUluQixFQUFFO0tBaEJXUiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL21vZHVsZXMvZGV2bG9nL3BhZ2VzL0RldmxvZy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IENvbnRlbnRIZWFkZXIgfSBmcm9tIFwiQC9tb2R1bGVzL2RldmxvZy9jb21wb25lbnRzL0NvbnRlbnRIZWFkZXJcIjtcbmltcG9ydCB7IFNjcm9sbEd1aWRlIH0gZnJvbSAnQC9tb2R1bGVzL2RldmxvZy9jb21wb25lbnRzL1Njcm9sbEd1aWRlJztcbmltcG9ydCB7IHJlZEhhdFRleHQgfSBmcm9tIFwiQC9tb2R1bGVzL2xheW91dC9mb250c1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuXHRjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuXHRzbHVnOiBzdHJpbmc7XG5cdHRpdGxlOiBzdHJpbmc7XG5cdGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBEZXZsb2cgPSAocHJvcHM6IFByb3BzKSA9PiB7XG5cdHJldHVybiAoXG5cdFx0PG1haW4gY2xhc3NOYW1lPXtcImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIHJlbGF0aXZlXCJ9PlxuXHRcdFx0PFNjcm9sbEd1aWRlIC8+XG5cdFx0XHQ8Q29udGVudEhlYWRlclxuXHRcdFx0XHRzbHVnPXtwcm9wcy5zbHVnfVxuXHRcdFx0XHR0aXRsZT17cHJvcHMudGl0bGV9XG5cdFx0XHRcdGRlc2NyaXB0aW9uPXtwcm9wcy5kZXNjcmlwdGlvbn1cblx0XHRcdC8+XG5cdFx0XHQ8c2VjdGlvblxuXHRcdFx0XHRjbGFzc05hbWU9e2B3LWZ1bGwgcHgtNCBsZzp3LTEvMiBteS04IHRleHQtbGcgJHtyZWRIYXRUZXh0LmNsYXNzTmFtZX1gfVxuXHRcdFx0PlxuXHRcdFx0XHR7cHJvcHMuY2hpbGRyZW59XG5cdFx0XHQ8L3NlY3Rpb24+XG5cdFx0PC9tYWluPlxuXHQpO1xufTtcbiJdLCJuYW1lcyI6WyJDb250ZW50SGVhZGVyIiwiU2Nyb2xsR3VpZGUiLCJyZWRIYXRUZXh0IiwiRGV2bG9nIiwicHJvcHMiLCJtYWluIiwiY2xhc3NOYW1lIiwic2x1ZyIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJzZWN0aW9uIiwiY2hpbGRyZW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./modules/devlog/pages/Devlog.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./modules/icons/Clipboard.tsx":
/*!*************************************!*\
  !*** ./modules/icons/Clipboard.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClipboardIcon: () => (/* binding */ SvgComponent)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst SvgComponent = (props)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: 18,\n        height: 18,\n        viewBox: \"0 0 18 18\",\n        stroke: \"currentColor\",\n        ...props,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                children: \"clipboard\"\n            }, void 0, false, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/icons/Clipboard.tsx\",\n                lineNumber: 4,\n                columnNumber: 3\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                fill: \"none\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeWidth: 1.5,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"M6.25 2.75h-1a2 2 0 0 0-2 2v9.5a2 2 0 0 0 2 2h7.5a2 2 0 0 0 2-2v-9.5a2 2 0 0 0-2-2h-1\"\n                    }, void 0, false, {\n                        fileName: \"/Users/sathira/Projects/grotto/modules/icons/Clipboard.tsx\",\n                        lineNumber: 11,\n                        columnNumber: 4\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                        width: 5.5,\n                        height: 3,\n                        x: 6.25,\n                        y: 1.25,\n                        rx: 1,\n                        ry: 1\n                    }, void 0, false, {\n                        fileName: \"/Users/sathira/Projects/grotto/modules/icons/Clipboard.tsx\",\n                        lineNumber: 12,\n                        columnNumber: 4\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/icons/Clipboard.tsx\",\n                lineNumber: 5,\n                columnNumber: 3\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/sathira/Projects/grotto/modules/icons/Clipboard.tsx\",\n        lineNumber: 3,\n        columnNumber: 2\n    }, undefined);\n_c = SvgComponent;\n\nvar _c;\n$RefreshReg$(_c, \"SvgComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL21vZHVsZXMvaWNvbnMvQ2xpcGJvYXJkLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxNQUFNQSxlQUFlLENBQUNDLHNCQUNyQiw4REFBQ0M7UUFBSUMsT0FBTTtRQUE2QkMsT0FBTztRQUFJQyxRQUFRO1FBQUlDLFNBQVE7UUFBWUMsUUFBTztRQUFnQixHQUFHTixLQUFLOzswQkFDakgsOERBQUNPOzBCQUFPOzs7Ozs7MEJBQ1IsOERBQUNDO2dCQUNBQyxNQUFLO2dCQUNMQyxlQUFjO2dCQUNkQyxnQkFBZTtnQkFDZkMsYUFBYTs7a0NBRWIsOERBQUNDO3dCQUFLQyxHQUFFOzs7Ozs7a0NBQ1IsOERBQUNDO3dCQUFLWixPQUFPO3dCQUFLQyxRQUFRO3dCQUFHWSxHQUFHO3dCQUFNQyxHQUFHO3dCQUFNQyxJQUFJO3dCQUFHQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FWdkRwQjtBQWNtQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL21vZHVsZXMvaWNvbnMvQ2xpcGJvYXJkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNWR1Byb3BzIH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBTdmdDb21wb25lbnQgPSAocHJvcHM6IFNWR1Byb3BzPFNWR1NWR0VsZW1lbnQ+KSA9PiAoXG5cdDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPXsxOH0gaGVpZ2h0PXsxOH0gdmlld0JveD1cIjAgMCAxOCAxOFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHsuLi5wcm9wc30+XG5cdFx0PHRpdGxlPntcImNsaXBib2FyZFwifTwvdGl0bGU+XG5cdFx0PGdcblx0XHRcdGZpbGw9XCJub25lXCJcblx0XHRcdHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG5cdFx0XHRzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcblx0XHRcdHN0cm9rZVdpZHRoPXsxLjV9XG5cdFx0PlxuXHRcdFx0PHBhdGggZD1cIk02LjI1IDIuNzVoLTFhMiAyIDAgMCAwLTIgMnY5LjVhMiAyIDAgMCAwIDIgMmg3LjVhMiAyIDAgMCAwIDItMnYtOS41YTIgMiAwIDAgMC0yLTJoLTFcIiAvPlxuXHRcdFx0PHJlY3Qgd2lkdGg9ezUuNX0gaGVpZ2h0PXszfSB4PXs2LjI1fSB5PXsxLjI1fSByeD17MX0gcnk9ezF9IC8+XG5cdFx0PC9nPlxuXHQ8L3N2Zz5cbik7XG5leHBvcnQgeyBTdmdDb21wb25lbnQgYXMgQ2xpcGJvYXJkSWNvbiB9O1xuIl0sIm5hbWVzIjpbIlN2Z0NvbXBvbmVudCIsInByb3BzIiwic3ZnIiwieG1sbnMiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJzdHJva2UiLCJ0aXRsZSIsImciLCJmaWxsIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwic3Ryb2tlV2lkdGgiLCJwYXRoIiwiZCIsInJlY3QiLCJ4IiwieSIsInJ4IiwicnkiLCJDbGlwYm9hcmRJY29uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./modules/icons/Clipboard.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./modules/icons/ClipboardCheck.tsx":
/*!******************************************!*\
  !*** ./modules/icons/ClipboardCheck.tsx ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClipboardCheckIcon: () => (/* binding */ SvgComponent)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst SvgComponent = (props)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: 18,\n        height: 18,\n        viewBox: \"0 0 18 18\",\n        stroke: \"currentColor\",\n        ...props,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                children: \"clipboard check\"\n            }, void 0, false, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/icons/ClipboardCheck.tsx\",\n                lineNumber: 11,\n                columnNumber: 3\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n                fill: \"none\",\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeWidth: 1.5,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"M6.25 2.75h-1a2 2 0 0 0-2 2v9.5a2 2 0 0 0 2 2h7.5a2 2 0 0 0 2-2v-9.5a2 2 0 0 0-2-2h-1\"\n                    }, void 0, false, {\n                        fileName: \"/Users/sathira/Projects/grotto/modules/icons/ClipboardCheck.tsx\",\n                        lineNumber: 18,\n                        columnNumber: 4\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                        width: 5.5,\n                        height: 3,\n                        x: 6.25,\n                        y: 1.25,\n                        rx: 1,\n                        ry: 1\n                    }, void 0, false, {\n                        fileName: \"/Users/sathira/Projects/grotto/modules/icons/ClipboardCheck.tsx\",\n                        lineNumber: 19,\n                        columnNumber: 4\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"m6.25 10.25 1.75 2 3.75-5\"\n                    }, void 0, false, {\n                        fileName: \"/Users/sathira/Projects/grotto/modules/icons/ClipboardCheck.tsx\",\n                        lineNumber: 20,\n                        columnNumber: 4\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/sathira/Projects/grotto/modules/icons/ClipboardCheck.tsx\",\n                lineNumber: 12,\n                columnNumber: 3\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/sathira/Projects/grotto/modules/icons/ClipboardCheck.tsx\",\n        lineNumber: 3,\n        columnNumber: 2\n    }, undefined);\n_c = SvgComponent;\n\nvar _c;\n$RefreshReg$(_c, \"SvgComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL21vZHVsZXMvaWNvbnMvQ2xpcGJvYXJkQ2hlY2sudHN4IiwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE1BQU1BLGVBQWUsQ0FBQ0Msc0JBQ3JCLDhEQUFDQztRQUNBQyxPQUFNO1FBQ05DLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxTQUFRO1FBQ1JDLFFBQU87UUFDTixHQUFHTixLQUFLOzswQkFFVCw4REFBQ087MEJBQU87Ozs7OzswQkFDUiw4REFBQ0M7Z0JBQ0FDLE1BQUs7Z0JBQ0xDLGVBQWM7Z0JBQ2RDLGdCQUFlO2dCQUNmQyxhQUFhOztrQ0FFYiw4REFBQ0M7d0JBQUtDLEdBQUU7Ozs7OztrQ0FDUiw4REFBQ0M7d0JBQUtaLE9BQU87d0JBQUtDLFFBQVE7d0JBQUdZLEdBQUc7d0JBQU1DLEdBQUc7d0JBQU1DLElBQUk7d0JBQUdDLElBQUk7Ozs7OztrQ0FDMUQsOERBQUNOO3dCQUFLQyxHQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FsQkxmO0FBc0J3QyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL21vZHVsZXMvaWNvbnMvQ2xpcGJvYXJkQ2hlY2sudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU1ZHUHJvcHMgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IFN2Z0NvbXBvbmVudCA9IChwcm9wczogU1ZHUHJvcHM8U1ZHU1ZHRWxlbWVudD4pID0+IChcblx0PHN2Z1xuXHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuXHRcdHdpZHRoPXsxOH1cblx0XHRoZWlnaHQ9ezE4fVxuXHRcdHZpZXdCb3g9XCIwIDAgMTggMThcIlxuXHRcdHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG5cdFx0ey4uLnByb3BzfVxuXHQ+XG5cdFx0PHRpdGxlPntcImNsaXBib2FyZCBjaGVja1wifTwvdGl0bGU+XG5cdFx0PGdcblx0XHRcdGZpbGw9XCJub25lXCJcblx0XHRcdHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG5cdFx0XHRzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcblx0XHRcdHN0cm9rZVdpZHRoPXsxLjV9XG5cdFx0PlxuXHRcdFx0PHBhdGggZD1cIk02LjI1IDIuNzVoLTFhMiAyIDAgMCAwLTIgMnY5LjVhMiAyIDAgMCAwIDIgMmg3LjVhMiAyIDAgMCAwIDItMnYtOS41YTIgMiAwIDAgMC0yLTJoLTFcIiAvPlxuXHRcdFx0PHJlY3Qgd2lkdGg9ezUuNX0gaGVpZ2h0PXszfSB4PXs2LjI1fSB5PXsxLjI1fSByeD17MX0gcnk9ezF9IC8+XG5cdFx0XHQ8cGF0aCBkPVwibTYuMjUgMTAuMjUgMS43NSAyIDMuNzUtNVwiIC8+XG5cdFx0PC9nPlxuXHQ8L3N2Zz5cbik7XG5leHBvcnQgeyBTdmdDb21wb25lbnQgYXMgQ2xpcGJvYXJkQ2hlY2tJY29uIH07XG4iXSwibmFtZXMiOlsiU3ZnQ29tcG9uZW50IiwicHJvcHMiLCJzdmciLCJ4bWxucyIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld0JveCIsInN0cm9rZSIsInRpdGxlIiwiZyIsImZpbGwiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iLCJzdHJva2VXaWR0aCIsInBhdGgiLCJkIiwicmVjdCIsIngiLCJ5IiwicngiLCJyeSIsIkNsaXBib2FyZENoZWNrSWNvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./modules/icons/ClipboardCheck.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./modules/layout/fonts.ts":
/*!*********************************!*\
  !*** ./modules/layout/fonts.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   redHatMono: () => (/* reexport default from dynamic */ next_font_google_target_css_path_modules_layout_fonts_ts_import_Red_Hat_Mono_arguments_subsets_latin_variableName_redHatMono___WEBPACK_IMPORTED_MODULE_1___default.a),\n/* harmony export */   redHatText: () => (/* reexport default from dynamic */ next_font_google_target_css_path_modules_layout_fonts_ts_import_Red_Hat_Text_arguments_subsets_latin_variableName_redHatText___WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var next_font_google_target_css_path_modules_layout_fonts_ts_import_Red_Hat_Text_arguments_subsets_latin_variableName_redHatText___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Text\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatText\"} */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\\\"path\\\":\\\"modules/layout/fonts.ts\\\",\\\"import\\\":\\\"Red_Hat_Text\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"redHatText\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_modules_layout_fonts_ts_import_Red_Hat_Text_arguments_subsets_latin_variableName_redHatText___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_modules_layout_fonts_ts_import_Red_Hat_Text_arguments_subsets_latin_variableName_redHatText___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_font_google_target_css_path_modules_layout_fonts_ts_import_Red_Hat_Mono_arguments_subsets_latin_variableName_redHatMono___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Mono\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatMono\"} */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\\\"path\\\":\\\"modules/layout/fonts.ts\\\",\\\"import\\\":\\\"Red_Hat_Mono\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"redHatMono\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_modules_layout_fonts_ts_import_Red_Hat_Mono_arguments_subsets_latin_variableName_redHatMono___WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_modules_layout_fonts_ts_import_Red_Hat_Mono_arguments_subsets_latin_variableName_redHatMono___WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL21vZHVsZXMvbGF5b3V0L2ZvbnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVhQTtBQUlBQztBQUpBRDtBQUlBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL21vZHVsZXMvbGF5b3V0L2ZvbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlZF9IYXRfTW9ubywgUmVkX0hhdF9UZXh0IH0gZnJvbSBcIm5leHQvZm9udC9nb29nbGVcIjtcblxuZXhwb3J0IGNvbnN0IHJlZEhhdFRleHQgPSBSZWRfSGF0X1RleHQoe1xuXHRzdWJzZXRzOiBbXCJsYXRpblwiXSxcbn0pO1xuXG5leHBvcnQgY29uc3QgcmVkSGF0TW9ubyA9IFJlZF9IYXRfTW9ubyh7XG5cdHN1YnNldHM6IFtcImxhdGluXCJdLFxufSk7XG4iXSwibmFtZXMiOlsicmVkSGF0VGV4dCIsInJlZEhhdE1vbm8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./modules/layout/fonts.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./modules/mdx/components/Code.tsx":
/*!*****************************************!*\
  !*** ./modules/mdx/components/Code.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _modules_icons_ClipboardCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/modules/icons/ClipboardCheck */ \"(app-pages-browser)/./modules/icons/ClipboardCheck.tsx\");\n/* harmony import */ var _modules_icons_Clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/modules/icons/Clipboard */ \"(app-pages-browser)/./modules/icons/Clipboard.tsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var shiki__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! shiki */ \"(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/bundle-full.mjs\");\n/* __next_internal_client_entry_do_not_use__ Code auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst Code = (props)=>{\n    var _props_file;\n    _s();\n    const [copied, setCopied] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [highlighted, setHighlighted] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(\"\");\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)({\n        \"Code.useEffect\": ()=>{\n            (0,shiki__WEBPACK_IMPORTED_MODULE_4__.codeToHtml)(props.code, {\n                lang: props.lang,\n                theme: \"catppuccin-latte\",\n                defaultColor: false\n            }).then({\n                \"Code.useEffect\": (html)=>setHighlighted(html)\n            }[\"Code.useEffect\"]);\n        }\n    }[\"Code.useEffect\"], [\n        props.code,\n        props.lang\n    ]);\n    const setClipboardContent = ()=>{\n        navigator.clipboard.writeText(props.code);\n        setCopied(true);\n        setTimeout(()=>setCopied(false), 2000);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"article\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"relative text-sm border block p-4 my-4 rounded-md\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex justify-between items-center pb-4\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h6\", {\n                            children: (_props_file = props.file) === null || _props_file === void 0 ? void 0 : _props_file.trim()\n                        }, void 0, false, {\n                            fileName: \"/Users/sathira/Projects/grotto/modules/mdx/components/Code.tsx\",\n                            lineNumber: 36,\n                            columnNumber: 6\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            type: \"button\",\n                            onClick: setClipboardContent,\n                            className: \"p-1 hover:bg-gray-100 rounded-md\",\n                            title: \"Copy to clipboard\",\n                            children: copied ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_modules_icons_ClipboardCheck__WEBPACK_IMPORTED_MODULE_1__.ClipboardCheckIcon, {\n                                className: \"size-4 hover:scale-125 text-lime-500 transition-transform\"\n                            }, void 0, false, {\n                                fileName: \"/Users/sathira/Projects/grotto/modules/mdx/components/Code.tsx\",\n                                lineNumber: 44,\n                                columnNumber: 8\n                            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_modules_icons_Clipboard__WEBPACK_IMPORTED_MODULE_2__.ClipboardIcon, {\n                                className: \"size-4 hover:scale-125 transition-transform\"\n                            }, void 0, false, {\n                                fileName: \"/Users/sathira/Projects/grotto/modules/mdx/components/Code.tsx\",\n                                lineNumber: 46,\n                                columnNumber: 8\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/Users/sathira/Projects/grotto/modules/mdx/components/Code.tsx\",\n                            lineNumber: 37,\n                            columnNumber: 6\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/sathira/Projects/grotto/modules/mdx/components/Code.tsx\",\n                    lineNumber: 35,\n                    columnNumber: 5\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"code\", {\n                        // biome-ignore lint/security/noDangerouslySetInnerHtml: <explanation>\n                        dangerouslySetInnerHTML: {\n                            __html: highlighted\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Users/sathira/Projects/grotto/modules/mdx/components/Code.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 6\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/sathira/Projects/grotto/modules/mdx/components/Code.tsx\",\n                    lineNumber: 50,\n                    columnNumber: 5\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/sathira/Projects/grotto/modules/mdx/components/Code.tsx\",\n            lineNumber: 34,\n            columnNumber: 4\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/sathira/Projects/grotto/modules/mdx/components/Code.tsx\",\n        lineNumber: 33,\n        columnNumber: 3\n    }, undefined);\n};\n_s(Code, \"Ud80pLIY09Pjpc2M3hr645uba7Y=\");\n_c = Code;\nvar _c;\n$RefreshReg$(_c, \"Code\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL21vZHVsZXMvbWR4L2NvbXBvbmVudHMvQ29kZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ29FO0FBQ1Y7QUFDZDtBQUVUO0FBUTVCLE1BQU1LLE9BQU8sQ0FBQ0M7UUFzQlhBOztJQXJCVCxNQUFNLENBQUNDLFFBQVFDLFVBQVUsR0FBR04sK0NBQVFBLENBQUM7SUFDckMsTUFBTSxDQUFDTyxhQUFhQyxlQUFlLEdBQUdSLCtDQUFRQSxDQUFDO0lBRS9DQyxnREFBU0E7MEJBQUM7WUFDVEMsaURBQVVBLENBQUNFLE1BQU1LLElBQUksRUFBRTtnQkFDdEJDLE1BQU1OLE1BQU1NLElBQUk7Z0JBQ2hCQyxPQUFPO2dCQUNQQyxjQUFjO1lBQ2YsR0FBR0MsSUFBSTtrQ0FBQyxDQUFDQyxPQUFTTixlQUFlTTs7UUFDbEM7eUJBQUc7UUFBQ1YsTUFBTUssSUFBSTtRQUFFTCxNQUFNTSxJQUFJO0tBQUM7SUFFM0IsTUFBTUssc0JBQXNCO1FBQzNCQyxVQUFVQyxTQUFTLENBQUNDLFNBQVMsQ0FBQ2QsTUFBTUssSUFBSTtRQUN4Q0gsVUFBVTtRQUNWYSxXQUFXLElBQU1iLFVBQVUsUUFBUTtJQUNwQztJQUVBLHFCQUNDLDhEQUFDYztrQkFDQSw0RUFBQ0M7WUFBSUMsV0FBVTs7OEJBQ2QsOERBQUNEO29CQUFJQyxXQUFVOztzQ0FDZCw4REFBQ0M7dUNBQUluQixjQUFBQSxNQUFNb0IsSUFBSSxjQUFWcEIsa0NBQUFBLFlBQVlxQixJQUFJOzs7Ozs7c0NBQ3JCLDhEQUFDQzs0QkFDQUMsTUFBSzs0QkFDTEMsU0FBU2I7NEJBQ1RPLFdBQVU7NEJBQ1ZPLE9BQU07c0NBRUx4Qix1QkFDQSw4REFBQ1AsNkVBQWtCQTtnQ0FBQ3dCLFdBQVU7Ozs7OzBEQUU5Qiw4REFBQ3ZCLG1FQUFhQTtnQ0FBQ3VCLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUk1Qiw4REFBQ0Q7OEJBQ0EsNEVBQUNaO3dCQUNBLHNFQUFzRTt3QkFDdEVxQix5QkFBeUI7NEJBQUVDLFFBQVF4Qjt3QkFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1yRCxFQUFFO0dBN0NXSjtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL21vZHVsZXMvbWR4L2NvbXBvbmVudHMvQ29kZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBDbGlwYm9hcmRDaGVja0ljb24gfSBmcm9tIFwiQC9tb2R1bGVzL2ljb25zL0NsaXBib2FyZENoZWNrXCI7XG5pbXBvcnQgeyBDbGlwYm9hcmRJY29uIH0gZnJvbSBcIkAvbW9kdWxlcy9pY29ucy9DbGlwYm9hcmRcIjtcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgQnVuZGxlZExhbmd1YWdlIH0gZnJvbSBcInNoaWtpXCI7XG5pbXBvcnQgeyBjb2RlVG9IdG1sIH0gZnJvbSBcInNoaWtpXCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG5cdGxhbmc6IHN0cmluZztcblx0Y29kZTogQnVuZGxlZExhbmd1YWdlO1xuXHRmaWxlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBDb2RlID0gKHByb3BzOiBQcm9wcykgPT4ge1xuXHRjb25zdCBbY29waWVkLCBzZXRDb3BpZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXHRjb25zdCBbaGlnaGxpZ2h0ZWQsIHNldEhpZ2hsaWdodGVkXSA9IHVzZVN0YXRlKFwiXCIpO1xuXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0Y29kZVRvSHRtbChwcm9wcy5jb2RlLCB7XG5cdFx0XHRsYW5nOiBwcm9wcy5sYW5nLFxuXHRcdFx0dGhlbWU6IFwiY2F0cHB1Y2Npbi1sYXR0ZVwiLFxuXHRcdFx0ZGVmYXVsdENvbG9yOiBmYWxzZSxcblx0XHR9KS50aGVuKChodG1sKSA9PiBzZXRIaWdobGlnaHRlZChodG1sKSk7XG5cdH0sIFtwcm9wcy5jb2RlLCBwcm9wcy5sYW5nXSk7XG5cblx0Y29uc3Qgc2V0Q2xpcGJvYXJkQ29udGVudCA9ICgpID0+IHtcblx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwcm9wcy5jb2RlKTtcblx0XHRzZXRDb3BpZWQodHJ1ZSk7XG5cdFx0c2V0VGltZW91dCgoKSA9PiBzZXRDb3BpZWQoZmFsc2UpLCAyMDAwKTtcblx0fTtcblxuXHRyZXR1cm4gKFxuXHRcdDxhcnRpY2xlPlxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSB0ZXh0LXNtIGJvcmRlciBibG9jayBwLTQgbXktNCByb3VuZGVkLW1kXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIHBiLTRcIj5cblx0XHRcdFx0XHQ8aDY+e3Byb3BzLmZpbGU/LnRyaW0oKX08L2g2PlxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdHR5cGU9XCJidXR0b25cIlxuXHRcdFx0XHRcdFx0b25DbGljaz17c2V0Q2xpcGJvYXJkQ29udGVudH1cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cInAtMSBob3ZlcjpiZy1ncmF5LTEwMCByb3VuZGVkLW1kXCJcblx0XHRcdFx0XHRcdHRpdGxlPVwiQ29weSB0byBjbGlwYm9hcmRcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHtjb3BpZWQgPyAoXG5cdFx0XHRcdFx0XHRcdDxDbGlwYm9hcmRDaGVja0ljb24gY2xhc3NOYW1lPVwic2l6ZS00IGhvdmVyOnNjYWxlLTEyNSB0ZXh0LWxpbWUtNTAwIHRyYW5zaXRpb24tdHJhbnNmb3JtXCIgLz5cblx0XHRcdFx0XHRcdCkgOiAoXG5cdFx0XHRcdFx0XHRcdDxDbGlwYm9hcmRJY29uIGNsYXNzTmFtZT1cInNpemUtNCBob3ZlcjpzY2FsZS0xMjUgdHJhbnNpdGlvbi10cmFuc2Zvcm1cIiAvPlxuXHRcdFx0XHRcdFx0KX1cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0PGNvZGVcblx0XHRcdFx0XHRcdC8vIGJpb21lLWlnbm9yZSBsaW50L3NlY3VyaXR5L25vRGFuZ2Vyb3VzbHlTZXRJbm5lckh0bWw6IDxleHBsYW5hdGlvbj5cblx0XHRcdFx0XHRcdGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaGlnaGxpZ2h0ZWQgfX1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvYXJ0aWNsZT5cblx0KTtcbn07XG4iXSwibmFtZXMiOlsiQ2xpcGJvYXJkQ2hlY2tJY29uIiwiQ2xpcGJvYXJkSWNvbiIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiY29kZVRvSHRtbCIsIkNvZGUiLCJwcm9wcyIsImNvcGllZCIsInNldENvcGllZCIsImhpZ2hsaWdodGVkIiwic2V0SGlnaGxpZ2h0ZWQiLCJjb2RlIiwibGFuZyIsInRoZW1lIiwiZGVmYXVsdENvbG9yIiwidGhlbiIsImh0bWwiLCJzZXRDbGlwYm9hcmRDb250ZW50IiwibmF2aWdhdG9yIiwiY2xpcGJvYXJkIiwid3JpdGVUZXh0Iiwic2V0VGltZW91dCIsImFydGljbGUiLCJkaXYiLCJjbGFzc05hbWUiLCJoNiIsImZpbGUiLCJ0cmltIiwiYnV0dG9uIiwidHlwZSIsIm9uQ2xpY2siLCJ0aXRsZSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./modules/mdx/components/Code.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./modules/mdx/inline/code.tsx":
/*!*************************************!*\
  !*** ./modules/mdx/inline/code.tsx ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ Code auto */ \nconst Code = (data)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"code\", {\n        className: \"text-sm border inline p-1 px-3 rounded-sm text-wrap break-all\",\n        children: data.children\n    }, void 0, false, {\n        fileName: \"/Users/sathira/Projects/grotto/modules/mdx/inline/code.tsx\",\n        lineNumber: 9,\n        columnNumber: 2\n    }, undefined);\n_c = Code;\nvar _c;\n$RefreshReg$(_c, \"Code\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL21vZHVsZXMvbWR4L2lubGluZS9jb2RlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFPTyxNQUFNQSxPQUFPLENBQUNDLHFCQUNwQiw4REFBQ0M7UUFBS0MsV0FBVTtrQkFDZEYsS0FBS0csUUFBUTs7Ozs7a0JBRWQ7S0FKV0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9tb2R1bGVzL21keC9pbmxpbmUvY29kZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmludGVyZmFjZSBQcm9wcyB7XG5cdGNsYXNzTmFtZT86IHN0cmluZztcblx0Y2hpbGRyZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IENvZGUgPSAoZGF0YTogUHJvcHMpID0+IChcblx0PGNvZGUgY2xhc3NOYW1lPVwidGV4dC1zbSBib3JkZXIgaW5saW5lIHAtMSBweC0zIHJvdW5kZWQtc20gdGV4dC13cmFwIGJyZWFrLWFsbFwiPlxuXHRcdHtkYXRhLmNoaWxkcmVufVxuXHQ8L2NvZGU+XG4pO1xuIl0sIm5hbWVzIjpbIkNvZGUiLCJkYXRhIiwiY29kZSIsImNsYXNzTmFtZSIsImNoaWxkcmVuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./modules/mdx/inline/code.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Mono\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatMono\"}":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{"path":"modules/layout/fonts.ts","import":"Red_Hat_Mono","arguments":[{"subsets":["latin"]}],"variableName":"redHatMono"} ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Red Hat Mono', 'Red Hat Mono Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_dbfe30\"};\n    if(true) {\n      // 1772336747378\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwibW9kdWxlcy9sYXlvdXQvZm9udHMudHNcIixcImltcG9ydFwiOlwiUmVkX0hhdF9Nb25vXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcInJlZEhhdE1vbm9cIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyw0RUFBNEU7QUFDdkcsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsOFZBQStMLGNBQWMsc0RBQXNEO0FBQ2pTLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcInBhdGhcIjpcIm1vZHVsZXMvbGF5b3V0L2ZvbnRzLnRzXCIsXCJpbXBvcnRcIjpcIlJlZF9IYXRfTW9ub1wiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJyZWRIYXRNb25vXCJ9Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidSZWQgSGF0IE1vbm8nLCAnUmVkIEhhdCBNb25vIEZhbGxiYWNrJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lX2RiZmUzMFwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzcyMzM2NzQ3Mzc4XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Mono\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatMono\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Text\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatText\"}":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{"path":"modules/layout/fonts.ts","import":"Red_Hat_Text","arguments":[{"subsets":["latin"]}],"variableName":"redHatText"} ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Red Hat Text', 'Red Hat Text Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_618921\"};\n    if(true) {\n      // 1772336747470\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwibW9kdWxlcy9sYXlvdXQvZm9udHMudHNcIixcImltcG9ydFwiOlwiUmVkX0hhdF9UZXh0XCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcInJlZEhhdFRleHRcIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyw0RUFBNEU7QUFDdkcsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsOFZBQStMLGNBQWMsc0RBQXNEO0FBQ2pTLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcInBhdGhcIjpcIm1vZHVsZXMvbGF5b3V0L2ZvbnRzLnRzXCIsXCJpbXBvcnRcIjpcIlJlZF9IYXRfVGV4dFwiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJyZWRIYXRUZXh0XCJ9Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidSZWQgSGF0IFRleHQnLCAnUmVkIEhhdCBUZXh0IEZhbGxiYWNrJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lXzYxODkyMVwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzcyMzM2NzQ3NDcwXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Text\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatText\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*******************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*******************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpTEFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge30sXG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx5UUFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/index.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/index.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FontStyle: () => (/* reexport safe */ _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle),\n/* harmony export */   ShikiError: () => (/* reexport safe */ _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError),\n/* harmony export */   StackElementMetadata: () => (/* reexport safe */ _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.EncodedTokenMetadata),\n/* harmony export */   addClassToHast: () => (/* binding */ addClassToHast),\n/* harmony export */   applyColorReplacements: () => (/* binding */ applyColorReplacements),\n/* harmony export */   codeToHast: () => (/* binding */ codeToHast),\n/* harmony export */   codeToHtml: () => (/* binding */ codeToHtml),\n/* harmony export */   codeToTokens: () => (/* binding */ codeToTokens),\n/* harmony export */   codeToTokensBase: () => (/* binding */ codeToTokensBase),\n/* harmony export */   codeToTokensWithThemes: () => (/* binding */ codeToTokensWithThemes),\n/* harmony export */   createCssVariablesTheme: () => (/* binding */ createCssVariablesTheme),\n/* harmony export */   createHighlighterCore: () => (/* binding */ createHighlighterCore),\n/* harmony export */   createHighlighterCoreSync: () => (/* binding */ createHighlighterCoreSync),\n/* harmony export */   createJavaScriptRegexEngine: () => (/* binding */ createJavaScriptRegexEngine),\n/* harmony export */   createOnigurumaEngine: () => (/* binding */ createOnigurumaEngine),\n/* harmony export */   createPositionConverter: () => (/* binding */ createPositionConverter),\n/* harmony export */   createShikiInternal: () => (/* binding */ createShikiInternal),\n/* harmony export */   createShikiInternalSync: () => (/* binding */ createShikiInternalSync),\n/* harmony export */   createSingletonShorthands: () => (/* binding */ createSingletonShorthands),\n/* harmony export */   createWasmOnigEngine: () => (/* binding */ createWasmOnigEngine),\n/* harmony export */   createdBundledHighlighter: () => (/* binding */ createdBundledHighlighter),\n/* harmony export */   defaultJavaScriptRegexConstructor: () => (/* binding */ defaultJavaScriptRegexConstructor),\n/* harmony export */   enableDeprecationWarnings: () => (/* reexport safe */ _shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.e),\n/* harmony export */   getHighlighterCore: () => (/* binding */ getHighlighterCore),\n/* harmony export */   getShikiInternal: () => (/* binding */ getShikiInternal),\n/* harmony export */   getSingletonHighlighterCore: () => (/* binding */ getSingletonHighlighterCore),\n/* harmony export */   getTokenStyleObject: () => (/* binding */ getTokenStyleObject),\n/* harmony export */   hastToHtml: () => (/* reexport safe */ hast_util_to_html__WEBPACK_IMPORTED_MODULE_3__.toHtml),\n/* harmony export */   isNoneTheme: () => (/* binding */ isNoneTheme),\n/* harmony export */   isPlainLang: () => (/* binding */ isPlainLang),\n/* harmony export */   isSpecialLang: () => (/* binding */ isSpecialLang),\n/* harmony export */   isSpecialTheme: () => (/* binding */ isSpecialTheme),\n/* harmony export */   loadWasm: () => (/* binding */ loadWasm),\n/* harmony export */   makeSingletonHighlighter: () => (/* binding */ makeSingletonHighlighter),\n/* harmony export */   makeSingletonHighlighterCore: () => (/* binding */ makeSingletonHighlighterCore),\n/* harmony export */   normalizeGetter: () => (/* binding */ normalizeGetter),\n/* harmony export */   normalizeTheme: () => (/* binding */ normalizeTheme),\n/* harmony export */   resolveColorReplacements: () => (/* binding */ resolveColorReplacements),\n/* harmony export */   splitLines: () => (/* binding */ splitLines),\n/* harmony export */   splitToken: () => (/* binding */ splitToken),\n/* harmony export */   splitTokens: () => (/* binding */ splitTokens),\n/* harmony export */   stringifyTokenStyle: () => (/* binding */ stringifyTokenStyle),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   tokenizeAnsiWithTheme: () => (/* binding */ tokenizeAnsiWithTheme),\n/* harmony export */   tokenizeWithTheme: () => (/* binding */ tokenizeWithTheme),\n/* harmony export */   tokensToHast: () => (/* binding */ tokensToHast),\n/* harmony export */   transformerDecorations: () => (/* binding */ transformerDecorations),\n/* harmony export */   warnDeprecated: () => (/* reexport safe */ _shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)\n/* harmony export */ });\n/* harmony import */ var _shikijs_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shikijs/types */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+types@1.27.0/node_modules/@shikijs/types/dist/index.mjs\");\n/* harmony import */ var _shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @shikijs/engine-oniguruma */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-oniguruma@1.27.0/node_modules/@shikijs/engine-oniguruma/dist/index.mjs\");\n/* harmony import */ var _shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/core.DVV8c4RZ.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/shared/core.DVV8c4RZ.mjs\");\n/* harmony import */ var _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shikijs/vscode-textmate */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+vscode-textmate@10.0.1/node_modules/@shikijs/vscode-textmate/dist/index.js\");\n/* harmony import */ var hast_util_to_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-to-html */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/index.js\");\n/* harmony import */ var _shikijs_engine_javascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @shikijs/engine-javascript */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-javascript@1.27.0/node_modules/@shikijs/engine-javascript/dist/engine-compile.mjs\");\n\n\n\n\n\n\n\n\n\n\n\nfunction createOnigurumaEngine(options) {\n  (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `createOnigurumaEngine` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(options);\n}\nfunction createWasmOnigEngine(options) {\n  (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `createOnigurumaEngine` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(options);\n}\nfunction loadWasm(options) {\n  (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `loadWasm` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.loadWasm)(options);\n}\n\nfunction toArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\nfunction splitLines(code, preserveEnding = false) {\n  const parts = code.split(/(\\r?\\n)/g);\n  let index = 0;\n  const lines = [];\n  for (let i = 0; i < parts.length; i += 2) {\n    const line = preserveEnding ? parts[i] + (parts[i + 1] || \"\") : parts[i];\n    lines.push([line, index]);\n    index += parts[i].length;\n    index += parts[i + 1]?.length || 0;\n  }\n  return lines;\n}\nfunction isPlainLang(lang) {\n  return !lang || [\"plaintext\", \"txt\", \"text\", \"plain\"].includes(lang);\n}\nfunction isSpecialLang(lang) {\n  return lang === \"ansi\" || isPlainLang(lang);\n}\nfunction isNoneTheme(theme) {\n  return theme === \"none\";\n}\nfunction isSpecialTheme(theme) {\n  return isNoneTheme(theme);\n}\nfunction addClassToHast(node, className) {\n  if (!className)\n    return node;\n  node.properties ||= {};\n  node.properties.class ||= [];\n  if (typeof node.properties.class === \"string\")\n    node.properties.class = node.properties.class.split(/\\s+/g);\n  if (!Array.isArray(node.properties.class))\n    node.properties.class = [];\n  const targets = Array.isArray(className) ? className : className.split(/\\s+/g);\n  for (const c of targets) {\n    if (c && !node.properties.class.includes(c))\n      node.properties.class.push(c);\n  }\n  return node;\n}\nfunction splitToken(token, offsets) {\n  let lastOffset = 0;\n  const tokens = [];\n  for (const offset of offsets) {\n    if (offset > lastOffset) {\n      tokens.push({\n        ...token,\n        content: token.content.slice(lastOffset, offset),\n        offset: token.offset + lastOffset\n      });\n    }\n    lastOffset = offset;\n  }\n  if (lastOffset < token.content.length) {\n    tokens.push({\n      ...token,\n      content: token.content.slice(lastOffset),\n      offset: token.offset + lastOffset\n    });\n  }\n  return tokens;\n}\nfunction splitTokens(tokens, breakpoints) {\n  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);\n  if (!sorted.length)\n    return tokens;\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);\n      if (!breakpointsInToken.length)\n        return token;\n      return splitToken(token, breakpointsInToken);\n    });\n  });\n}\nasync function normalizeGetter(p) {\n  return Promise.resolve(typeof p === \"function\" ? p() : p).then((r) => r.default || r);\n}\nfunction resolveColorReplacements(theme, options) {\n  const replacements = typeof theme === \"string\" ? {} : { ...theme.colorReplacements };\n  const themeName = typeof theme === \"string\" ? theme : theme.name;\n  for (const [key, value] of Object.entries(options?.colorReplacements || {})) {\n    if (typeof value === \"string\")\n      replacements[key] = value;\n    else if (key === themeName)\n      Object.assign(replacements, value);\n  }\n  return replacements;\n}\nfunction applyColorReplacements(color, replacements) {\n  if (!color)\n    return color;\n  return replacements?.[color?.toLowerCase()] || color;\n}\nfunction getTokenStyleObject(token) {\n  const styles = {};\n  if (token.color)\n    styles.color = token.color;\n  if (token.bgColor)\n    styles[\"background-color\"] = token.bgColor;\n  if (token.fontStyle) {\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Italic)\n      styles[\"font-style\"] = \"italic\";\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Bold)\n      styles[\"font-weight\"] = \"bold\";\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Underline)\n      styles[\"text-decoration\"] = \"underline\";\n  }\n  return styles;\n}\nfunction stringifyTokenStyle(token) {\n  if (typeof token === \"string\")\n    return token;\n  return Object.entries(token).map(([key, value]) => `${key}:${value}`).join(\";\");\n}\nfunction createPositionConverter(code) {\n  const lines = splitLines(code, true).map(([line]) => line);\n  function indexToPos(index) {\n    if (index === code.length) {\n      return {\n        line: lines.length - 1,\n        character: lines[lines.length - 1].length\n      };\n    }\n    let character = index;\n    let line = 0;\n    for (const lineText of lines) {\n      if (character < lineText.length)\n        break;\n      character -= lineText.length;\n      line++;\n    }\n    return { line, character };\n  }\n  function posToIndex(line, character) {\n    let index = 0;\n    for (let i = 0; i < line; i++)\n      index += lines[i].length;\n    index += character;\n    return index;\n  }\n  return {\n    lines,\n    indexToPos,\n    posToIndex\n  };\n}\n\nclass ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nconst _grammarStateMap = /* @__PURE__ */ new WeakMap();\nfunction setLastGrammarStateToMap(keys, state) {\n  _grammarStateMap.set(keys, state);\n}\nfunction getLastGrammarStateFromMap(keys) {\n  return _grammarStateMap.get(keys);\n}\nclass GrammarState {\n  /**\n   * Theme to Stack mapping\n   */\n  _stacks = {};\n  lang;\n  get themes() {\n    return Object.keys(this._stacks);\n  }\n  get theme() {\n    return this.themes[0];\n  }\n  get _stack() {\n    return this._stacks[this.theme];\n  }\n  /**\n   * Static method to create a initial grammar state.\n   */\n  static initial(lang, themes) {\n    return new GrammarState(\n      Object.fromEntries(toArray(themes).map((theme) => [theme, _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.INITIAL])),\n      lang\n    );\n  }\n  constructor(...args) {\n    if (args.length === 2) {\n      const [stacksMap, lang] = args;\n      this.lang = lang;\n      this._stacks = stacksMap;\n    } else {\n      const [stack, lang, theme] = args;\n      this.lang = lang;\n      this._stacks = { [theme]: stack };\n    }\n  }\n  /**\n   * Get the internal stack object.\n   * @internal\n   */\n  getInternalStack(theme = this.theme) {\n    return this._stacks[theme];\n  }\n  /**\n   * @deprecated use `getScopes` instead\n   */\n  get scopes() {\n    return getScopes(this._stacks[this.theme]);\n  }\n  getScopes(theme = this.theme) {\n    return getScopes(this._stacks[theme]);\n  }\n  toJSON() {\n    return {\n      lang: this.lang,\n      theme: this.theme,\n      themes: this.themes,\n      scopes: this.scopes\n    };\n  }\n}\nfunction getScopes(stack) {\n  const scopes = [];\n  const visited = /* @__PURE__ */ new Set();\n  function pushScope(stack2) {\n    if (visited.has(stack2))\n      return;\n    visited.add(stack2);\n    const name = stack2?.nameScopesList?.scopeName;\n    if (name)\n      scopes.push(name);\n    if (stack2.parent)\n      pushScope(stack2.parent);\n  }\n  pushScope(stack);\n  return scopes;\n}\nfunction getGrammarStack(state, theme) {\n  if (!(state instanceof GrammarState))\n    throw new ShikiError(\"Invalid grammar state\");\n  return state.getInternalStack(theme);\n}\n\nfunction transformerDecorations() {\n  const map = /* @__PURE__ */ new WeakMap();\n  function getContext(shiki) {\n    if (!map.has(shiki.meta)) {\n      let normalizePosition = function(p) {\n        if (typeof p === \"number\") {\n          if (p < 0 || p > shiki.source.length)\n            throw new ShikiError(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);\n          return {\n            ...converter.indexToPos(p),\n            offset: p\n          };\n        } else {\n          const line = converter.lines[p.line];\n          if (line === undefined)\n            throw new ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);\n          if (p.character < 0 || p.character > line.length)\n            throw new ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);\n          return {\n            ...p,\n            offset: converter.posToIndex(p.line, p.character)\n          };\n        }\n      };\n      const converter = createPositionConverter(shiki.source);\n      const decorations = (shiki.options.decorations || []).map((d) => ({\n        ...d,\n        start: normalizePosition(d.start),\n        end: normalizePosition(d.end)\n      }));\n      verifyIntersections(decorations);\n      map.set(shiki.meta, {\n        decorations,\n        converter,\n        source: shiki.source\n      });\n    }\n    return map.get(shiki.meta);\n  }\n  return {\n    name: \"shiki:decorations\",\n    tokens(tokens) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);\n      const splitted = splitTokens(tokens, breakpoints);\n      return splitted;\n    },\n    code(codeEl) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const lines = Array.from(codeEl.children).filter((i) => i.type === \"element\" && i.tagName === \"span\");\n      if (lines.length !== ctx.converter.lines.length)\n        throw new ShikiError(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);\n      function applyLineSection(line, start, end, decoration) {\n        const lineEl = lines[line];\n        let text = \"\";\n        let startIndex = -1;\n        let endIndex = -1;\n        if (start === 0)\n          startIndex = 0;\n        if (end === 0)\n          endIndex = 0;\n        if (end === Number.POSITIVE_INFINITY)\n          endIndex = lineEl.children.length;\n        if (startIndex === -1 || endIndex === -1) {\n          for (let i = 0; i < lineEl.children.length; i++) {\n            text += stringify(lineEl.children[i]);\n            if (startIndex === -1 && text.length === start)\n              startIndex = i + 1;\n            if (endIndex === -1 && text.length === end)\n              endIndex = i + 1;\n          }\n        }\n        if (startIndex === -1)\n          throw new ShikiError(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);\n        if (endIndex === -1)\n          throw new ShikiError(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);\n        const children = lineEl.children.slice(startIndex, endIndex);\n        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {\n          applyDecoration(lineEl, decoration, \"line\");\n        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === \"element\") {\n          applyDecoration(children[0], decoration, \"token\");\n        } else {\n          const wrapper = {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {},\n            children\n          };\n          applyDecoration(wrapper, decoration, \"wrapper\");\n          lineEl.children.splice(startIndex, children.length, wrapper);\n        }\n      }\n      function applyLine(line, decoration) {\n        lines[line] = applyDecoration(lines[line], decoration, \"line\");\n      }\n      function applyDecoration(el, decoration, type) {\n        const properties = decoration.properties || {};\n        const transform = decoration.transform || ((i) => i);\n        el.tagName = decoration.tagName || \"span\";\n        el.properties = {\n          ...el.properties,\n          ...properties,\n          class: el.properties.class\n        };\n        if (decoration.properties?.class)\n          addClassToHast(el, decoration.properties.class);\n        el = transform(el, type) || el;\n        return el;\n      }\n      const lineApplies = [];\n      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset);\n      for (const decoration of sorted) {\n        const { start, end } = decoration;\n        if (start.line === end.line) {\n          applyLineSection(start.line, start.character, end.character, decoration);\n        } else if (start.line < end.line) {\n          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);\n          for (let i = start.line + 1; i < end.line; i++)\n            lineApplies.unshift(() => applyLine(i, decoration));\n          applyLineSection(end.line, 0, end.character, decoration);\n        }\n      }\n      lineApplies.forEach((i) => i());\n    }\n  };\n}\nfunction verifyIntersections(items) {\n  for (let i = 0; i < items.length; i++) {\n    const foo = items[i];\n    if (foo.start.offset > foo.end.offset)\n      throw new ShikiError(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);\n    for (let j = i + 1; j < items.length; j++) {\n      const bar = items[j];\n      const isFooHasBarStart = foo.start.offset < bar.start.offset && bar.start.offset < foo.end.offset;\n      const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset < foo.end.offset;\n      const isBarHasFooStart = bar.start.offset < foo.start.offset && foo.start.offset < bar.end.offset;\n      const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset < bar.end.offset;\n      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {\n        if (isFooHasBarEnd && isFooHasBarEnd)\n          continue;\n        if (isBarHasFooStart && isBarHasFooEnd)\n          continue;\n        throw new ShikiError(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);\n      }\n    }\n  }\n}\nfunction stringify(el) {\n  if (el.type === \"text\")\n    return el.value;\n  if (el.type === \"element\")\n    return el.children.map(stringify).join(\"\");\n  return \"\";\n}\n\nconst builtInTransformers = [\n  /* @__PURE__ */ transformerDecorations()\n];\nfunction getTransformers(options) {\n  return [\n    ...options.transformers || [],\n    ...builtInTransformers\n  ];\n}\n\n// src/colors.ts\nvar namedColors = [\n  \"black\",\n  \"red\",\n  \"green\",\n  \"yellow\",\n  \"blue\",\n  \"magenta\",\n  \"cyan\",\n  \"white\",\n  \"brightBlack\",\n  \"brightRed\",\n  \"brightGreen\",\n  \"brightYellow\",\n  \"brightBlue\",\n  \"brightMagenta\",\n  \"brightCyan\",\n  \"brightWhite\"\n];\n\n// src/decorations.ts\nvar decorations = {\n  1: \"bold\",\n  2: \"dim\",\n  3: \"italic\",\n  4: \"underline\",\n  7: \"reverse\",\n  9: \"strikethrough\"\n};\n\n// src/parser.ts\nfunction findSequence(value, position) {\n  const nextEscape = value.indexOf(\"\\x1B[\", position);\n  if (nextEscape !== -1) {\n    const nextClose = value.indexOf(\"m\", nextEscape);\n    return {\n      sequence: value.substring(nextEscape + 2, nextClose).split(\";\"),\n      startPosition: nextEscape,\n      position: nextClose + 1\n    };\n  }\n  return {\n    position: value.length\n  };\n}\nfunction parseColor(sequence, index) {\n  let offset = 1;\n  const colorMode = sequence[index + offset++];\n  let color;\n  if (colorMode === \"2\") {\n    const rgb = [\n      sequence[index + offset++],\n      sequence[index + offset++],\n      sequence[index + offset]\n    ].map((x) => Number.parseInt(x));\n    if (rgb.length === 3 && !rgb.some((x) => Number.isNaN(x))) {\n      color = {\n        type: \"rgb\",\n        rgb\n      };\n    }\n  } else if (colorMode === \"5\") {\n    const colorIndex = Number.parseInt(sequence[index + offset]);\n    if (!Number.isNaN(colorIndex)) {\n      color = { type: \"table\", index: Number(colorIndex) };\n    }\n  }\n  return [offset, color];\n}\nfunction parseSequence(sequence) {\n  const commands = [];\n  for (let i = 0; i < sequence.length; i++) {\n    const code = sequence[i];\n    const codeInt = Number.parseInt(code);\n    if (Number.isNaN(codeInt))\n      continue;\n    if (codeInt === 0) {\n      commands.push({ type: \"resetAll\" });\n    } else if (codeInt <= 9) {\n      const decoration = decorations[codeInt];\n      if (decoration) {\n        commands.push({\n          type: \"setDecoration\",\n          value: decorations[codeInt]\n        });\n      }\n    } else if (codeInt <= 29) {\n      const decoration = decorations[codeInt - 20];\n      if (decoration) {\n        commands.push({\n          type: \"resetDecoration\",\n          value: decoration\n        });\n      }\n    } else if (codeInt <= 37) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 30] }\n      });\n    } else if (codeInt === 38) {\n      const [offset, color] = parseColor(sequence, i);\n      if (color) {\n        commands.push({\n          type: \"setForegroundColor\",\n          value: color\n        });\n      }\n      i += offset;\n    } else if (codeInt === 39) {\n      commands.push({\n        type: \"resetForegroundColor\"\n      });\n    } else if (codeInt <= 47) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 40] }\n      });\n    } else if (codeInt === 48) {\n      const [offset, color] = parseColor(sequence, i);\n      if (color) {\n        commands.push({\n          type: \"setBackgroundColor\",\n          value: color\n        });\n      }\n      i += offset;\n    } else if (codeInt === 49) {\n      commands.push({\n        type: \"resetBackgroundColor\"\n      });\n    } else if (codeInt >= 90 && codeInt <= 97) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 90 + 8] }\n      });\n    } else if (codeInt >= 100 && codeInt <= 107) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 100 + 8] }\n      });\n    }\n  }\n  return commands;\n}\nfunction createAnsiSequenceParser() {\n  let foreground = null;\n  let background = null;\n  let decorations2 = /* @__PURE__ */ new Set();\n  return {\n    parse(value) {\n      const tokens = [];\n      let position = 0;\n      do {\n        const findResult = findSequence(value, position);\n        const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);\n        if (text.length > 0) {\n          tokens.push({\n            value: text,\n            foreground,\n            background,\n            decorations: new Set(decorations2)\n          });\n        }\n        if (findResult.sequence) {\n          const commands = parseSequence(findResult.sequence);\n          for (const styleToken of commands) {\n            if (styleToken.type === \"resetAll\") {\n              foreground = null;\n              background = null;\n              decorations2.clear();\n            } else if (styleToken.type === \"resetForegroundColor\") {\n              foreground = null;\n            } else if (styleToken.type === \"resetBackgroundColor\") {\n              background = null;\n            } else if (styleToken.type === \"resetDecoration\") {\n              decorations2.delete(styleToken.value);\n            }\n          }\n          for (const styleToken of commands) {\n            if (styleToken.type === \"setForegroundColor\") {\n              foreground = styleToken.value;\n            } else if (styleToken.type === \"setBackgroundColor\") {\n              background = styleToken.value;\n            } else if (styleToken.type === \"setDecoration\") {\n              decorations2.add(styleToken.value);\n            }\n          }\n        }\n        position = findResult.position;\n      } while (position < value.length);\n      return tokens;\n    }\n  };\n}\n\n// src/palette.ts\nvar defaultNamedColorsMap = {\n  black: \"#000000\",\n  red: \"#bb0000\",\n  green: \"#00bb00\",\n  yellow: \"#bbbb00\",\n  blue: \"#0000bb\",\n  magenta: \"#ff00ff\",\n  cyan: \"#00bbbb\",\n  white: \"#eeeeee\",\n  brightBlack: \"#555555\",\n  brightRed: \"#ff5555\",\n  brightGreen: \"#00ff00\",\n  brightYellow: \"#ffff55\",\n  brightBlue: \"#5555ff\",\n  brightMagenta: \"#ff55ff\",\n  brightCyan: \"#55ffff\",\n  brightWhite: \"#ffffff\"\n};\nfunction createColorPalette(namedColorsMap = defaultNamedColorsMap) {\n  function namedColor(name) {\n    return namedColorsMap[name];\n  }\n  function rgbColor(rgb) {\n    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, \"0\")).join(\"\")}`;\n  }\n  let colorTable;\n  function getColorTable() {\n    if (colorTable) {\n      return colorTable;\n    }\n    colorTable = [];\n    for (let i = 0; i < namedColors.length; i++) {\n      colorTable.push(namedColor(namedColors[i]));\n    }\n    let levels = [0, 95, 135, 175, 215, 255];\n    for (let r = 0; r < 6; r++) {\n      for (let g = 0; g < 6; g++) {\n        for (let b = 0; b < 6; b++) {\n          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));\n        }\n      }\n    }\n    let level = 8;\n    for (let i = 0; i < 24; i++, level += 10) {\n      colorTable.push(rgbColor([level, level, level]));\n    }\n    return colorTable;\n  }\n  function tableColor(index) {\n    return getColorTable()[index];\n  }\n  function value(color) {\n    switch (color.type) {\n      case \"named\":\n        return namedColor(color.name);\n      case \"rgb\":\n        return rgbColor(color.rgb);\n      case \"table\":\n        return tableColor(color.index);\n    }\n  }\n  return {\n    value\n  };\n}\n\nfunction tokenizeAnsiWithTheme(theme, fileContents, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const lines = splitLines(fileContents);\n  const colorPalette = createColorPalette(\n    Object.fromEntries(\n      namedColors.map((name) => [\n        name,\n        theme.colors?.[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]\n      ])\n    )\n  );\n  const parser = createAnsiSequenceParser();\n  return lines.map(\n    (line) => parser.parse(line[0]).map((token) => {\n      let color;\n      let bgColor;\n      if (token.decorations.has(\"reverse\")) {\n        color = token.background ? colorPalette.value(token.background) : theme.bg;\n        bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n      } else {\n        color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n        bgColor = token.background ? colorPalette.value(token.background) : undefined;\n      }\n      color = applyColorReplacements(color, colorReplacements);\n      bgColor = applyColorReplacements(bgColor, colorReplacements);\n      if (token.decorations.has(\"dim\"))\n        color = dimColor(color);\n      let fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.None;\n      if (token.decorations.has(\"bold\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Bold;\n      if (token.decorations.has(\"italic\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Italic;\n      if (token.decorations.has(\"underline\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Underline;\n      return {\n        content: token.value,\n        offset: line[1],\n        // TODO: more accurate offset? might need to fork ansi-sequence-parser\n        color,\n        bgColor,\n        fontStyle\n      };\n    })\n  );\n}\nfunction dimColor(color) {\n  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);\n  if (hexMatch) {\n    if (hexMatch[3]) {\n      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, \"0\");\n      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;\n    } else if (hexMatch[2]) {\n      return `#${hexMatch[1]}${hexMatch[2]}80`;\n    } else {\n      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join(\"\")}80`;\n    }\n  }\n  const cssVarMatch = color.match(/var\\((--[\\w-]+-ansi-[\\w-]+)\\)/);\n  if (cssVarMatch)\n    return `var(${cssVarMatch[1]}-dim)`;\n  return color;\n}\n\nfunction codeToTokensBase(internal, code, options = {}) {\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    return splitLines(code).map((line) => [{ content: line[0], offset: line[1] }]);\n  const { theme, colorMap } = internal.setTheme(themeName);\n  if (lang === \"ansi\")\n    return tokenizeAnsiWithTheme(theme, code, options);\n  const _grammar = internal.getLanguage(lang);\n  if (options.grammarState) {\n    if (options.grammarState.lang !== _grammar.name) {\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state language \"${options.grammarState.lang}\" does not match highlight language \"${_grammar.name}\"`);\n    }\n    if (!options.grammarState.themes.includes(theme.name)) {\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state themes \"${options.grammarState.themes}\" do not contain highlight theme \"${theme.name}\"`);\n    }\n  }\n  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);\n}\nfunction getLastGrammarState(...args) {\n  if (args.length === 2) {\n    return getLastGrammarStateFromMap(args[1]);\n  }\n  const [internal, code, options = {}] = args;\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Plain language does not have grammar state\");\n  if (lang === \"ansi\")\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"ANSI language does not have grammar state\");\n  const { theme, colorMap } = internal.setTheme(themeName);\n  const _grammar = internal.getLanguage(lang);\n  return new GrammarState(\n    _tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack,\n    _grammar.name,\n    theme.name\n  );\n}\nfunction tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);\n  const grammarState = new GrammarState(\n    _tokenizeWithTheme(code, grammar, theme, colorMap, options).stateStack,\n    grammar.name,\n    theme.name\n  );\n  setLastGrammarStateToMap(result.tokens, grammarState);\n  return result.tokens;\n}\nfunction _tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const {\n    tokenizeMaxLineLength = 0,\n    tokenizeTimeLimit = 500\n  } = options;\n  const lines = splitLines(code);\n  let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(\n    options.grammarContextCode,\n    grammar,\n    theme,\n    colorMap,\n    {\n      ...options,\n      grammarState: undefined,\n      grammarContextCode: undefined\n    }\n  ).stateStack : _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.INITIAL;\n  let actual = [];\n  const final = [];\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const [line, lineOffset] = lines[i];\n    if (line === \"\") {\n      actual = [];\n      final.push([]);\n      continue;\n    }\n    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {\n      actual = [];\n      final.push([{\n        content: line,\n        offset: lineOffset,\n        color: \"\",\n        fontStyle: 0\n      }]);\n      continue;\n    }\n    let resultWithScopes;\n    let tokensWithScopes;\n    let tokensWithScopesIndex;\n    if (options.includeExplanation) {\n      resultWithScopes = grammar.tokenizeLine(line, stateStack);\n      tokensWithScopes = resultWithScopes.tokens;\n      tokensWithScopesIndex = 0;\n    }\n    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);\n    const tokensLength = result.tokens.length / 2;\n    for (let j = 0; j < tokensLength; j++) {\n      const startIndex = result.tokens[2 * j];\n      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;\n      if (startIndex === nextStartIndex)\n        continue;\n      const metadata = result.tokens[2 * j + 1];\n      const color = applyColorReplacements(\n        colorMap[_shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.EncodedTokenMetadata.getForeground(metadata)],\n        colorReplacements\n      );\n      const fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.EncodedTokenMetadata.getFontStyle(metadata);\n      const token = {\n        content: line.substring(startIndex, nextStartIndex),\n        offset: lineOffset + startIndex,\n        color,\n        fontStyle\n      };\n      if (options.includeExplanation) {\n        const themeSettingsSelectors = [];\n        if (options.includeExplanation !== \"scopeName\") {\n          for (const setting of theme.settings) {\n            let selectors;\n            switch (typeof setting.scope) {\n              case \"string\":\n                selectors = setting.scope.split(/,/).map((scope) => scope.trim());\n                break;\n              case \"object\":\n                selectors = setting.scope;\n                break;\n              default:\n                continue;\n            }\n            themeSettingsSelectors.push({\n              settings: setting,\n              selectors: selectors.map((selector) => selector.split(/ /))\n            });\n          }\n        }\n        token.explanation = [];\n        let offset = 0;\n        while (startIndex + offset < nextStartIndex) {\n          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];\n          const tokenWithScopesText = line.substring(\n            tokenWithScopes.startIndex,\n            tokenWithScopes.endIndex\n          );\n          offset += tokenWithScopesText.length;\n          token.explanation.push({\n            content: tokenWithScopesText,\n            scopes: options.includeExplanation === \"scopeName\" ? explainThemeScopesNameOnly(\n              tokenWithScopes.scopes\n            ) : explainThemeScopesFull(\n              themeSettingsSelectors,\n              tokenWithScopes.scopes\n            )\n          });\n          tokensWithScopesIndex += 1;\n        }\n      }\n      actual.push(token);\n    }\n    final.push(actual);\n    actual = [];\n    stateStack = result.ruleStack;\n  }\n  return {\n    tokens: final,\n    stateStack\n  };\n}\nfunction explainThemeScopesNameOnly(scopes) {\n  return scopes.map((scope) => ({ scopeName: scope }));\n}\nfunction explainThemeScopesFull(themeSelectors, scopes) {\n  const result = [];\n  for (let i = 0, len = scopes.length; i < len; i++) {\n    const scope = scopes[i];\n    result[i] = {\n      scopeName: scope,\n      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))\n    };\n  }\n  return result;\n}\nfunction matchesOne(selector, scope) {\n  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === \".\";\n}\nfunction matches(selectors, scope, parentScopes) {\n  if (!matchesOne(selectors[selectors.length - 1], scope))\n    return false;\n  let selectorParentIndex = selectors.length - 2;\n  let parentIndex = parentScopes.length - 1;\n  while (selectorParentIndex >= 0 && parentIndex >= 0) {\n    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))\n      selectorParentIndex -= 1;\n    parentIndex -= 1;\n  }\n  if (selectorParentIndex === -1)\n    return true;\n  return false;\n}\nfunction explainThemeScope(themeSettingsSelectors, scope, parentScopes) {\n  const result = [];\n  for (const { selectors, settings } of themeSettingsSelectors) {\n    for (const selectorPieces of selectors) {\n      if (matches(selectorPieces, scope, parentScopes)) {\n        result.push(settings);\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfunction codeToTokensWithThemes(internal, code, options) {\n  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));\n  const themedTokens = themes.map((t) => {\n    const tokens2 = codeToTokensBase(internal, code, {\n      ...options,\n      theme: t.theme\n    });\n    const state = getLastGrammarStateFromMap(tokens2);\n    const theme = typeof t.theme === \"string\" ? t.theme : t.theme.name;\n    return {\n      tokens: tokens2,\n      state,\n      theme\n    };\n  });\n  const tokens = syncThemesTokenization(\n    ...themedTokens.map((i) => i.tokens)\n  );\n  const mergedTokens = tokens[0].map(\n    (line, lineIdx) => line.map((_token, tokenIdx) => {\n      const mergedToken = {\n        content: _token.content,\n        variants: {},\n        offset: _token.offset\n      };\n      if (\"includeExplanation\" in options && options.includeExplanation) {\n        mergedToken.explanation = _token.explanation;\n      }\n      tokens.forEach((t, themeIdx) => {\n        const {\n          content: _,\n          explanation: __,\n          offset: ___,\n          ...styles\n        } = t[lineIdx][tokenIdx];\n        mergedToken.variants[themes[themeIdx].color] = styles;\n      });\n      return mergedToken;\n    })\n  );\n  const mergedGrammarState = themedTokens[0].state ? new GrammarState(\n    Object.fromEntries(themedTokens.map((s) => [s.theme, s.state?.getInternalStack(s.theme)])),\n    themedTokens[0].state.lang\n  ) : undefined;\n  if (mergedGrammarState)\n    setLastGrammarStateToMap(mergedTokens, mergedGrammarState);\n  return mergedTokens;\n}\nfunction syncThemesTokenization(...themes) {\n  const outThemes = themes.map(() => []);\n  const count = themes.length;\n  for (let i = 0; i < themes[0].length; i++) {\n    const lines = themes.map((t) => t[i]);\n    const outLines = outThemes.map(() => []);\n    outThemes.forEach((t, i2) => t.push(outLines[i2]));\n    const indexes = lines.map(() => 0);\n    const current = lines.map((l) => l[0]);\n    while (current.every((t) => t)) {\n      const minLength = Math.min(...current.map((t) => t.content.length));\n      for (let n = 0; n < count; n++) {\n        const token = current[n];\n        if (token.content.length === minLength) {\n          outLines[n].push(token);\n          indexes[n] += 1;\n          current[n] = lines[n][indexes[n]];\n        } else {\n          outLines[n].push({\n            ...token,\n            content: token.content.slice(0, minLength)\n          });\n          current[n] = {\n            ...token,\n            content: token.content.slice(minLength),\n            offset: token.offset + minLength\n          };\n        }\n      }\n    }\n  }\n  return outThemes;\n}\n\nfunction codeToTokens(internal, code, options) {\n  let bg;\n  let fg;\n  let tokens;\n  let themeName;\n  let rootStyle;\n  let grammarState;\n  if (\"themes\" in options) {\n    const {\n      defaultColor = \"light\",\n      cssVariablePrefix = \"--shiki-\"\n    } = options;\n    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);\n    if (themes.length === 0)\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"`themes` option must not be empty\");\n    const themeTokens = codeToTokensWithThemes(\n      internal,\n      code,\n      options\n    );\n    grammarState = getLastGrammarStateFromMap(themeTokens);\n    if (defaultColor && !themes.find((t) => t.color === defaultColor))\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`\\`themes\\` option must contain the defaultColor key \\`${defaultColor}\\``);\n    const themeRegs = themes.map((t) => internal.getTheme(t.theme));\n    const themesOrder = themes.map((t) => t.color);\n    tokens = themeTokens.map((line) => line.map((token) => mergeToken(token, themesOrder, cssVariablePrefix, defaultColor)));\n    if (grammarState)\n      setLastGrammarStateToMap(tokens, grammarState);\n    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));\n    fg = themes.map((t, idx) => (idx === 0 && defaultColor ? \"\" : `${cssVariablePrefix + t.color}:`) + (applyColorReplacements(themeRegs[idx].fg, themeColorReplacements[idx]) || \"inherit\")).join(\";\");\n    bg = themes.map((t, idx) => (idx === 0 && defaultColor ? \"\" : `${cssVariablePrefix + t.color}-bg:`) + (applyColorReplacements(themeRegs[idx].bg, themeColorReplacements[idx]) || \"inherit\")).join(\";\");\n    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(\" \")}`;\n    rootStyle = defaultColor ? undefined : [fg, bg].join(\";\");\n  } else if (\"theme\" in options) {\n    const colorReplacements = resolveColorReplacements(options.theme, options);\n    tokens = codeToTokensBase(\n      internal,\n      code,\n      options\n    );\n    const _theme = internal.getTheme(options.theme);\n    bg = applyColorReplacements(_theme.bg, colorReplacements);\n    fg = applyColorReplacements(_theme.fg, colorReplacements);\n    themeName = _theme.name;\n    grammarState = getLastGrammarStateFromMap(tokens);\n  } else {\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Invalid options, either `theme` or `themes` must be provided\");\n  }\n  return {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  };\n}\nfunction mergeToken(merged, variantsOrder, cssVariablePrefix, defaultColor) {\n  const token = {\n    content: merged.content,\n    explanation: merged.explanation,\n    offset: merged.offset\n  };\n  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));\n  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));\n  const mergedStyles = {};\n  styles.forEach((cur, idx) => {\n    for (const key of styleKeys) {\n      const value = cur[key] || \"inherit\";\n      if (idx === 0 && defaultColor) {\n        mergedStyles[key] = value;\n      } else {\n        const keyName = key === \"color\" ? \"\" : key === \"background-color\" ? \"-bg\" : `-${key}`;\n        const varKey = cssVariablePrefix + variantsOrder[idx] + (key === \"color\" ? \"\" : keyName);\n        mergedStyles[varKey] = value;\n      }\n    }\n  });\n  token.htmlStyle = mergedStyles;\n  return token;\n}\n\nfunction codeToHast(internal, code, options, transformerContext = {\n  meta: {},\n  options,\n  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n}) {\n  let input = code;\n  for (const transformer of getTransformers(options))\n    input = transformer.preprocess?.call(transformerContext, input, options) || input;\n  let {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  } = codeToTokens(internal, input, options);\n  const {\n    mergeWhitespaces = true\n  } = options;\n  if (mergeWhitespaces === true)\n    tokens = mergeWhitespaceTokens(tokens);\n  else if (mergeWhitespaces === \"never\")\n    tokens = splitWhitespaceTokens(tokens);\n  const contextSource = {\n    ...transformerContext,\n    get source() {\n      return input;\n    }\n  };\n  for (const transformer of getTransformers(options))\n    tokens = transformer.tokens?.call(contextSource, tokens) || tokens;\n  return tokensToHast(\n    tokens,\n    {\n      ...options,\n      fg,\n      bg,\n      themeName,\n      rootStyle\n    },\n    contextSource,\n    grammarState\n  );\n}\nfunction tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {\n  const transformers = getTransformers(options);\n  const lines = [];\n  const root = {\n    type: \"root\",\n    children: []\n  };\n  const {\n    structure = \"classic\",\n    tabindex = \"0\"\n  } = options;\n  let preNode = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {\n      class: `shiki ${options.themeName || \"\"}`,\n      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,\n      ...tabindex !== false && tabindex != null ? {\n        tabindex: tabindex.toString()\n      } : {},\n      ...Object.fromEntries(\n        Array.from(\n          Object.entries(options.meta || {})\n        ).filter(([key]) => !key.startsWith(\"_\"))\n      )\n    },\n    children: []\n  };\n  let codeNode = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: {},\n    children: lines\n  };\n  const lineNodes = [];\n  const context = {\n    ...transformerContext,\n    structure,\n    addClassToHast,\n    get source() {\n      return transformerContext.source;\n    },\n    get tokens() {\n      return tokens;\n    },\n    get options() {\n      return options;\n    },\n    get root() {\n      return root;\n    },\n    get pre() {\n      return preNode;\n    },\n    get code() {\n      return codeNode;\n    },\n    get lines() {\n      return lineNodes;\n    }\n  };\n  tokens.forEach((line, idx) => {\n    if (idx) {\n      if (structure === \"inline\")\n        root.children.push({ type: \"element\", tagName: \"br\", properties: {}, children: [] });\n      else if (structure === \"classic\")\n        lines.push({ type: \"text\", value: \"\\n\" });\n    }\n    let lineNode = {\n      type: \"element\",\n      tagName: \"span\",\n      properties: { class: \"line\" },\n      children: []\n    };\n    let col = 0;\n    for (const token of line) {\n      let tokenNode = {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          ...token.htmlAttrs\n        },\n        children: [{ type: \"text\", value: token.content }]\n      };\n      if (typeof token.htmlStyle === \"string\")\n        (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`htmlStyle` as a string is deprecated. Use an object instead.\");\n      const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n      if (style)\n        tokenNode.properties.style = style;\n      for (const transformer of transformers)\n        tokenNode = transformer?.span?.call(context, tokenNode, idx + 1, col, lineNode, token) || tokenNode;\n      if (structure === \"inline\")\n        root.children.push(tokenNode);\n      else if (structure === \"classic\")\n        lineNode.children.push(tokenNode);\n      col += token.content.length;\n    }\n    if (structure === \"classic\") {\n      for (const transformer of transformers)\n        lineNode = transformer?.line?.call(context, lineNode, idx + 1) || lineNode;\n      lineNodes.push(lineNode);\n      lines.push(lineNode);\n    }\n  });\n  if (structure === \"classic\") {\n    for (const transformer of transformers)\n      codeNode = transformer?.code?.call(context, codeNode) || codeNode;\n    preNode.children.push(codeNode);\n    for (const transformer of transformers)\n      preNode = transformer?.pre?.call(context, preNode) || preNode;\n    root.children.push(preNode);\n  }\n  let result = root;\n  for (const transformer of transformers)\n    result = transformer?.root?.call(context, result) || result;\n  if (grammarState)\n    setLastGrammarStateToMap(result, grammarState);\n  return result;\n}\nfunction mergeWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    const newLine = [];\n    let carryOnContent = \"\";\n    let firstOffset = 0;\n    line.forEach((token, idx) => {\n      const isUnderline = token.fontStyle && token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Underline;\n      const couldMerge = !isUnderline;\n      if (couldMerge && token.content.match(/^\\s+$/) && line[idx + 1]) {\n        if (!firstOffset)\n          firstOffset = token.offset;\n        carryOnContent += token.content;\n      } else {\n        if (carryOnContent) {\n          if (couldMerge) {\n            newLine.push({\n              ...token,\n              offset: firstOffset,\n              content: carryOnContent + token.content\n            });\n          } else {\n            newLine.push(\n              {\n                content: carryOnContent,\n                offset: firstOffset\n              },\n              token\n            );\n          }\n          firstOffset = 0;\n          carryOnContent = \"\";\n        } else {\n          newLine.push(token);\n        }\n      }\n    });\n    return newLine;\n  });\n}\nfunction splitWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      if (token.content.match(/^\\s+$/))\n        return token;\n      const match = token.content.match(/^(\\s*)(.*?)(\\s*)$/);\n      if (!match)\n        return token;\n      const [, leading, content, trailing] = match;\n      if (!leading && !trailing)\n        return token;\n      const expanded = [{\n        ...token,\n        offset: token.offset + leading.length,\n        content\n      }];\n      if (leading) {\n        expanded.unshift({\n          content: leading,\n          offset: token.offset\n        });\n      }\n      if (trailing) {\n        expanded.push({\n          content: trailing,\n          offset: token.offset + leading.length + content.length\n        });\n      }\n      return expanded;\n    });\n  });\n}\n\nfunction codeToHtml(internal, code, options) {\n  const context = {\n    meta: {},\n    options,\n    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n  };\n  let result = (0,hast_util_to_html__WEBPACK_IMPORTED_MODULE_3__.toHtml)(codeToHast(internal, code, options, context));\n  for (const transformer of getTransformers(options))\n    result = transformer.postprocess?.call(context, result, options) || result;\n  return result;\n}\n\nconst VSCODE_FALLBACK_EDITOR_FG = { light: \"#333333\", dark: \"#bbbbbb\" };\nconst VSCODE_FALLBACK_EDITOR_BG = { light: \"#fffffe\", dark: \"#1e1e1e\" };\nconst RESOLVED_KEY = \"__shiki_resolved\";\nfunction normalizeTheme(rawTheme) {\n  if (rawTheme?.[RESOLVED_KEY])\n    return rawTheme;\n  const theme = {\n    ...rawTheme\n  };\n  if (theme.tokenColors && !theme.settings) {\n    theme.settings = theme.tokenColors;\n    delete theme.tokenColors;\n  }\n  theme.type ||= \"dark\";\n  theme.colorReplacements = { ...theme.colorReplacements };\n  theme.settings ||= [];\n  let { bg, fg } = theme;\n  if (!bg || !fg) {\n    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : undefined;\n    if (globalSetting?.settings?.foreground)\n      fg = globalSetting.settings.foreground;\n    if (globalSetting?.settings?.background)\n      bg = globalSetting.settings.background;\n    if (!fg && theme?.colors?.[\"editor.foreground\"])\n      fg = theme.colors[\"editor.foreground\"];\n    if (!bg && theme?.colors?.[\"editor.background\"])\n      bg = theme.colors[\"editor.background\"];\n    if (!fg)\n      fg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;\n    if (!bg)\n      bg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;\n    theme.fg = fg;\n    theme.bg = bg;\n  }\n  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {\n    theme.settings.unshift({\n      settings: {\n        foreground: theme.fg,\n        background: theme.bg\n      }\n    });\n  }\n  let replacementCount = 0;\n  const replacementMap = /* @__PURE__ */ new Map();\n  function getReplacementColor(value) {\n    if (replacementMap.has(value))\n      return replacementMap.get(value);\n    replacementCount += 1;\n    const hex = `#${replacementCount.toString(16).padStart(8, \"0\").toLowerCase()}`;\n    if (theme.colorReplacements?.[`#${hex}`])\n      return getReplacementColor(value);\n    replacementMap.set(value, hex);\n    return hex;\n  }\n  theme.settings = theme.settings.map((setting) => {\n    const replaceFg = setting.settings?.foreground && !setting.settings.foreground.startsWith(\"#\");\n    const replaceBg = setting.settings?.background && !setting.settings.background.startsWith(\"#\");\n    if (!replaceFg && !replaceBg)\n      return setting;\n    const clone = {\n      ...setting,\n      settings: {\n        ...setting.settings\n      }\n    };\n    if (replaceFg) {\n      const replacement = getReplacementColor(setting.settings.foreground);\n      theme.colorReplacements[replacement] = setting.settings.foreground;\n      clone.settings.foreground = replacement;\n    }\n    if (replaceBg) {\n      const replacement = getReplacementColor(setting.settings.background);\n      theme.colorReplacements[replacement] = setting.settings.background;\n      clone.settings.background = replacement;\n    }\n    return clone;\n  });\n  for (const key of Object.keys(theme.colors || {})) {\n    if (key === \"editor.foreground\" || key === \"editor.background\" || key.startsWith(\"terminal.ansi\")) {\n      if (!theme.colors[key]?.startsWith(\"#\")) {\n        const replacement = getReplacementColor(theme.colors[key]);\n        theme.colorReplacements[replacement] = theme.colors[key];\n        theme.colors[key] = replacement;\n      }\n    }\n  }\n  Object.defineProperty(theme, RESOLVED_KEY, {\n    enumerable: false,\n    writable: false,\n    value: true\n  });\n  return theme;\n}\n\nasync function resolveLangs(langs) {\n  return Array.from(new Set((await Promise.all(\n    langs.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r]))\n  )).flat()));\n}\nasync function resolveThemes(themes) {\n  const resolved = await Promise.all(\n    themes.map(\n      async (theme) => isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))\n    )\n  );\n  return resolved.filter((i) => !!i);\n}\n\nclass Registry extends _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.Registry {\n  constructor(_resolver, _themes, _langs, _alias = {}) {\n    super(_resolver);\n    this._resolver = _resolver;\n    this._themes = _themes;\n    this._langs = _langs;\n    this._alias = _alias;\n    this._themes.map((t) => this.loadTheme(t));\n    this.loadLanguages(this._langs);\n  }\n  _resolvedThemes = /* @__PURE__ */ new Map();\n  _resolvedGrammars = /* @__PURE__ */ new Map();\n  _langMap = /* @__PURE__ */ new Map();\n  _langGraph = /* @__PURE__ */ new Map();\n  _textmateThemeCache = /* @__PURE__ */ new WeakMap();\n  _loadedThemesCache = null;\n  _loadedLanguagesCache = null;\n  getTheme(theme) {\n    if (typeof theme === \"string\")\n      return this._resolvedThemes.get(theme);\n    else\n      return this.loadTheme(theme);\n  }\n  loadTheme(theme) {\n    const _theme = normalizeTheme(theme);\n    if (_theme.name) {\n      this._resolvedThemes.set(_theme.name, _theme);\n      this._loadedThemesCache = null;\n    }\n    return _theme;\n  }\n  getLoadedThemes() {\n    if (!this._loadedThemesCache)\n      this._loadedThemesCache = [...this._resolvedThemes.keys()];\n    return this._loadedThemesCache;\n  }\n  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`\n  // is expensive. Themes can switch often especially for dual-theme support.\n  //\n  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,\n  // we omit here so it's easier to cache the themes.\n  setTheme(theme) {\n    let textmateTheme = this._textmateThemeCache.get(theme);\n    if (!textmateTheme) {\n      textmateTheme = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.Theme.createFromRawTheme(theme);\n      this._textmateThemeCache.set(theme, textmateTheme);\n    }\n    this._syncRegistry.setTheme(textmateTheme);\n  }\n  getGrammar(name) {\n    if (this._alias[name]) {\n      const resolved = /* @__PURE__ */ new Set([name]);\n      while (this._alias[name]) {\n        name = this._alias[name];\n        if (resolved.has(name))\n          throw new ShikiError(`Circular alias \\`${Array.from(resolved).join(\" -> \")} -> ${name}\\``);\n        resolved.add(name);\n      }\n    }\n    return this._resolvedGrammars.get(name);\n  }\n  loadLanguage(lang) {\n    if (this.getGrammar(lang.name))\n      return;\n    const embeddedLazilyBy = new Set(\n      [...this._langMap.values()].filter((i) => i.embeddedLangsLazy?.includes(lang.name))\n    );\n    this._resolver.addLanguage(lang);\n    const grammarConfig = {\n      balancedBracketSelectors: lang.balancedBracketSelectors || [\"*\"],\n      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []\n    };\n    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);\n    const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);\n    g.name = lang.name;\n    this._resolvedGrammars.set(lang.name, g);\n    if (lang.aliases) {\n      lang.aliases.forEach((alias) => {\n        this._alias[alias] = lang.name;\n      });\n    }\n    this._loadedLanguagesCache = null;\n    if (embeddedLazilyBy.size) {\n      for (const e of embeddedLazilyBy) {\n        this._resolvedGrammars.delete(e.name);\n        this._loadedLanguagesCache = null;\n        this._syncRegistry?._injectionGrammars?.delete(e.scopeName);\n        this._syncRegistry?._grammars?.delete(e.scopeName);\n        this.loadLanguage(this._langMap.get(e.name));\n      }\n    }\n  }\n  dispose() {\n    super.dispose();\n    this._resolvedThemes.clear();\n    this._resolvedGrammars.clear();\n    this._langMap.clear();\n    this._langGraph.clear();\n    this._loadedThemesCache = null;\n  }\n  loadLanguages(langs) {\n    for (const lang of langs)\n      this.resolveEmbeddedLanguages(lang);\n    const langsGraphArray = Array.from(this._langGraph.entries());\n    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);\n    if (missingLangs.length) {\n      const dependents = langsGraphArray.filter(([_, lang]) => lang && lang.embeddedLangs?.some((l) => missingLangs.map(([name]) => name).includes(l))).filter((lang) => !missingLangs.includes(lang));\n      throw new ShikiError(`Missing languages ${missingLangs.map(([name]) => `\\`${name}\\``).join(\", \")}, required by ${dependents.map(([name]) => `\\`${name}\\``).join(\", \")}`);\n    }\n    for (const [_, lang] of langsGraphArray)\n      this._resolver.addLanguage(lang);\n    for (const [_, lang] of langsGraphArray)\n      this.loadLanguage(lang);\n  }\n  getLoadedLanguages() {\n    if (!this._loadedLanguagesCache) {\n      this._loadedLanguagesCache = [\n        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])\n      ];\n    }\n    return this._loadedLanguagesCache;\n  }\n  resolveEmbeddedLanguages(lang) {\n    this._langMap.set(lang.name, lang);\n    this._langGraph.set(lang.name, lang);\n    if (lang.embeddedLangs) {\n      for (const embeddedLang of lang.embeddedLangs)\n        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));\n    }\n  }\n}\n\nclass Resolver {\n  _langs = /* @__PURE__ */ new Map();\n  _scopeToLang = /* @__PURE__ */ new Map();\n  _injections = /* @__PURE__ */ new Map();\n  _onigLib;\n  constructor(engine, langs) {\n    this._onigLib = {\n      createOnigScanner: (patterns) => engine.createScanner(patterns),\n      createOnigString: (s) => engine.createString(s)\n    };\n    langs.forEach((i) => this.addLanguage(i));\n  }\n  get onigLib() {\n    return this._onigLib;\n  }\n  getLangRegistration(langIdOrAlias) {\n    return this._langs.get(langIdOrAlias);\n  }\n  loadGrammar(scopeName) {\n    return this._scopeToLang.get(scopeName);\n  }\n  addLanguage(l) {\n    this._langs.set(l.name, l);\n    if (l.aliases) {\n      l.aliases.forEach((a) => {\n        this._langs.set(a, l);\n      });\n    }\n    this._scopeToLang.set(l.scopeName, l);\n    if (l.injectTo) {\n      l.injectTo.forEach((i) => {\n        if (!this._injections.get(i))\n          this._injections.set(i, []);\n        this._injections.get(i).push(l.scopeName);\n      });\n    }\n  }\n  getInjections(scopeName) {\n    const scopeParts = scopeName.split(\".\");\n    let injections = [];\n    for (let i = 1; i <= scopeParts.length; i++) {\n      const subScopeName = scopeParts.slice(0, i).join(\".\");\n      injections = [...injections, ...this._injections.get(subScopeName) || []];\n    }\n    return injections;\n  }\n}\n\nlet instancesCount = 0;\nfunction createShikiInternalSync(options) {\n  instancesCount += 1;\n  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)\n    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \\`highlighter.dispose()\\` to release unused instances.`);\n  let isDisposed = false;\n  if (!options.engine)\n    throw new ShikiError(\"`engine` option is required for synchronous mode\");\n  const langs = (options.langs || []).flat(1);\n  const themes = (options.themes || []).flat(1).map(normalizeTheme);\n  const resolver = new Resolver(options.engine, langs);\n  const _registry = new Registry(resolver, themes, langs, options.langAlias);\n  let _lastTheme;\n  function getLanguage(name) {\n    ensureNotDisposed();\n    const _lang = _registry.getGrammar(typeof name === \"string\" ? name : name.name);\n    if (!_lang)\n      throw new ShikiError(`Language \\`${name}\\` not found, you may need to load it first`);\n    return _lang;\n  }\n  function getTheme(name) {\n    if (name === \"none\")\n      return { bg: \"\", fg: \"\", name: \"none\", settings: [], type: \"dark\" };\n    ensureNotDisposed();\n    const _theme = _registry.getTheme(name);\n    if (!_theme)\n      throw new ShikiError(`Theme \\`${name}\\` not found, you may need to load it first`);\n    return _theme;\n  }\n  function setTheme(name) {\n    ensureNotDisposed();\n    const theme = getTheme(name);\n    if (_lastTheme !== name) {\n      _registry.setTheme(theme);\n      _lastTheme = name;\n    }\n    const colorMap = _registry.getColorMap();\n    return {\n      theme,\n      colorMap\n    };\n  }\n  function getLoadedThemes() {\n    ensureNotDisposed();\n    return _registry.getLoadedThemes();\n  }\n  function getLoadedLanguages() {\n    ensureNotDisposed();\n    return _registry.getLoadedLanguages();\n  }\n  function loadLanguageSync(...langs2) {\n    ensureNotDisposed();\n    _registry.loadLanguages(langs2.flat(1));\n  }\n  async function loadLanguage(...langs2) {\n    return loadLanguageSync(await resolveLangs(langs2));\n  }\n  function loadThemeSync(...themes2) {\n    ensureNotDisposed();\n    for (const theme of themes2.flat(1)) {\n      _registry.loadTheme(theme);\n    }\n  }\n  async function loadTheme(...themes2) {\n    ensureNotDisposed();\n    return loadThemeSync(await resolveThemes(themes2));\n  }\n  function ensureNotDisposed() {\n    if (isDisposed)\n      throw new ShikiError(\"Shiki instance has been disposed\");\n  }\n  function dispose() {\n    if (isDisposed)\n      return;\n    isDisposed = true;\n    _registry.dispose();\n    instancesCount -= 1;\n  }\n  return {\n    setTheme,\n    getTheme,\n    getLanguage,\n    getLoadedThemes,\n    getLoadedLanguages,\n    loadLanguage,\n    loadLanguageSync,\n    loadTheme,\n    loadThemeSync,\n    dispose,\n    [Symbol.dispose]: dispose\n  };\n}\n\nasync function createShikiInternal(options = {}) {\n  if (options.loadWasm) {\n    (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`loadWasm` option is deprecated. Use `engine: createOnigurumaEngine(loadWasm)` instead.\");\n  }\n  const [\n    themes,\n    langs,\n    engine\n  ] = await Promise.all([\n    resolveThemes(options.themes || []),\n    resolveLangs(options.langs || []),\n    options.engine || (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(options.loadWasm || (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.getDefaultWasmLoader)())\n  ]);\n  return createShikiInternalSync({\n    ...options,\n    loadWasm: undefined,\n    themes,\n    langs,\n    engine\n  });\n}\nfunction getShikiInternal(options = {}) {\n  (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`getShikiInternal` is deprecated. Use `createShikiInternal` instead.\");\n  return createShikiInternal(options);\n}\n\nasync function createHighlighterCore(options = {}) {\n  const internal = await createShikiInternal(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction createHighlighterCoreSync(options = {}) {\n  const internal = createShikiInternalSync(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction makeSingletonHighlighterCore(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighterCore2(options = {}) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighterCore2;\n}\nconst getSingletonHighlighterCore = /* @__PURE__ */ makeSingletonHighlighterCore(createHighlighterCore);\nfunction getHighlighterCore(options = {}) {\n  (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`getHighlighterCore` is deprecated. Use `createHighlighterCore` or `getSingletonHighlighterCore` instead.\");\n  return createHighlighterCore(options);\n}\n\nfunction createdBundledHighlighter(arg1, arg2, arg3) {\n  let bundledLanguages;\n  let bundledThemes;\n  let engine;\n  if (arg2) {\n    (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`createdBundledHighlighter` signature with `bundledLanguages` and `bundledThemes` is deprecated. Use the options object signature instead.\");\n    bundledLanguages = arg1;\n    bundledThemes = arg2;\n    engine = () => createOnigurumaEngine(arg3);\n  } else {\n    const options = arg1;\n    bundledLanguages = options.langs;\n    bundledThemes = options.themes;\n    engine = options.engine;\n  }\n  async function createHighlighter(options) {\n    function resolveLang(lang) {\n      if (typeof lang === \"string\") {\n        if (isSpecialLang(lang))\n          return [];\n        const bundle = bundledLanguages[lang];\n        if (!bundle)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Language \\`${lang}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return lang;\n    }\n    function resolveTheme(theme) {\n      if (isSpecialTheme(theme))\n        return \"none\";\n      if (typeof theme === \"string\") {\n        const bundle = bundledThemes[theme];\n        if (!bundle)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Theme \\`${theme}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return theme;\n    }\n    const _themes = (options.themes ?? []).map((i) => resolveTheme(i));\n    const langs = (options.langs ?? []).map((i) => resolveLang(i));\n    const core = await createHighlighterCore({\n      engine: options.engine ?? engine(),\n      ...options,\n      themes: _themes,\n      langs\n    });\n    return {\n      ...core,\n      loadLanguage(...langs2) {\n        return core.loadLanguage(...langs2.map(resolveLang));\n      },\n      loadTheme(...themes) {\n        return core.loadTheme(...themes.map(resolveTheme));\n      }\n    };\n  }\n  return createHighlighter;\n}\nfunction makeSingletonHighlighter(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighter(options = {}) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighter;\n}\nfunction createSingletonShorthands(createHighlighter) {\n  const getSingletonHighlighter = makeSingletonHighlighter(createHighlighter);\n  return {\n    getSingletonHighlighter(options) {\n      return getSingletonHighlighter(options);\n    },\n    async codeToHtml(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n      });\n      return shiki.codeToHtml(code, options);\n    },\n    async codeToHast(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n      });\n      return shiki.codeToHast(code, options);\n    },\n    async codeToTokens(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n      });\n      return shiki.codeToTokens(code, options);\n    },\n    async codeToTokensBase(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: [options.theme]\n      });\n      return shiki.codeToTokensBase(code, options);\n    },\n    async codeToTokensWithThemes(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: Object.values(options.themes).filter(Boolean)\n      });\n      return shiki.codeToTokensWithThemes(code, options);\n    },\n    async getLastGrammarState(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: [options.theme]\n      });\n      return shiki.getLastGrammarState(code, options);\n    }\n  };\n}\n\nfunction createJavaScriptRegexEngine(options) {\n  (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `createJavaScriptRegexEngine` from `@shikijs/engine-javascript` or `shiki/engine/javascript` instead\");\n  return (0,_shikijs_engine_javascript__WEBPACK_IMPORTED_MODULE_5__.createJavaScriptRegexEngine)(options);\n}\nfunction defaultJavaScriptRegexConstructor(pattern) {\n  (0,_shared_core_DVV8c4RZ_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `defaultJavaScriptRegexConstructor` from `@shikijs/engine-javascript` or `shiki/engine/javascript` instead\");\n  return (0,_shikijs_engine_javascript__WEBPACK_IMPORTED_MODULE_5__.defaultJavaScriptRegexConstructor)(pattern);\n}\n\nfunction createCssVariablesTheme(options = {}) {\n  const {\n    name = \"css-variables\",\n    variablePrefix = \"--shiki-\",\n    fontStyle = true\n  } = options;\n  const variable = (name2) => {\n    if (options.variableDefaults?.[name2])\n      return `var(${variablePrefix}${name2}, ${options.variableDefaults[name2]})`;\n    return `var(${variablePrefix}${name2})`;\n  };\n  const theme = {\n    name,\n    type: \"dark\",\n    colors: {\n      \"editor.foreground\": variable(\"foreground\"),\n      \"editor.background\": variable(\"background\"),\n      \"terminal.ansiBlack\": variable(\"ansi-black\"),\n      \"terminal.ansiRed\": variable(\"ansi-red\"),\n      \"terminal.ansiGreen\": variable(\"ansi-green\"),\n      \"terminal.ansiYellow\": variable(\"ansi-yellow\"),\n      \"terminal.ansiBlue\": variable(\"ansi-blue\"),\n      \"terminal.ansiMagenta\": variable(\"ansi-magenta\"),\n      \"terminal.ansiCyan\": variable(\"ansi-cyan\"),\n      \"terminal.ansiWhite\": variable(\"ansi-white\"),\n      \"terminal.ansiBrightBlack\": variable(\"ansi-bright-black\"),\n      \"terminal.ansiBrightRed\": variable(\"ansi-bright-red\"),\n      \"terminal.ansiBrightGreen\": variable(\"ansi-bright-green\"),\n      \"terminal.ansiBrightYellow\": variable(\"ansi-bright-yellow\"),\n      \"terminal.ansiBrightBlue\": variable(\"ansi-bright-blue\"),\n      \"terminal.ansiBrightMagenta\": variable(\"ansi-bright-magenta\"),\n      \"terminal.ansiBrightCyan\": variable(\"ansi-bright-cyan\"),\n      \"terminal.ansiBrightWhite\": variable(\"ansi-bright-white\")\n    },\n    tokenColors: [\n      {\n        scope: [\n          \"keyword.operator.accessor\",\n          \"meta.group.braces.round.function.arguments\",\n          \"meta.template.expression\",\n          \"markup.fenced_code meta.embedded.block\"\n        ],\n        settings: {\n          foreground: variable(\"foreground\")\n        }\n      },\n      {\n        scope: \"emphasis\",\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: [\"strong\", \"markup.heading.markdown\", \"markup.bold.markdown\"],\n        settings: {\n          fontStyle: \"bold\"\n        }\n      },\n      {\n        scope: [\"markup.italic.markdown\"],\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: \"meta.link.inline.markdown\",\n        settings: {\n          fontStyle: \"underline\",\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        scope: [\"string\", \"markup.fenced_code\", \"markup.inline\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        scope: [\"comment\", \"string.quoted.docstring.multi\"],\n        settings: {\n          foreground: variable(\"token-comment\")\n        }\n      },\n      {\n        scope: [\n          \"constant.numeric\",\n          \"constant.language\",\n          \"constant.other.placeholder\",\n          \"constant.character.format.placeholder\",\n          \"variable.language.this\",\n          \"variable.other.object\",\n          \"variable.other.class\",\n          \"variable.other.constant\",\n          \"meta.property-name\",\n          \"meta.property-value\",\n          \"support\"\n        ],\n        settings: {\n          foreground: variable(\"token-constant\")\n        }\n      },\n      {\n        scope: [\n          \"keyword\",\n          \"storage.modifier\",\n          \"storage.type\",\n          \"storage.control.clojure\",\n          \"entity.name.function.clojure\",\n          \"entity.name.tag.yaml\",\n          \"support.function.node\",\n          \"support.type.property-name.json\",\n          \"punctuation.separator.key-value\",\n          \"punctuation.definition.template-expression\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        scope: \"variable.parameter.function\",\n        settings: {\n          foreground: variable(\"token-parameter\")\n        }\n      },\n      {\n        scope: [\n          \"support.function\",\n          \"entity.name.type\",\n          \"entity.other.inherited-class\",\n          \"meta.function-call\",\n          \"meta.instance.constructor\",\n          \"entity.other.attribute-name\",\n          \"entity.name.function\",\n          \"constant.keyword.clojure\"\n        ],\n        settings: {\n          foreground: variable(\"token-function\")\n        }\n      },\n      {\n        scope: [\n          \"entity.name.tag\",\n          \"string.quoted\",\n          \"string.regexp\",\n          \"string.interpolated\",\n          \"string.template\",\n          \"string.unquoted.plain.out.yaml\",\n          \"keyword.other.template\"\n        ],\n        settings: {\n          foreground: variable(\"token-string-expression\")\n        }\n      },\n      {\n        scope: [\n          \"punctuation.definition.arguments\",\n          \"punctuation.definition.dict\",\n          \"punctuation.separator\",\n          \"meta.function-call.arguments\"\n        ],\n        settings: {\n          foreground: variable(\"token-punctuation\")\n        }\n      },\n      {\n        // [Custom] Markdown links\n        scope: [\n          \"markup.underline.link\",\n          \"punctuation.definition.metadata.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        // [Custom] Markdown list\n        scope: [\"beginning.punctuation.definition.list.markdown\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        // [Custom] Markdown punctuation definition brackets\n        scope: [\n          \"punctuation.definition.string.begin.markdown\",\n          \"punctuation.definition.string.end.markdown\",\n          \"string.other.link.title.markdown\",\n          \"string.other.link.description.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        // [Custom] Diff\n        scope: [\n          \"markup.inserted\",\n          \"meta.diff.header.to-file\",\n          \"punctuation.definition.inserted\"\n        ],\n        settings: {\n          foreground: variable(\"token-inserted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.deleted\",\n          \"meta.diff.header.from-file\",\n          \"punctuation.definition.deleted\"\n        ],\n        settings: {\n          foreground: variable(\"token-deleted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.changed\",\n          \"punctuation.definition.changed\"\n        ],\n        settings: {\n          foreground: variable(\"token-changed\")\n        }\n      }\n    ]\n  };\n  if (!fontStyle) {\n    theme.tokenColors = theme.tokenColors?.map((tokenColor) => {\n      if (tokenColor.settings?.fontStyle)\n        delete tokenColor.settings.fontStyle;\n      return tokenColor;\n    });\n  }\n  return theme;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcytjb3JlQDEuMjcuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDN0I7QUFDNEc7QUFDMUU7QUFDVztBQUN1QztBQUNoQjtBQUN4RDtBQUNjO0FBQzJIOztBQUVwTDtBQUNBLEVBQUUsNERBQWM7QUFDaEIsU0FBUyxnRkFBdUI7QUFDaEM7QUFDQTtBQUNBLEVBQUUsNERBQWM7QUFDaEIsU0FBUyxnRkFBdUI7QUFDaEM7QUFDQTtBQUNBLEVBQUUsNERBQWM7QUFDaEIsU0FBUyxtRUFBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELElBQUk7QUFDMUQ7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQVM7QUFDbkM7QUFDQSwwQkFBMEIsK0RBQVM7QUFDbkM7QUFDQSwwQkFBMEIsK0RBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSSxHQUFHLE1BQU0sVUFBVTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw2REFBTztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUV3MkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vQHNoaWtpanMrY29yZUAxLjI3LjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2NvcmUvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hpa2lFcnJvciBhcyBTaGlraUVycm9yJDEgfSBmcm9tICdAc2hpa2lqcy90eXBlcyc7XG5leHBvcnQgKiBmcm9tICdAc2hpa2lqcy90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVPbmlndXJ1bWFFbmdpbmUgYXMgY3JlYXRlT25pZ3VydW1hRW5naW5lJDEsIGxvYWRXYXNtIGFzIGxvYWRXYXNtJDEsIGdldERlZmF1bHRXYXNtTG9hZGVyIH0gZnJvbSAnQHNoaWtpanMvZW5naW5lLW9uaWd1cnVtYSc7XG5pbXBvcnQgeyB3IGFzIHdhcm5EZXByZWNhdGVkIH0gZnJvbSAnLi9zaGFyZWQvY29yZS5EVlY4YzRSWi5tanMnO1xuZXhwb3J0IHsgZSBhcyBlbmFibGVEZXByZWNhdGlvbldhcm5pbmdzIH0gZnJvbSAnLi9zaGFyZWQvY29yZS5EVlY4YzRSWi5tanMnO1xuaW1wb3J0IHsgRm9udFN0eWxlLCBJTklUSUFMLCBFbmNvZGVkVG9rZW5NZXRhZGF0YSwgUmVnaXN0cnkgYXMgUmVnaXN0cnkkMSwgVGhlbWUgfSBmcm9tICdAc2hpa2lqcy92c2NvZGUtdGV4dG1hdGUnO1xuZXhwb3J0IHsgRm9udFN0eWxlLCBFbmNvZGVkVG9rZW5NZXRhZGF0YSBhcyBTdGFja0VsZW1lbnRNZXRhZGF0YSB9IGZyb20gJ0BzaGlraWpzL3ZzY29kZS10ZXh0bWF0ZSc7XG5pbXBvcnQgeyB0b0h0bWwgfSBmcm9tICdoYXN0LXV0aWwtdG8taHRtbCc7XG5leHBvcnQgeyB0b0h0bWwgYXMgaGFzdFRvSHRtbCB9IGZyb20gJ2hhc3QtdXRpbC10by1odG1sJztcbmltcG9ydCB7IGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZSBhcyBjcmVhdGVKYXZhU2NyaXB0UmVnZXhFbmdpbmUkMSwgZGVmYXVsdEphdmFTY3JpcHRSZWdleENvbnN0cnVjdG9yIGFzIGRlZmF1bHRKYXZhU2NyaXB0UmVnZXhDb25zdHJ1Y3RvciQxIH0gZnJvbSAnQHNoaWtpanMvZW5naW5lLWphdmFzY3JpcHQnO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmlndXJ1bWFFbmdpbmUob3B0aW9ucykge1xuICB3YXJuRGVwcmVjYXRlZChcImltcG9ydCBgY3JlYXRlT25pZ3VydW1hRW5naW5lYCBmcm9tIGBAc2hpa2lqcy9lbmdpbmUtb25pZ3VydW1hYCBvciBgc2hpa2kvZW5naW5lL29uaWd1cnVtYWAgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIGNyZWF0ZU9uaWd1cnVtYUVuZ2luZSQxKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlV2FzbU9uaWdFbmdpbmUob3B0aW9ucykge1xuICB3YXJuRGVwcmVjYXRlZChcImltcG9ydCBgY3JlYXRlT25pZ3VydW1hRW5naW5lYCBmcm9tIGBAc2hpa2lqcy9lbmdpbmUtb25pZ3VydW1hYCBvciBgc2hpa2kvZW5naW5lL29uaWd1cnVtYWAgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIGNyZWF0ZU9uaWd1cnVtYUVuZ2luZSQxKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gbG9hZFdhc20ob3B0aW9ucykge1xuICB3YXJuRGVwcmVjYXRlZChcImltcG9ydCBgbG9hZFdhc21gIGZyb20gYEBzaGlraWpzL2VuZ2luZS1vbmlndXJ1bWFgIG9yIGBzaGlraS9lbmdpbmUvb25pZ3VydW1hYCBpbnN0ZWFkXCIpO1xuICByZXR1cm4gbG9hZFdhc20kMShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSh4KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpID8geCA6IFt4XTtcbn1cbmZ1bmN0aW9uIHNwbGl0TGluZXMoY29kZSwgcHJlc2VydmVFbmRpbmcgPSBmYWxzZSkge1xuICBjb25zdCBwYXJ0cyA9IGNvZGUuc3BsaXQoLyhcXHI/XFxuKS9nKTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGxpbmUgPSBwcmVzZXJ2ZUVuZGluZyA/IHBhcnRzW2ldICsgKHBhcnRzW2kgKyAxXSB8fCBcIlwiKSA6IHBhcnRzW2ldO1xuICAgIGxpbmVzLnB1c2goW2xpbmUsIGluZGV4XSk7XG4gICAgaW5kZXggKz0gcGFydHNbaV0ubGVuZ3RoO1xuICAgIGluZGV4ICs9IHBhcnRzW2kgKyAxXT8ubGVuZ3RoIHx8IDA7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufVxuZnVuY3Rpb24gaXNQbGFpbkxhbmcobGFuZykge1xuICByZXR1cm4gIWxhbmcgfHwgW1wicGxhaW50ZXh0XCIsIFwidHh0XCIsIFwidGV4dFwiLCBcInBsYWluXCJdLmluY2x1ZGVzKGxhbmcpO1xufVxuZnVuY3Rpb24gaXNTcGVjaWFsTGFuZyhsYW5nKSB7XG4gIHJldHVybiBsYW5nID09PSBcImFuc2lcIiB8fCBpc1BsYWluTGFuZyhsYW5nKTtcbn1cbmZ1bmN0aW9uIGlzTm9uZVRoZW1lKHRoZW1lKSB7XG4gIHJldHVybiB0aGVtZSA9PT0gXCJub25lXCI7XG59XG5mdW5jdGlvbiBpc1NwZWNpYWxUaGVtZSh0aGVtZSkge1xuICByZXR1cm4gaXNOb25lVGhlbWUodGhlbWUpO1xufVxuZnVuY3Rpb24gYWRkQ2xhc3NUb0hhc3Qobm9kZSwgY2xhc3NOYW1lKSB7XG4gIGlmICghY2xhc3NOYW1lKVxuICAgIHJldHVybiBub2RlO1xuICBub2RlLnByb3BlcnRpZXMgfHw9IHt9O1xuICBub2RlLnByb3BlcnRpZXMuY2xhc3MgfHw9IFtdO1xuICBpZiAodHlwZW9mIG5vZGUucHJvcGVydGllcy5jbGFzcyA9PT0gXCJzdHJpbmdcIilcbiAgICBub2RlLnByb3BlcnRpZXMuY2xhc3MgPSBub2RlLnByb3BlcnRpZXMuY2xhc3Muc3BsaXQoL1xccysvZyk7XG4gIGlmICghQXJyYXkuaXNBcnJheShub2RlLnByb3BlcnRpZXMuY2xhc3MpKVxuICAgIG5vZGUucHJvcGVydGllcy5jbGFzcyA9IFtdO1xuICBjb25zdCB0YXJnZXRzID0gQXJyYXkuaXNBcnJheShjbGFzc05hbWUpID8gY2xhc3NOYW1lIDogY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpO1xuICBmb3IgKGNvbnN0IGMgb2YgdGFyZ2V0cykge1xuICAgIGlmIChjICYmICFub2RlLnByb3BlcnRpZXMuY2xhc3MuaW5jbHVkZXMoYykpXG4gICAgICBub2RlLnByb3BlcnRpZXMuY2xhc3MucHVzaChjKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNwbGl0VG9rZW4odG9rZW4sIG9mZnNldHMpIHtcbiAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgZm9yIChjb25zdCBvZmZzZXQgb2Ygb2Zmc2V0cykge1xuICAgIGlmIChvZmZzZXQgPiBsYXN0T2Zmc2V0KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIC4uLnRva2VuLFxuICAgICAgICBjb250ZW50OiB0b2tlbi5jb250ZW50LnNsaWNlKGxhc3RPZmZzZXQsIG9mZnNldCksXG4gICAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGFzdE9mZnNldFxuICAgICAgfSk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gIH1cbiAgaWYgKGxhc3RPZmZzZXQgPCB0b2tlbi5jb250ZW50Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIC4uLnRva2VuLFxuICAgICAgY29udGVudDogdG9rZW4uY29udGVudC5zbGljZShsYXN0T2Zmc2V0KSxcbiAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGFzdE9mZnNldFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBzcGxpdFRva2Vucyh0b2tlbnMsIGJyZWFrcG9pbnRzKSB7XG4gIGNvbnN0IHNvcnRlZCA9IEFycmF5LmZyb20oYnJlYWtwb2ludHMgaW5zdGFuY2VvZiBTZXQgPyBicmVha3BvaW50cyA6IG5ldyBTZXQoYnJlYWtwb2ludHMpKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGlmICghc29ydGVkLmxlbmd0aClcbiAgICByZXR1cm4gdG9rZW5zO1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIHJldHVybiBsaW5lLmZsYXRNYXAoKHRva2VuKSA9PiB7XG4gICAgICBjb25zdCBicmVha3BvaW50c0luVG9rZW4gPSBzb3J0ZWQuZmlsdGVyKChpKSA9PiB0b2tlbi5vZmZzZXQgPCBpICYmIGkgPCB0b2tlbi5vZmZzZXQgKyB0b2tlbi5jb250ZW50Lmxlbmd0aCkubWFwKChpKSA9PiBpIC0gdG9rZW4ub2Zmc2V0KS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICBpZiAoIWJyZWFrcG9pbnRzSW5Ub2tlbi5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIHJldHVybiBzcGxpdFRva2VuKHRva2VuLCBicmVha3BvaW50c0luVG9rZW4pO1xuICAgIH0pO1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG5vcm1hbGl6ZUdldHRlcihwKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUodHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIiA/IHAoKSA6IHApLnRoZW4oKHIpID0+IHIuZGVmYXVsdCB8fCByKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDb2xvclJlcGxhY2VtZW50cyh0aGVtZSwgb3B0aW9ucykge1xuICBjb25zdCByZXBsYWNlbWVudHMgPSB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyB7fSA6IHsgLi4udGhlbWUuY29sb3JSZXBsYWNlbWVudHMgfTtcbiAgY29uc3QgdGhlbWVOYW1lID0gdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8gdGhlbWUgOiB0aGVtZS5uYW1lO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zPy5jb2xvclJlcGxhY2VtZW50cyB8fCB7fSkpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgcmVwbGFjZW1lbnRzW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIGlmIChrZXkgPT09IHRoZW1lTmFtZSlcbiAgICAgIE9iamVjdC5hc3NpZ24ocmVwbGFjZW1lbnRzLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2VtZW50cztcbn1cbmZ1bmN0aW9uIGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoY29sb3IsIHJlcGxhY2VtZW50cykge1xuICBpZiAoIWNvbG9yKVxuICAgIHJldHVybiBjb2xvcjtcbiAgcmV0dXJuIHJlcGxhY2VtZW50cz8uW2NvbG9yPy50b0xvd2VyQ2FzZSgpXSB8fCBjb2xvcjtcbn1cbmZ1bmN0aW9uIGdldFRva2VuU3R5bGVPYmplY3QodG9rZW4pIHtcbiAgY29uc3Qgc3R5bGVzID0ge307XG4gIGlmICh0b2tlbi5jb2xvcilcbiAgICBzdHlsZXMuY29sb3IgPSB0b2tlbi5jb2xvcjtcbiAgaWYgKHRva2VuLmJnQ29sb3IpXG4gICAgc3R5bGVzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IHRva2VuLmJnQ29sb3I7XG4gIGlmICh0b2tlbi5mb250U3R5bGUpIHtcbiAgICBpZiAodG9rZW4uZm9udFN0eWxlICYgRm9udFN0eWxlLkl0YWxpYylcbiAgICAgIHN0eWxlc1tcImZvbnQtc3R5bGVcIl0gPSBcIml0YWxpY1wiO1xuICAgIGlmICh0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuQm9sZClcbiAgICAgIHN0eWxlc1tcImZvbnQtd2VpZ2h0XCJdID0gXCJib2xkXCI7XG4gICAgaWYgKHRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5VbmRlcmxpbmUpXG4gICAgICBzdHlsZXNbXCJ0ZXh0LWRlY29yYXRpb25cIl0gPSBcInVuZGVybGluZVwiO1xuICB9XG4gIHJldHVybiBzdHlsZXM7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlUb2tlblN0eWxlKHRva2VuKSB7XG4gIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHRva2VuO1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXModG9rZW4pLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9OiR7dmFsdWV9YCkuam9pbihcIjtcIik7XG59XG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbkNvbnZlcnRlcihjb2RlKSB7XG4gIGNvbnN0IGxpbmVzID0gc3BsaXRMaW5lcyhjb2RlLCB0cnVlKS5tYXAoKFtsaW5lXSkgPT4gbGluZSk7XG4gIGZ1bmN0aW9uIGluZGV4VG9Qb3MoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IGNvZGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBsaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICBjaGFyYWN0ZXI6IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNoYXJhY3RlciA9IGluZGV4O1xuICAgIGxldCBsaW5lID0gMDtcbiAgICBmb3IgKGNvbnN0IGxpbmVUZXh0IG9mIGxpbmVzKSB7XG4gICAgICBpZiAoY2hhcmFjdGVyIDwgbGluZVRleHQubGVuZ3RoKVxuICAgICAgICBicmVhaztcbiAgICAgIGNoYXJhY3RlciAtPSBsaW5lVGV4dC5sZW5ndGg7XG4gICAgICBsaW5lKys7XG4gICAgfVxuICAgIHJldHVybiB7IGxpbmUsIGNoYXJhY3RlciB9O1xuICB9XG4gIGZ1bmN0aW9uIHBvc1RvSW5kZXgobGluZSwgY2hhcmFjdGVyKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKylcbiAgICAgIGluZGV4ICs9IGxpbmVzW2ldLmxlbmd0aDtcbiAgICBpbmRleCArPSBjaGFyYWN0ZXI7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIHJldHVybiB7XG4gICAgbGluZXMsXG4gICAgaW5kZXhUb1BvcyxcbiAgICBwb3NUb0luZGV4XG4gIH07XG59XG5cbmNsYXNzIFNoaWtpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNoaWtpRXJyb3JcIjtcbiAgfVxufVxuXG5jb25zdCBfZ3JhbW1hclN0YXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAoa2V5cywgc3RhdGUpIHtcbiAgX2dyYW1tYXJTdGF0ZU1hcC5zZXQoa2V5cywgc3RhdGUpO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEdyYW1tYXJTdGF0ZUZyb21NYXAoa2V5cykge1xuICByZXR1cm4gX2dyYW1tYXJTdGF0ZU1hcC5nZXQoa2V5cyk7XG59XG5jbGFzcyBHcmFtbWFyU3RhdGUge1xuICAvKipcbiAgICogVGhlbWUgdG8gU3RhY2sgbWFwcGluZ1xuICAgKi9cbiAgX3N0YWNrcyA9IHt9O1xuICBsYW5nO1xuICBnZXQgdGhlbWVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdGFja3MpO1xuICB9XG4gIGdldCB0aGVtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVtZXNbMF07XG4gIH1cbiAgZ2V0IF9zdGFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tzW3RoaXMudGhlbWVdO1xuICB9XG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIHRvIGNyZWF0ZSBhIGluaXRpYWwgZ3JhbW1hciBzdGF0ZS5cbiAgICovXG4gIHN0YXRpYyBpbml0aWFsKGxhbmcsIHRoZW1lcykge1xuICAgIHJldHVybiBuZXcgR3JhbW1hclN0YXRlKFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKHRvQXJyYXkodGhlbWVzKS5tYXAoKHRoZW1lKSA9PiBbdGhlbWUsIElOSVRJQUxdKSksXG4gICAgICBsYW5nXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBbc3RhY2tzTWFwLCBsYW5nXSA9IGFyZ3M7XG4gICAgICB0aGlzLmxhbmcgPSBsYW5nO1xuICAgICAgdGhpcy5fc3RhY2tzID0gc3RhY2tzTWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbc3RhY2ssIGxhbmcsIHRoZW1lXSA9IGFyZ3M7XG4gICAgICB0aGlzLmxhbmcgPSBsYW5nO1xuICAgICAgdGhpcy5fc3RhY2tzID0geyBbdGhlbWVdOiBzdGFjayB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcm5hbCBzdGFjayBvYmplY3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0SW50ZXJuYWxTdGFjayh0aGVtZSA9IHRoaXMudGhlbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tzW3RoZW1lXTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBnZXRTY29wZXNgIGluc3RlYWRcbiAgICovXG4gIGdldCBzY29wZXMoKSB7XG4gICAgcmV0dXJuIGdldFNjb3Blcyh0aGlzLl9zdGFja3NbdGhpcy50aGVtZV0pO1xuICB9XG4gIGdldFNjb3Blcyh0aGVtZSA9IHRoaXMudGhlbWUpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGVzKHRoaXMuX3N0YWNrc1t0aGVtZV0pO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZzogdGhpcy5sYW5nLFxuICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICB0aGVtZXM6IHRoaXMudGhlbWVzLFxuICAgICAgc2NvcGVzOiB0aGlzLnNjb3Blc1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNjb3BlcyhzdGFjaykge1xuICBjb25zdCBzY29wZXMgPSBbXTtcbiAgY29uc3QgdmlzaXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIHB1c2hTY29wZShzdGFjazIpIHtcbiAgICBpZiAodmlzaXRlZC5oYXMoc3RhY2syKSlcbiAgICAgIHJldHVybjtcbiAgICB2aXNpdGVkLmFkZChzdGFjazIpO1xuICAgIGNvbnN0IG5hbWUgPSBzdGFjazI/Lm5hbWVTY29wZXNMaXN0Py5zY29wZU5hbWU7XG4gICAgaWYgKG5hbWUpXG4gICAgICBzY29wZXMucHVzaChuYW1lKTtcbiAgICBpZiAoc3RhY2syLnBhcmVudClcbiAgICAgIHB1c2hTY29wZShzdGFjazIucGFyZW50KTtcbiAgfVxuICBwdXNoU2NvcGUoc3RhY2spO1xuICByZXR1cm4gc2NvcGVzO1xufVxuZnVuY3Rpb24gZ2V0R3JhbW1hclN0YWNrKHN0YXRlLCB0aGVtZSkge1xuICBpZiAoIShzdGF0ZSBpbnN0YW5jZW9mIEdyYW1tYXJTdGF0ZSkpXG4gICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoXCJJbnZhbGlkIGdyYW1tYXIgc3RhdGVcIik7XG4gIHJldHVybiBzdGF0ZS5nZXRJbnRlcm5hbFN0YWNrKHRoZW1lKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXJEZWNvcmF0aW9ucygpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGZ1bmN0aW9uIGdldENvbnRleHQoc2hpa2kpIHtcbiAgICBpZiAoIW1hcC5oYXMoc2hpa2kubWV0YSkpIHtcbiAgICAgIGxldCBub3JtYWxpemVQb3NpdGlvbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKHAgPCAwIHx8IHAgPiBzaGlraS5zb3VyY2UubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoYEludmFsaWQgZGVjb3JhdGlvbiBvZmZzZXQ6ICR7cH0uIENvZGUgbGVuZ3RoOiAke3NoaWtpLnNvdXJjZS5sZW5ndGh9YCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbnZlcnRlci5pbmRleFRvUG9zKHApLFxuICAgICAgICAgICAgb2Zmc2V0OiBwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsaW5lID0gY29udmVydGVyLmxpbmVzW3AubGluZV07XG4gICAgICAgICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBJbnZhbGlkIGRlY29yYXRpb24gcG9zaXRpb24gJHtKU09OLnN0cmluZ2lmeShwKX0uIExpbmVzIGxlbmd0aDogJHtjb252ZXJ0ZXIubGluZXMubGVuZ3RofWApO1xuICAgICAgICAgIGlmIChwLmNoYXJhY3RlciA8IDAgfHwgcC5jaGFyYWN0ZXIgPiBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBJbnZhbGlkIGRlY29yYXRpb24gcG9zaXRpb24gJHtKU09OLnN0cmluZ2lmeShwKX0uIExpbmUgJHtwLmxpbmV9IGxlbmd0aDogJHtsaW5lLmxlbmd0aH1gKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgIG9mZnNldDogY29udmVydGVyLnBvc1RvSW5kZXgocC5saW5lLCBwLmNoYXJhY3RlcilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udmVydGVyID0gY3JlYXRlUG9zaXRpb25Db252ZXJ0ZXIoc2hpa2kuc291cmNlKTtcbiAgICAgIGNvbnN0IGRlY29yYXRpb25zID0gKHNoaWtpLm9wdGlvbnMuZGVjb3JhdGlvbnMgfHwgW10pLm1hcCgoZCkgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgc3RhcnQ6IG5vcm1hbGl6ZVBvc2l0aW9uKGQuc3RhcnQpLFxuICAgICAgICBlbmQ6IG5vcm1hbGl6ZVBvc2l0aW9uKGQuZW5kKVxuICAgICAgfSkpO1xuICAgICAgdmVyaWZ5SW50ZXJzZWN0aW9ucyhkZWNvcmF0aW9ucyk7XG4gICAgICBtYXAuc2V0KHNoaWtpLm1ldGEsIHtcbiAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgIGNvbnZlcnRlcixcbiAgICAgICAgc291cmNlOiBzaGlraS5zb3VyY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwLmdldChzaGlraS5tZXRhKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IFwic2hpa2k6ZGVjb3JhdGlvbnNcIixcbiAgICB0b2tlbnModG9rZW5zKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kZWNvcmF0aW9ucz8ubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBjdHggPSBnZXRDb250ZXh0KHRoaXMpO1xuICAgICAgY29uc3QgYnJlYWtwb2ludHMgPSBjdHguZGVjb3JhdGlvbnMuZmxhdE1hcCgoZCkgPT4gW2Quc3RhcnQub2Zmc2V0LCBkLmVuZC5vZmZzZXRdKTtcbiAgICAgIGNvbnN0IHNwbGl0dGVkID0gc3BsaXRUb2tlbnModG9rZW5zLCBicmVha3BvaW50cyk7XG4gICAgICByZXR1cm4gc3BsaXR0ZWQ7XG4gICAgfSxcbiAgICBjb2RlKGNvZGVFbCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGVjb3JhdGlvbnM/Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dCh0aGlzKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gQXJyYXkuZnJvbShjb2RlRWwuY2hpbGRyZW4pLmZpbHRlcigoaSkgPT4gaS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBpLnRhZ05hbWUgPT09IFwic3BhblwiKTtcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggIT09IGN0eC5jb252ZXJ0ZXIubGluZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihgTnVtYmVyIG9mIGxpbmVzIGluIGNvZGUgZWxlbWVudCAoJHtsaW5lcy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSBzb3VyY2UgKCR7Y3R4LmNvbnZlcnRlci5saW5lcy5sZW5ndGh9KS4gRmFpbGVkIHRvIGFwcGx5IGRlY29yYXRpb25zLmApO1xuICAgICAgZnVuY3Rpb24gYXBwbHlMaW5lU2VjdGlvbihsaW5lLCBzdGFydCwgZW5kLCBkZWNvcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxpbmVFbCA9IGxpbmVzW2xpbmVdO1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gLTE7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IC0xO1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApXG4gICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIGlmIChlbmQgPT09IDApXG4gICAgICAgICAgZW5kSW5kZXggPSAwO1xuICAgICAgICBpZiAoZW5kID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgZW5kSW5kZXggPSBsaW5lRWwuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gLTEgfHwgZW5kSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lRWwuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRleHQgKz0gc3RyaW5naWZ5KGxpbmVFbC5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gLTEgJiYgdGV4dC5sZW5ndGggPT09IHN0YXJ0KVxuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICBpZiAoZW5kSW5kZXggPT09IC0xICYmIHRleHQubGVuZ3RoID09PSBlbmQpXG4gICAgICAgICAgICAgIGVuZEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSAtMSlcbiAgICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihgRmFpbGVkIHRvIGZpbmQgc3RhcnQgaW5kZXggZm9yIGRlY29yYXRpb24gJHtKU09OLnN0cmluZ2lmeShkZWNvcmF0aW9uLnN0YXJ0KX1gKTtcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSAtMSlcbiAgICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihgRmFpbGVkIHRvIGZpbmQgZW5kIGluZGV4IGZvciBkZWNvcmF0aW9uICR7SlNPTi5zdHJpbmdpZnkoZGVjb3JhdGlvbi5lbmQpfWApO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGxpbmVFbC5jaGlsZHJlbi5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgIGlmICghZGVjb3JhdGlvbi5hbHdheXNXcmFwICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gbGluZUVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbihsaW5lRWwsIGRlY29yYXRpb24sIFwibGluZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVjb3JhdGlvbi5hbHdheXNXcmFwICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50eXBlID09PSBcImVsZW1lbnRcIikge1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbihjaGlsZHJlblswXSwgZGVjb3JhdGlvbiwgXCJ0b2tlblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyID0ge1xuICAgICAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbih3cmFwcGVyLCBkZWNvcmF0aW9uLCBcIndyYXBwZXJcIik7XG4gICAgICAgICAgbGluZUVsLmNoaWxkcmVuLnNwbGljZShzdGFydEluZGV4LCBjaGlsZHJlbi5sZW5ndGgsIHdyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcHBseUxpbmUobGluZSwgZGVjb3JhdGlvbikge1xuICAgICAgICBsaW5lc1tsaW5lXSA9IGFwcGx5RGVjb3JhdGlvbihsaW5lc1tsaW5lXSwgZGVjb3JhdGlvbiwgXCJsaW5lXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXBwbHlEZWNvcmF0aW9uKGVsLCBkZWNvcmF0aW9uLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkZWNvcmF0aW9uLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGRlY29yYXRpb24udHJhbnNmb3JtIHx8ICgoaSkgPT4gaSk7XG4gICAgICAgIGVsLnRhZ05hbWUgPSBkZWNvcmF0aW9uLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIGVsLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgLi4uZWwucHJvcGVydGllcyxcbiAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGNsYXNzOiBlbC5wcm9wZXJ0aWVzLmNsYXNzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWNvcmF0aW9uLnByb3BlcnRpZXM/LmNsYXNzKVxuICAgICAgICAgIGFkZENsYXNzVG9IYXN0KGVsLCBkZWNvcmF0aW9uLnByb3BlcnRpZXMuY2xhc3MpO1xuICAgICAgICBlbCA9IHRyYW5zZm9ybShlbCwgdHlwZSkgfHwgZWw7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmVBcHBsaWVzID0gW107XG4gICAgICBjb25zdCBzb3J0ZWQgPSBjdHguZGVjb3JhdGlvbnMuc29ydCgoYSwgYikgPT4gYi5zdGFydC5vZmZzZXQgLSBhLnN0YXJ0Lm9mZnNldCk7XG4gICAgICBmb3IgKGNvbnN0IGRlY29yYXRpb24gb2Ygc29ydGVkKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZGVjb3JhdGlvbjtcbiAgICAgICAgaWYgKHN0YXJ0LmxpbmUgPT09IGVuZC5saW5lKSB7XG4gICAgICAgICAgYXBwbHlMaW5lU2VjdGlvbihzdGFydC5saW5lLCBzdGFydC5jaGFyYWN0ZXIsIGVuZC5jaGFyYWN0ZXIsIGRlY29yYXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0LmxpbmUgPCBlbmQubGluZSkge1xuICAgICAgICAgIGFwcGx5TGluZVNlY3Rpb24oc3RhcnQubGluZSwgc3RhcnQuY2hhcmFjdGVyLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGRlY29yYXRpb24pO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydC5saW5lICsgMTsgaSA8IGVuZC5saW5lOyBpKyspXG4gICAgICAgICAgICBsaW5lQXBwbGllcy51bnNoaWZ0KCgpID0+IGFwcGx5TGluZShpLCBkZWNvcmF0aW9uKSk7XG4gICAgICAgICAgYXBwbHlMaW5lU2VjdGlvbihlbmQubGluZSwgMCwgZW5kLmNoYXJhY3RlciwgZGVjb3JhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpbmVBcHBsaWVzLmZvckVhY2goKGkpID0+IGkoKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdmVyaWZ5SW50ZXJzZWN0aW9ucyhpdGVtcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZm9vID0gaXRlbXNbaV07XG4gICAgaWYgKGZvby5zdGFydC5vZmZzZXQgPiBmb28uZW5kLm9mZnNldClcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBJbnZhbGlkIGRlY29yYXRpb24gcmFuZ2U6ICR7SlNPTi5zdHJpbmdpZnkoZm9vLnN0YXJ0KX0gLSAke0pTT04uc3RyaW5naWZ5KGZvby5lbmQpfWApO1xuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBiYXIgPSBpdGVtc1tqXTtcbiAgICAgIGNvbnN0IGlzRm9vSGFzQmFyU3RhcnQgPSBmb28uc3RhcnQub2Zmc2V0IDwgYmFyLnN0YXJ0Lm9mZnNldCAmJiBiYXIuc3RhcnQub2Zmc2V0IDwgZm9vLmVuZC5vZmZzZXQ7XG4gICAgICBjb25zdCBpc0Zvb0hhc0JhckVuZCA9IGZvby5zdGFydC5vZmZzZXQgPCBiYXIuZW5kLm9mZnNldCAmJiBiYXIuZW5kLm9mZnNldCA8IGZvby5lbmQub2Zmc2V0O1xuICAgICAgY29uc3QgaXNCYXJIYXNGb29TdGFydCA9IGJhci5zdGFydC5vZmZzZXQgPCBmb28uc3RhcnQub2Zmc2V0ICYmIGZvby5zdGFydC5vZmZzZXQgPCBiYXIuZW5kLm9mZnNldDtcbiAgICAgIGNvbnN0IGlzQmFySGFzRm9vRW5kID0gYmFyLnN0YXJ0Lm9mZnNldCA8IGZvby5lbmQub2Zmc2V0ICYmIGZvby5lbmQub2Zmc2V0IDwgYmFyLmVuZC5vZmZzZXQ7XG4gICAgICBpZiAoaXNGb29IYXNCYXJTdGFydCB8fCBpc0Zvb0hhc0JhckVuZCB8fCBpc0Jhckhhc0Zvb1N0YXJ0IHx8IGlzQmFySGFzRm9vRW5kKSB7XG4gICAgICAgIGlmIChpc0Zvb0hhc0JhckVuZCAmJiBpc0Zvb0hhc0JhckVuZClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGlzQmFySGFzRm9vU3RhcnQgJiYgaXNCYXJIYXNGb29FbmQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBEZWNvcmF0aW9ucyAke0pTT04uc3RyaW5naWZ5KGZvby5zdGFydCl9IGFuZCAke0pTT04uc3RyaW5naWZ5KGJhci5zdGFydCl9IGludGVyc2VjdC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShlbCkge1xuICBpZiAoZWwudHlwZSA9PT0gXCJ0ZXh0XCIpXG4gICAgcmV0dXJuIGVsLnZhbHVlO1xuICBpZiAoZWwudHlwZSA9PT0gXCJlbGVtZW50XCIpXG4gICAgcmV0dXJuIGVsLmNoaWxkcmVuLm1hcChzdHJpbmdpZnkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBcIlwiO1xufVxuXG5jb25zdCBidWlsdEluVHJhbnNmb3JtZXJzID0gW1xuICAvKiBAX19QVVJFX18gKi8gdHJhbnNmb3JtZXJEZWNvcmF0aW9ucygpXG5dO1xuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtZXJzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICAuLi5vcHRpb25zLnRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAuLi5idWlsdEluVHJhbnNmb3JtZXJzXG4gIF07XG59XG5cbi8vIHNyYy9jb2xvcnMudHNcbnZhciBuYW1lZENvbG9ycyA9IFtcbiAgXCJibGFja1wiLFxuICBcInJlZFwiLFxuICBcImdyZWVuXCIsXG4gIFwieWVsbG93XCIsXG4gIFwiYmx1ZVwiLFxuICBcIm1hZ2VudGFcIixcbiAgXCJjeWFuXCIsXG4gIFwid2hpdGVcIixcbiAgXCJicmlnaHRCbGFja1wiLFxuICBcImJyaWdodFJlZFwiLFxuICBcImJyaWdodEdyZWVuXCIsXG4gIFwiYnJpZ2h0WWVsbG93XCIsXG4gIFwiYnJpZ2h0Qmx1ZVwiLFxuICBcImJyaWdodE1hZ2VudGFcIixcbiAgXCJicmlnaHRDeWFuXCIsXG4gIFwiYnJpZ2h0V2hpdGVcIlxuXTtcblxuLy8gc3JjL2RlY29yYXRpb25zLnRzXG52YXIgZGVjb3JhdGlvbnMgPSB7XG4gIDE6IFwiYm9sZFwiLFxuICAyOiBcImRpbVwiLFxuICAzOiBcIml0YWxpY1wiLFxuICA0OiBcInVuZGVybGluZVwiLFxuICA3OiBcInJldmVyc2VcIixcbiAgOTogXCJzdHJpa2V0aHJvdWdoXCJcbn07XG5cbi8vIHNyYy9wYXJzZXIudHNcbmZ1bmN0aW9uIGZpbmRTZXF1ZW5jZSh2YWx1ZSwgcG9zaXRpb24pIHtcbiAgY29uc3QgbmV4dEVzY2FwZSA9IHZhbHVlLmluZGV4T2YoXCJcXHgxQltcIiwgcG9zaXRpb24pO1xuICBpZiAobmV4dEVzY2FwZSAhPT0gLTEpIHtcbiAgICBjb25zdCBuZXh0Q2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwibVwiLCBuZXh0RXNjYXBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2VxdWVuY2U6IHZhbHVlLnN1YnN0cmluZyhuZXh0RXNjYXBlICsgMiwgbmV4dENsb3NlKS5zcGxpdChcIjtcIiksXG4gICAgICBzdGFydFBvc2l0aW9uOiBuZXh0RXNjYXBlLFxuICAgICAgcG9zaXRpb246IG5leHRDbG9zZSArIDFcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHZhbHVlLmxlbmd0aFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VDb2xvcihzZXF1ZW5jZSwgaW5kZXgpIHtcbiAgbGV0IG9mZnNldCA9IDE7XG4gIGNvbnN0IGNvbG9yTW9kZSA9IHNlcXVlbmNlW2luZGV4ICsgb2Zmc2V0KytdO1xuICBsZXQgY29sb3I7XG4gIGlmIChjb2xvck1vZGUgPT09IFwiMlwiKSB7XG4gICAgY29uc3QgcmdiID0gW1xuICAgICAgc2VxdWVuY2VbaW5kZXggKyBvZmZzZXQrK10sXG4gICAgICBzZXF1ZW5jZVtpbmRleCArIG9mZnNldCsrXSxcbiAgICAgIHNlcXVlbmNlW2luZGV4ICsgb2Zmc2V0XVxuICAgIF0ubWFwKCh4KSA9PiBOdW1iZXIucGFyc2VJbnQoeCkpO1xuICAgIGlmIChyZ2IubGVuZ3RoID09PSAzICYmICFyZ2Iuc29tZSgoeCkgPT4gTnVtYmVyLmlzTmFOKHgpKSkge1xuICAgICAgY29sb3IgPSB7XG4gICAgICAgIHR5cGU6IFwicmdiXCIsXG4gICAgICAgIHJnYlxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29sb3JNb2RlID09PSBcIjVcIikge1xuICAgIGNvbnN0IGNvbG9ySW5kZXggPSBOdW1iZXIucGFyc2VJbnQoc2VxdWVuY2VbaW5kZXggKyBvZmZzZXRdKTtcbiAgICBpZiAoIU51bWJlci5pc05hTihjb2xvckluZGV4KSkge1xuICAgICAgY29sb3IgPSB7IHR5cGU6IFwidGFibGVcIiwgaW5kZXg6IE51bWJlcihjb2xvckluZGV4KSB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gW29mZnNldCwgY29sb3JdO1xufVxuZnVuY3Rpb24gcGFyc2VTZXF1ZW5jZShzZXF1ZW5jZSkge1xuICBjb25zdCBjb21tYW5kcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHNlcXVlbmNlW2ldO1xuICAgIGNvbnN0IGNvZGVJbnQgPSBOdW1iZXIucGFyc2VJbnQoY29kZSk7XG4gICAgaWYgKE51bWJlci5pc05hTihjb2RlSW50KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChjb2RlSW50ID09PSAwKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHsgdHlwZTogXCJyZXNldEFsbFwiIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA8PSA5KSB7XG4gICAgICBjb25zdCBkZWNvcmF0aW9uID0gZGVjb3JhdGlvbnNbY29kZUludF07XG4gICAgICBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInNldERlY29yYXRpb25cIixcbiAgICAgICAgICB2YWx1ZTogZGVjb3JhdGlvbnNbY29kZUludF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlSW50IDw9IDI5KSB7XG4gICAgICBjb25zdCBkZWNvcmF0aW9uID0gZGVjb3JhdGlvbnNbY29kZUludCAtIDIwXTtcbiAgICAgIGlmIChkZWNvcmF0aW9uKSB7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwicmVzZXREZWNvcmF0aW9uXCIsXG4gICAgICAgICAgdmFsdWU6IGRlY29yYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlSW50IDw9IDM3KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzZXRGb3JlZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgdmFsdWU6IHsgdHlwZTogXCJuYW1lZFwiLCBuYW1lOiBuYW1lZENvbG9yc1tjb2RlSW50IC0gMzBdIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gMzgpIHtcbiAgICAgIGNvbnN0IFtvZmZzZXQsIGNvbG9yXSA9IHBhcnNlQ29sb3Ioc2VxdWVuY2UsIGkpO1xuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic2V0Rm9yZWdyb3VuZENvbG9yXCIsXG4gICAgICAgICAgdmFsdWU6IGNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaSArPSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSAzOSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwicmVzZXRGb3JlZ3JvdW5kQ29sb3JcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50IDw9IDQ3KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzZXRCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgdmFsdWU6IHsgdHlwZTogXCJuYW1lZFwiLCBuYW1lOiBuYW1lZENvbG9yc1tjb2RlSW50IC0gNDBdIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gNDgpIHtcbiAgICAgIGNvbnN0IFtvZmZzZXQsIGNvbG9yXSA9IHBhcnNlQ29sb3Ioc2VxdWVuY2UsIGkpO1xuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic2V0QmFja2dyb3VuZENvbG9yXCIsXG4gICAgICAgICAgdmFsdWU6IGNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaSArPSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSA0OSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwicmVzZXRCYWNrZ3JvdW5kQ29sb3JcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID49IDkwICYmIGNvZGVJbnQgPD0gOTcpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNldEZvcmVncm91bmRDb2xvclwiLFxuICAgICAgICB2YWx1ZTogeyB0eXBlOiBcIm5hbWVkXCIsIG5hbWU6IG5hbWVkQ29sb3JzW2NvZGVJbnQgLSA5MCArIDhdIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA+PSAxMDAgJiYgY29kZUludCA8PSAxMDcpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNldEJhY2tncm91bmRDb2xvclwiLFxuICAgICAgICB2YWx1ZTogeyB0eXBlOiBcIm5hbWVkXCIsIG5hbWU6IG5hbWVkQ29sb3JzW2NvZGVJbnQgLSAxMDAgKyA4XSB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbW1hbmRzO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5zaVNlcXVlbmNlUGFyc2VyKCkge1xuICBsZXQgZm9yZWdyb3VuZCA9IG51bGw7XG4gIGxldCBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgbGV0IGRlY29yYXRpb25zMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiB7XG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgZmluZFJlc3VsdCA9IGZpbmRTZXF1ZW5jZSh2YWx1ZSwgcG9zaXRpb24pO1xuICAgICAgICBjb25zdCB0ZXh0ID0gZmluZFJlc3VsdC5zZXF1ZW5jZSA/IHZhbHVlLnN1YnN0cmluZyhwb3NpdGlvbiwgZmluZFJlc3VsdC5zdGFydFBvc2l0aW9uKSA6IHZhbHVlLnN1YnN0cmluZyhwb3NpdGlvbik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICAgIGZvcmVncm91bmQsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IG5ldyBTZXQoZGVjb3JhdGlvbnMyKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5kUmVzdWx0LnNlcXVlbmNlKSB7XG4gICAgICAgICAgY29uc3QgY29tbWFuZHMgPSBwYXJzZVNlcXVlbmNlKGZpbmRSZXN1bHQuc2VxdWVuY2UpO1xuICAgICAgICAgIGZvciAoY29uc3Qgc3R5bGVUb2tlbiBvZiBjb21tYW5kcykge1xuICAgICAgICAgICAgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJyZXNldEFsbFwiKSB7XG4gICAgICAgICAgICAgIGZvcmVncm91bmQgPSBudWxsO1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbnMyLmNsZWFyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJyZXNldEZvcmVncm91bmRDb2xvclwiKSB7XG4gICAgICAgICAgICAgIGZvcmVncm91bmQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwicmVzZXRCYWNrZ3JvdW5kQ29sb3JcIikge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInJlc2V0RGVjb3JhdGlvblwiKSB7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zMi5kZWxldGUoc3R5bGVUb2tlbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3Qgc3R5bGVUb2tlbiBvZiBjb21tYW5kcykge1xuICAgICAgICAgICAgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJzZXRGb3JlZ3JvdW5kQ29sb3JcIikge1xuICAgICAgICAgICAgICBmb3JlZ3JvdW5kID0gc3R5bGVUb2tlbi52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInNldEJhY2tncm91bmRDb2xvclwiKSB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQgPSBzdHlsZVRva2VuLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwic2V0RGVjb3JhdGlvblwiKSB7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zMi5hZGQoc3R5bGVUb2tlbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uID0gZmluZFJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIH0gd2hpbGUgKHBvc2l0aW9uIDwgdmFsdWUubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvcGFsZXR0ZS50c1xudmFyIGRlZmF1bHROYW1lZENvbG9yc01hcCA9IHtcbiAgYmxhY2s6IFwiIzAwMDAwMFwiLFxuICByZWQ6IFwiI2JiMDAwMFwiLFxuICBncmVlbjogXCIjMDBiYjAwXCIsXG4gIHllbGxvdzogXCIjYmJiYjAwXCIsXG4gIGJsdWU6IFwiIzAwMDBiYlwiLFxuICBtYWdlbnRhOiBcIiNmZjAwZmZcIixcbiAgY3lhbjogXCIjMDBiYmJiXCIsXG4gIHdoaXRlOiBcIiNlZWVlZWVcIixcbiAgYnJpZ2h0QmxhY2s6IFwiIzU1NTU1NVwiLFxuICBicmlnaHRSZWQ6IFwiI2ZmNTU1NVwiLFxuICBicmlnaHRHcmVlbjogXCIjMDBmZjAwXCIsXG4gIGJyaWdodFllbGxvdzogXCIjZmZmZjU1XCIsXG4gIGJyaWdodEJsdWU6IFwiIzU1NTVmZlwiLFxuICBicmlnaHRNYWdlbnRhOiBcIiNmZjU1ZmZcIixcbiAgYnJpZ2h0Q3lhbjogXCIjNTVmZmZmXCIsXG4gIGJyaWdodFdoaXRlOiBcIiNmZmZmZmZcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yUGFsZXR0ZShuYW1lZENvbG9yc01hcCA9IGRlZmF1bHROYW1lZENvbG9yc01hcCkge1xuICBmdW5jdGlvbiBuYW1lZENvbG9yKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZWRDb2xvcnNNYXBbbmFtZV07XG4gIH1cbiAgZnVuY3Rpb24gcmdiQ29sb3IocmdiKSB7XG4gICAgcmV0dXJuIGAjJHtyZ2IubWFwKCh4KSA9PiBNYXRoLm1heCgwLCBNYXRoLm1pbih4LCAyNTUpKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpfWA7XG4gIH1cbiAgbGV0IGNvbG9yVGFibGU7XG4gIGZ1bmN0aW9uIGdldENvbG9yVGFibGUoKSB7XG4gICAgaWYgKGNvbG9yVGFibGUpIHtcbiAgICAgIHJldHVybiBjb2xvclRhYmxlO1xuICAgIH1cbiAgICBjb2xvclRhYmxlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lZENvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29sb3JUYWJsZS5wdXNoKG5hbWVkQ29sb3IobmFtZWRDb2xvcnNbaV0pKTtcbiAgICB9XG4gICAgbGV0IGxldmVscyA9IFswLCA5NSwgMTM1LCAxNzUsIDIxNSwgMjU1XTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IDY7IHIrKykge1xuICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCA2OyBnKyspIHtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCA2OyBiKyspIHtcbiAgICAgICAgICBjb2xvclRhYmxlLnB1c2gocmdiQ29sb3IoW2xldmVsc1tyXSwgbGV2ZWxzW2ddLCBsZXZlbHNbYl1dKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxldmVsID0gODtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI0OyBpKyssIGxldmVsICs9IDEwKSB7XG4gICAgICBjb2xvclRhYmxlLnB1c2gocmdiQ29sb3IoW2xldmVsLCBsZXZlbCwgbGV2ZWxdKSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvclRhYmxlO1xuICB9XG4gIGZ1bmN0aW9uIHRhYmxlQ29sb3IoaW5kZXgpIHtcbiAgICByZXR1cm4gZ2V0Q29sb3JUYWJsZSgpW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiB2YWx1ZShjb2xvcikge1xuICAgIHN3aXRjaCAoY29sb3IudHlwZSkge1xuICAgICAgY2FzZSBcIm5hbWVkXCI6XG4gICAgICAgIHJldHVybiBuYW1lZENvbG9yKGNvbG9yLm5hbWUpO1xuICAgICAgY2FzZSBcInJnYlwiOlxuICAgICAgICByZXR1cm4gcmdiQ29sb3IoY29sb3IucmdiKTtcbiAgICAgIGNhc2UgXCJ0YWJsZVwiOlxuICAgICAgICByZXR1cm4gdGFibGVDb2xvcihjb2xvci5pbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9rZW5pemVBbnNpV2l0aFRoZW1lKHRoZW1lLCBmaWxlQ29udGVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29sb3JSZXBsYWNlbWVudHMgPSByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHModGhlbWUsIG9wdGlvbnMpO1xuICBjb25zdCBsaW5lcyA9IHNwbGl0TGluZXMoZmlsZUNvbnRlbnRzKTtcbiAgY29uc3QgY29sb3JQYWxldHRlID0gY3JlYXRlQ29sb3JQYWxldHRlKFxuICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIG5hbWVkQ29sb3JzLm1hcCgobmFtZSkgPT4gW1xuICAgICAgICBuYW1lLFxuICAgICAgICB0aGVtZS5jb2xvcnM/LltgdGVybWluYWwuYW5zaSR7bmFtZVswXS50b1VwcGVyQ2FzZSgpfSR7bmFtZS5zdWJzdHJpbmcoMSl9YF1cbiAgICAgIF0pXG4gICAgKVxuICApO1xuICBjb25zdCBwYXJzZXIgPSBjcmVhdGVBbnNpU2VxdWVuY2VQYXJzZXIoKTtcbiAgcmV0dXJuIGxpbmVzLm1hcChcbiAgICAobGluZSkgPT4gcGFyc2VyLnBhcnNlKGxpbmVbMF0pLm1hcCgodG9rZW4pID0+IHtcbiAgICAgIGxldCBjb2xvcjtcbiAgICAgIGxldCBiZ0NvbG9yO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcInJldmVyc2VcIikpIHtcbiAgICAgICAgY29sb3IgPSB0b2tlbi5iYWNrZ3JvdW5kID8gY29sb3JQYWxldHRlLnZhbHVlKHRva2VuLmJhY2tncm91bmQpIDogdGhlbWUuYmc7XG4gICAgICAgIGJnQ29sb3IgPSB0b2tlbi5mb3JlZ3JvdW5kID8gY29sb3JQYWxldHRlLnZhbHVlKHRva2VuLmZvcmVncm91bmQpIDogdGhlbWUuZmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xvciA9IHRva2VuLmZvcmVncm91bmQgPyBjb2xvclBhbGV0dGUudmFsdWUodG9rZW4uZm9yZWdyb3VuZCkgOiB0aGVtZS5mZztcbiAgICAgICAgYmdDb2xvciA9IHRva2VuLmJhY2tncm91bmQgPyBjb2xvclBhbGV0dGUudmFsdWUodG9rZW4uYmFja2dyb3VuZCkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb2xvciA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoY29sb3IsIGNvbG9yUmVwbGFjZW1lbnRzKTtcbiAgICAgIGJnQ29sb3IgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKGJnQ29sb3IsIGNvbG9yUmVwbGFjZW1lbnRzKTtcbiAgICAgIGlmICh0b2tlbi5kZWNvcmF0aW9ucy5oYXMoXCJkaW1cIikpXG4gICAgICAgIGNvbG9yID0gZGltQ29sb3IoY29sb3IpO1xuICAgICAgbGV0IGZvbnRTdHlsZSA9IEZvbnRTdHlsZS5Ob25lO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcImJvbGRcIikpXG4gICAgICAgIGZvbnRTdHlsZSB8PSBGb250U3R5bGUuQm9sZDtcbiAgICAgIGlmICh0b2tlbi5kZWNvcmF0aW9ucy5oYXMoXCJpdGFsaWNcIikpXG4gICAgICAgIGZvbnRTdHlsZSB8PSBGb250U3R5bGUuSXRhbGljO1xuICAgICAgaWYgKHRva2VuLmRlY29yYXRpb25zLmhhcyhcInVuZGVybGluZVwiKSlcbiAgICAgICAgZm9udFN0eWxlIHw9IEZvbnRTdHlsZS5VbmRlcmxpbmU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiB0b2tlbi52YWx1ZSxcbiAgICAgICAgb2Zmc2V0OiBsaW5lWzFdLFxuICAgICAgICAvLyBUT0RPOiBtb3JlIGFjY3VyYXRlIG9mZnNldD8gbWlnaHQgbmVlZCB0byBmb3JrIGFuc2ktc2VxdWVuY2UtcGFyc2VyXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBiZ0NvbG9yLFxuICAgICAgICBmb250U3R5bGVcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGRpbUNvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IGhleE1hdGNoID0gY29sb3IubWF0Y2goLyMoWzAtOWEtZl17M30pKFswLTlhLWZdezN9KT8oWzAtOWEtZl17Mn0pPy8pO1xuICBpZiAoaGV4TWF0Y2gpIHtcbiAgICBpZiAoaGV4TWF0Y2hbM10pIHtcbiAgICAgIGNvbnN0IGFscGhhID0gTWF0aC5yb3VuZChOdW1iZXIucGFyc2VJbnQoaGV4TWF0Y2hbM10sIDE2KSAvIDIpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgICByZXR1cm4gYCMke2hleE1hdGNoWzFdfSR7aGV4TWF0Y2hbMl19JHthbHBoYX1gO1xuICAgIH0gZWxzZSBpZiAoaGV4TWF0Y2hbMl0pIHtcbiAgICAgIHJldHVybiBgIyR7aGV4TWF0Y2hbMV19JHtoZXhNYXRjaFsyXX04MGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgIyR7QXJyYXkuZnJvbShoZXhNYXRjaFsxXSkubWFwKCh4KSA9PiBgJHt4fSR7eH1gKS5qb2luKFwiXCIpfTgwYDtcbiAgICB9XG4gIH1cbiAgY29uc3QgY3NzVmFyTWF0Y2ggPSBjb2xvci5tYXRjaCgvdmFyXFwoKC0tW1xcdy1dKy1hbnNpLVtcXHctXSspXFwpLyk7XG4gIGlmIChjc3NWYXJNYXRjaClcbiAgICByZXR1cm4gYHZhcigke2Nzc1Zhck1hdGNoWzFdfS1kaW0pYDtcbiAgcmV0dXJuIGNvbG9yO1xufVxuXG5mdW5jdGlvbiBjb2RlVG9Ub2tlbnNCYXNlKGludGVybmFsLCBjb2RlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGxhbmcgPSBcInRleHRcIixcbiAgICB0aGVtZTogdGhlbWVOYW1lID0gaW50ZXJuYWwuZ2V0TG9hZGVkVGhlbWVzKClbMF1cbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChpc1BsYWluTGFuZyhsYW5nKSB8fCBpc05vbmVUaGVtZSh0aGVtZU5hbWUpKVxuICAgIHJldHVybiBzcGxpdExpbmVzKGNvZGUpLm1hcCgobGluZSkgPT4gW3sgY29udGVudDogbGluZVswXSwgb2Zmc2V0OiBsaW5lWzFdIH1dKTtcbiAgY29uc3QgeyB0aGVtZSwgY29sb3JNYXAgfSA9IGludGVybmFsLnNldFRoZW1lKHRoZW1lTmFtZSk7XG4gIGlmIChsYW5nID09PSBcImFuc2lcIilcbiAgICByZXR1cm4gdG9rZW5pemVBbnNpV2l0aFRoZW1lKHRoZW1lLCBjb2RlLCBvcHRpb25zKTtcbiAgY29uc3QgX2dyYW1tYXIgPSBpbnRlcm5hbC5nZXRMYW5ndWFnZShsYW5nKTtcbiAgaWYgKG9wdGlvbnMuZ3JhbW1hclN0YXRlKSB7XG4gICAgaWYgKG9wdGlvbnMuZ3JhbW1hclN0YXRlLmxhbmcgIT09IF9ncmFtbWFyLm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEdyYW1tYXIgc3RhdGUgbGFuZ3VhZ2UgXCIke29wdGlvbnMuZ3JhbW1hclN0YXRlLmxhbmd9XCIgZG9lcyBub3QgbWF0Y2ggaGlnaGxpZ2h0IGxhbmd1YWdlIFwiJHtfZ3JhbW1hci5uYW1lfVwiYCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5ncmFtbWFyU3RhdGUudGhlbWVzLmluY2x1ZGVzKHRoZW1lLm5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBHcmFtbWFyIHN0YXRlIHRoZW1lcyBcIiR7b3B0aW9ucy5ncmFtbWFyU3RhdGUudGhlbWVzfVwiIGRvIG5vdCBjb250YWluIGhpZ2hsaWdodCB0aGVtZSBcIiR7dGhlbWUubmFtZX1cImApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgX2dyYW1tYXIsIHRoZW1lLCBjb2xvck1hcCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXRMYXN0R3JhbW1hclN0YXRlKC4uLmFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKGFyZ3NbMV0pO1xuICB9XG4gIGNvbnN0IFtpbnRlcm5hbCwgY29kZSwgb3B0aW9ucyA9IHt9XSA9IGFyZ3M7XG4gIGNvbnN0IHtcbiAgICBsYW5nID0gXCJ0ZXh0XCIsXG4gICAgdGhlbWU6IHRoZW1lTmFtZSA9IGludGVybmFsLmdldExvYWRlZFRoZW1lcygpWzBdXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoaXNQbGFpbkxhbmcobGFuZykgfHwgaXNOb25lVGhlbWUodGhlbWVOYW1lKSlcbiAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKFwiUGxhaW4gbGFuZ3VhZ2UgZG9lcyBub3QgaGF2ZSBncmFtbWFyIHN0YXRlXCIpO1xuICBpZiAobGFuZyA9PT0gXCJhbnNpXCIpXG4gICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShcIkFOU0kgbGFuZ3VhZ2UgZG9lcyBub3QgaGF2ZSBncmFtbWFyIHN0YXRlXCIpO1xuICBjb25zdCB7IHRoZW1lLCBjb2xvck1hcCB9ID0gaW50ZXJuYWwuc2V0VGhlbWUodGhlbWVOYW1lKTtcbiAgY29uc3QgX2dyYW1tYXIgPSBpbnRlcm5hbC5nZXRMYW5ndWFnZShsYW5nKTtcbiAgcmV0dXJuIG5ldyBHcmFtbWFyU3RhdGUoXG4gICAgX3Rva2VuaXplV2l0aFRoZW1lKGNvZGUsIF9ncmFtbWFyLCB0aGVtZSwgY29sb3JNYXAsIG9wdGlvbnMpLnN0YXRlU3RhY2ssXG4gICAgX2dyYW1tYXIubmFtZSxcbiAgICB0aGVtZS5uYW1lXG4gICk7XG59XG5mdW5jdGlvbiB0b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBncmFtbWFyLCB0aGVtZSwgY29sb3JNYXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gX3Rva2VuaXplV2l0aFRoZW1lKGNvZGUsIGdyYW1tYXIsIHRoZW1lLCBjb2xvck1hcCwgb3B0aW9ucyk7XG4gIGNvbnN0IGdyYW1tYXJTdGF0ZSA9IG5ldyBHcmFtbWFyU3RhdGUoXG4gICAgX3Rva2VuaXplV2l0aFRoZW1lKGNvZGUsIGdyYW1tYXIsIHRoZW1lLCBjb2xvck1hcCwgb3B0aW9ucykuc3RhdGVTdGFjayxcbiAgICBncmFtbWFyLm5hbWUsXG4gICAgdGhlbWUubmFtZVxuICApO1xuICBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAocmVzdWx0LnRva2VucywgZ3JhbW1hclN0YXRlKTtcbiAgcmV0dXJuIHJlc3VsdC50b2tlbnM7XG59XG5mdW5jdGlvbiBfdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbG9yUmVwbGFjZW1lbnRzID0gcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lLCBvcHRpb25zKTtcbiAgY29uc3Qge1xuICAgIHRva2VuaXplTWF4TGluZUxlbmd0aCA9IDAsXG4gICAgdG9rZW5pemVUaW1lTGltaXQgPSA1MDBcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGxpbmVzID0gc3BsaXRMaW5lcyhjb2RlKTtcbiAgbGV0IHN0YXRlU3RhY2sgPSBvcHRpb25zLmdyYW1tYXJTdGF0ZSA/IGdldEdyYW1tYXJTdGFjayhvcHRpb25zLmdyYW1tYXJTdGF0ZSwgdGhlbWUubmFtZSkgPz8gSU5JVElBTCA6IG9wdGlvbnMuZ3JhbW1hckNvbnRleHRDb2RlICE9IG51bGwgPyBfdG9rZW5pemVXaXRoVGhlbWUoXG4gICAgb3B0aW9ucy5ncmFtbWFyQ29udGV4dENvZGUsXG4gICAgZ3JhbW1hcixcbiAgICB0aGVtZSxcbiAgICBjb2xvck1hcCxcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZ3JhbW1hclN0YXRlOiB1bmRlZmluZWQsXG4gICAgICBncmFtbWFyQ29udGV4dENvZGU6IHVuZGVmaW5lZFxuICAgIH1cbiAgKS5zdGF0ZVN0YWNrIDogSU5JVElBTDtcbiAgbGV0IGFjdHVhbCA9IFtdO1xuICBjb25zdCBmaW5hbCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBbbGluZSwgbGluZU9mZnNldF0gPSBsaW5lc1tpXTtcbiAgICBpZiAobGluZSA9PT0gXCJcIikge1xuICAgICAgYWN0dWFsID0gW107XG4gICAgICBmaW5hbC5wdXNoKFtdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodG9rZW5pemVNYXhMaW5lTGVuZ3RoID4gMCAmJiBsaW5lLmxlbmd0aCA+PSB0b2tlbml6ZU1heExpbmVMZW5ndGgpIHtcbiAgICAgIGFjdHVhbCA9IFtdO1xuICAgICAgZmluYWwucHVzaChbe1xuICAgICAgICBjb250ZW50OiBsaW5lLFxuICAgICAgICBvZmZzZXQ6IGxpbmVPZmZzZXQsXG4gICAgICAgIGNvbG9yOiBcIlwiLFxuICAgICAgICBmb250U3R5bGU6IDBcbiAgICAgIH1dKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0V2l0aFNjb3BlcztcbiAgICBsZXQgdG9rZW5zV2l0aFNjb3BlcztcbiAgICBsZXQgdG9rZW5zV2l0aFNjb3Blc0luZGV4O1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbikge1xuICAgICAgcmVzdWx0V2l0aFNjb3BlcyA9IGdyYW1tYXIudG9rZW5pemVMaW5lKGxpbmUsIHN0YXRlU3RhY2spO1xuICAgICAgdG9rZW5zV2l0aFNjb3BlcyA9IHJlc3VsdFdpdGhTY29wZXMudG9rZW5zO1xuICAgICAgdG9rZW5zV2l0aFNjb3Blc0luZGV4ID0gMDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZ3JhbW1hci50b2tlbml6ZUxpbmUyKGxpbmUsIHN0YXRlU3RhY2ssIHRva2VuaXplVGltZUxpbWl0KTtcbiAgICBjb25zdCB0b2tlbnNMZW5ndGggPSByZXN1bHQudG9rZW5zLmxlbmd0aCAvIDI7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b2tlbnNMZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHJlc3VsdC50b2tlbnNbMiAqIGpdO1xuICAgICAgY29uc3QgbmV4dFN0YXJ0SW5kZXggPSBqICsgMSA8IHRva2Vuc0xlbmd0aCA/IHJlc3VsdC50b2tlbnNbMiAqIGogKyAyXSA6IGxpbmUubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IG5leHRTdGFydEluZGV4KVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gcmVzdWx0LnRva2Vuc1syICogaiArIDFdO1xuICAgICAgY29uc3QgY29sb3IgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKFxuICAgICAgICBjb2xvck1hcFtFbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb3JlZ3JvdW5kKG1ldGFkYXRhKV0sXG4gICAgICAgIGNvbG9yUmVwbGFjZW1lbnRzXG4gICAgICApO1xuICAgICAgY29uc3QgZm9udFN0eWxlID0gRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0Rm9udFN0eWxlKG1ldGFkYXRhKTtcbiAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICBjb250ZW50OiBsaW5lLnN1YnN0cmluZyhzdGFydEluZGV4LCBuZXh0U3RhcnRJbmRleCksXG4gICAgICAgIG9mZnNldDogbGluZU9mZnNldCArIHN0YXJ0SW5kZXgsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBmb250U3R5bGVcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24pIHtcbiAgICAgICAgY29uc3QgdGhlbWVTZXR0aW5nc1NlbGVjdG9ycyA9IFtdO1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24gIT09IFwic2NvcGVOYW1lXCIpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNldHRpbmcgb2YgdGhlbWUuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RvcnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzZXR0aW5nLnNjb3BlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBzZXR0aW5nLnNjb3BlLnNwbGl0KC8sLykubWFwKChzY29wZSkgPT4gc2NvcGUudHJpbSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHNldHRpbmcuc2NvcGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGVtZVNldHRpbmdzU2VsZWN0b3JzLnB1c2goe1xuICAgICAgICAgICAgICBzZXR0aW5nczogc2V0dGluZyxcbiAgICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMubWFwKChzZWxlY3RvcikgPT4gc2VsZWN0b3Iuc3BsaXQoLyAvKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbi5leHBsYW5hdGlvbiA9IFtdO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggKyBvZmZzZXQgPCBuZXh0U3RhcnRJbmRleCkge1xuICAgICAgICAgIGNvbnN0IHRva2VuV2l0aFNjb3BlcyA9IHRva2Vuc1dpdGhTY29wZXNbdG9rZW5zV2l0aFNjb3Blc0luZGV4XTtcbiAgICAgICAgICBjb25zdCB0b2tlbldpdGhTY29wZXNUZXh0ID0gbGluZS5zdWJzdHJpbmcoXG4gICAgICAgICAgICB0b2tlbldpdGhTY29wZXMuc3RhcnRJbmRleCxcbiAgICAgICAgICAgIHRva2VuV2l0aFNjb3Blcy5lbmRJbmRleFxuICAgICAgICAgICk7XG4gICAgICAgICAgb2Zmc2V0ICs9IHRva2VuV2l0aFNjb3Blc1RleHQubGVuZ3RoO1xuICAgICAgICAgIHRva2VuLmV4cGxhbmF0aW9uLnB1c2goe1xuICAgICAgICAgICAgY29udGVudDogdG9rZW5XaXRoU2NvcGVzVGV4dCxcbiAgICAgICAgICAgIHNjb3Blczogb3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24gPT09IFwic2NvcGVOYW1lXCIgPyBleHBsYWluVGhlbWVTY29wZXNOYW1lT25seShcbiAgICAgICAgICAgICAgdG9rZW5XaXRoU2NvcGVzLnNjb3Blc1xuICAgICAgICAgICAgKSA6IGV4cGxhaW5UaGVtZVNjb3Blc0Z1bGwoXG4gICAgICAgICAgICAgIHRoZW1lU2V0dGluZ3NTZWxlY3RvcnMsXG4gICAgICAgICAgICAgIHRva2VuV2l0aFNjb3Blcy5zY29wZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0b2tlbnNXaXRoU2NvcGVzSW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0dWFsLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICBmaW5hbC5wdXNoKGFjdHVhbCk7XG4gICAgYWN0dWFsID0gW107XG4gICAgc3RhdGVTdGFjayA9IHJlc3VsdC5ydWxlU3RhY2s7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IGZpbmFsLFxuICAgIHN0YXRlU3RhY2tcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4cGxhaW5UaGVtZVNjb3Blc05hbWVPbmx5KHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLm1hcCgoc2NvcGUpID0+ICh7IHNjb3BlTmFtZTogc2NvcGUgfSkpO1xufVxuZnVuY3Rpb24gZXhwbGFpblRoZW1lU2NvcGVzRnVsbCh0aGVtZVNlbGVjdG9ycywgc2NvcGVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2NvcGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBzY29wZXNbaV07XG4gICAgcmVzdWx0W2ldID0ge1xuICAgICAgc2NvcGVOYW1lOiBzY29wZSxcbiAgICAgIHRoZW1lTWF0Y2hlczogZXhwbGFpblRoZW1lU2NvcGUodGhlbWVTZWxlY3RvcnMsIHNjb3BlLCBzY29wZXMuc2xpY2UoMCwgaSkpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWF0Y2hlc09uZShzZWxlY3Rvciwgc2NvcGUpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09PSBzY29wZSB8fCBzY29wZS5zdWJzdHJpbmcoMCwgc2VsZWN0b3IubGVuZ3RoKSA9PT0gc2VsZWN0b3IgJiYgc2NvcGVbc2VsZWN0b3IubGVuZ3RoXSA9PT0gXCIuXCI7XG59XG5mdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9ycywgc2NvcGUsIHBhcmVudFNjb3Blcykge1xuICBpZiAoIW1hdGNoZXNPbmUoc2VsZWN0b3JzW3NlbGVjdG9ycy5sZW5ndGggLSAxXSwgc2NvcGUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgbGV0IHNlbGVjdG9yUGFyZW50SW5kZXggPSBzZWxlY3RvcnMubGVuZ3RoIC0gMjtcbiAgbGV0IHBhcmVudEluZGV4ID0gcGFyZW50U2NvcGVzLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChzZWxlY3RvclBhcmVudEluZGV4ID49IDAgJiYgcGFyZW50SW5kZXggPj0gMCkge1xuICAgIGlmIChtYXRjaGVzT25lKHNlbGVjdG9yc1tzZWxlY3RvclBhcmVudEluZGV4XSwgcGFyZW50U2NvcGVzW3BhcmVudEluZGV4XSkpXG4gICAgICBzZWxlY3RvclBhcmVudEluZGV4IC09IDE7XG4gICAgcGFyZW50SW5kZXggLT0gMTtcbiAgfVxuICBpZiAoc2VsZWN0b3JQYXJlbnRJbmRleCA9PT0gLTEpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV4cGxhaW5UaGVtZVNjb3BlKHRoZW1lU2V0dGluZ3NTZWxlY3RvcnMsIHNjb3BlLCBwYXJlbnRTY29wZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3QgeyBzZWxlY3RvcnMsIHNldHRpbmdzIH0gb2YgdGhlbWVTZXR0aW5nc1NlbGVjdG9ycykge1xuICAgIGZvciAoY29uc3Qgc2VsZWN0b3JQaWVjZXMgb2Ygc2VsZWN0b3JzKSB7XG4gICAgICBpZiAobWF0Y2hlcyhzZWxlY3RvclBpZWNlcywgc2NvcGUsIHBhcmVudFNjb3BlcykpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goc2V0dGluZ3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhpbnRlcm5hbCwgY29kZSwgb3B0aW9ucykge1xuICBjb25zdCB0aGVtZXMgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLnRoZW1lcykuZmlsdGVyKChpKSA9PiBpWzFdKS5tYXAoKGkpID0+ICh7IGNvbG9yOiBpWzBdLCB0aGVtZTogaVsxXSB9KSk7XG4gIGNvbnN0IHRoZW1lZFRva2VucyA9IHRoZW1lcy5tYXAoKHQpID0+IHtcbiAgICBjb25zdCB0b2tlbnMyID0gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRoZW1lOiB0LnRoZW1lXG4gICAgfSk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRMYXN0R3JhbW1hclN0YXRlRnJvbU1hcCh0b2tlbnMyKTtcbiAgICBjb25zdCB0aGVtZSA9IHR5cGVvZiB0LnRoZW1lID09PSBcInN0cmluZ1wiID8gdC50aGVtZSA6IHQudGhlbWUubmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiB0b2tlbnMyLFxuICAgICAgc3RhdGUsXG4gICAgICB0aGVtZVxuICAgIH07XG4gIH0pO1xuICBjb25zdCB0b2tlbnMgPSBzeW5jVGhlbWVzVG9rZW5pemF0aW9uKFxuICAgIC4uLnRoZW1lZFRva2Vucy5tYXAoKGkpID0+IGkudG9rZW5zKVxuICApO1xuICBjb25zdCBtZXJnZWRUb2tlbnMgPSB0b2tlbnNbMF0ubWFwKFxuICAgIChsaW5lLCBsaW5lSWR4KSA9PiBsaW5lLm1hcCgoX3Rva2VuLCB0b2tlbklkeCkgPT4ge1xuICAgICAgY29uc3QgbWVyZ2VkVG9rZW4gPSB7XG4gICAgICAgIGNvbnRlbnQ6IF90b2tlbi5jb250ZW50LFxuICAgICAgICB2YXJpYW50czoge30sXG4gICAgICAgIG9mZnNldDogX3Rva2VuLm9mZnNldFxuICAgICAgfTtcbiAgICAgIGlmIChcImluY2x1ZGVFeHBsYW5hdGlvblwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24pIHtcbiAgICAgICAgbWVyZ2VkVG9rZW4uZXhwbGFuYXRpb24gPSBfdG9rZW4uZXhwbGFuYXRpb247XG4gICAgICB9XG4gICAgICB0b2tlbnMuZm9yRWFjaCgodCwgdGhlbWVJZHgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbnRlbnQ6IF8sXG4gICAgICAgICAgZXhwbGFuYXRpb246IF9fLFxuICAgICAgICAgIG9mZnNldDogX19fLFxuICAgICAgICAgIC4uLnN0eWxlc1xuICAgICAgICB9ID0gdFtsaW5lSWR4XVt0b2tlbklkeF07XG4gICAgICAgIG1lcmdlZFRva2VuLnZhcmlhbnRzW3RoZW1lc1t0aGVtZUlkeF0uY29sb3JdID0gc3R5bGVzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWVyZ2VkVG9rZW47XG4gICAgfSlcbiAgKTtcbiAgY29uc3QgbWVyZ2VkR3JhbW1hclN0YXRlID0gdGhlbWVkVG9rZW5zWzBdLnN0YXRlID8gbmV3IEdyYW1tYXJTdGF0ZShcbiAgICBPYmplY3QuZnJvbUVudHJpZXModGhlbWVkVG9rZW5zLm1hcCgocykgPT4gW3MudGhlbWUsIHMuc3RhdGU/LmdldEludGVybmFsU3RhY2socy50aGVtZSldKSksXG4gICAgdGhlbWVkVG9rZW5zWzBdLnN0YXRlLmxhbmdcbiAgKSA6IHVuZGVmaW5lZDtcbiAgaWYgKG1lcmdlZEdyYW1tYXJTdGF0ZSlcbiAgICBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAobWVyZ2VkVG9rZW5zLCBtZXJnZWRHcmFtbWFyU3RhdGUpO1xuICByZXR1cm4gbWVyZ2VkVG9rZW5zO1xufVxuZnVuY3Rpb24gc3luY1RoZW1lc1Rva2VuaXphdGlvbiguLi50aGVtZXMpIHtcbiAgY29uc3Qgb3V0VGhlbWVzID0gdGhlbWVzLm1hcCgoKSA9PiBbXSk7XG4gIGNvbnN0IGNvdW50ID0gdGhlbWVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGVtZXNbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lcyA9IHRoZW1lcy5tYXAoKHQpID0+IHRbaV0pO1xuICAgIGNvbnN0IG91dExpbmVzID0gb3V0VGhlbWVzLm1hcCgoKSA9PiBbXSk7XG4gICAgb3V0VGhlbWVzLmZvckVhY2goKHQsIGkyKSA9PiB0LnB1c2gob3V0TGluZXNbaTJdKSk7XG4gICAgY29uc3QgaW5kZXhlcyA9IGxpbmVzLm1hcCgoKSA9PiAwKTtcbiAgICBjb25zdCBjdXJyZW50ID0gbGluZXMubWFwKChsKSA9PiBsWzBdKTtcbiAgICB3aGlsZSAoY3VycmVudC5ldmVyeSgodCkgPT4gdCkpIHtcbiAgICAgIGNvbnN0IG1pbkxlbmd0aCA9IE1hdGgubWluKC4uLmN1cnJlbnQubWFwKCh0KSA9PiB0LmNvbnRlbnQubGVuZ3RoKSk7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGNvdW50OyBuKyspIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBjdXJyZW50W25dO1xuICAgICAgICBpZiAodG9rZW4uY29udGVudC5sZW5ndGggPT09IG1pbkxlbmd0aCkge1xuICAgICAgICAgIG91dExpbmVzW25dLnB1c2godG9rZW4pO1xuICAgICAgICAgIGluZGV4ZXNbbl0gKz0gMTtcbiAgICAgICAgICBjdXJyZW50W25dID0gbGluZXNbbl1baW5kZXhlc1tuXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0TGluZXNbbl0ucHVzaCh7XG4gICAgICAgICAgICAuLi50b2tlbixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRva2VuLmNvbnRlbnQuc2xpY2UoMCwgbWluTGVuZ3RoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnRbbl0gPSB7XG4gICAgICAgICAgICAuLi50b2tlbixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRva2VuLmNvbnRlbnQuc2xpY2UobWluTGVuZ3RoKSxcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbWluTGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0VGhlbWVzO1xufVxuXG5mdW5jdGlvbiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMpIHtcbiAgbGV0IGJnO1xuICBsZXQgZmc7XG4gIGxldCB0b2tlbnM7XG4gIGxldCB0aGVtZU5hbWU7XG4gIGxldCByb290U3R5bGU7XG4gIGxldCBncmFtbWFyU3RhdGU7XG4gIGlmIChcInRoZW1lc1wiIGluIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZWZhdWx0Q29sb3IgPSBcImxpZ2h0XCIsXG4gICAgICBjc3NWYXJpYWJsZVByZWZpeCA9IFwiLS1zaGlraS1cIlxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRoZW1lcyA9IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudGhlbWVzKS5maWx0ZXIoKGkpID0+IGlbMV0pLm1hcCgoaSkgPT4gKHsgY29sb3I6IGlbMF0sIHRoZW1lOiBpWzFdIH0pKS5zb3J0KChhLCBiKSA9PiBhLmNvbG9yID09PSBkZWZhdWx0Q29sb3IgPyAtMSA6IGIuY29sb3IgPT09IGRlZmF1bHRDb2xvciA/IDEgOiAwKTtcbiAgICBpZiAodGhlbWVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJgdGhlbWVzYCBvcHRpb24gbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gICAgY29uc3QgdGhlbWVUb2tlbnMgPSBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKFxuICAgICAgaW50ZXJuYWwsXG4gICAgICBjb2RlLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZ3JhbW1hclN0YXRlID0gZ2V0TGFzdEdyYW1tYXJTdGF0ZUZyb21NYXAodGhlbWVUb2tlbnMpO1xuICAgIGlmIChkZWZhdWx0Q29sb3IgJiYgIXRoZW1lcy5maW5kKCh0KSA9PiB0LmNvbG9yID09PSBkZWZhdWx0Q29sb3IpKVxuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgXFxgdGhlbWVzXFxgIG9wdGlvbiBtdXN0IGNvbnRhaW4gdGhlIGRlZmF1bHRDb2xvciBrZXkgXFxgJHtkZWZhdWx0Q29sb3J9XFxgYCk7XG4gICAgY29uc3QgdGhlbWVSZWdzID0gdGhlbWVzLm1hcCgodCkgPT4gaW50ZXJuYWwuZ2V0VGhlbWUodC50aGVtZSkpO1xuICAgIGNvbnN0IHRoZW1lc09yZGVyID0gdGhlbWVzLm1hcCgodCkgPT4gdC5jb2xvcik7XG4gICAgdG9rZW5zID0gdGhlbWVUb2tlbnMubWFwKChsaW5lKSA9PiBsaW5lLm1hcCgodG9rZW4pID0+IG1lcmdlVG9rZW4odG9rZW4sIHRoZW1lc09yZGVyLCBjc3NWYXJpYWJsZVByZWZpeCwgZGVmYXVsdENvbG9yKSkpO1xuICAgIGlmIChncmFtbWFyU3RhdGUpXG4gICAgICBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAodG9rZW5zLCBncmFtbWFyU3RhdGUpO1xuICAgIGNvbnN0IHRoZW1lQ29sb3JSZXBsYWNlbWVudHMgPSB0aGVtZXMubWFwKCh0KSA9PiByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHModC50aGVtZSwgb3B0aW9ucykpO1xuICAgIGZnID0gdGhlbWVzLm1hcCgodCwgaWR4KSA9PiAoaWR4ID09PSAwICYmIGRlZmF1bHRDb2xvciA/IFwiXCIgOiBgJHtjc3NWYXJpYWJsZVByZWZpeCArIHQuY29sb3J9OmApICsgKGFwcGx5Q29sb3JSZXBsYWNlbWVudHModGhlbWVSZWdzW2lkeF0uZmcsIHRoZW1lQ29sb3JSZXBsYWNlbWVudHNbaWR4XSkgfHwgXCJpbmhlcml0XCIpKS5qb2luKFwiO1wiKTtcbiAgICBiZyA9IHRoZW1lcy5tYXAoKHQsIGlkeCkgPT4gKGlkeCA9PT0gMCAmJiBkZWZhdWx0Q29sb3IgPyBcIlwiIDogYCR7Y3NzVmFyaWFibGVQcmVmaXggKyB0LmNvbG9yfS1iZzpgKSArIChhcHBseUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lUmVnc1tpZHhdLmJnLCB0aGVtZUNvbG9yUmVwbGFjZW1lbnRzW2lkeF0pIHx8IFwiaW5oZXJpdFwiKSkuam9pbihcIjtcIik7XG4gICAgdGhlbWVOYW1lID0gYHNoaWtpLXRoZW1lcyAke3RoZW1lUmVncy5tYXAoKHQpID0+IHQubmFtZSkuam9pbihcIiBcIil9YDtcbiAgICByb290U3R5bGUgPSBkZWZhdWx0Q29sb3IgPyB1bmRlZmluZWQgOiBbZmcsIGJnXS5qb2luKFwiO1wiKTtcbiAgfSBlbHNlIGlmIChcInRoZW1lXCIgaW4gb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbG9yUmVwbGFjZW1lbnRzID0gcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzKG9wdGlvbnMudGhlbWUsIG9wdGlvbnMpO1xuICAgIHRva2VucyA9IGNvZGVUb1Rva2Vuc0Jhc2UoXG4gICAgICBpbnRlcm5hbCxcbiAgICAgIGNvZGUsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBjb25zdCBfdGhlbWUgPSBpbnRlcm5hbC5nZXRUaGVtZShvcHRpb25zLnRoZW1lKTtcbiAgICBiZyA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoX3RoZW1lLmJnLCBjb2xvclJlcGxhY2VtZW50cyk7XG4gICAgZmcgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKF90aGVtZS5mZywgY29sb3JSZXBsYWNlbWVudHMpO1xuICAgIHRoZW1lTmFtZSA9IF90aGVtZS5uYW1lO1xuICAgIGdyYW1tYXJTdGF0ZSA9IGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKHRva2Vucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShcIkludmFsaWQgb3B0aW9ucywgZWl0aGVyIGB0aGVtZWAgb3IgYHRoZW1lc2AgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRva2VucyxcbiAgICBmZyxcbiAgICBiZyxcbiAgICB0aGVtZU5hbWUsXG4gICAgcm9vdFN0eWxlLFxuICAgIGdyYW1tYXJTdGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VUb2tlbihtZXJnZWQsIHZhcmlhbnRzT3JkZXIsIGNzc1ZhcmlhYmxlUHJlZml4LCBkZWZhdWx0Q29sb3IpIHtcbiAgY29uc3QgdG9rZW4gPSB7XG4gICAgY29udGVudDogbWVyZ2VkLmNvbnRlbnQsXG4gICAgZXhwbGFuYXRpb246IG1lcmdlZC5leHBsYW5hdGlvbixcbiAgICBvZmZzZXQ6IG1lcmdlZC5vZmZzZXRcbiAgfTtcbiAgY29uc3Qgc3R5bGVzID0gdmFyaWFudHNPcmRlci5tYXAoKHQpID0+IGdldFRva2VuU3R5bGVPYmplY3QobWVyZ2VkLnZhcmlhbnRzW3RdKSk7XG4gIGNvbnN0IHN0eWxlS2V5cyA9IG5ldyBTZXQoc3R5bGVzLmZsYXRNYXAoKHQpID0+IE9iamVjdC5rZXlzKHQpKSk7XG4gIGNvbnN0IG1lcmdlZFN0eWxlcyA9IHt9O1xuICBzdHlsZXMuZm9yRWFjaCgoY3VyLCBpZHgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzdHlsZUtleXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3VyW2tleV0gfHwgXCJpbmhlcml0XCI7XG4gICAgICBpZiAoaWR4ID09PSAwICYmIGRlZmF1bHRDb2xvcikge1xuICAgICAgICBtZXJnZWRTdHlsZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleSA9PT0gXCJjb2xvclwiID8gXCJcIiA6IGtleSA9PT0gXCJiYWNrZ3JvdW5kLWNvbG9yXCIgPyBcIi1iZ1wiIDogYC0ke2tleX1gO1xuICAgICAgICBjb25zdCB2YXJLZXkgPSBjc3NWYXJpYWJsZVByZWZpeCArIHZhcmlhbnRzT3JkZXJbaWR4XSArIChrZXkgPT09IFwiY29sb3JcIiA/IFwiXCIgOiBrZXlOYW1lKTtcbiAgICAgICAgbWVyZ2VkU3R5bGVzW3ZhcktleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0b2tlbi5odG1sU3R5bGUgPSBtZXJnZWRTdHlsZXM7XG4gIHJldHVybiB0b2tlbjtcbn1cblxuZnVuY3Rpb24gY29kZVRvSGFzdChpbnRlcm5hbCwgY29kZSwgb3B0aW9ucywgdHJhbnNmb3JtZXJDb250ZXh0ID0ge1xuICBtZXRhOiB7fSxcbiAgb3B0aW9ucyxcbiAgY29kZVRvSGFzdDogKF9jb2RlLCBfb3B0aW9ucykgPT4gY29kZVRvSGFzdChpbnRlcm5hbCwgX2NvZGUsIF9vcHRpb25zKSxcbiAgY29kZVRvVG9rZW5zOiAoX2NvZGUsIF9vcHRpb25zKSA9PiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIF9jb2RlLCBfb3B0aW9ucylcbn0pIHtcbiAgbGV0IGlucHV0ID0gY29kZTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykpXG4gICAgaW5wdXQgPSB0cmFuc2Zvcm1lci5wcmVwcm9jZXNzPy5jYWxsKHRyYW5zZm9ybWVyQ29udGV4dCwgaW5wdXQsIG9wdGlvbnMpIHx8IGlucHV0O1xuICBsZXQge1xuICAgIHRva2VucyxcbiAgICBmZyxcbiAgICBiZyxcbiAgICB0aGVtZU5hbWUsXG4gICAgcm9vdFN0eWxlLFxuICAgIGdyYW1tYXJTdGF0ZVxuICB9ID0gY29kZVRvVG9rZW5zKGludGVybmFsLCBpbnB1dCwgb3B0aW9ucyk7XG4gIGNvbnN0IHtcbiAgICBtZXJnZVdoaXRlc3BhY2VzID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgaWYgKG1lcmdlV2hpdGVzcGFjZXMgPT09IHRydWUpXG4gICAgdG9rZW5zID0gbWVyZ2VXaGl0ZXNwYWNlVG9rZW5zKHRva2Vucyk7XG4gIGVsc2UgaWYgKG1lcmdlV2hpdGVzcGFjZXMgPT09IFwibmV2ZXJcIilcbiAgICB0b2tlbnMgPSBzcGxpdFdoaXRlc3BhY2VUb2tlbnModG9rZW5zKTtcbiAgY29uc3QgY29udGV4dFNvdXJjZSA9IHtcbiAgICAuLi50cmFuc2Zvcm1lckNvbnRleHQsXG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgZ2V0VHJhbnNmb3JtZXJzKG9wdGlvbnMpKVxuICAgIHRva2VucyA9IHRyYW5zZm9ybWVyLnRva2Vucz8uY2FsbChjb250ZXh0U291cmNlLCB0b2tlbnMpIHx8IHRva2VucztcbiAgcmV0dXJuIHRva2Vuc1RvSGFzdChcbiAgICB0b2tlbnMsXG4gICAge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGZnLFxuICAgICAgYmcsXG4gICAgICB0aGVtZU5hbWUsXG4gICAgICByb290U3R5bGVcbiAgICB9LFxuICAgIGNvbnRleHRTb3VyY2UsXG4gICAgZ3JhbW1hclN0YXRlXG4gICk7XG59XG5mdW5jdGlvbiB0b2tlbnNUb0hhc3QodG9rZW5zLCBvcHRpb25zLCB0cmFuc2Zvcm1lckNvbnRleHQsIGdyYW1tYXJTdGF0ZSA9IGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKHRva2VucykpIHtcbiAgY29uc3QgdHJhbnNmb3JtZXJzID0gZ2V0VHJhbnNmb3JtZXJzKG9wdGlvbnMpO1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBjb25zdCByb290ID0ge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9O1xuICBjb25zdCB7XG4gICAgc3RydWN0dXJlID0gXCJjbGFzc2ljXCIsXG4gICAgdGFiaW5kZXggPSBcIjBcIlxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHByZU5vZGUgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJwcmVcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBjbGFzczogYHNoaWtpICR7b3B0aW9ucy50aGVtZU5hbWUgfHwgXCJcIn1gLFxuICAgICAgc3R5bGU6IG9wdGlvbnMucm9vdFN0eWxlIHx8IGBiYWNrZ3JvdW5kLWNvbG9yOiR7b3B0aW9ucy5iZ307Y29sb3I6JHtvcHRpb25zLmZnfWAsXG4gICAgICAuLi50YWJpbmRleCAhPT0gZmFsc2UgJiYgdGFiaW5kZXggIT0gbnVsbCA/IHtcbiAgICAgICAgdGFiaW5kZXg6IHRhYmluZGV4LnRvU3RyaW5nKClcbiAgICAgIH0gOiB7fSxcbiAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbShcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLm1ldGEgfHwge30pXG4gICAgICAgICkuZmlsdGVyKChba2V5XSkgPT4gIWtleS5zdGFydHNXaXRoKFwiX1wiKSlcbiAgICAgIClcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9O1xuICBsZXQgY29kZU5vZGUgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJjb2RlXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IGxpbmVzXG4gIH07XG4gIGNvbnN0IGxpbmVOb2RlcyA9IFtdO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIC4uLnRyYW5zZm9ybWVyQ29udGV4dCxcbiAgICBzdHJ1Y3R1cmUsXG4gICAgYWRkQ2xhc3NUb0hhc3QsXG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lckNvbnRleHQuc291cmNlO1xuICAgIH0sXG4gICAgZ2V0IHRva2VucygpIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfSxcbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0sXG4gICAgZ2V0IHJvb3QoKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9LFxuICAgIGdldCBwcmUoKSB7XG4gICAgICByZXR1cm4gcHJlTm9kZTtcbiAgICB9LFxuICAgIGdldCBjb2RlKCkge1xuICAgICAgcmV0dXJuIGNvZGVOb2RlO1xuICAgIH0sXG4gICAgZ2V0IGxpbmVzKCkge1xuICAgICAgcmV0dXJuIGxpbmVOb2RlcztcbiAgICB9XG4gIH07XG4gIHRva2Vucy5mb3JFYWNoKChsaW5lLCBpZHgpID0+IHtcbiAgICBpZiAoaWR4KSB7XG4gICAgICBpZiAoc3RydWN0dXJlID09PSBcImlubGluZVwiKVxuICAgICAgICByb290LmNoaWxkcmVuLnB1c2goeyB0eXBlOiBcImVsZW1lbnRcIiwgdGFnTmFtZTogXCJiclwiLCBwcm9wZXJ0aWVzOiB7fSwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgZWxzZSBpZiAoc3RydWN0dXJlID09PSBcImNsYXNzaWNcIilcbiAgICAgICAgbGluZXMucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogXCJcXG5cIiB9KTtcbiAgICB9XG4gICAgbGV0IGxpbmVOb2RlID0ge1xuICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgIHByb3BlcnRpZXM6IHsgY2xhc3M6IFwibGluZVwiIH0sXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICAgIGxldCBjb2wgPSAwO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbGluZSkge1xuICAgICAgbGV0IHRva2VuTm9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwic3BhblwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgLi4udG9rZW4uaHRtbEF0dHJzXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHRva2VuLmNvbnRlbnQgfV1cbiAgICAgIH07XG4gICAgICBpZiAodHlwZW9mIHRva2VuLmh0bWxTdHlsZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgd2FybkRlcHJlY2F0ZWQoXCJgaHRtbFN0eWxlYCBhcyBhIHN0cmluZyBpcyBkZXByZWNhdGVkLiBVc2UgYW4gb2JqZWN0IGluc3RlYWQuXCIpO1xuICAgICAgY29uc3Qgc3R5bGUgPSBzdHJpbmdpZnlUb2tlblN0eWxlKHRva2VuLmh0bWxTdHlsZSB8fCBnZXRUb2tlblN0eWxlT2JqZWN0KHRva2VuKSk7XG4gICAgICBpZiAoc3R5bGUpXG4gICAgICAgIHRva2VuTm9kZS5wcm9wZXJ0aWVzLnN0eWxlID0gc3R5bGU7XG4gICAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycylcbiAgICAgICAgdG9rZW5Ob2RlID0gdHJhbnNmb3JtZXI/LnNwYW4/LmNhbGwoY29udGV4dCwgdG9rZW5Ob2RlLCBpZHggKyAxLCBjb2wsIGxpbmVOb2RlLCB0b2tlbikgfHwgdG9rZW5Ob2RlO1xuICAgICAgaWYgKHN0cnVjdHVyZSA9PT0gXCJpbmxpbmVcIilcbiAgICAgICAgcm9vdC5jaGlsZHJlbi5wdXNoKHRva2VuTm9kZSk7XG4gICAgICBlbHNlIGlmIChzdHJ1Y3R1cmUgPT09IFwiY2xhc3NpY1wiKVxuICAgICAgICBsaW5lTm9kZS5jaGlsZHJlbi5wdXNoKHRva2VuTm9kZSk7XG4gICAgICBjb2wgKz0gdG9rZW4uY29udGVudC5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChzdHJ1Y3R1cmUgPT09IFwiY2xhc3NpY1wiKSB7XG4gICAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycylcbiAgICAgICAgbGluZU5vZGUgPSB0cmFuc2Zvcm1lcj8ubGluZT8uY2FsbChjb250ZXh0LCBsaW5lTm9kZSwgaWR4ICsgMSkgfHwgbGluZU5vZGU7XG4gICAgICBsaW5lTm9kZXMucHVzaChsaW5lTm9kZSk7XG4gICAgICBsaW5lcy5wdXNoKGxpbmVOb2RlKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoc3RydWN0dXJlID09PSBcImNsYXNzaWNcIikge1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgY29kZU5vZGUgPSB0cmFuc2Zvcm1lcj8uY29kZT8uY2FsbChjb250ZXh0LCBjb2RlTm9kZSkgfHwgY29kZU5vZGU7XG4gICAgcHJlTm9kZS5jaGlsZHJlbi5wdXNoKGNvZGVOb2RlKTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycylcbiAgICAgIHByZU5vZGUgPSB0cmFuc2Zvcm1lcj8ucHJlPy5jYWxsKGNvbnRleHQsIHByZU5vZGUpIHx8IHByZU5vZGU7XG4gICAgcm9vdC5jaGlsZHJlbi5wdXNoKHByZU5vZGUpO1xuICB9XG4gIGxldCByZXN1bHQgPSByb290O1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycylcbiAgICByZXN1bHQgPSB0cmFuc2Zvcm1lcj8ucm9vdD8uY2FsbChjb250ZXh0LCByZXN1bHQpIHx8IHJlc3VsdDtcbiAgaWYgKGdyYW1tYXJTdGF0ZSlcbiAgICBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAocmVzdWx0LCBncmFtbWFyU3RhdGUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWVyZ2VXaGl0ZXNwYWNlVG9rZW5zKHRva2Vucykge1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIGNvbnN0IG5ld0xpbmUgPSBbXTtcbiAgICBsZXQgY2FycnlPbkNvbnRlbnQgPSBcIlwiO1xuICAgIGxldCBmaXJzdE9mZnNldCA9IDA7XG4gICAgbGluZS5mb3JFYWNoKCh0b2tlbiwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBpc1VuZGVybGluZSA9IHRva2VuLmZvbnRTdHlsZSAmJiB0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuVW5kZXJsaW5lO1xuICAgICAgY29uc3QgY291bGRNZXJnZSA9ICFpc1VuZGVybGluZTtcbiAgICAgIGlmIChjb3VsZE1lcmdlICYmIHRva2VuLmNvbnRlbnQubWF0Y2goL15cXHMrJC8pICYmIGxpbmVbaWR4ICsgMV0pIHtcbiAgICAgICAgaWYgKCFmaXJzdE9mZnNldClcbiAgICAgICAgICBmaXJzdE9mZnNldCA9IHRva2VuLm9mZnNldDtcbiAgICAgICAgY2FycnlPbkNvbnRlbnQgKz0gdG9rZW4uY29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYXJyeU9uQ29udGVudCkge1xuICAgICAgICAgIGlmIChjb3VsZE1lcmdlKSB7XG4gICAgICAgICAgICBuZXdMaW5lLnB1c2goe1xuICAgICAgICAgICAgICAuLi50b2tlbixcbiAgICAgICAgICAgICAgb2Zmc2V0OiBmaXJzdE9mZnNldCxcbiAgICAgICAgICAgICAgY29udGVudDogY2FycnlPbkNvbnRlbnQgKyB0b2tlbi5jb250ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGluZS5wdXNoKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29udGVudDogY2FycnlPbkNvbnRlbnQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmaXJzdE9mZnNldFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlyc3RPZmZzZXQgPSAwO1xuICAgICAgICAgIGNhcnJ5T25Db250ZW50ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMaW5lLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0xpbmU7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3BsaXRXaGl0ZXNwYWNlVG9rZW5zKHRva2Vucykge1xuICByZXR1cm4gdG9rZW5zLm1hcCgobGluZSkgPT4ge1xuICAgIHJldHVybiBsaW5lLmZsYXRNYXAoKHRva2VuKSA9PiB7XG4gICAgICBpZiAodG9rZW4uY29udGVudC5tYXRjaCgvXlxccyskLykpXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIGNvbnN0IG1hdGNoID0gdG9rZW4uY29udGVudC5tYXRjaCgvXihcXHMqKSguKj8pKFxccyopJC8pO1xuICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgY29uc3QgWywgbGVhZGluZywgY29udGVudCwgdHJhaWxpbmddID0gbWF0Y2g7XG4gICAgICBpZiAoIWxlYWRpbmcgJiYgIXRyYWlsaW5nKVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICBjb25zdCBleHBhbmRlZCA9IFt7XG4gICAgICAgIC4uLnRva2VuLFxuICAgICAgICBvZmZzZXQ6IHRva2VuLm9mZnNldCArIGxlYWRpbmcubGVuZ3RoLFxuICAgICAgICBjb250ZW50XG4gICAgICB9XTtcbiAgICAgIGlmIChsZWFkaW5nKSB7XG4gICAgICAgIGV4cGFuZGVkLnVuc2hpZnQoe1xuICAgICAgICAgIGNvbnRlbnQ6IGxlYWRpbmcsXG4gICAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhaWxpbmcpIHtcbiAgICAgICAgZXhwYW5kZWQucHVzaCh7XG4gICAgICAgICAgY29udGVudDogdHJhaWxpbmcsXG4gICAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXQgKyBsZWFkaW5nLmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29kZVRvSHRtbChpbnRlcm5hbCwgY29kZSwgb3B0aW9ucykge1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIG1ldGE6IHt9LFxuICAgIG9wdGlvbnMsXG4gICAgY29kZVRvSGFzdDogKF9jb2RlLCBfb3B0aW9ucykgPT4gY29kZVRvSGFzdChpbnRlcm5hbCwgX2NvZGUsIF9vcHRpb25zKSxcbiAgICBjb2RlVG9Ub2tlbnM6IChfY29kZSwgX29wdGlvbnMpID0+IGNvZGVUb1Rva2VucyhpbnRlcm5hbCwgX2NvZGUsIF9vcHRpb25zKVxuICB9O1xuICBsZXQgcmVzdWx0ID0gdG9IdG1sKGNvZGVUb0hhc3QoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMsIGNvbnRleHQpKTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykpXG4gICAgcmVzdWx0ID0gdHJhbnNmb3JtZXIucG9zdHByb2Nlc3M/LmNhbGwoY29udGV4dCwgcmVzdWx0LCBvcHRpb25zKSB8fCByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfRkcgPSB7IGxpZ2h0OiBcIiMzMzMzMzNcIiwgZGFyazogXCIjYmJiYmJiXCIgfTtcbmNvbnN0IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfQkcgPSB7IGxpZ2h0OiBcIiNmZmZmZmVcIiwgZGFyazogXCIjMWUxZTFlXCIgfTtcbmNvbnN0IFJFU09MVkVEX0tFWSA9IFwiX19zaGlraV9yZXNvbHZlZFwiO1xuZnVuY3Rpb24gbm9ybWFsaXplVGhlbWUocmF3VGhlbWUpIHtcbiAgaWYgKHJhd1RoZW1lPy5bUkVTT0xWRURfS0VZXSlcbiAgICByZXR1cm4gcmF3VGhlbWU7XG4gIGNvbnN0IHRoZW1lID0ge1xuICAgIC4uLnJhd1RoZW1lXG4gIH07XG4gIGlmICh0aGVtZS50b2tlbkNvbG9ycyAmJiAhdGhlbWUuc2V0dGluZ3MpIHtcbiAgICB0aGVtZS5zZXR0aW5ncyA9IHRoZW1lLnRva2VuQ29sb3JzO1xuICAgIGRlbGV0ZSB0aGVtZS50b2tlbkNvbG9ycztcbiAgfVxuICB0aGVtZS50eXBlIHx8PSBcImRhcmtcIjtcbiAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHMgPSB7IC4uLnRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzIH07XG4gIHRoZW1lLnNldHRpbmdzIHx8PSBbXTtcbiAgbGV0IHsgYmcsIGZnIH0gPSB0aGVtZTtcbiAgaWYgKCFiZyB8fCAhZmcpIHtcbiAgICBjb25zdCBnbG9iYWxTZXR0aW5nID0gdGhlbWUuc2V0dGluZ3MgPyB0aGVtZS5zZXR0aW5ncy5maW5kKChzKSA9PiAhcy5uYW1lICYmICFzLnNjb3BlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoZ2xvYmFsU2V0dGluZz8uc2V0dGluZ3M/LmZvcmVncm91bmQpXG4gICAgICBmZyA9IGdsb2JhbFNldHRpbmcuc2V0dGluZ3MuZm9yZWdyb3VuZDtcbiAgICBpZiAoZ2xvYmFsU2V0dGluZz8uc2V0dGluZ3M/LmJhY2tncm91bmQpXG4gICAgICBiZyA9IGdsb2JhbFNldHRpbmcuc2V0dGluZ3MuYmFja2dyb3VuZDtcbiAgICBpZiAoIWZnICYmIHRoZW1lPy5jb2xvcnM/LltcImVkaXRvci5mb3JlZ3JvdW5kXCJdKVxuICAgICAgZmcgPSB0aGVtZS5jb2xvcnNbXCJlZGl0b3IuZm9yZWdyb3VuZFwiXTtcbiAgICBpZiAoIWJnICYmIHRoZW1lPy5jb2xvcnM/LltcImVkaXRvci5iYWNrZ3JvdW5kXCJdKVxuICAgICAgYmcgPSB0aGVtZS5jb2xvcnNbXCJlZGl0b3IuYmFja2dyb3VuZFwiXTtcbiAgICBpZiAoIWZnKVxuICAgICAgZmcgPSB0aGVtZS50eXBlID09PSBcImxpZ2h0XCIgPyBWU0NPREVfRkFMTEJBQ0tfRURJVE9SX0ZHLmxpZ2h0IDogVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9GRy5kYXJrO1xuICAgIGlmICghYmcpXG4gICAgICBiZyA9IHRoZW1lLnR5cGUgPT09IFwibGlnaHRcIiA/IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfQkcubGlnaHQgOiBWU0NPREVfRkFMTEJBQ0tfRURJVE9SX0JHLmRhcms7XG4gICAgdGhlbWUuZmcgPSBmZztcbiAgICB0aGVtZS5iZyA9IGJnO1xuICB9XG4gIGlmICghKHRoZW1lLnNldHRpbmdzWzBdICYmIHRoZW1lLnNldHRpbmdzWzBdLnNldHRpbmdzICYmICF0aGVtZS5zZXR0aW5nc1swXS5zY29wZSkpIHtcbiAgICB0aGVtZS5zZXR0aW5ncy51bnNoaWZ0KHtcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIGZvcmVncm91bmQ6IHRoZW1lLmZnLFxuICAgICAgICBiYWNrZ3JvdW5kOiB0aGVtZS5iZ1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxldCByZXBsYWNlbWVudENvdW50ID0gMDtcbiAgY29uc3QgcmVwbGFjZW1lbnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBnZXRSZXBsYWNlbWVudENvbG9yKHZhbHVlKSB7XG4gICAgaWYgKHJlcGxhY2VtZW50TWFwLmhhcyh2YWx1ZSkpXG4gICAgICByZXR1cm4gcmVwbGFjZW1lbnRNYXAuZ2V0KHZhbHVlKTtcbiAgICByZXBsYWNlbWVudENvdW50ICs9IDE7XG4gICAgY29uc3QgaGV4ID0gYCMke3JlcGxhY2VtZW50Q291bnQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKS50b0xvd2VyQ2FzZSgpfWA7XG4gICAgaWYgKHRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzPy5bYCMke2hleH1gXSlcbiAgICAgIHJldHVybiBnZXRSZXBsYWNlbWVudENvbG9yKHZhbHVlKTtcbiAgICByZXBsYWNlbWVudE1hcC5zZXQodmFsdWUsIGhleCk7XG4gICAgcmV0dXJuIGhleDtcbiAgfVxuICB0aGVtZS5zZXR0aW5ncyA9IHRoZW1lLnNldHRpbmdzLm1hcCgoc2V0dGluZykgPT4ge1xuICAgIGNvbnN0IHJlcGxhY2VGZyA9IHNldHRpbmcuc2V0dGluZ3M/LmZvcmVncm91bmQgJiYgIXNldHRpbmcuc2V0dGluZ3MuZm9yZWdyb3VuZC5zdGFydHNXaXRoKFwiI1wiKTtcbiAgICBjb25zdCByZXBsYWNlQmcgPSBzZXR0aW5nLnNldHRpbmdzPy5iYWNrZ3JvdW5kICYmICFzZXR0aW5nLnNldHRpbmdzLmJhY2tncm91bmQuc3RhcnRzV2l0aChcIiNcIik7XG4gICAgaWYgKCFyZXBsYWNlRmcgJiYgIXJlcGxhY2VCZylcbiAgICAgIHJldHVybiBzZXR0aW5nO1xuICAgIGNvbnN0IGNsb25lID0ge1xuICAgICAgLi4uc2V0dGluZyxcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIC4uLnNldHRpbmcuc2V0dGluZ3NcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChyZXBsYWNlRmcpIHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0UmVwbGFjZW1lbnRDb2xvcihzZXR0aW5nLnNldHRpbmdzLmZvcmVncm91bmQpO1xuICAgICAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRdID0gc2V0dGluZy5zZXR0aW5ncy5mb3JlZ3JvdW5kO1xuICAgICAgY2xvbmUuc2V0dGluZ3MuZm9yZWdyb3VuZCA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICBpZiAocmVwbGFjZUJnKSB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGdldFJlcGxhY2VtZW50Q29sb3Ioc2V0dGluZy5zZXR0aW5ncy5iYWNrZ3JvdW5kKTtcbiAgICAgIHRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzW3JlcGxhY2VtZW50XSA9IHNldHRpbmcuc2V0dGluZ3MuYmFja2dyb3VuZDtcbiAgICAgIGNsb25lLnNldHRpbmdzLmJhY2tncm91bmQgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9KTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhlbWUuY29sb3JzIHx8IHt9KSkge1xuICAgIGlmIChrZXkgPT09IFwiZWRpdG9yLmZvcmVncm91bmRcIiB8fCBrZXkgPT09IFwiZWRpdG9yLmJhY2tncm91bmRcIiB8fCBrZXkuc3RhcnRzV2l0aChcInRlcm1pbmFsLmFuc2lcIikpIHtcbiAgICAgIGlmICghdGhlbWUuY29sb3JzW2tleV0/LnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0UmVwbGFjZW1lbnRDb2xvcih0aGVtZS5jb2xvcnNba2V5XSk7XG4gICAgICAgIHRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzW3JlcGxhY2VtZW50XSA9IHRoZW1lLmNvbG9yc1trZXldO1xuICAgICAgICB0aGVtZS5jb2xvcnNba2V5XSA9IHJlcGxhY2VtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhlbWUsIFJFU09MVkVEX0tFWSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIHRoZW1lO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlTGFuZ3MobGFuZ3MpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCgoYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbGFuZ3MuZmlsdGVyKChsKSA9PiAhaXNTcGVjaWFsTGFuZyhsKSkubWFwKGFzeW5jIChsYW5nKSA9PiBhd2FpdCBub3JtYWxpemVHZXR0ZXIobGFuZykudGhlbigocikgPT4gQXJyYXkuaXNBcnJheShyKSA/IHIgOiBbcl0pKVxuICApKS5mbGF0KCkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVUaGVtZXModGhlbWVzKSB7XG4gIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdGhlbWVzLm1hcChcbiAgICAgIGFzeW5jICh0aGVtZSkgPT4gaXNTcGVjaWFsVGhlbWUodGhlbWUpID8gbnVsbCA6IG5vcm1hbGl6ZVRoZW1lKGF3YWl0IG5vcm1hbGl6ZUdldHRlcih0aGVtZSkpXG4gICAgKVxuICApO1xuICByZXR1cm4gcmVzb2x2ZWQuZmlsdGVyKChpKSA9PiAhIWkpO1xufVxuXG5jbGFzcyBSZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5JDEge1xuICBjb25zdHJ1Y3RvcihfcmVzb2x2ZXIsIF90aGVtZXMsIF9sYW5ncywgX2FsaWFzID0ge30pIHtcbiAgICBzdXBlcihfcmVzb2x2ZXIpO1xuICAgIHRoaXMuX3Jlc29sdmVyID0gX3Jlc29sdmVyO1xuICAgIHRoaXMuX3RoZW1lcyA9IF90aGVtZXM7XG4gICAgdGhpcy5fbGFuZ3MgPSBfbGFuZ3M7XG4gICAgdGhpcy5fYWxpYXMgPSBfYWxpYXM7XG4gICAgdGhpcy5fdGhlbWVzLm1hcCgodCkgPT4gdGhpcy5sb2FkVGhlbWUodCkpO1xuICAgIHRoaXMubG9hZExhbmd1YWdlcyh0aGlzLl9sYW5ncyk7XG4gIH1cbiAgX3Jlc29sdmVkVGhlbWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3Jlc29sdmVkR3JhbW1hcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfbGFuZ01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9sYW5nR3JhcGggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfdGV4dG1hdGVUaGVtZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIF9sb2FkZWRUaGVtZXNDYWNoZSA9IG51bGw7XG4gIF9sb2FkZWRMYW5ndWFnZXNDYWNoZSA9IG51bGw7XG4gIGdldFRoZW1lKHRoZW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZFRoZW1lcy5nZXQodGhlbWUpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmxvYWRUaGVtZSh0aGVtZSk7XG4gIH1cbiAgbG9hZFRoZW1lKHRoZW1lKSB7XG4gICAgY29uc3QgX3RoZW1lID0gbm9ybWFsaXplVGhlbWUodGhlbWUpO1xuICAgIGlmIChfdGhlbWUubmFtZSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZWRUaGVtZXMuc2V0KF90aGVtZS5uYW1lLCBfdGhlbWUpO1xuICAgICAgdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3RoZW1lO1xuICB9XG4gIGdldExvYWRlZFRoZW1lcygpIHtcbiAgICBpZiAoIXRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlKVxuICAgICAgdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGUgPSBbLi4udGhpcy5fcmVzb2x2ZWRUaGVtZXMua2V5cygpXTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGU7XG4gIH1cbiAgLy8gT3ZlcnJpZGUgYW5kIHJlLWltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBjYWNoZSB0aGUgdGV4dG1hdGUgdGhlbWVzIGFzIGBUZXh0TWF0ZVRoZW1lLmNyZWF0ZUZyb21SYXdUaGVtZWBcbiAgLy8gaXMgZXhwZW5zaXZlLiBUaGVtZXMgY2FuIHN3aXRjaCBvZnRlbiBlc3BlY2lhbGx5IGZvciBkdWFsLXRoZW1lIHN1cHBvcnQuXG4gIC8vXG4gIC8vIFRoZSBwYXJlbnQgY2xhc3MgYWxzbyBhY2NlcHRzIGBjb2xvck1hcGAgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIsIGJ1dCBzaW5jZSB3ZSBkb24ndCB1c2UgdGhhdCxcbiAgLy8gd2Ugb21pdCBoZXJlIHNvIGl0J3MgZWFzaWVyIHRvIGNhY2hlIHRoZSB0aGVtZXMuXG4gIHNldFRoZW1lKHRoZW1lKSB7XG4gICAgbGV0IHRleHRtYXRlVGhlbWUgPSB0aGlzLl90ZXh0bWF0ZVRoZW1lQ2FjaGUuZ2V0KHRoZW1lKTtcbiAgICBpZiAoIXRleHRtYXRlVGhlbWUpIHtcbiAgICAgIHRleHRtYXRlVGhlbWUgPSBUaGVtZS5jcmVhdGVGcm9tUmF3VGhlbWUodGhlbWUpO1xuICAgICAgdGhpcy5fdGV4dG1hdGVUaGVtZUNhY2hlLnNldCh0aGVtZSwgdGV4dG1hdGVUaGVtZSk7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNSZWdpc3RyeS5zZXRUaGVtZSh0ZXh0bWF0ZVRoZW1lKTtcbiAgfVxuICBnZXRHcmFtbWFyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fYWxpYXNbbmFtZV0pIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW25hbWVdKTtcbiAgICAgIHdoaWxlICh0aGlzLl9hbGlhc1tuYW1lXSkge1xuICAgICAgICBuYW1lID0gdGhpcy5fYWxpYXNbbmFtZV07XG4gICAgICAgIGlmIChyZXNvbHZlZC5oYXMobmFtZSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoYENpcmN1bGFyIGFsaWFzIFxcYCR7QXJyYXkuZnJvbShyZXNvbHZlZCkuam9pbihcIiAtPiBcIil9IC0+ICR7bmFtZX1cXGBgKTtcbiAgICAgICAgcmVzb2x2ZWQuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRHcmFtbWFycy5nZXQobmFtZSk7XG4gIH1cbiAgbG9hZExhbmd1YWdlKGxhbmcpIHtcbiAgICBpZiAodGhpcy5nZXRHcmFtbWFyKGxhbmcubmFtZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZW1iZWRkZWRMYXppbHlCeSA9IG5ldyBTZXQoXG4gICAgICBbLi4udGhpcy5fbGFuZ01hcC52YWx1ZXMoKV0uZmlsdGVyKChpKSA9PiBpLmVtYmVkZGVkTGFuZ3NMYXp5Py5pbmNsdWRlcyhsYW5nLm5hbWUpKVxuICAgICk7XG4gICAgdGhpcy5fcmVzb2x2ZXIuYWRkTGFuZ3VhZ2UobGFuZyk7XG4gICAgY29uc3QgZ3JhbW1hckNvbmZpZyA9IHtcbiAgICAgIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9yczogbGFuZy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgfHwgW1wiKlwiXSxcbiAgICAgIHVuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzOiBsYW5nLnVuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIHx8IFtdXG4gICAgfTtcbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkuX3Jhd0dyYW1tYXJzLnNldChsYW5nLnNjb3BlTmFtZSwgbGFuZyk7XG4gICAgY29uc3QgZyA9IHRoaXMubG9hZEdyYW1tYXJXaXRoQ29uZmlndXJhdGlvbihsYW5nLnNjb3BlTmFtZSwgMSwgZ3JhbW1hckNvbmZpZyk7XG4gICAgZy5uYW1lID0gbGFuZy5uYW1lO1xuICAgIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuc2V0KGxhbmcubmFtZSwgZyk7XG4gICAgaWYgKGxhbmcuYWxpYXNlcykge1xuICAgICAgbGFuZy5hbGlhc2VzLmZvckVhY2goKGFsaWFzKSA9PiB7XG4gICAgICAgIHRoaXMuX2FsaWFzW2FsaWFzXSA9IGxhbmcubmFtZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWRMYW5ndWFnZXNDYWNoZSA9IG51bGw7XG4gICAgaWYgKGVtYmVkZGVkTGF6aWx5Qnkuc2l6ZSkge1xuICAgICAgZm9yIChjb25zdCBlIG9mIGVtYmVkZGVkTGF6aWx5QnkpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRHcmFtbWFycy5kZWxldGUoZS5uYW1lKTtcbiAgICAgICAgdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zeW5jUmVnaXN0cnk/Ll9pbmplY3Rpb25HcmFtbWFycz8uZGVsZXRlKGUuc2NvcGVOYW1lKTtcbiAgICAgICAgdGhpcy5fc3luY1JlZ2lzdHJ5Py5fZ3JhbW1hcnM/LmRlbGV0ZShlLnNjb3BlTmFtZSk7XG4gICAgICAgIHRoaXMubG9hZExhbmd1YWdlKHRoaXMuX2xhbmdNYXAuZ2V0KGUubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9yZXNvbHZlZFRoZW1lcy5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuY2xlYXIoKTtcbiAgICB0aGlzLl9sYW5nTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5fbGFuZ0dyYXBoLmNsZWFyKCk7XG4gICAgdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGUgPSBudWxsO1xuICB9XG4gIGxvYWRMYW5ndWFnZXMobGFuZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGxhbmcgb2YgbGFuZ3MpXG4gICAgICB0aGlzLnJlc29sdmVFbWJlZGRlZExhbmd1YWdlcyhsYW5nKTtcbiAgICBjb25zdCBsYW5nc0dyYXBoQXJyYXkgPSBBcnJheS5mcm9tKHRoaXMuX2xhbmdHcmFwaC5lbnRyaWVzKCkpO1xuICAgIGNvbnN0IG1pc3NpbmdMYW5ncyA9IGxhbmdzR3JhcGhBcnJheS5maWx0ZXIoKFtfLCBsYW5nXSkgPT4gIWxhbmcpO1xuICAgIGlmIChtaXNzaW5nTGFuZ3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZXBlbmRlbnRzID0gbGFuZ3NHcmFwaEFycmF5LmZpbHRlcigoW18sIGxhbmddKSA9PiBsYW5nICYmIGxhbmcuZW1iZWRkZWRMYW5ncz8uc29tZSgobCkgPT4gbWlzc2luZ0xhbmdzLm1hcCgoW25hbWVdKSA9PiBuYW1lKS5pbmNsdWRlcyhsKSkpLmZpbHRlcigobGFuZykgPT4gIW1pc3NpbmdMYW5ncy5pbmNsdWRlcyhsYW5nKSk7XG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihgTWlzc2luZyBsYW5ndWFnZXMgJHttaXNzaW5nTGFuZ3MubWFwKChbbmFtZV0pID0+IGBcXGAke25hbWV9XFxgYCkuam9pbihcIiwgXCIpfSwgcmVxdWlyZWQgYnkgJHtkZXBlbmRlbnRzLm1hcCgoW25hbWVdKSA9PiBgXFxgJHtuYW1lfVxcYGApLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbXywgbGFuZ10gb2YgbGFuZ3NHcmFwaEFycmF5KVxuICAgICAgdGhpcy5fcmVzb2x2ZXIuYWRkTGFuZ3VhZ2UobGFuZyk7XG4gICAgZm9yIChjb25zdCBbXywgbGFuZ10gb2YgbGFuZ3NHcmFwaEFycmF5KVxuICAgICAgdGhpcy5sb2FkTGFuZ3VhZ2UobGFuZyk7XG4gIH1cbiAgZ2V0TG9hZGVkTGFuZ3VhZ2VzKCkge1xuICAgIGlmICghdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUpIHtcbiAgICAgIHRoaXMuX2xvYWRlZExhbmd1YWdlc0NhY2hlID0gW1xuICAgICAgICAuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4udGhpcy5fcmVzb2x2ZWRHcmFtbWFycy5rZXlzKCksIC4uLk9iamVjdC5rZXlzKHRoaXMuX2FsaWFzKV0pXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGU7XG4gIH1cbiAgcmVzb2x2ZUVtYmVkZGVkTGFuZ3VhZ2VzKGxhbmcpIHtcbiAgICB0aGlzLl9sYW5nTWFwLnNldChsYW5nLm5hbWUsIGxhbmcpO1xuICAgIHRoaXMuX2xhbmdHcmFwaC5zZXQobGFuZy5uYW1lLCBsYW5nKTtcbiAgICBpZiAobGFuZy5lbWJlZGRlZExhbmdzKSB7XG4gICAgICBmb3IgKGNvbnN0IGVtYmVkZGVkTGFuZyBvZiBsYW5nLmVtYmVkZGVkTGFuZ3MpXG4gICAgICAgIHRoaXMuX2xhbmdHcmFwaC5zZXQoZW1iZWRkZWRMYW5nLCB0aGlzLl9sYW5nTWFwLmdldChlbWJlZGRlZExhbmcpKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVzb2x2ZXIge1xuICBfbGFuZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfc2NvcGVUb0xhbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfaW5qZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9vbmlnTGliO1xuICBjb25zdHJ1Y3RvcihlbmdpbmUsIGxhbmdzKSB7XG4gICAgdGhpcy5fb25pZ0xpYiA9IHtcbiAgICAgIGNyZWF0ZU9uaWdTY2FubmVyOiAocGF0dGVybnMpID0+IGVuZ2luZS5jcmVhdGVTY2FubmVyKHBhdHRlcm5zKSxcbiAgICAgIGNyZWF0ZU9uaWdTdHJpbmc6IChzKSA9PiBlbmdpbmUuY3JlYXRlU3RyaW5nKHMpXG4gICAgfTtcbiAgICBsYW5ncy5mb3JFYWNoKChpKSA9PiB0aGlzLmFkZExhbmd1YWdlKGkpKTtcbiAgfVxuICBnZXQgb25pZ0xpYigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25pZ0xpYjtcbiAgfVxuICBnZXRMYW5nUmVnaXN0cmF0aW9uKGxhbmdJZE9yQWxpYXMpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFuZ3MuZ2V0KGxhbmdJZE9yQWxpYXMpO1xuICB9XG4gIGxvYWRHcmFtbWFyKHNjb3BlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9zY29wZVRvTGFuZy5nZXQoc2NvcGVOYW1lKTtcbiAgfVxuICBhZGRMYW5ndWFnZShsKSB7XG4gICAgdGhpcy5fbGFuZ3Muc2V0KGwubmFtZSwgbCk7XG4gICAgaWYgKGwuYWxpYXNlcykge1xuICAgICAgbC5hbGlhc2VzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgdGhpcy5fbGFuZ3Muc2V0KGEsIGwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3Njb3BlVG9MYW5nLnNldChsLnNjb3BlTmFtZSwgbCk7XG4gICAgaWYgKGwuaW5qZWN0VG8pIHtcbiAgICAgIGwuaW5qZWN0VG8uZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX2luamVjdGlvbnMuZ2V0KGkpKVxuICAgICAgICAgIHRoaXMuX2luamVjdGlvbnMuc2V0KGksIFtdKTtcbiAgICAgICAgdGhpcy5faW5qZWN0aW9ucy5nZXQoaSkucHVzaChsLnNjb3BlTmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0SW5qZWN0aW9ucyhzY29wZU5hbWUpIHtcbiAgICBjb25zdCBzY29wZVBhcnRzID0gc2NvcGVOYW1lLnNwbGl0KFwiLlwiKTtcbiAgICBsZXQgaW5qZWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHNjb3BlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1YlNjb3BlTmFtZSA9IHNjb3BlUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi5cIik7XG4gICAgICBpbmplY3Rpb25zID0gWy4uLmluamVjdGlvbnMsIC4uLnRoaXMuX2luamVjdGlvbnMuZ2V0KHN1YlNjb3BlTmFtZSkgfHwgW11dO1xuICAgIH1cbiAgICByZXR1cm4gaW5qZWN0aW9ucztcbiAgfVxufVxuXG5sZXQgaW5zdGFuY2VzQ291bnQgPSAwO1xuZnVuY3Rpb24gY3JlYXRlU2hpa2lJbnRlcm5hbFN5bmMob3B0aW9ucykge1xuICBpbnN0YW5jZXNDb3VudCArPSAxO1xuICBpZiAob3B0aW9ucy53YXJuaW5ncyAhPT0gZmFsc2UgJiYgaW5zdGFuY2VzQ291bnQgPj0gMTAgJiYgaW5zdGFuY2VzQ291bnQgJSAxMCA9PT0gMClcbiAgICBjb25zb2xlLndhcm4oYFtTaGlraV0gJHtpbnN0YW5jZXNDb3VudH0gaW5zdGFuY2VzIGhhdmUgYmVlbiBjcmVhdGVkLiBTaGlraSBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGFzIGEgc2luZ2xldG9uLCBjb25zaWRlciByZWZhY3RvcmluZyB5b3VyIGNvZGUgdG8gY2FjaGUgeW91ciBoaWdobGlnaHRlciBpbnN0YW5jZTsgT3IgY2FsbCBcXGBoaWdobGlnaHRlci5kaXNwb3NlKClcXGAgdG8gcmVsZWFzZSB1bnVzZWQgaW5zdGFuY2VzLmApO1xuICBsZXQgaXNEaXNwb3NlZCA9IGZhbHNlO1xuICBpZiAoIW9wdGlvbnMuZW5naW5lKVxuICAgIHRocm93IG5ldyBTaGlraUVycm9yKFwiYGVuZ2luZWAgb3B0aW9uIGlzIHJlcXVpcmVkIGZvciBzeW5jaHJvbm91cyBtb2RlXCIpO1xuICBjb25zdCBsYW5ncyA9IChvcHRpb25zLmxhbmdzIHx8IFtdKS5mbGF0KDEpO1xuICBjb25zdCB0aGVtZXMgPSAob3B0aW9ucy50aGVtZXMgfHwgW10pLmZsYXQoMSkubWFwKG5vcm1hbGl6ZVRoZW1lKTtcbiAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIob3B0aW9ucy5lbmdpbmUsIGxhbmdzKTtcbiAgY29uc3QgX3JlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KHJlc29sdmVyLCB0aGVtZXMsIGxhbmdzLCBvcHRpb25zLmxhbmdBbGlhcyk7XG4gIGxldCBfbGFzdFRoZW1lO1xuICBmdW5jdGlvbiBnZXRMYW5ndWFnZShuYW1lKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBjb25zdCBfbGFuZyA9IF9yZWdpc3RyeS5nZXRHcmFtbWFyKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiID8gbmFtZSA6IG5hbWUubmFtZSk7XG4gICAgaWYgKCFfbGFuZylcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBMYW5ndWFnZSBcXGAke25hbWV9XFxgIG5vdCBmb3VuZCwgeW91IG1heSBuZWVkIHRvIGxvYWQgaXQgZmlyc3RgKTtcbiAgICByZXR1cm4gX2xhbmc7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VGhlbWUobmFtZSkge1xuICAgIGlmIChuYW1lID09PSBcIm5vbmVcIilcbiAgICAgIHJldHVybiB7IGJnOiBcIlwiLCBmZzogXCJcIiwgbmFtZTogXCJub25lXCIsIHNldHRpbmdzOiBbXSwgdHlwZTogXCJkYXJrXCIgfTtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIGNvbnN0IF90aGVtZSA9IF9yZWdpc3RyeS5nZXRUaGVtZShuYW1lKTtcbiAgICBpZiAoIV90aGVtZSlcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBUaGVtZSBcXGAke25hbWV9XFxgIG5vdCBmb3VuZCwgeW91IG1heSBuZWVkIHRvIGxvYWQgaXQgZmlyc3RgKTtcbiAgICByZXR1cm4gX3RoZW1lO1xuICB9XG4gIGZ1bmN0aW9uIHNldFRoZW1lKG5hbWUpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIGNvbnN0IHRoZW1lID0gZ2V0VGhlbWUobmFtZSk7XG4gICAgaWYgKF9sYXN0VGhlbWUgIT09IG5hbWUpIHtcbiAgICAgIF9yZWdpc3RyeS5zZXRUaGVtZSh0aGVtZSk7XG4gICAgICBfbGFzdFRoZW1lID0gbmFtZTtcbiAgICB9XG4gICAgY29uc3QgY29sb3JNYXAgPSBfcmVnaXN0cnkuZ2V0Q29sb3JNYXAoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhlbWUsXG4gICAgICBjb2xvck1hcFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TG9hZGVkVGhlbWVzKCkge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgcmV0dXJuIF9yZWdpc3RyeS5nZXRMb2FkZWRUaGVtZXMoKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRMb2FkZWRMYW5ndWFnZXMoKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICByZXR1cm4gX3JlZ2lzdHJ5LmdldExvYWRlZExhbmd1YWdlcygpO1xuICB9XG4gIGZ1bmN0aW9uIGxvYWRMYW5ndWFnZVN5bmMoLi4ubGFuZ3MyKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBfcmVnaXN0cnkubG9hZExhbmd1YWdlcyhsYW5nczIuZmxhdCgxKSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZExhbmd1YWdlKC4uLmxhbmdzMikge1xuICAgIHJldHVybiBsb2FkTGFuZ3VhZ2VTeW5jKGF3YWl0IHJlc29sdmVMYW5ncyhsYW5nczIpKTtcbiAgfVxuICBmdW5jdGlvbiBsb2FkVGhlbWVTeW5jKC4uLnRoZW1lczIpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIGZvciAoY29uc3QgdGhlbWUgb2YgdGhlbWVzMi5mbGF0KDEpKSB7XG4gICAgICBfcmVnaXN0cnkubG9hZFRoZW1lKHRoZW1lKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFRoZW1lKC4uLnRoZW1lczIpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIHJldHVybiBsb2FkVGhlbWVTeW5jKGF3YWl0IHJlc29sdmVUaGVtZXModGhlbWVzMikpO1xuICB9XG4gIGZ1bmN0aW9uIGVuc3VyZU5vdERpc3Bvc2VkKCkge1xuICAgIGlmIChpc0Rpc3Bvc2VkKVxuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoXCJTaGlraSBpbnN0YW5jZSBoYXMgYmVlbiBkaXNwb3NlZFwiKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmIChpc0Rpc3Bvc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIGlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIF9yZWdpc3RyeS5kaXNwb3NlKCk7XG4gICAgaW5zdGFuY2VzQ291bnQgLT0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNldFRoZW1lLFxuICAgIGdldFRoZW1lLFxuICAgIGdldExhbmd1YWdlLFxuICAgIGdldExvYWRlZFRoZW1lcyxcbiAgICBnZXRMb2FkZWRMYW5ndWFnZXMsXG4gICAgbG9hZExhbmd1YWdlLFxuICAgIGxvYWRMYW5ndWFnZVN5bmMsXG4gICAgbG9hZFRoZW1lLFxuICAgIGxvYWRUaGVtZVN5bmMsXG4gICAgZGlzcG9zZSxcbiAgICBbU3ltYm9sLmRpc3Bvc2VdOiBkaXNwb3NlXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNoaWtpSW50ZXJuYWwob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChvcHRpb25zLmxvYWRXYXNtKSB7XG4gICAgd2FybkRlcHJlY2F0ZWQoXCJgbG9hZFdhc21gIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgYGVuZ2luZTogY3JlYXRlT25pZ3VydW1hRW5naW5lKGxvYWRXYXNtKWAgaW5zdGVhZC5cIik7XG4gIH1cbiAgY29uc3QgW1xuICAgIHRoZW1lcyxcbiAgICBsYW5ncyxcbiAgICBlbmdpbmVcbiAgXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICByZXNvbHZlVGhlbWVzKG9wdGlvbnMudGhlbWVzIHx8IFtdKSxcbiAgICByZXNvbHZlTGFuZ3Mob3B0aW9ucy5sYW5ncyB8fCBbXSksXG4gICAgb3B0aW9ucy5lbmdpbmUgfHwgY3JlYXRlT25pZ3VydW1hRW5naW5lJDEob3B0aW9ucy5sb2FkV2FzbSB8fCBnZXREZWZhdWx0V2FzbUxvYWRlcigpKVxuICBdKTtcbiAgcmV0dXJuIGNyZWF0ZVNoaWtpSW50ZXJuYWxTeW5jKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGxvYWRXYXNtOiB1bmRlZmluZWQsXG4gICAgdGhlbWVzLFxuICAgIGxhbmdzLFxuICAgIGVuZ2luZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNoaWtpSW50ZXJuYWwob3B0aW9ucyA9IHt9KSB7XG4gIHdhcm5EZXByZWNhdGVkKFwiYGdldFNoaWtpSW50ZXJuYWxgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgY3JlYXRlU2hpa2lJbnRlcm5hbGAgaW5zdGVhZC5cIik7XG4gIHJldHVybiBjcmVhdGVTaGlraUludGVybmFsKG9wdGlvbnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVIaWdobGlnaHRlckNvcmUob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGludGVybmFsID0gYXdhaXQgY3JlYXRlU2hpa2lJbnRlcm5hbChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBnZXRMYXN0R3JhbW1hclN0YXRlOiAoLi4uYXJncykgPT4gZ2V0TGFzdEdyYW1tYXJTdGF0ZShpbnRlcm5hbCwgLi4uYXJncyksXG4gICAgY29kZVRvVG9rZW5zQmFzZTogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnNCYXNlKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvVG9rZW5zV2l0aFRoZW1lczogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKGludGVybmFsLCBjb2RlLCBvcHRpb25zMiksXG4gICAgY29kZVRvVG9rZW5zOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb1Rva2VucyhpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb0hhc3Q6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvSGFzdChpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb0h0bWw6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvSHRtbChpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIC4uLmludGVybmFsLFxuICAgIGdldEludGVybmFsQ29udGV4dDogKCkgPT4gaW50ZXJuYWxcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodGVyQ29yZVN5bmMob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGludGVybmFsID0gY3JlYXRlU2hpa2lJbnRlcm5hbFN5bmMob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgZ2V0TGFzdEdyYW1tYXJTdGF0ZTogKC4uLmFyZ3MpID0+IGdldExhc3RHcmFtbWFyU3RhdGUoaW50ZXJuYWwsIC4uLmFyZ3MpLFxuICAgIGNvZGVUb1Rva2Vuc0Jhc2U6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXM6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2VuczogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IYXN0OiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0hhc3QoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IdG1sOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0h0bWwoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICAuLi5pbnRlcm5hbCxcbiAgICBnZXRJbnRlcm5hbENvbnRleHQ6ICgpID0+IGludGVybmFsXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlKGNyZWF0ZUhpZ2hsaWdodGVyKSB7XG4gIGxldCBfc2hpa2k7XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZTIob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFfc2hpa2kpIHtcbiAgICAgIF9zaGlraSA9IGNyZWF0ZUhpZ2hsaWdodGVyKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdGhlbWVzOiBvcHRpb25zLnRoZW1lcyB8fCBbXSxcbiAgICAgICAgbGFuZ3M6IG9wdGlvbnMubGFuZ3MgfHwgW11cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9zaGlraTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcyA9IGF3YWl0IF9zaGlraTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgcy5sb2FkVGhlbWUoLi4ub3B0aW9ucy50aGVtZXMgfHwgW10pLFxuICAgICAgICBzLmxvYWRMYW5ndWFnZSguLi5vcHRpb25zLmxhbmdzIHx8IFtdKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZTI7XG59XG5jb25zdCBnZXRTaW5nbGV0b25IaWdobGlnaHRlckNvcmUgPSAvKiBAX19QVVJFX18gKi8gbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZShjcmVhdGVIaWdobGlnaHRlckNvcmUpO1xuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZXJDb3JlKG9wdGlvbnMgPSB7fSkge1xuICB3YXJuRGVwcmVjYXRlZChcImBnZXRIaWdobGlnaHRlckNvcmVgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlYCBvciBgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlYCBpbnN0ZWFkLlwiKTtcbiAgcmV0dXJuIGNyZWF0ZUhpZ2hsaWdodGVyQ29yZShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlZEJ1bmRsZWRIaWdobGlnaHRlcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGxldCBidW5kbGVkTGFuZ3VhZ2VzO1xuICBsZXQgYnVuZGxlZFRoZW1lcztcbiAgbGV0IGVuZ2luZTtcbiAgaWYgKGFyZzIpIHtcbiAgICB3YXJuRGVwcmVjYXRlZChcImBjcmVhdGVkQnVuZGxlZEhpZ2hsaWdodGVyYCBzaWduYXR1cmUgd2l0aCBgYnVuZGxlZExhbmd1YWdlc2AgYW5kIGBidW5kbGVkVGhlbWVzYCBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIG9wdGlvbnMgb2JqZWN0IHNpZ25hdHVyZSBpbnN0ZWFkLlwiKTtcbiAgICBidW5kbGVkTGFuZ3VhZ2VzID0gYXJnMTtcbiAgICBidW5kbGVkVGhlbWVzID0gYXJnMjtcbiAgICBlbmdpbmUgPSAoKSA9PiBjcmVhdGVPbmlndXJ1bWFFbmdpbmUoYXJnMyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZzE7XG4gICAgYnVuZGxlZExhbmd1YWdlcyA9IG9wdGlvbnMubGFuZ3M7XG4gICAgYnVuZGxlZFRoZW1lcyA9IG9wdGlvbnMudGhlbWVzO1xuICAgIGVuZ2luZSA9IG9wdGlvbnMuZW5naW5lO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodGVyKG9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiByZXNvbHZlTGFuZyhsYW5nKSB7XG4gICAgICBpZiAodHlwZW9mIGxhbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGlzU3BlY2lhbExhbmcobGFuZykpXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBjb25zdCBidW5kbGUgPSBidW5kbGVkTGFuZ3VhZ2VzW2xhbmddO1xuICAgICAgICBpZiAoIWJ1bmRsZSlcbiAgICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBMYW5ndWFnZSBcXGAke2xhbmd9XFxgIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGJ1bmRsZS4gWW91IG1heSB3YW50IHRvIGxvYWQgaXQgZnJvbSBleHRlcm5hbCBzb3VyY2UuYCk7XG4gICAgICAgIHJldHVybiBidW5kbGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFuZztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVRoZW1lKHRoZW1lKSB7XG4gICAgICBpZiAoaXNTcGVjaWFsVGhlbWUodGhlbWUpKVxuICAgICAgICByZXR1cm4gXCJub25lXCI7XG4gICAgICBpZiAodHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IGJ1bmRsZWRUaGVtZXNbdGhlbWVdO1xuICAgICAgICBpZiAoIWJ1bmRsZSlcbiAgICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBUaGVtZSBcXGAke3RoZW1lfVxcYCBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBidW5kbGUuIFlvdSBtYXkgd2FudCB0byBsb2FkIGl0IGZyb20gZXh0ZXJuYWwgc291cmNlLmApO1xuICAgICAgICByZXR1cm4gYnVuZGxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoZW1lO1xuICAgIH1cbiAgICBjb25zdCBfdGhlbWVzID0gKG9wdGlvbnMudGhlbWVzID8/IFtdKS5tYXAoKGkpID0+IHJlc29sdmVUaGVtZShpKSk7XG4gICAgY29uc3QgbGFuZ3MgPSAob3B0aW9ucy5sYW5ncyA/PyBbXSkubWFwKChpKSA9PiByZXNvbHZlTGFuZyhpKSk7XG4gICAgY29uc3QgY29yZSA9IGF3YWl0IGNyZWF0ZUhpZ2hsaWdodGVyQ29yZSh7XG4gICAgICBlbmdpbmU6IG9wdGlvbnMuZW5naW5lID8/IGVuZ2luZSgpLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRoZW1lczogX3RoZW1lcyxcbiAgICAgIGxhbmdzXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvcmUsXG4gICAgICBsb2FkTGFuZ3VhZ2UoLi4ubGFuZ3MyKSB7XG4gICAgICAgIHJldHVybiBjb3JlLmxvYWRMYW5ndWFnZSguLi5sYW5nczIubWFwKHJlc29sdmVMYW5nKSk7XG4gICAgICB9LFxuICAgICAgbG9hZFRoZW1lKC4uLnRoZW1lcykge1xuICAgICAgICByZXR1cm4gY29yZS5sb2FkVGhlbWUoLi4udGhlbWVzLm1hcChyZXNvbHZlVGhlbWUpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjcmVhdGVIaWdobGlnaHRlcjtcbn1cbmZ1bmN0aW9uIG1ha2VTaW5nbGV0b25IaWdobGlnaHRlcihjcmVhdGVIaWdobGlnaHRlcikge1xuICBsZXQgX3NoaWtpO1xuICBhc3luYyBmdW5jdGlvbiBnZXRTaW5nbGV0b25IaWdobGlnaHRlcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIV9zaGlraSkge1xuICAgICAgX3NoaWtpID0gY3JlYXRlSGlnaGxpZ2h0ZXIoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB0aGVtZXM6IG9wdGlvbnMudGhlbWVzIHx8IFtdLFxuICAgICAgICBsYW5nczogb3B0aW9ucy5sYW5ncyB8fCBbXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3NoaWtpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzID0gYXdhaXQgX3NoaWtpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzLmxvYWRUaGVtZSguLi5vcHRpb25zLnRoZW1lcyB8fCBbXSksXG4gICAgICAgIHMubG9hZExhbmd1YWdlKC4uLm9wdGlvbnMubGFuZ3MgfHwgW10pXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25TaG9ydGhhbmRzKGNyZWF0ZUhpZ2hsaWdodGVyKSB7XG4gIGNvbnN0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyID0gbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyKGNyZWF0ZUhpZ2hsaWdodGVyKTtcbiAgcmV0dXJuIHtcbiAgICBnZXRTaW5nbGV0b25IaWdobGlnaHRlcihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIob3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBjb2RlVG9IdG1sKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIoe1xuICAgICAgICBsYW5nczogW29wdGlvbnMubGFuZ10sXG4gICAgICAgIHRoZW1lczogXCJ0aGVtZVwiIGluIG9wdGlvbnMgPyBbb3B0aW9ucy50aGVtZV0gOiBPYmplY3QudmFsdWVzKG9wdGlvbnMudGhlbWVzKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2hpa2kuY29kZVRvSHRtbChjb2RlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvZGVUb0hhc3QoY29kZSwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXRTaW5nbGV0b25IaWdobGlnaHRlcih7XG4gICAgICAgIGxhbmdzOiBbb3B0aW9ucy5sYW5nXSxcbiAgICAgICAgdGhlbWVzOiBcInRoZW1lXCIgaW4gb3B0aW9ucyA/IFtvcHRpb25zLnRoZW1lXSA6IE9iamVjdC52YWx1ZXMob3B0aW9ucy50aGVtZXMpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzaGlraS5jb2RlVG9IYXN0KGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgY29kZVRvVG9rZW5zKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIoe1xuICAgICAgICBsYW5nczogW29wdGlvbnMubGFuZ10sXG4gICAgICAgIHRoZW1lczogXCJ0aGVtZVwiIGluIG9wdGlvbnMgPyBbb3B0aW9ucy50aGVtZV0gOiBPYmplY3QudmFsdWVzKG9wdGlvbnMudGhlbWVzKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2hpa2kuY29kZVRvVG9rZW5zKGNvZGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgYXN5bmMgY29kZVRvVG9rZW5zQmFzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyKHtcbiAgICAgICAgbGFuZ3M6IFtvcHRpb25zLmxhbmddLFxuICAgICAgICB0aGVtZXM6IFtvcHRpb25zLnRoZW1lXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2hpa2kuY29kZVRvVG9rZW5zQmFzZShjb2RlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMoY29kZSwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXRTaW5nbGV0b25IaWdobGlnaHRlcih7XG4gICAgICAgIGxhbmdzOiBbb3B0aW9ucy5sYW5nXSxcbiAgICAgICAgdGhlbWVzOiBPYmplY3QudmFsdWVzKG9wdGlvbnMudGhlbWVzKS5maWx0ZXIoQm9vbGVhbilcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNoaWtpLmNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBnZXRMYXN0R3JhbW1hclN0YXRlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIoe1xuICAgICAgICBsYW5nczogW29wdGlvbnMubGFuZ10sXG4gICAgICAgIHRoZW1lczogW29wdGlvbnMudGhlbWVdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzaGlraS5nZXRMYXN0R3JhbW1hclN0YXRlKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSmF2YVNjcmlwdFJlZ2V4RW5naW5lKG9wdGlvbnMpIHtcbiAgd2FybkRlcHJlY2F0ZWQoXCJpbXBvcnQgYGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZWAgZnJvbSBgQHNoaWtpanMvZW5naW5lLWphdmFzY3JpcHRgIG9yIGBzaGlraS9lbmdpbmUvamF2YXNjcmlwdGAgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZSQxKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZGVmYXVsdEphdmFTY3JpcHRSZWdleENvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgd2FybkRlcHJlY2F0ZWQoXCJpbXBvcnQgYGRlZmF1bHRKYXZhU2NyaXB0UmVnZXhDb25zdHJ1Y3RvcmAgZnJvbSBgQHNoaWtpanMvZW5naW5lLWphdmFzY3JpcHRgIG9yIGBzaGlraS9lbmdpbmUvamF2YXNjcmlwdGAgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIGRlZmF1bHRKYXZhU2NyaXB0UmVnZXhDb25zdHJ1Y3RvciQxKHBhdHRlcm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDc3NWYXJpYWJsZXNUaGVtZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcImNzcy12YXJpYWJsZXNcIixcbiAgICB2YXJpYWJsZVByZWZpeCA9IFwiLS1zaGlraS1cIixcbiAgICBmb250U3R5bGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB2YXJpYWJsZSA9IChuYW1lMikgPT4ge1xuICAgIGlmIChvcHRpb25zLnZhcmlhYmxlRGVmYXVsdHM/LltuYW1lMl0pXG4gICAgICByZXR1cm4gYHZhcigke3ZhcmlhYmxlUHJlZml4fSR7bmFtZTJ9LCAke29wdGlvbnMudmFyaWFibGVEZWZhdWx0c1tuYW1lMl19KWA7XG4gICAgcmV0dXJuIGB2YXIoJHt2YXJpYWJsZVByZWZpeH0ke25hbWUyfSlgO1xuICB9O1xuICBjb25zdCB0aGVtZSA9IHtcbiAgICBuYW1lLFxuICAgIHR5cGU6IFwiZGFya1wiLFxuICAgIGNvbG9yczoge1xuICAgICAgXCJlZGl0b3IuZm9yZWdyb3VuZFwiOiB2YXJpYWJsZShcImZvcmVncm91bmRcIiksXG4gICAgICBcImVkaXRvci5iYWNrZ3JvdW5kXCI6IHZhcmlhYmxlKFwiYmFja2dyb3VuZFwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJsYWNrXCI6IHZhcmlhYmxlKFwiYW5zaS1ibGFja1wiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaVJlZFwiOiB2YXJpYWJsZShcImFuc2ktcmVkXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpR3JlZW5cIjogdmFyaWFibGUoXCJhbnNpLWdyZWVuXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpWWVsbG93XCI6IHZhcmlhYmxlKFwiYW5zaS15ZWxsb3dcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCbHVlXCI6IHZhcmlhYmxlKFwiYW5zaS1ibHVlXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpTWFnZW50YVwiOiB2YXJpYWJsZShcImFuc2ktbWFnZW50YVwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUN5YW5cIjogdmFyaWFibGUoXCJhbnNpLWN5YW5cIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lXaGl0ZVwiOiB2YXJpYWJsZShcImFuc2ktd2hpdGVcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRCbGFja1wiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LWJsYWNrXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0UmVkXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtcmVkXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0R3JlZW5cIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1ncmVlblwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodFllbGxvd1wiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LXllbGxvd1wiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodEJsdWVcIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1ibHVlXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0TWFnZW50YVwiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LW1hZ2VudGFcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRDeWFuXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtY3lhblwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodFdoaXRlXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtd2hpdGVcIilcbiAgICB9LFxuICAgIHRva2VuQ29sb3JzOiBbXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJrZXl3b3JkLm9wZXJhdG9yLmFjY2Vzc29yXCIsXG4gICAgICAgICAgXCJtZXRhLmdyb3VwLmJyYWNlcy5yb3VuZC5mdW5jdGlvbi5hcmd1bWVudHNcIixcbiAgICAgICAgICBcIm1ldGEudGVtcGxhdGUuZXhwcmVzc2lvblwiLFxuICAgICAgICAgIFwibWFya3VwLmZlbmNlZF9jb2RlIG1ldGEuZW1iZWRkZWQuYmxvY2tcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwiZm9yZWdyb3VuZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJlbXBoYXNpc1wiLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wic3Ryb25nXCIsIFwibWFya3VwLmhlYWRpbmcubWFya2Rvd25cIiwgXCJtYXJrdXAuYm9sZC5tYXJrZG93blwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb250U3R5bGU6IFwiYm9sZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXCJtYXJrdXAuaXRhbGljLm1hcmtkb3duXCJdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJtZXRhLmxpbmsuaW5saW5lLm1hcmtkb3duXCIsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9udFN0eWxlOiBcInVuZGVybGluZVwiLFxuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tbGlua1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wic3RyaW5nXCIsIFwibWFya3VwLmZlbmNlZF9jb2RlXCIsIFwibWFya3VwLmlubGluZVwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wiY29tbWVudFwiLCBcInN0cmluZy5xdW90ZWQuZG9jc3RyaW5nLm11bHRpXCJdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tY29tbWVudFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwiY29uc3RhbnQubnVtZXJpY1wiLFxuICAgICAgICAgIFwiY29uc3RhbnQubGFuZ3VhZ2VcIixcbiAgICAgICAgICBcImNvbnN0YW50Lm90aGVyLnBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgXCJjb25zdGFudC5jaGFyYWN0ZXIuZm9ybWF0LnBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5sYW5ndWFnZS50aGlzXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5vdGhlci5vYmplY3RcIixcbiAgICAgICAgICBcInZhcmlhYmxlLm90aGVyLmNsYXNzXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5vdGhlci5jb25zdGFudFwiLFxuICAgICAgICAgIFwibWV0YS5wcm9wZXJ0eS1uYW1lXCIsXG4gICAgICAgICAgXCJtZXRhLnByb3BlcnR5LXZhbHVlXCIsXG4gICAgICAgICAgXCJzdXBwb3J0XCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWNvbnN0YW50XCIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJrZXl3b3JkXCIsXG4gICAgICAgICAgXCJzdG9yYWdlLm1vZGlmaWVyXCIsXG4gICAgICAgICAgXCJzdG9yYWdlLnR5cGVcIixcbiAgICAgICAgICBcInN0b3JhZ2UuY29udHJvbC5jbG9qdXJlXCIsXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS5mdW5jdGlvbi5jbG9qdXJlXCIsXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS50YWcueWFtbFwiLFxuICAgICAgICAgIFwic3VwcG9ydC5mdW5jdGlvbi5ub2RlXCIsXG4gICAgICAgICAgXCJzdXBwb3J0LnR5cGUucHJvcGVydHktbmFtZS5qc29uXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5zZXBhcmF0b3Iua2V5LXZhbHVlXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnRlbXBsYXRlLWV4cHJlc3Npb25cIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4ta2V5d29yZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJ2YXJpYWJsZS5wYXJhbWV0ZXIuZnVuY3Rpb25cIixcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXBhcmFtZXRlclwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwic3VwcG9ydC5mdW5jdGlvblwiLFxuICAgICAgICAgIFwiZW50aXR5Lm5hbWUudHlwZVwiLFxuICAgICAgICAgIFwiZW50aXR5Lm90aGVyLmluaGVyaXRlZC1jbGFzc1wiLFxuICAgICAgICAgIFwibWV0YS5mdW5jdGlvbi1jYWxsXCIsXG4gICAgICAgICAgXCJtZXRhLmluc3RhbmNlLmNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgXCJlbnRpdHkub3RoZXIuYXR0cmlidXRlLW5hbWVcIixcbiAgICAgICAgICBcImVudGl0eS5uYW1lLmZ1bmN0aW9uXCIsXG4gICAgICAgICAgXCJjb25zdGFudC5rZXl3b3JkLmNsb2p1cmVcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tZnVuY3Rpb25cIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcImVudGl0eS5uYW1lLnRhZ1wiLFxuICAgICAgICAgIFwic3RyaW5nLnF1b3RlZFwiLFxuICAgICAgICAgIFwic3RyaW5nLnJlZ2V4cFwiLFxuICAgICAgICAgIFwic3RyaW5nLmludGVycG9sYXRlZFwiLFxuICAgICAgICAgIFwic3RyaW5nLnRlbXBsYXRlXCIsXG4gICAgICAgICAgXCJzdHJpbmcudW5xdW90ZWQucGxhaW4ub3V0LnlhbWxcIixcbiAgICAgICAgICBcImtleXdvcmQub3RoZXIudGVtcGxhdGVcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tc3RyaW5nLWV4cHJlc3Npb25cIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uYXJndW1lbnRzXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmRpY3RcIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLnNlcGFyYXRvclwiLFxuICAgICAgICAgIFwibWV0YS5mdW5jdGlvbi1jYWxsLmFyZ3VtZW50c1wiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1wdW5jdHVhdGlvblwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBNYXJrZG93biBsaW5rc1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLnVuZGVybGluZS5saW5rXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLm1ldGFkYXRhLm1hcmtkb3duXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWxpbmtcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gW0N1c3RvbV0gTWFya2Rvd24gbGlzdFxuICAgICAgICBzY29wZTogW1wiYmVnaW5uaW5nLnB1bmN0dWF0aW9uLmRlZmluaXRpb24ubGlzdC5tYXJrZG93blwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBNYXJrZG93biBwdW5jdHVhdGlvbiBkZWZpbml0aW9uIGJyYWNrZXRzXG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnN0cmluZy5iZWdpbi5tYXJrZG93blwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5zdHJpbmcuZW5kLm1hcmtkb3duXCIsXG4gICAgICAgICAgXCJzdHJpbmcub3RoZXIubGluay50aXRsZS5tYXJrZG93blwiLFxuICAgICAgICAgIFwic3RyaW5nLm90aGVyLmxpbmsuZGVzY3JpcHRpb24ubWFya2Rvd25cIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4ta2V5d29yZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBEaWZmXG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJtYXJrdXAuaW5zZXJ0ZWRcIixcbiAgICAgICAgICBcIm1ldGEuZGlmZi5oZWFkZXIudG8tZmlsZVwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5pbnNlcnRlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1pbnNlcnRlZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLmRlbGV0ZWRcIixcbiAgICAgICAgICBcIm1ldGEuZGlmZi5oZWFkZXIuZnJvbS1maWxlXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmRlbGV0ZWRcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tZGVsZXRlZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLmNoYW5nZWRcIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uY2hhbmdlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1jaGFuZ2VkXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGlmICghZm9udFN0eWxlKSB7XG4gICAgdGhlbWUudG9rZW5Db2xvcnMgPSB0aGVtZS50b2tlbkNvbG9ycz8ubWFwKCh0b2tlbkNvbG9yKSA9PiB7XG4gICAgICBpZiAodG9rZW5Db2xvci5zZXR0aW5ncz8uZm9udFN0eWxlKVxuICAgICAgICBkZWxldGUgdG9rZW5Db2xvci5zZXR0aW5ncy5mb250U3R5bGU7XG4gICAgICByZXR1cm4gdG9rZW5Db2xvcjtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhlbWU7XG59XG5cbmV4cG9ydCB7IGFkZENsYXNzVG9IYXN0LCBhcHBseUNvbG9yUmVwbGFjZW1lbnRzLCBjb2RlVG9IYXN0LCBjb2RlVG9IdG1sLCBjb2RlVG9Ub2tlbnMsIGNvZGVUb1Rva2Vuc0Jhc2UsIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMsIGNyZWF0ZUNzc1ZhcmlhYmxlc1RoZW1lLCBjcmVhdGVIaWdobGlnaHRlckNvcmUsIGNyZWF0ZUhpZ2hsaWdodGVyQ29yZVN5bmMsIGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZSwgY3JlYXRlT25pZ3VydW1hRW5naW5lLCBjcmVhdGVQb3NpdGlvbkNvbnZlcnRlciwgY3JlYXRlU2hpa2lJbnRlcm5hbCwgY3JlYXRlU2hpa2lJbnRlcm5hbFN5bmMsIGNyZWF0ZVNpbmdsZXRvblNob3J0aGFuZHMsIGNyZWF0ZVdhc21PbmlnRW5naW5lLCBjcmVhdGVkQnVuZGxlZEhpZ2hsaWdodGVyLCBkZWZhdWx0SmF2YVNjcmlwdFJlZ2V4Q29uc3RydWN0b3IsIGdldEhpZ2hsaWdodGVyQ29yZSwgZ2V0U2hpa2lJbnRlcm5hbCwgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlLCBnZXRUb2tlblN0eWxlT2JqZWN0LCBpc05vbmVUaGVtZSwgaXNQbGFpbkxhbmcsIGlzU3BlY2lhbExhbmcsIGlzU3BlY2lhbFRoZW1lLCBsb2FkV2FzbSwgbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyLCBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlLCBub3JtYWxpemVHZXR0ZXIsIG5vcm1hbGl6ZVRoZW1lLCByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHMsIHNwbGl0TGluZXMsIHNwbGl0VG9rZW4sIHNwbGl0VG9rZW5zLCBzdHJpbmdpZnlUb2tlblN0eWxlLCB0b0FycmF5LCB0b2tlbml6ZUFuc2lXaXRoVGhlbWUsIHRva2VuaXplV2l0aFRoZW1lLCB0b2tlbnNUb0hhc3QsIHRyYW5zZm9ybWVyRGVjb3JhdGlvbnMsIHdhcm5EZXByZWNhdGVkIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/shared/core.DVV8c4RZ.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/shared/core.DVV8c4RZ.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   e: () => (/* binding */ enableDeprecationWarnings),\n/* harmony export */   w: () => (/* binding */ warnDeprecated)\n/* harmony export */ });\nlet emitDeprecation = false;\nfunction enableDeprecationWarnings(value = true) {\n  emitDeprecation = value;\n}\nfunction warnDeprecated(message) {\n  if (emitDeprecation)\n    console.trace(`[SHIKI DEPRECATE]: ${message}`);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcytjb3JlQDEuMjcuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvY29yZS9kaXN0L3NoYXJlZC9jb3JlLkRWVjhjNFJaLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEOztBQUUrRCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcytjb3JlQDEuMjcuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvY29yZS9kaXN0L3NoYXJlZC9jb3JlLkRWVjhjNFJaLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZW1pdERlcHJlY2F0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBlbmFibGVEZXByZWNhdGlvbldhcm5pbmdzKHZhbHVlID0gdHJ1ZSkge1xuICBlbWl0RGVwcmVjYXRpb24gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHdhcm5EZXByZWNhdGVkKG1lc3NhZ2UpIHtcbiAgaWYgKGVtaXREZXByZWNhdGlvbilcbiAgICBjb25zb2xlLnRyYWNlKGBbU0hJS0kgREVQUkVDQVRFXTogJHttZXNzYWdlfWApO1xufVxuXG5leHBvcnQgeyBlbmFibGVEZXByZWNhdGlvbldhcm5pbmdzIGFzIGUsIHdhcm5EZXByZWNhdGVkIGFzIHcgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/shared/core.DVV8c4RZ.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-javascript@1.27.0/node_modules/@shikijs/engine-javascript/dist/engine-compile.mjs":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+engine-javascript@1.27.0/node_modules/@shikijs/engine-javascript/dist/engine-compile.mjs ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createJavaScriptRegexEngine: () => (/* binding */ createJavaScriptRegexEngine),\n/* harmony export */   defaultJavaScriptRegexConstructor: () => (/* binding */ defaultJavaScriptRegexConstructor)\n/* harmony export */ });\n/* harmony import */ var oniguruma_to_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! oniguruma-to-es */ \"(app-pages-browser)/./node_modules/.pnpm/oniguruma-to-es@1.0.0/node_modules/oniguruma-to-es/dist/index.mjs\");\n/* harmony import */ var _shared_engine_javascript_hzpS1_41_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/engine-javascript.hzpS1_41.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-javascript@1.27.0/node_modules/@shikijs/engine-javascript/dist/shared/engine-javascript.hzpS1_41.mjs\");\n\n\n\nfunction defaultJavaScriptRegexConstructor(pattern, options) {\n  return (0,oniguruma_to_es__WEBPACK_IMPORTED_MODULE_0__.toRegExp)(\n    pattern,\n    {\n      global: true,\n      hasIndices: true,\n      rules: {\n        // Needed since TextMate grammars merge backrefs across patterns\n        allowOrphanBackrefs: true,\n        // Improves search performance for generated regexes\n        asciiWordBoundaries: true,\n        // Follow `vscode-oniguruma` which enables this Oniguruma option by default\n        captureGroup: true,\n        // Removing `\\G` anchors in cases when they're not supported for emulation allows\n        // supporting more grammars, but also allows some mismatches\n        ignoreUnsupportedGAnchors: true,\n        // Oniguruma uses depth limit `20`; lowered here to keep regexes shorter and maybe\n        // sometimes faster, but can be increased if issues reported due to low limit\n        recursionLimit: 5\n      },\n      ...options\n    }\n  );\n}\nfunction createJavaScriptRegexEngine(options = {}) {\n  const _options = Object.assign(\n    {\n      target: \"auto\",\n      cache: /* @__PURE__ */ new Map()\n    },\n    options\n  );\n  _options.regexConstructor ||= (pattern) => defaultJavaScriptRegexConstructor(pattern, { target: _options.target });\n  return {\n    createScanner(patterns) {\n      return new _shared_engine_javascript_hzpS1_41_mjs__WEBPACK_IMPORTED_MODULE_1__.J(patterns, _options);\n    },\n    createString(s) {\n      return {\n        content: s\n      };\n    }\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcytlbmdpbmUtamF2YXNjcmlwdEAxLjI3LjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2VuZ2luZS1qYXZhc2NyaXB0L2Rpc3QvZW5naW5lLWNvbXBpbGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkM7QUFDc0M7O0FBRWpGO0FBQ0EsU0FBUyx5REFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBGQUEwRix5QkFBeUI7QUFDbkg7QUFDQTtBQUNBLGlCQUFpQixxRUFBaUI7QUFDbEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwRSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcytlbmdpbmUtamF2YXNjcmlwdEAxLjI3LjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2VuZ2luZS1qYXZhc2NyaXB0L2Rpc3QvZW5naW5lLWNvbXBpbGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvUmVnRXhwIH0gZnJvbSAnb25pZ3VydW1hLXRvLWVzJztcbmltcG9ydCB7IEogYXMgSmF2YVNjcmlwdFNjYW5uZXIgfSBmcm9tICcuL3NoYXJlZC9lbmdpbmUtamF2YXNjcmlwdC5oenBTMV80MS5tanMnO1xuXG5mdW5jdGlvbiBkZWZhdWx0SmF2YVNjcmlwdFJlZ2V4Q29uc3RydWN0b3IocGF0dGVybiwgb3B0aW9ucykge1xuICByZXR1cm4gdG9SZWdFeHAoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBnbG9iYWw6IHRydWUsXG4gICAgICBoYXNJbmRpY2VzOiB0cnVlLFxuICAgICAgcnVsZXM6IHtcbiAgICAgICAgLy8gTmVlZGVkIHNpbmNlIFRleHRNYXRlIGdyYW1tYXJzIG1lcmdlIGJhY2tyZWZzIGFjcm9zcyBwYXR0ZXJuc1xuICAgICAgICBhbGxvd09ycGhhbkJhY2tyZWZzOiB0cnVlLFxuICAgICAgICAvLyBJbXByb3ZlcyBzZWFyY2ggcGVyZm9ybWFuY2UgZm9yIGdlbmVyYXRlZCByZWdleGVzXG4gICAgICAgIGFzY2lpV29yZEJvdW5kYXJpZXM6IHRydWUsXG4gICAgICAgIC8vIEZvbGxvdyBgdnNjb2RlLW9uaWd1cnVtYWAgd2hpY2ggZW5hYmxlcyB0aGlzIE9uaWd1cnVtYSBvcHRpb24gYnkgZGVmYXVsdFxuICAgICAgICBjYXB0dXJlR3JvdXA6IHRydWUsXG4gICAgICAgIC8vIFJlbW92aW5nIGBcXEdgIGFuY2hvcnMgaW4gY2FzZXMgd2hlbiB0aGV5J3JlIG5vdCBzdXBwb3J0ZWQgZm9yIGVtdWxhdGlvbiBhbGxvd3NcbiAgICAgICAgLy8gc3VwcG9ydGluZyBtb3JlIGdyYW1tYXJzLCBidXQgYWxzbyBhbGxvd3Mgc29tZSBtaXNtYXRjaGVzXG4gICAgICAgIGlnbm9yZVVuc3VwcG9ydGVkR0FuY2hvcnM6IHRydWUsXG4gICAgICAgIC8vIE9uaWd1cnVtYSB1c2VzIGRlcHRoIGxpbWl0IGAyMGA7IGxvd2VyZWQgaGVyZSB0byBrZWVwIHJlZ2V4ZXMgc2hvcnRlciBhbmQgbWF5YmVcbiAgICAgICAgLy8gc29tZXRpbWVzIGZhc3RlciwgYnV0IGNhbiBiZSBpbmNyZWFzZWQgaWYgaXNzdWVzIHJlcG9ydGVkIGR1ZSB0byBsb3cgbGltaXRcbiAgICAgICAgcmVjdXJzaW9uTGltaXQ6IDVcbiAgICAgIH0sXG4gICAgICAuLi5vcHRpb25zXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlSmF2YVNjcmlwdFJlZ2V4RW5naW5lKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAge1xuICAgICAgdGFyZ2V0OiBcImF1dG9cIixcbiAgICAgIGNhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIF9vcHRpb25zLnJlZ2V4Q29uc3RydWN0b3IgfHw9IChwYXR0ZXJuKSA9PiBkZWZhdWx0SmF2YVNjcmlwdFJlZ2V4Q29uc3RydWN0b3IocGF0dGVybiwgeyB0YXJnZXQ6IF9vcHRpb25zLnRhcmdldCB9KTtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVTY2FubmVyKHBhdHRlcm5zKSB7XG4gICAgICByZXR1cm4gbmV3IEphdmFTY3JpcHRTY2FubmVyKHBhdHRlcm5zLCBfb3B0aW9ucyk7XG4gICAgfSxcbiAgICBjcmVhdGVTdHJpbmcocykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZSwgZGVmYXVsdEphdmFTY3JpcHRSZWdleENvbnN0cnVjdG9yIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-javascript@1.27.0/node_modules/@shikijs/engine-javascript/dist/engine-compile.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-javascript@1.27.0/node_modules/@shikijs/engine-javascript/dist/shared/engine-javascript.hzpS1_41.mjs":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+engine-javascript@1.27.0/node_modules/@shikijs/engine-javascript/dist/shared/engine-javascript.hzpS1_41.mjs ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ JavaScriptScanner)\n/* harmony export */ });\nconst MAX = 4294967295;\nclass JavaScriptScanner {\n  constructor(patterns, options = {}) {\n    this.patterns = patterns;\n    this.options = options;\n    const {\n      forgiving = false,\n      cache,\n      regexConstructor\n    } = options;\n    if (!regexConstructor) {\n      throw new Error(\"Option `regexConstructor` is not provided\");\n    }\n    this.regexps = patterns.map((p) => {\n      if (typeof p !== \"string\") {\n        return p;\n      }\n      const cached = cache?.get(p);\n      if (cached) {\n        if (cached instanceof RegExp) {\n          return cached;\n        }\n        if (forgiving)\n          return null;\n        throw cached;\n      }\n      try {\n        const regex = regexConstructor(p);\n        cache?.set(p, regex);\n        return regex;\n      } catch (e) {\n        cache?.set(p, e);\n        if (forgiving)\n          return null;\n        throw e;\n      }\n    });\n  }\n  regexps;\n  findNextMatchSync(string, startPosition, _options) {\n    const str = typeof string === \"string\" ? string : string.content;\n    const pending = [];\n    function toResult(index, match, offset = 0) {\n      return {\n        index,\n        captureIndices: match.indices.map((indice) => {\n          if (indice == null) {\n            return {\n              start: MAX,\n              end: MAX,\n              length: 0\n            };\n          }\n          return {\n            start: indice[0] + offset,\n            end: indice[1] + offset,\n            length: indice[1] - indice[0]\n          };\n        })\n      };\n    }\n    for (let i = 0; i < this.regexps.length; i++) {\n      const regexp = this.regexps[i];\n      if (!regexp)\n        continue;\n      try {\n        regexp.lastIndex = startPosition;\n        const match = regexp.exec(str);\n        if (!match)\n          continue;\n        if (match.index === startPosition) {\n          return toResult(i, match, 0);\n        }\n        pending.push([i, match, 0]);\n      } catch (e) {\n        if (this.options.forgiving)\n          continue;\n        throw e;\n      }\n    }\n    if (pending.length) {\n      const minIndex = Math.min(...pending.map((m) => m[1].index));\n      for (const [i, match, offset] of pending) {\n        if (match.index === minIndex) {\n          return toResult(i, match, offset);\n        }\n      }\n    }\n    return null;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcytlbmdpbmUtamF2YXNjcmlwdEAxLjI3LjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL2VuZ2luZS1qYXZhc2NyaXB0L2Rpc3Qvc2hhcmVkL2VuZ2luZS1qYXZhc2NyaXB0Lmh6cFMxXzQxLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK2VuZ2luZS1qYXZhc2NyaXB0QDEuMjcuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvZW5naW5lLWphdmFzY3JpcHQvZGlzdC9zaGFyZWQvZW5naW5lLWphdmFzY3JpcHQuaHpwUzFfNDEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1BWCA9IDQyOTQ5NjcyOTU7XG5jbGFzcyBKYXZhU2NyaXB0U2Nhbm5lciB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm5zLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBmb3JnaXZpbmcgPSBmYWxzZSxcbiAgICAgIGNhY2hlLFxuICAgICAgcmVnZXhDb25zdHJ1Y3RvclxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghcmVnZXhDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uIGByZWdleENvbnN0cnVjdG9yYCBpcyBub3QgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIHRoaXMucmVnZXhwcyA9IHBhdHRlcm5zLm1hcCgocCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGU/LmdldChwKTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgaWYgKGNhY2hlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcmdpdmluZylcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhyb3cgY2FjaGVkO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVnZXggPSByZWdleENvbnN0cnVjdG9yKHApO1xuICAgICAgICBjYWNoZT8uc2V0KHAsIHJlZ2V4KTtcbiAgICAgICAgcmV0dXJuIHJlZ2V4O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZT8uc2V0KHAsIGUpO1xuICAgICAgICBpZiAoZm9yZ2l2aW5nKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlZ2V4cHM7XG4gIGZpbmROZXh0TWF0Y2hTeW5jKHN0cmluZywgc3RhcnRQb3NpdGlvbiwgX29wdGlvbnMpIHtcbiAgICBjb25zdCBzdHIgPSB0eXBlb2Ygc3RyaW5nID09PSBcInN0cmluZ1wiID8gc3RyaW5nIDogc3RyaW5nLmNvbnRlbnQ7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZ1bmN0aW9uIHRvUmVzdWx0KGluZGV4LCBtYXRjaCwgb2Zmc2V0ID0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGNhcHR1cmVJbmRpY2VzOiBtYXRjaC5pbmRpY2VzLm1hcCgoaW5kaWNlKSA9PiB7XG4gICAgICAgICAgaWYgKGluZGljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdGFydDogTUFYLFxuICAgICAgICAgICAgICBlbmQ6IE1BWCxcbiAgICAgICAgICAgICAgbGVuZ3RoOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IGluZGljZVswXSArIG9mZnNldCxcbiAgICAgICAgICAgIGVuZDogaW5kaWNlWzFdICsgb2Zmc2V0LFxuICAgICAgICAgICAgbGVuZ3RoOiBpbmRpY2VbMV0gLSBpbmRpY2VbMF1cbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlZ2V4cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZ2V4cCA9IHRoaXMucmVnZXhwc1tpXTtcbiAgICAgIGlmICghcmVnZXhwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHJlZ2V4cC5leGVjKHN0cik7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gc3RhcnRQb3NpdGlvbikge1xuICAgICAgICAgIHJldHVybiB0b1Jlc3VsdChpLCBtYXRjaCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZy5wdXNoKFtpLCBtYXRjaCwgMF0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmdpdmluZylcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtaW5JbmRleCA9IE1hdGgubWluKC4uLnBlbmRpbmcubWFwKChtKSA9PiBtWzFdLmluZGV4KSk7XG4gICAgICBmb3IgKGNvbnN0IFtpLCBtYXRjaCwgb2Zmc2V0XSBvZiBwZW5kaW5nKSB7XG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gbWluSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gdG9SZXN1bHQoaSwgbWF0Y2gsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgSmF2YVNjcmlwdFNjYW5uZXIgYXMgSiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-javascript@1.27.0/node_modules/@shikijs/engine-javascript/dist/shared/engine-javascript.hzpS1_41.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-oniguruma@1.27.0/node_modules/@shikijs/engine-oniguruma/dist/index.mjs":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+engine-oniguruma@1.27.0/node_modules/@shikijs/engine-oniguruma/dist/index.mjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOnigurumaEngine: () => (/* binding */ createOnigurumaEngine),\n/* harmony export */   createWasmOnigEngine: () => (/* binding */ createWasmOnigEngine),\n/* harmony export */   getDefaultWasmLoader: () => (/* binding */ getDefaultWasmLoader),\n/* harmony export */   loadWasm: () => (/* binding */ loadWasm),\n/* harmony export */   setDefaultWasmLoader: () => (/* binding */ setDefaultWasmLoader)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\nclass ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nfunction getHeapMax() {\n  return 2147483648;\n}\nfunction _emscripten_get_now() {\n  return typeof performance !== \"undefined\" ? performance.now() : Date.now();\n}\nconst alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\nasync function main(init) {\n  let wasmMemory;\n  let buffer;\n  const binding = {};\n  function updateGlobalBufferAndViews(buf) {\n    buffer = buf;\n    binding.HEAPU8 = new Uint8Array(buf);\n    binding.HEAPU32 = new Uint32Array(buf);\n  }\n  function _emscripten_memcpy_big(dest, src, num) {\n    binding.HEAPU8.copyWithin(dest, src, src + num);\n  }\n  function emscripten_realloc_buffer(size) {\n    try {\n      wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n      updateGlobalBufferAndViews(wasmMemory.buffer);\n      return 1;\n    } catch {\n    }\n  }\n  function _emscripten_resize_heap(requestedSize) {\n    const oldSize = binding.HEAPU8.length;\n    requestedSize = requestedSize >>> 0;\n    const maxHeapSize = getHeapMax();\n    if (requestedSize > maxHeapSize)\n      return false;\n    for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {\n      let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n      const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n      const replacement = emscripten_realloc_buffer(newSize);\n      if (replacement)\n        return true;\n    }\n    return false;\n  }\n  const UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead = 1024) {\n    const endIdx = idx + maxBytesToRead;\n    let endPtr = idx;\n    while (heapOrArray[endPtr] && !(endPtr >= endIdx))\n      ++endPtr;\n    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n    }\n    let str = \"\";\n    while (idx < endPtr) {\n      let u0 = heapOrArray[idx++];\n      if (!(u0 & 128)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n      const u1 = heapOrArray[idx++] & 63;\n      if ((u0 & 224) === 192) {\n        str += String.fromCharCode((u0 & 31) << 6 | u1);\n        continue;\n      }\n      const u2 = heapOrArray[idx++] & 63;\n      if ((u0 & 240) === 224) {\n        u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n      } else {\n        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n      }\n      if (u0 < 65536) {\n        str += String.fromCharCode(u0);\n      } else {\n        const ch = u0 - 65536;\n        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n      }\n    }\n    return str;\n  }\n  function UTF8ToString(ptr, maxBytesToRead) {\n    return ptr ? UTF8ArrayToString(binding.HEAPU8, ptr, maxBytesToRead) : \"\";\n  }\n  const asmLibraryArg = {\n    emscripten_get_now: _emscripten_get_now,\n    emscripten_memcpy_big: _emscripten_memcpy_big,\n    emscripten_resize_heap: _emscripten_resize_heap,\n    fd_write: () => 0\n  };\n  async function createWasm() {\n    const info = {\n      env: asmLibraryArg,\n      wasi_snapshot_preview1: asmLibraryArg\n    };\n    const exports = await init(info);\n    wasmMemory = exports.memory;\n    updateGlobalBufferAndViews(wasmMemory.buffer);\n    Object.assign(binding, exports);\n    binding.UTF8ToString = UTF8ToString;\n  }\n  await createWasm();\n  return binding;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nlet onigBinding = null;\nfunction throwLastOnigError(onigBinding2) {\n  throw new ShikiError(onigBinding2.UTF8ToString(onigBinding2.getLastOnigError()));\n}\nclass UtfString {\n  constructor(str) {\n    __publicField(this, \"utf16Length\");\n    __publicField(this, \"utf8Length\");\n    __publicField(this, \"utf16Value\");\n    __publicField(this, \"utf8Value\");\n    __publicField(this, \"utf16OffsetToUtf8\");\n    __publicField(this, \"utf8OffsetToUtf16\");\n    const utf16Length = str.length;\n    const utf8Length = UtfString._utf8ByteLength(str);\n    const computeIndicesMapping = utf8Length !== utf16Length;\n    const utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;\n    if (computeIndicesMapping)\n      utf16OffsetToUtf8[utf16Length] = utf8Length;\n    const utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;\n    if (computeIndicesMapping)\n      utf8OffsetToUtf16[utf8Length] = utf16Length;\n    const utf8Value = new Uint8Array(utf8Length);\n    let i8 = 0;\n    for (let i16 = 0; i16 < utf16Length; i16++) {\n      const charCode = str.charCodeAt(i16);\n      let codePoint = charCode;\n      let wasSurrogatePair = false;\n      if (charCode >= 55296 && charCode <= 56319) {\n        if (i16 + 1 < utf16Length) {\n          const nextCharCode = str.charCodeAt(i16 + 1);\n          if (nextCharCode >= 56320 && nextCharCode <= 57343) {\n            codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;\n            wasSurrogatePair = true;\n          }\n        }\n      }\n      if (computeIndicesMapping) {\n        utf16OffsetToUtf8[i16] = i8;\n        if (wasSurrogatePair)\n          utf16OffsetToUtf8[i16 + 1] = i8;\n        if (codePoint <= 127) {\n          utf8OffsetToUtf16[i8 + 0] = i16;\n        } else if (codePoint <= 2047) {\n          utf8OffsetToUtf16[i8 + 0] = i16;\n          utf8OffsetToUtf16[i8 + 1] = i16;\n        } else if (codePoint <= 65535) {\n          utf8OffsetToUtf16[i8 + 0] = i16;\n          utf8OffsetToUtf16[i8 + 1] = i16;\n          utf8OffsetToUtf16[i8 + 2] = i16;\n        } else {\n          utf8OffsetToUtf16[i8 + 0] = i16;\n          utf8OffsetToUtf16[i8 + 1] = i16;\n          utf8OffsetToUtf16[i8 + 2] = i16;\n          utf8OffsetToUtf16[i8 + 3] = i16;\n        }\n      }\n      if (codePoint <= 127) {\n        utf8Value[i8++] = codePoint;\n      } else if (codePoint <= 2047) {\n        utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6;\n        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;\n      } else if (codePoint <= 65535) {\n        utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12;\n        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;\n        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;\n      } else {\n        utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18;\n        utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12;\n        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;\n        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;\n      }\n      if (wasSurrogatePair)\n        i16++;\n    }\n    this.utf16Length = utf16Length;\n    this.utf8Length = utf8Length;\n    this.utf16Value = str;\n    this.utf8Value = utf8Value;\n    this.utf16OffsetToUtf8 = utf16OffsetToUtf8;\n    this.utf8OffsetToUtf16 = utf8OffsetToUtf16;\n  }\n  static _utf8ByteLength(str) {\n    let result = 0;\n    for (let i = 0, len = str.length; i < len; i++) {\n      const charCode = str.charCodeAt(i);\n      let codepoint = charCode;\n      let wasSurrogatePair = false;\n      if (charCode >= 55296 && charCode <= 56319) {\n        if (i + 1 < len) {\n          const nextCharCode = str.charCodeAt(i + 1);\n          if (nextCharCode >= 56320 && nextCharCode <= 57343) {\n            codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;\n            wasSurrogatePair = true;\n          }\n        }\n      }\n      if (codepoint <= 127)\n        result += 1;\n      else if (codepoint <= 2047)\n        result += 2;\n      else if (codepoint <= 65535)\n        result += 3;\n      else\n        result += 4;\n      if (wasSurrogatePair)\n        i++;\n    }\n    return result;\n  }\n  createString(onigBinding2) {\n    const result = onigBinding2.omalloc(this.utf8Length);\n    onigBinding2.HEAPU8.set(this.utf8Value, result);\n    return result;\n  }\n}\nconst _OnigString = class {\n  constructor(str) {\n    __publicField(this, \"id\", ++_OnigString.LAST_ID);\n    __publicField(this, \"_onigBinding\");\n    __publicField(this, \"content\");\n    __publicField(this, \"utf16Length\");\n    __publicField(this, \"utf8Length\");\n    __publicField(this, \"utf16OffsetToUtf8\");\n    __publicField(this, \"utf8OffsetToUtf16\");\n    __publicField(this, \"ptr\");\n    if (!onigBinding)\n      throw new ShikiError(\"Must invoke loadWasm first.\");\n    this._onigBinding = onigBinding;\n    this.content = str;\n    const utfString = new UtfString(str);\n    this.utf16Length = utfString.utf16Length;\n    this.utf8Length = utfString.utf8Length;\n    this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8;\n    this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16;\n    if (this.utf8Length < 1e4 && !_OnigString._sharedPtrInUse) {\n      if (!_OnigString._sharedPtr)\n        _OnigString._sharedPtr = onigBinding.omalloc(1e4);\n      _OnigString._sharedPtrInUse = true;\n      onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString._sharedPtr);\n      this.ptr = _OnigString._sharedPtr;\n    } else {\n      this.ptr = utfString.createString(onigBinding);\n    }\n  }\n  convertUtf8OffsetToUtf16(utf8Offset) {\n    if (this.utf8OffsetToUtf16) {\n      if (utf8Offset < 0)\n        return 0;\n      if (utf8Offset > this.utf8Length)\n        return this.utf16Length;\n      return this.utf8OffsetToUtf16[utf8Offset];\n    }\n    return utf8Offset;\n  }\n  convertUtf16OffsetToUtf8(utf16Offset) {\n    if (this.utf16OffsetToUtf8) {\n      if (utf16Offset < 0)\n        return 0;\n      if (utf16Offset > this.utf16Length)\n        return this.utf8Length;\n      return this.utf16OffsetToUtf8[utf16Offset];\n    }\n    return utf16Offset;\n  }\n  dispose() {\n    if (this.ptr === _OnigString._sharedPtr)\n      _OnigString._sharedPtrInUse = false;\n    else\n      this._onigBinding.ofree(this.ptr);\n  }\n};\nlet OnigString = _OnigString;\n__publicField(OnigString, \"LAST_ID\", 0);\n__publicField(OnigString, \"_sharedPtr\", 0);\n// a pointer to a string of 10000 bytes\n__publicField(OnigString, \"_sharedPtrInUse\", false);\nclass OnigScanner {\n  constructor(patterns) {\n    __publicField(this, \"_onigBinding\");\n    __publicField(this, \"_ptr\");\n    if (!onigBinding)\n      throw new ShikiError(\"Must invoke loadWasm first.\");\n    const strPtrsArr = [];\n    const strLenArr = [];\n    for (let i = 0, len = patterns.length; i < len; i++) {\n      const utfString = new UtfString(patterns[i]);\n      strPtrsArr[i] = utfString.createString(onigBinding);\n      strLenArr[i] = utfString.utf8Length;\n    }\n    const strPtrsPtr = onigBinding.omalloc(4 * patterns.length);\n    onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);\n    const strLenPtr = onigBinding.omalloc(4 * patterns.length);\n    onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);\n    const scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);\n    for (let i = 0, len = patterns.length; i < len; i++)\n      onigBinding.ofree(strPtrsArr[i]);\n    onigBinding.ofree(strLenPtr);\n    onigBinding.ofree(strPtrsPtr);\n    if (scannerPtr === 0)\n      throwLastOnigError(onigBinding);\n    this._onigBinding = onigBinding;\n    this._ptr = scannerPtr;\n  }\n  dispose() {\n    this._onigBinding.freeOnigScanner(this._ptr);\n  }\n  findNextMatchSync(string, startPosition, arg) {\n    let options = 0 /* None */;\n    if (typeof arg === \"number\") {\n      options = arg;\n    }\n    if (typeof string === \"string\") {\n      string = new OnigString(string);\n      const result = this._findNextMatchSync(string, startPosition, false, options);\n      string.dispose();\n      return result;\n    }\n    return this._findNextMatchSync(string, startPosition, false, options);\n  }\n  _findNextMatchSync(string, startPosition, debugCall, options) {\n    const onigBinding2 = this._onigBinding;\n    const resultPtr = onigBinding2.findNextOnigScannerMatch(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);\n    if (resultPtr === 0) {\n      return null;\n    }\n    const HEAPU32 = onigBinding2.HEAPU32;\n    let offset = resultPtr / 4;\n    const index = HEAPU32[offset++];\n    const count = HEAPU32[offset++];\n    const captureIndices = [];\n    for (let i = 0; i < count; i++) {\n      const beg = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);\n      const end = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);\n      captureIndices[i] = {\n        start: beg,\n        end,\n        length: end - beg\n      };\n    }\n    return {\n      index,\n      captureIndices\n    };\n  }\n}\nfunction isInstantiatorOptionsObject(dataOrOptions) {\n  return typeof dataOrOptions.instantiator === \"function\";\n}\nfunction isInstantiatorModule(dataOrOptions) {\n  return typeof dataOrOptions.default === \"function\";\n}\nfunction isDataOptionsObject(dataOrOptions) {\n  return typeof dataOrOptions.data !== \"undefined\";\n}\nfunction isResponse(dataOrOptions) {\n  return typeof Response !== \"undefined\" && dataOrOptions instanceof Response;\n}\nfunction isArrayBuffer(data) {\n  return typeof ArrayBuffer !== \"undefined\" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof Buffer !== \"undefined\" && Buffer.isBuffer?.(data) || typeof SharedArrayBuffer !== \"undefined\" && data instanceof SharedArrayBuffer || typeof Uint32Array !== \"undefined\" && data instanceof Uint32Array;\n}\nlet initPromise;\nfunction loadWasm(options) {\n  if (initPromise)\n    return initPromise;\n  async function _load() {\n    onigBinding = await main(async (info) => {\n      let instance = options;\n      instance = await instance;\n      if (typeof instance === \"function\")\n        instance = await instance(info);\n      if (typeof instance === \"function\")\n        instance = await instance(info);\n      if (isInstantiatorOptionsObject(instance)) {\n        instance = await instance.instantiator(info);\n      } else if (isInstantiatorModule(instance)) {\n        instance = await instance.default(info);\n      } else {\n        if (isDataOptionsObject(instance))\n          instance = instance.data;\n        if (isResponse(instance)) {\n          if (typeof WebAssembly.instantiateStreaming === \"function\")\n            instance = await _makeResponseStreamingLoader(instance)(info);\n          else\n            instance = await _makeResponseNonStreamingLoader(instance)(info);\n        } else if (isArrayBuffer(instance)) {\n          instance = await _makeArrayBufferLoader(instance)(info);\n        } else if (instance instanceof WebAssembly.Module) {\n          instance = await _makeArrayBufferLoader(instance)(info);\n        } else if (\"default\" in instance && instance.default instanceof WebAssembly.Module) {\n          instance = await _makeArrayBufferLoader(instance.default)(info);\n        }\n      }\n      if (\"instance\" in instance)\n        instance = instance.instance;\n      if (\"exports\" in instance)\n        instance = instance.exports;\n      return instance;\n    });\n  }\n  initPromise = _load();\n  return initPromise;\n}\nfunction _makeArrayBufferLoader(data) {\n  return (importObject) => WebAssembly.instantiate(data, importObject);\n}\nfunction _makeResponseStreamingLoader(data) {\n  return (importObject) => WebAssembly.instantiateStreaming(data, importObject);\n}\nfunction _makeResponseNonStreamingLoader(data) {\n  return async (importObject) => {\n    const arrayBuffer = await data.arrayBuffer();\n    return WebAssembly.instantiate(arrayBuffer, importObject);\n  };\n}\n\nlet _defaultWasmLoader;\nfunction setDefaultWasmLoader(_loader) {\n  _defaultWasmLoader = _loader;\n}\nfunction getDefaultWasmLoader() {\n  return _defaultWasmLoader;\n}\nasync function createOnigurumaEngine(options) {\n  if (options)\n    await loadWasm(options);\n  return {\n    createScanner(patterns) {\n      return new OnigScanner(patterns.map((p) => typeof p === \"string\" ? p : p.source));\n    },\n    createString(s) {\n      return new OnigString(s);\n    }\n  };\n}\nasync function createWasmOnigEngine(options) {\n  return createOnigurumaEngine(options);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcytlbmdpbmUtb25pZ3VydW1hQDEuMjcuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvZW5naW5lLW9uaWd1cnVtYS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUgsTUFBTSxvQkFBb0IsTUFBTTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2RyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcytlbmdpbmUtb25pZ3VydW1hQDEuMjcuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvZW5naW5lLW9uaWd1cnVtYS9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTaGlraUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTaGlraUVycm9yXCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SGVhcE1heCgpIHtcbiAgcmV0dXJuIDIxNDc0ODM2NDg7XG59XG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfbm93KCkge1xuICByZXR1cm4gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiID8gcGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xufVxuY29uc3QgYWxpZ25VcCA9ICh4LCBtdWx0aXBsZSkgPT4geCArIChtdWx0aXBsZSAtIHggJSBtdWx0aXBsZSkgJSBtdWx0aXBsZTtcbmFzeW5jIGZ1bmN0aW9uIG1haW4oaW5pdCkge1xuICBsZXQgd2FzbU1lbW9yeTtcbiAgbGV0IGJ1ZmZlcjtcbiAgY29uc3QgYmluZGluZyA9IHt9O1xuICBmdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyhidWYpIHtcbiAgICBidWZmZXIgPSBidWY7XG4gICAgYmluZGluZy5IRUFQVTggPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGJpbmRpbmcuSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShidWYpO1xuICB9XG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCwgc3JjLCBudW0pIHtcbiAgICBiaW5kaW5nLkhFQVBVOC5jb3B5V2l0aGluKGRlc3QsIHNyYywgc3JjICsgbnVtKTtcbiAgfVxuICBmdW5jdGlvbiBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKHNpemUpIHtcbiAgICB0cnkge1xuICAgICAgd2FzbU1lbW9yeS5ncm93KHNpemUgLSBidWZmZXIuYnl0ZUxlbmd0aCArIDY1NTM1ID4+PiAxNik7XG4gICAgICB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyh3YXNtTWVtb3J5LmJ1ZmZlcik7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSkge1xuICAgIGNvbnN0IG9sZFNpemUgPSBiaW5kaW5nLkhFQVBVOC5sZW5ndGg7XG4gICAgcmVxdWVzdGVkU2l6ZSA9IHJlcXVlc3RlZFNpemUgPj4+IDA7XG4gICAgY29uc3QgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgaWYgKHJlcXVlc3RlZFNpemUgPiBtYXhIZWFwU2l6ZSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBjdXREb3duID0gMTsgY3V0RG93biA8PSA0OyBjdXREb3duICo9IDIpIHtcbiAgICAgIGxldCBvdmVyR3Jvd25IZWFwU2l6ZSA9IG9sZFNpemUgKiAoMSArIDAuMiAvIGN1dERvd24pO1xuICAgICAgb3Zlckdyb3duSGVhcFNpemUgPSBNYXRoLm1pbihvdmVyR3Jvd25IZWFwU2l6ZSwgcmVxdWVzdGVkU2l6ZSArIDEwMDY2MzI5Nik7XG4gICAgICBjb25zdCBuZXdTaXplID0gTWF0aC5taW4obWF4SGVhcFNpemUsIGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSwgb3Zlckdyb3duSGVhcFNpemUpLCA2NTUzNikpO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKG5ld1NpemUpO1xuICAgICAgaWYgKHJlcGxhY2VtZW50KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IFVURjhEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9IFwidW5kZWZpbmVkXCIgPyBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpIDogdW5kZWZpbmVkO1xuICBmdW5jdGlvbiBVVEY4QXJyYXlUb1N0cmluZyhoZWFwT3JBcnJheSwgaWR4LCBtYXhCeXRlc1RvUmVhZCA9IDEwMjQpIHtcbiAgICBjb25zdCBlbmRJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZDtcbiAgICBsZXQgZW5kUHRyID0gaWR4O1xuICAgIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpXG4gICAgICArK2VuZFB0cjtcbiAgICBpZiAoZW5kUHRyIC0gaWR4ID4gMTYgJiYgaGVhcE9yQXJyYXkuYnVmZmVyICYmIFVURjhEZWNvZGVyKSB7XG4gICAgICByZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XG4gICAgfVxuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIHdoaWxlIChpZHggPCBlbmRQdHIpIHtcbiAgICAgIGxldCB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICAgIGlmICghKHUwICYgMTI4KSkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdTEgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICAgIGlmICgodTAgJiAyMjQpID09PSAxOTIpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHUwICYgMzEpIDw8IDYgfCB1MSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdTIgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICAgIGlmICgodTAgJiAyNDApID09PSAyMjQpIHtcbiAgICAgICAgdTAgPSAodTAgJiAxNSkgPDwgMTIgfCB1MSA8PCA2IHwgdTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1MCA9ICh1MCAmIDcpIDw8IDE4IHwgdTEgPDwgMTIgfCB1MiA8PCA2IHwgaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICB9XG4gICAgICBpZiAodTAgPCA2NTUzNikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaCA9IHUwIC0gNjU1MzY7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgY2ggPj4gMTAsIDU2MzIwIHwgY2ggJiAxMDIzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBmdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyLCBtYXhCeXRlc1RvUmVhZCkge1xuICAgIHJldHVybiBwdHIgPyBVVEY4QXJyYXlUb1N0cmluZyhiaW5kaW5nLkhFQVBVOCwgcHRyLCBtYXhCeXRlc1RvUmVhZCkgOiBcIlwiO1xuICB9XG4gIGNvbnN0IGFzbUxpYnJhcnlBcmcgPSB7XG4gICAgZW1zY3JpcHRlbl9nZXRfbm93OiBfZW1zY3JpcHRlbl9nZXRfbm93LFxuICAgIGVtc2NyaXB0ZW5fbWVtY3B5X2JpZzogX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyxcbiAgICBlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiAgICBmZF93cml0ZTogKCkgPT4gMFxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVXYXNtKCkge1xuICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICBlbnY6IGFzbUxpYnJhcnlBcmcsXG4gICAgICB3YXNpX3NuYXBzaG90X3ByZXZpZXcxOiBhc21MaWJyYXJ5QXJnXG4gICAgfTtcbiAgICBjb25zdCBleHBvcnRzID0gYXdhaXQgaW5pdChpbmZvKTtcbiAgICB3YXNtTWVtb3J5ID0gZXhwb3J0cy5tZW1vcnk7XG4gICAgdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3Mod2FzbU1lbW9yeS5idWZmZXIpO1xuICAgIE9iamVjdC5hc3NpZ24oYmluZGluZywgZXhwb3J0cyk7XG4gICAgYmluZGluZy5VVEY4VG9TdHJpbmcgPSBVVEY4VG9TdHJpbmc7XG4gIH1cbiAgYXdhaXQgY3JlYXRlV2FzbSgpO1xuICByZXR1cm4gYmluZGluZztcbn1cblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xubGV0IG9uaWdCaW5kaW5nID0gbnVsbDtcbmZ1bmN0aW9uIHRocm93TGFzdE9uaWdFcnJvcihvbmlnQmluZGluZzIpIHtcbiAgdGhyb3cgbmV3IFNoaWtpRXJyb3Iob25pZ0JpbmRpbmcyLlVURjhUb1N0cmluZyhvbmlnQmluZGluZzIuZ2V0TGFzdE9uaWdFcnJvcigpKSk7XG59XG5jbGFzcyBVdGZTdHJpbmcge1xuICBjb25zdHJ1Y3RvcihzdHIpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXRmMTZMZW5ndGhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInV0ZjhMZW5ndGhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInV0ZjE2VmFsdWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInV0ZjhWYWx1ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXRmMTZPZmZzZXRUb1V0ZjhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInV0ZjhPZmZzZXRUb1V0ZjE2XCIpO1xuICAgIGNvbnN0IHV0ZjE2TGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICBjb25zdCB1dGY4TGVuZ3RoID0gVXRmU3RyaW5nLl91dGY4Qnl0ZUxlbmd0aChzdHIpO1xuICAgIGNvbnN0IGNvbXB1dGVJbmRpY2VzTWFwcGluZyA9IHV0ZjhMZW5ndGggIT09IHV0ZjE2TGVuZ3RoO1xuICAgIGNvbnN0IHV0ZjE2T2Zmc2V0VG9VdGY4ID0gY29tcHV0ZUluZGljZXNNYXBwaW5nID8gbmV3IFVpbnQzMkFycmF5KHV0ZjE2TGVuZ3RoICsgMSkgOiBudWxsO1xuICAgIGlmIChjb21wdXRlSW5kaWNlc01hcHBpbmcpXG4gICAgICB1dGYxNk9mZnNldFRvVXRmOFt1dGYxNkxlbmd0aF0gPSB1dGY4TGVuZ3RoO1xuICAgIGNvbnN0IHV0ZjhPZmZzZXRUb1V0ZjE2ID0gY29tcHV0ZUluZGljZXNNYXBwaW5nID8gbmV3IFVpbnQzMkFycmF5KHV0ZjhMZW5ndGggKyAxKSA6IG51bGw7XG4gICAgaWYgKGNvbXB1dGVJbmRpY2VzTWFwcGluZylcbiAgICAgIHV0ZjhPZmZzZXRUb1V0ZjE2W3V0ZjhMZW5ndGhdID0gdXRmMTZMZW5ndGg7XG4gICAgY29uc3QgdXRmOFZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodXRmOExlbmd0aCk7XG4gICAgbGV0IGk4ID0gMDtcbiAgICBmb3IgKGxldCBpMTYgPSAwOyBpMTYgPCB1dGYxNkxlbmd0aDsgaTE2KyspIHtcbiAgICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaTE2KTtcbiAgICAgIGxldCBjb2RlUG9pbnQgPSBjaGFyQ29kZTtcbiAgICAgIGxldCB3YXNTdXJyb2dhdGVQYWlyID0gZmFsc2U7XG4gICAgICBpZiAoY2hhckNvZGUgPj0gNTUyOTYgJiYgY2hhckNvZGUgPD0gNTYzMTkpIHtcbiAgICAgICAgaWYgKGkxNiArIDEgPCB1dGYxNkxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkxNiArIDEpO1xuICAgICAgICAgIGlmIChuZXh0Q2hhckNvZGUgPj0gNTYzMjAgJiYgbmV4dENoYXJDb2RlIDw9IDU3MzQzKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSAoY2hhckNvZGUgLSA1NTI5NiA8PCAxMCkgKyA2NTUzNiB8IG5leHRDaGFyQ29kZSAtIDU2MzIwO1xuICAgICAgICAgICAgd2FzU3Vycm9nYXRlUGFpciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcHV0ZUluZGljZXNNYXBwaW5nKSB7XG4gICAgICAgIHV0ZjE2T2Zmc2V0VG9VdGY4W2kxNl0gPSBpODtcbiAgICAgICAgaWYgKHdhc1N1cnJvZ2F0ZVBhaXIpXG4gICAgICAgICAgdXRmMTZPZmZzZXRUb1V0ZjhbaTE2ICsgMV0gPSBpODtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAxMjcpIHtcbiAgICAgICAgICB1dGY4T2Zmc2V0VG9VdGYxNltpOCArIDBdID0gaTE2O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8PSAyMDQ3KSB7XG4gICAgICAgICAgdXRmOE9mZnNldFRvVXRmMTZbaTggKyAwXSA9IGkxNjtcbiAgICAgICAgICB1dGY4T2Zmc2V0VG9VdGYxNltpOCArIDFdID0gaTE2O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8PSA2NTUzNSkge1xuICAgICAgICAgIHV0ZjhPZmZzZXRUb1V0ZjE2W2k4ICsgMF0gPSBpMTY7XG4gICAgICAgICAgdXRmOE9mZnNldFRvVXRmMTZbaTggKyAxXSA9IGkxNjtcbiAgICAgICAgICB1dGY4T2Zmc2V0VG9VdGYxNltpOCArIDJdID0gaTE2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0ZjhPZmZzZXRUb1V0ZjE2W2k4ICsgMF0gPSBpMTY7XG4gICAgICAgICAgdXRmOE9mZnNldFRvVXRmMTZbaTggKyAxXSA9IGkxNjtcbiAgICAgICAgICB1dGY4T2Zmc2V0VG9VdGYxNltpOCArIDJdID0gaTE2O1xuICAgICAgICAgIHV0ZjhPZmZzZXRUb1V0ZjE2W2k4ICsgM10gPSBpMTY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb2RlUG9pbnQgPD0gMTI3KSB7XG4gICAgICAgIHV0ZjhWYWx1ZVtpOCsrXSA9IGNvZGVQb2ludDtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDw9IDIwNDcpIHtcbiAgICAgICAgdXRmOFZhbHVlW2k4KytdID0gMTkyIHwgKGNvZGVQb2ludCAmIDE5ODQpID4+PiA2O1xuICAgICAgICB1dGY4VmFsdWVbaTgrK10gPSAxMjggfCAoY29kZVBvaW50ICYgNjMpID4+PiAwO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPD0gNjU1MzUpIHtcbiAgICAgICAgdXRmOFZhbHVlW2k4KytdID0gMjI0IHwgKGNvZGVQb2ludCAmIDYxNDQwKSA+Pj4gMTI7XG4gICAgICAgIHV0ZjhWYWx1ZVtpOCsrXSA9IDEyOCB8IChjb2RlUG9pbnQgJiA0MDMyKSA+Pj4gNjtcbiAgICAgICAgdXRmOFZhbHVlW2k4KytdID0gMTI4IHwgKGNvZGVQb2ludCAmIDYzKSA+Pj4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0ZjhWYWx1ZVtpOCsrXSA9IDI0MCB8IChjb2RlUG9pbnQgJiAxODM1MDA4KSA+Pj4gMTg7XG4gICAgICAgIHV0ZjhWYWx1ZVtpOCsrXSA9IDEyOCB8IChjb2RlUG9pbnQgJiAyNTgwNDgpID4+PiAxMjtcbiAgICAgICAgdXRmOFZhbHVlW2k4KytdID0gMTI4IHwgKGNvZGVQb2ludCAmIDQwMzIpID4+PiA2O1xuICAgICAgICB1dGY4VmFsdWVbaTgrK10gPSAxMjggfCAoY29kZVBvaW50ICYgNjMpID4+PiAwO1xuICAgICAgfVxuICAgICAgaWYgKHdhc1N1cnJvZ2F0ZVBhaXIpXG4gICAgICAgIGkxNisrO1xuICAgIH1cbiAgICB0aGlzLnV0ZjE2TGVuZ3RoID0gdXRmMTZMZW5ndGg7XG4gICAgdGhpcy51dGY4TGVuZ3RoID0gdXRmOExlbmd0aDtcbiAgICB0aGlzLnV0ZjE2VmFsdWUgPSBzdHI7XG4gICAgdGhpcy51dGY4VmFsdWUgPSB1dGY4VmFsdWU7XG4gICAgdGhpcy51dGYxNk9mZnNldFRvVXRmOCA9IHV0ZjE2T2Zmc2V0VG9VdGY4O1xuICAgIHRoaXMudXRmOE9mZnNldFRvVXRmMTYgPSB1dGY4T2Zmc2V0VG9VdGYxNjtcbiAgfVxuICBzdGF0aWMgX3V0ZjhCeXRlTGVuZ3RoKHN0cikge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBsZXQgY29kZXBvaW50ID0gY2hhckNvZGU7XG4gICAgICBsZXQgd2FzU3Vycm9nYXRlUGFpciA9IGZhbHNlO1xuICAgICAgaWYgKGNoYXJDb2RlID49IDU1Mjk2ICYmIGNoYXJDb2RlIDw9IDU2MzE5KSB7XG4gICAgICAgIGlmIChpICsgMSA8IGxlbikge1xuICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dENoYXJDb2RlID49IDU2MzIwICYmIG5leHRDaGFyQ29kZSA8PSA1NzM0Mykge1xuICAgICAgICAgICAgY29kZXBvaW50ID0gKGNoYXJDb2RlIC0gNTUyOTYgPDwgMTApICsgNjU1MzYgfCBuZXh0Q2hhckNvZGUgLSA1NjMyMDtcbiAgICAgICAgICAgIHdhc1N1cnJvZ2F0ZVBhaXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvZGVwb2ludCA8PSAxMjcpXG4gICAgICAgIHJlc3VsdCArPSAxO1xuICAgICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDIwNDcpXG4gICAgICAgIHJlc3VsdCArPSAyO1xuICAgICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDY1NTM1KVxuICAgICAgICByZXN1bHQgKz0gMztcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzdWx0ICs9IDQ7XG4gICAgICBpZiAod2FzU3Vycm9nYXRlUGFpcilcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVN0cmluZyhvbmlnQmluZGluZzIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBvbmlnQmluZGluZzIub21hbGxvYyh0aGlzLnV0ZjhMZW5ndGgpO1xuICAgIG9uaWdCaW5kaW5nMi5IRUFQVTguc2V0KHRoaXMudXRmOFZhbHVlLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmNvbnN0IF9PbmlnU3RyaW5nID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdHIpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWRcIiwgKytfT25pZ1N0cmluZy5MQVNUX0lEKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX29uaWdCaW5kaW5nXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb250ZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1dGYxNkxlbmd0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXRmOExlbmd0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXRmMTZPZmZzZXRUb1V0ZjhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInV0ZjhPZmZzZXRUb1V0ZjE2XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwdHJcIik7XG4gICAgaWYgKCFvbmlnQmluZGluZylcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKFwiTXVzdCBpbnZva2UgbG9hZFdhc20gZmlyc3QuXCIpO1xuICAgIHRoaXMuX29uaWdCaW5kaW5nID0gb25pZ0JpbmRpbmc7XG4gICAgdGhpcy5jb250ZW50ID0gc3RyO1xuICAgIGNvbnN0IHV0ZlN0cmluZyA9IG5ldyBVdGZTdHJpbmcoc3RyKTtcbiAgICB0aGlzLnV0ZjE2TGVuZ3RoID0gdXRmU3RyaW5nLnV0ZjE2TGVuZ3RoO1xuICAgIHRoaXMudXRmOExlbmd0aCA9IHV0ZlN0cmluZy51dGY4TGVuZ3RoO1xuICAgIHRoaXMudXRmMTZPZmZzZXRUb1V0ZjggPSB1dGZTdHJpbmcudXRmMTZPZmZzZXRUb1V0Zjg7XG4gICAgdGhpcy51dGY4T2Zmc2V0VG9VdGYxNiA9IHV0ZlN0cmluZy51dGY4T2Zmc2V0VG9VdGYxNjtcbiAgICBpZiAodGhpcy51dGY4TGVuZ3RoIDwgMWU0ICYmICFfT25pZ1N0cmluZy5fc2hhcmVkUHRySW5Vc2UpIHtcbiAgICAgIGlmICghX09uaWdTdHJpbmcuX3NoYXJlZFB0cilcbiAgICAgICAgX09uaWdTdHJpbmcuX3NoYXJlZFB0ciA9IG9uaWdCaW5kaW5nLm9tYWxsb2MoMWU0KTtcbiAgICAgIF9PbmlnU3RyaW5nLl9zaGFyZWRQdHJJblVzZSA9IHRydWU7XG4gICAgICBvbmlnQmluZGluZy5IRUFQVTguc2V0KHV0ZlN0cmluZy51dGY4VmFsdWUsIF9PbmlnU3RyaW5nLl9zaGFyZWRQdHIpO1xuICAgICAgdGhpcy5wdHIgPSBfT25pZ1N0cmluZy5fc2hhcmVkUHRyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB0ciA9IHV0ZlN0cmluZy5jcmVhdGVTdHJpbmcob25pZ0JpbmRpbmcpO1xuICAgIH1cbiAgfVxuICBjb252ZXJ0VXRmOE9mZnNldFRvVXRmMTYodXRmOE9mZnNldCkge1xuICAgIGlmICh0aGlzLnV0ZjhPZmZzZXRUb1V0ZjE2KSB7XG4gICAgICBpZiAodXRmOE9mZnNldCA8IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgaWYgKHV0ZjhPZmZzZXQgPiB0aGlzLnV0ZjhMZW5ndGgpXG4gICAgICAgIHJldHVybiB0aGlzLnV0ZjE2TGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMudXRmOE9mZnNldFRvVXRmMTZbdXRmOE9mZnNldF07XG4gICAgfVxuICAgIHJldHVybiB1dGY4T2Zmc2V0O1xuICB9XG4gIGNvbnZlcnRVdGYxNk9mZnNldFRvVXRmOCh1dGYxNk9mZnNldCkge1xuICAgIGlmICh0aGlzLnV0ZjE2T2Zmc2V0VG9VdGY4KSB7XG4gICAgICBpZiAodXRmMTZPZmZzZXQgPCAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGlmICh1dGYxNk9mZnNldCA+IHRoaXMudXRmMTZMZW5ndGgpXG4gICAgICAgIHJldHVybiB0aGlzLnV0ZjhMZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy51dGYxNk9mZnNldFRvVXRmOFt1dGYxNk9mZnNldF07XG4gICAgfVxuICAgIHJldHVybiB1dGYxNk9mZnNldDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLnB0ciA9PT0gX09uaWdTdHJpbmcuX3NoYXJlZFB0cilcbiAgICAgIF9PbmlnU3RyaW5nLl9zaGFyZWRQdHJJblVzZSA9IGZhbHNlO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX29uaWdCaW5kaW5nLm9mcmVlKHRoaXMucHRyKTtcbiAgfVxufTtcbmxldCBPbmlnU3RyaW5nID0gX09uaWdTdHJpbmc7XG5fX3B1YmxpY0ZpZWxkKE9uaWdTdHJpbmcsIFwiTEFTVF9JRFwiLCAwKTtcbl9fcHVibGljRmllbGQoT25pZ1N0cmluZywgXCJfc2hhcmVkUHRyXCIsIDApO1xuLy8gYSBwb2ludGVyIHRvIGEgc3RyaW5nIG9mIDEwMDAwIGJ5dGVzXG5fX3B1YmxpY0ZpZWxkKE9uaWdTdHJpbmcsIFwiX3NoYXJlZFB0ckluVXNlXCIsIGZhbHNlKTtcbmNsYXNzIE9uaWdTY2FubmVyIHtcbiAgY29uc3RydWN0b3IocGF0dGVybnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX29uaWdCaW5kaW5nXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcHRyXCIpO1xuICAgIGlmICghb25pZ0JpbmRpbmcpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihcIk11c3QgaW52b2tlIGxvYWRXYXNtIGZpcnN0LlwiKTtcbiAgICBjb25zdCBzdHJQdHJzQXJyID0gW107XG4gICAgY29uc3Qgc3RyTGVuQXJyID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhdHRlcm5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB1dGZTdHJpbmcgPSBuZXcgVXRmU3RyaW5nKHBhdHRlcm5zW2ldKTtcbiAgICAgIHN0clB0cnNBcnJbaV0gPSB1dGZTdHJpbmcuY3JlYXRlU3RyaW5nKG9uaWdCaW5kaW5nKTtcbiAgICAgIHN0ckxlbkFycltpXSA9IHV0ZlN0cmluZy51dGY4TGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBzdHJQdHJzUHRyID0gb25pZ0JpbmRpbmcub21hbGxvYyg0ICogcGF0dGVybnMubGVuZ3RoKTtcbiAgICBvbmlnQmluZGluZy5IRUFQVTMyLnNldChzdHJQdHJzQXJyLCBzdHJQdHJzUHRyIC8gNCk7XG4gICAgY29uc3Qgc3RyTGVuUHRyID0gb25pZ0JpbmRpbmcub21hbGxvYyg0ICogcGF0dGVybnMubGVuZ3RoKTtcbiAgICBvbmlnQmluZGluZy5IRUFQVTMyLnNldChzdHJMZW5BcnIsIHN0ckxlblB0ciAvIDQpO1xuICAgIGNvbnN0IHNjYW5uZXJQdHIgPSBvbmlnQmluZGluZy5jcmVhdGVPbmlnU2Nhbm5lcihzdHJQdHJzUHRyLCBzdHJMZW5QdHIsIHBhdHRlcm5zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhdHRlcm5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgb25pZ0JpbmRpbmcub2ZyZWUoc3RyUHRyc0FycltpXSk7XG4gICAgb25pZ0JpbmRpbmcub2ZyZWUoc3RyTGVuUHRyKTtcbiAgICBvbmlnQmluZGluZy5vZnJlZShzdHJQdHJzUHRyKTtcbiAgICBpZiAoc2Nhbm5lclB0ciA9PT0gMClcbiAgICAgIHRocm93TGFzdE9uaWdFcnJvcihvbmlnQmluZGluZyk7XG4gICAgdGhpcy5fb25pZ0JpbmRpbmcgPSBvbmlnQmluZGluZztcbiAgICB0aGlzLl9wdHIgPSBzY2FubmVyUHRyO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fb25pZ0JpbmRpbmcuZnJlZU9uaWdTY2FubmVyKHRoaXMuX3B0cik7XG4gIH1cbiAgZmluZE5leHRNYXRjaFN5bmMoc3RyaW5nLCBzdGFydFBvc2l0aW9uLCBhcmcpIHtcbiAgICBsZXQgb3B0aW9ucyA9IDAgLyogTm9uZSAqLztcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgb3B0aW9ucyA9IGFyZztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN0cmluZyA9IG5ldyBPbmlnU3RyaW5nKHN0cmluZyk7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9maW5kTmV4dE1hdGNoU3luYyhzdHJpbmcsIHN0YXJ0UG9zaXRpb24sIGZhbHNlLCBvcHRpb25zKTtcbiAgICAgIHN0cmluZy5kaXNwb3NlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmluZE5leHRNYXRjaFN5bmMoc3RyaW5nLCBzdGFydFBvc2l0aW9uLCBmYWxzZSwgb3B0aW9ucyk7XG4gIH1cbiAgX2ZpbmROZXh0TWF0Y2hTeW5jKHN0cmluZywgc3RhcnRQb3NpdGlvbiwgZGVidWdDYWxsLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb25pZ0JpbmRpbmcyID0gdGhpcy5fb25pZ0JpbmRpbmc7XG4gICAgY29uc3QgcmVzdWx0UHRyID0gb25pZ0JpbmRpbmcyLmZpbmROZXh0T25pZ1NjYW5uZXJNYXRjaCh0aGlzLl9wdHIsIHN0cmluZy5pZCwgc3RyaW5nLnB0ciwgc3RyaW5nLnV0ZjhMZW5ndGgsIHN0cmluZy5jb252ZXJ0VXRmMTZPZmZzZXRUb1V0Zjgoc3RhcnRQb3NpdGlvbiksIG9wdGlvbnMpO1xuICAgIGlmIChyZXN1bHRQdHIgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBIRUFQVTMyID0gb25pZ0JpbmRpbmcyLkhFQVBVMzI7XG4gICAgbGV0IG9mZnNldCA9IHJlc3VsdFB0ciAvIDQ7XG4gICAgY29uc3QgaW5kZXggPSBIRUFQVTMyW29mZnNldCsrXTtcbiAgICBjb25zdCBjb3VudCA9IEhFQVBVMzJbb2Zmc2V0KytdO1xuICAgIGNvbnN0IGNhcHR1cmVJbmRpY2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBiZWcgPSBzdHJpbmcuY29udmVydFV0ZjhPZmZzZXRUb1V0ZjE2KEhFQVBVMzJbb2Zmc2V0KytdKTtcbiAgICAgIGNvbnN0IGVuZCA9IHN0cmluZy5jb252ZXJ0VXRmOE9mZnNldFRvVXRmMTYoSEVBUFUzMltvZmZzZXQrK10pO1xuICAgICAgY2FwdHVyZUluZGljZXNbaV0gPSB7XG4gICAgICAgIHN0YXJ0OiBiZWcsXG4gICAgICAgIGVuZCxcbiAgICAgICAgbGVuZ3RoOiBlbmQgLSBiZWdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbmRleCxcbiAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNJbnN0YW50aWF0b3JPcHRpb25zT2JqZWN0KGRhdGFPck9wdGlvbnMpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhT3JPcHRpb25zLmluc3RhbnRpYXRvciA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNJbnN0YW50aWF0b3JNb2R1bGUoZGF0YU9yT3B0aW9ucykge1xuICByZXR1cm4gdHlwZW9mIGRhdGFPck9wdGlvbnMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNEYXRhT3B0aW9uc09iamVjdChkYXRhT3JPcHRpb25zKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YU9yT3B0aW9ucy5kYXRhICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZShkYXRhT3JPcHRpb25zKSB7XG4gIHJldHVybiB0eXBlb2YgUmVzcG9uc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YU9yT3B0aW9ucyBpbnN0YW5jZW9mIFJlc3BvbnNlO1xufVxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHx8IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgQnVmZmVyLmlzQnVmZmVyPy4oZGF0YSkgfHwgdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlciB8fCB0eXBlb2YgVWludDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5O1xufVxubGV0IGluaXRQcm9taXNlO1xuZnVuY3Rpb24gbG9hZFdhc20ob3B0aW9ucykge1xuICBpZiAoaW5pdFByb21pc2UpXG4gICAgcmV0dXJuIGluaXRQcm9taXNlO1xuICBhc3luYyBmdW5jdGlvbiBfbG9hZCgpIHtcbiAgICBvbmlnQmluZGluZyA9IGF3YWl0IG1haW4oYXN5bmMgKGluZm8pID0+IHtcbiAgICAgIGxldCBpbnN0YW5jZSA9IG9wdGlvbnM7XG4gICAgICBpbnN0YW5jZSA9IGF3YWl0IGluc3RhbmNlO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBpbnN0YW5jZSA9IGF3YWl0IGluc3RhbmNlKGluZm8pO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBpbnN0YW5jZSA9IGF3YWl0IGluc3RhbmNlKGluZm8pO1xuICAgICAgaWYgKGlzSW5zdGFudGlhdG9yT3B0aW9uc09iamVjdChpbnN0YW5jZSkpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCBpbnN0YW5jZS5pbnN0YW50aWF0b3IoaW5mbyk7XG4gICAgICB9IGVsc2UgaWYgKGlzSW5zdGFudGlhdG9yTW9kdWxlKGluc3RhbmNlKSkge1xuICAgICAgICBpbnN0YW5jZSA9IGF3YWl0IGluc3RhbmNlLmRlZmF1bHQoaW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNEYXRhT3B0aW9uc09iamVjdChpbnN0YW5jZSkpXG4gICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5kYXRhO1xuICAgICAgICBpZiAoaXNSZXNwb25zZShpbnN0YW5jZSkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBpbnN0YW5jZSA9IGF3YWl0IF9tYWtlUmVzcG9uc2VTdHJlYW1pbmdMb2FkZXIoaW5zdGFuY2UpKGluZm8pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGluc3RhbmNlID0gYXdhaXQgX21ha2VSZXNwb25zZU5vblN0cmVhbWluZ0xvYWRlcihpbnN0YW5jZSkoaW5mbyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihpbnN0YW5jZSkpIHtcbiAgICAgICAgICBpbnN0YW5jZSA9IGF3YWl0IF9tYWtlQXJyYXlCdWZmZXJMb2FkZXIoaW5zdGFuY2UpKGluZm8pO1xuICAgICAgICB9IGVsc2UgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCBfbWFrZUFycmF5QnVmZmVyTG9hZGVyKGluc3RhbmNlKShpbmZvKTtcbiAgICAgICAgfSBlbHNlIGlmIChcImRlZmF1bHRcIiBpbiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5kZWZhdWx0IGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlKSB7XG4gICAgICAgICAgaW5zdGFuY2UgPSBhd2FpdCBfbWFrZUFycmF5QnVmZmVyTG9hZGVyKGluc3RhbmNlLmRlZmF1bHQpKGluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJpbnN0YW5jZVwiIGluIGluc3RhbmNlKVxuICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlLmluc3RhbmNlO1xuICAgICAgaWYgKFwiZXhwb3J0c1wiIGluIGluc3RhbmNlKVxuICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSk7XG4gIH1cbiAgaW5pdFByb21pc2UgPSBfbG9hZCgpO1xuICByZXR1cm4gaW5pdFByb21pc2U7XG59XG5mdW5jdGlvbiBfbWFrZUFycmF5QnVmZmVyTG9hZGVyKGRhdGEpIHtcbiAgcmV0dXJuIChpbXBvcnRPYmplY3QpID0+IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGRhdGEsIGltcG9ydE9iamVjdCk7XG59XG5mdW5jdGlvbiBfbWFrZVJlc3BvbnNlU3RyZWFtaW5nTG9hZGVyKGRhdGEpIHtcbiAgcmV0dXJuIChpbXBvcnRPYmplY3QpID0+IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGRhdGEsIGltcG9ydE9iamVjdCk7XG59XG5mdW5jdGlvbiBfbWFrZVJlc3BvbnNlTm9uU3RyZWFtaW5nTG9hZGVyKGRhdGEpIHtcbiAgcmV0dXJuIGFzeW5jIChpbXBvcnRPYmplY3QpID0+IHtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYXJyYXlCdWZmZXIsIGltcG9ydE9iamVjdCk7XG4gIH07XG59XG5cbmxldCBfZGVmYXVsdFdhc21Mb2FkZXI7XG5mdW5jdGlvbiBzZXREZWZhdWx0V2FzbUxvYWRlcihfbG9hZGVyKSB7XG4gIF9kZWZhdWx0V2FzbUxvYWRlciA9IF9sb2FkZXI7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0V2FzbUxvYWRlcigpIHtcbiAgcmV0dXJuIF9kZWZhdWx0V2FzbUxvYWRlcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU9uaWd1cnVtYUVuZ2luZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKVxuICAgIGF3YWl0IGxvYWRXYXNtKG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZVNjYW5uZXIocGF0dGVybnMpIHtcbiAgICAgIHJldHVybiBuZXcgT25pZ1NjYW5uZXIocGF0dGVybnMubWFwKChwKSA9PiB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHAgOiBwLnNvdXJjZSkpO1xuICAgIH0sXG4gICAgY3JlYXRlU3RyaW5nKHMpIHtcbiAgICAgIHJldHVybiBuZXcgT25pZ1N0cmluZyhzKTtcbiAgICB9XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVXYXNtT25pZ0VuZ2luZShvcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVPbmlndXJ1bWFFbmdpbmUob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU9uaWd1cnVtYUVuZ2luZSwgY3JlYXRlV2FzbU9uaWdFbmdpbmUsIGdldERlZmF1bHRXYXNtTG9hZGVyLCBsb2FkV2FzbSwgc2V0RGVmYXVsdFdhc21Mb2FkZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-oniguruma@1.27.0/node_modules/@shikijs/engine-oniguruma/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@shikijs+types@1.27.0/node_modules/@shikijs/types/dist/index.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+types@1.27.0/node_modules/@shikijs/types/dist/index.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShikiError: () => (/* binding */ ShikiError)\n/* harmony export */ });\nclass ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcyt0eXBlc0AxLjI3LjAvbm9kZV9tb2R1bGVzL0BzaGlraWpzL3R5cGVzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNCIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaGlraWpzK3R5cGVzQDEuMjcuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvdHlwZXMvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgU2hpa2lFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2hpa2lFcnJvclwiO1xuICB9XG59XG5cbmV4cG9ydCB7IFNoaWtpRXJyb3IgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@shikijs+types@1.27.0/node_modules/@shikijs/types/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@shikijs+vscode-textmate@10.0.1/node_modules/@shikijs/vscode-textmate/dist/index.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+vscode-textmate@10.0.1/node_modules/@shikijs/vscode-textmate/dist/index.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncodedTokenMetadata: () => (/* binding */ EncodedTokenMetadata),\n/* harmony export */   FindOption: () => (/* binding */ FindOption),\n/* harmony export */   FontStyle: () => (/* binding */ FontStyle),\n/* harmony export */   INITIAL: () => (/* binding */ INITIAL),\n/* harmony export */   Registry: () => (/* binding */ Registry),\n/* harmony export */   Theme: () => (/* binding */ Theme),\n/* harmony export */   disposeOnigString: () => (/* binding */ disposeOnigString)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/polyfills/process.js\");\n// src/utils.ts\nfunction clone(something) {\n  return doClone(something);\n}\nfunction doClone(something) {\n  if (Array.isArray(something)) {\n    return cloneArray(something);\n  }\n  if (something instanceof RegExp) {\n    return something;\n  }\n  if (typeof something === \"object\") {\n    return cloneObj(something);\n  }\n  return something;\n}\nfunction cloneArray(arr) {\n  let r = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    r[i] = doClone(arr[i]);\n  }\n  return r;\n}\nfunction cloneObj(obj) {\n  let r = {};\n  for (let key in obj) {\n    r[key] = doClone(obj[key]);\n  }\n  return r;\n}\nfunction mergeObjects(target, ...sources) {\n  sources.forEach((source) => {\n    for (let key in source) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n}\nfunction basename(path) {\n  const idx = ~path.lastIndexOf(\"/\") || ~path.lastIndexOf(\"\\\\\");\n  if (idx === 0) {\n    return path;\n  } else if (~idx === path.length - 1) {\n    return basename(path.substring(0, path.length - 1));\n  } else {\n    return path.substr(~idx + 1);\n  }\n}\nvar CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/g;\nvar RegexSource = class {\n  static hasCaptures(regexSource) {\n    if (regexSource === null) {\n      return false;\n    }\n    CAPTURING_REGEX_SOURCE.lastIndex = 0;\n    return CAPTURING_REGEX_SOURCE.test(regexSource);\n  }\n  static replaceCaptures(regexSource, captureSource, captureIndices) {\n    return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {\n      let capture = captureIndices[parseInt(index || commandIndex, 10)];\n      if (capture) {\n        let result = captureSource.substring(capture.start, capture.end);\n        while (result[0] === \".\") {\n          result = result.substring(1);\n        }\n        switch (command) {\n          case \"downcase\":\n            return result.toLowerCase();\n          case \"upcase\":\n            return result.toUpperCase();\n          default:\n            return result;\n        }\n      } else {\n        return match;\n      }\n    });\n  }\n};\nfunction strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction strArrCmp(a, b) {\n  if (a === null && b === null) {\n    return 0;\n  }\n  if (!a) {\n    return -1;\n  }\n  if (!b) {\n    return 1;\n  }\n  let len1 = a.length;\n  let len2 = b.length;\n  if (len1 === len2) {\n    for (let i = 0; i < len1; i++) {\n      let res = strcmp(a[i], b[i]);\n      if (res !== 0) {\n        return res;\n      }\n    }\n    return 0;\n  }\n  return len1 - len2;\n}\nfunction isValidHexColor(hex) {\n  if (/^#[0-9a-f]{6}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{8}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{3}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{4}$/i.test(hex)) {\n    return true;\n  }\n  return false;\n}\nfunction escapeRegExpCharacters(value) {\n  return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, \"\\\\$&\");\n}\nvar CachedFn = class {\n  constructor(fn) {\n    this.fn = fn;\n  }\n  cache = /* @__PURE__ */ new Map();\n  get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n    const value = this.fn(key);\n    this.cache.set(key, value);\n    return value;\n  }\n};\n\n// src/theme.ts\nvar Theme = class {\n  constructor(_colorMap, _defaults, _root) {\n    this._colorMap = _colorMap;\n    this._defaults = _defaults;\n    this._root = _root;\n  }\n  static createFromRawTheme(source, colorMap) {\n    return this.createFromParsedTheme(parseTheme(source), colorMap);\n  }\n  static createFromParsedTheme(source, colorMap) {\n    return resolveParsedThemeRules(source, colorMap);\n  }\n  _cachedMatchRoot = new CachedFn(\n    (scopeName) => this._root.match(scopeName)\n  );\n  getColorMap() {\n    return this._colorMap.getColorMap();\n  }\n  getDefaults() {\n    return this._defaults;\n  }\n  match(scopePath) {\n    if (scopePath === null) {\n      return this._defaults;\n    }\n    const scopeName = scopePath.scopeName;\n    const matchingTrieElements = this._cachedMatchRoot.get(scopeName);\n    const effectiveRule = matchingTrieElements.find(\n      (v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes)\n    );\n    if (!effectiveRule) {\n      return null;\n    }\n    return new StyleAttributes(\n      effectiveRule.fontStyle,\n      effectiveRule.foreground,\n      effectiveRule.background\n    );\n  }\n};\nvar ScopeStack = class _ScopeStack {\n  constructor(parent, scopeName) {\n    this.parent = parent;\n    this.scopeName = scopeName;\n  }\n  static push(path, scopeNames) {\n    for (const name of scopeNames) {\n      path = new _ScopeStack(path, name);\n    }\n    return path;\n  }\n  static from(...segments) {\n    let result = null;\n    for (let i = 0; i < segments.length; i++) {\n      result = new _ScopeStack(result, segments[i]);\n    }\n    return result;\n  }\n  push(scopeName) {\n    return new _ScopeStack(this, scopeName);\n  }\n  getSegments() {\n    let item = this;\n    const result = [];\n    while (item) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    result.reverse();\n    return result;\n  }\n  toString() {\n    return this.getSegments().join(\" \");\n  }\n  extends(other) {\n    if (this === other) {\n      return true;\n    }\n    if (this.parent === null) {\n      return false;\n    }\n    return this.parent.extends(other);\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let item = this;\n    while (item && item !== base) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    return item === base ? result.reverse() : void 0;\n  }\n};\nfunction _scopePathMatchesParentScopes(scopePath, parentScopes) {\n  if (parentScopes.length === 0) {\n    return true;\n  }\n  for (let index = 0; index < parentScopes.length; index++) {\n    let scopePattern = parentScopes[index];\n    let scopeMustMatch = false;\n    if (scopePattern === \">\") {\n      if (index === parentScopes.length - 1) {\n        return false;\n      }\n      scopePattern = parentScopes[++index];\n      scopeMustMatch = true;\n    }\n    while (scopePath) {\n      if (_matchesScope(scopePath.scopeName, scopePattern)) {\n        break;\n      }\n      if (scopeMustMatch) {\n        return false;\n      }\n      scopePath = scopePath.parent;\n    }\n    if (!scopePath) {\n      return false;\n    }\n    scopePath = scopePath.parent;\n  }\n  return true;\n}\nfunction _matchesScope(scopeName, scopePattern) {\n  return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === \".\";\n}\nvar StyleAttributes = class {\n  constructor(fontStyle, foregroundId, backgroundId) {\n    this.fontStyle = fontStyle;\n    this.foregroundId = foregroundId;\n    this.backgroundId = backgroundId;\n  }\n};\nfunction parseTheme(source) {\n  if (!source) {\n    return [];\n  }\n  if (!source.settings || !Array.isArray(source.settings)) {\n    return [];\n  }\n  let settings = source.settings;\n  let result = [], resultLen = 0;\n  for (let i = 0, len = settings.length; i < len; i++) {\n    let entry = settings[i];\n    if (!entry.settings) {\n      continue;\n    }\n    let scopes;\n    if (typeof entry.scope === \"string\") {\n      let _scope = entry.scope;\n      _scope = _scope.replace(/^[,]+/, \"\");\n      _scope = _scope.replace(/[,]+$/, \"\");\n      scopes = _scope.split(\",\");\n    } else if (Array.isArray(entry.scope)) {\n      scopes = entry.scope;\n    } else {\n      scopes = [\"\"];\n    }\n    let fontStyle = -1 /* NotSet */;\n    if (typeof entry.settings.fontStyle === \"string\") {\n      fontStyle = 0 /* None */;\n      let segments = entry.settings.fontStyle.split(\" \");\n      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n        let segment = segments[j];\n        switch (segment) {\n          case \"italic\":\n            fontStyle = fontStyle | 1 /* Italic */;\n            break;\n          case \"bold\":\n            fontStyle = fontStyle | 2 /* Bold */;\n            break;\n          case \"underline\":\n            fontStyle = fontStyle | 4 /* Underline */;\n            break;\n          case \"strikethrough\":\n            fontStyle = fontStyle | 8 /* Strikethrough */;\n            break;\n        }\n      }\n    }\n    let foreground = null;\n    if (typeof entry.settings.foreground === \"string\" && isValidHexColor(entry.settings.foreground)) {\n      foreground = entry.settings.foreground;\n    }\n    let background = null;\n    if (typeof entry.settings.background === \"string\" && isValidHexColor(entry.settings.background)) {\n      background = entry.settings.background;\n    }\n    for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {\n      let _scope = scopes[j].trim();\n      let segments = _scope.split(\" \");\n      let scope = segments[segments.length - 1];\n      let parentScopes = null;\n      if (segments.length > 1) {\n        parentScopes = segments.slice(0, segments.length - 1);\n        parentScopes.reverse();\n      }\n      result[resultLen++] = new ParsedThemeRule(\n        scope,\n        parentScopes,\n        i,\n        fontStyle,\n        foreground,\n        background\n      );\n    }\n  }\n  return result;\n}\nvar ParsedThemeRule = class {\n  constructor(scope, parentScopes, index, fontStyle, foreground, background) {\n    this.scope = scope;\n    this.parentScopes = parentScopes;\n    this.index = index;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n};\nvar FontStyle = /* @__PURE__ */ ((FontStyle2) => {\n  FontStyle2[FontStyle2[\"NotSet\"] = -1] = \"NotSet\";\n  FontStyle2[FontStyle2[\"None\"] = 0] = \"None\";\n  FontStyle2[FontStyle2[\"Italic\"] = 1] = \"Italic\";\n  FontStyle2[FontStyle2[\"Bold\"] = 2] = \"Bold\";\n  FontStyle2[FontStyle2[\"Underline\"] = 4] = \"Underline\";\n  FontStyle2[FontStyle2[\"Strikethrough\"] = 8] = \"Strikethrough\";\n  return FontStyle2;\n})(FontStyle || {});\nfunction resolveParsedThemeRules(parsedThemeRules, _colorMap) {\n  parsedThemeRules.sort((a, b) => {\n    let r = strcmp(a.scope, b.scope);\n    if (r !== 0) {\n      return r;\n    }\n    r = strArrCmp(a.parentScopes, b.parentScopes);\n    if (r !== 0) {\n      return r;\n    }\n    return a.index - b.index;\n  });\n  let defaultFontStyle = 0 /* None */;\n  let defaultForeground = \"#000000\";\n  let defaultBackground = \"#ffffff\";\n  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === \"\") {\n    let incomingDefaults = parsedThemeRules.shift();\n    if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n      defaultFontStyle = incomingDefaults.fontStyle;\n    }\n    if (incomingDefaults.foreground !== null) {\n      defaultForeground = incomingDefaults.foreground;\n    }\n    if (incomingDefaults.background !== null) {\n      defaultBackground = incomingDefaults.background;\n    }\n  }\n  let colorMap = new ColorMap(_colorMap);\n  let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n  let root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1 /* NotSet */, 0, 0), []);\n  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n    let rule = parsedThemeRules[i];\n    root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n  }\n  return new Theme(colorMap, defaults, root);\n}\nvar ColorMap = class {\n  _isFrozen;\n  _lastColorId;\n  _id2color;\n  _color2id;\n  constructor(_colorMap) {\n    this._lastColorId = 0;\n    this._id2color = [];\n    this._color2id = /* @__PURE__ */ Object.create(null);\n    if (Array.isArray(_colorMap)) {\n      this._isFrozen = true;\n      for (let i = 0, len = _colorMap.length; i < len; i++) {\n        this._color2id[_colorMap[i]] = i;\n        this._id2color[i] = _colorMap[i];\n      }\n    } else {\n      this._isFrozen = false;\n    }\n  }\n  getId(color) {\n    if (color === null) {\n      return 0;\n    }\n    color = color.toUpperCase();\n    let value = this._color2id[color];\n    if (value) {\n      return value;\n    }\n    if (this._isFrozen) {\n      throw new Error(`Missing color in color map - ${color}`);\n    }\n    value = ++this._lastColorId;\n    this._color2id[color] = value;\n    this._id2color[value] = color;\n    return value;\n  }\n  getColorMap() {\n    return this._id2color.slice(0);\n  }\n};\nvar emptyParentScopes = Object.freeze([]);\nvar ThemeTrieElementRule = class _ThemeTrieElementRule {\n  scopeDepth;\n  parentScopes;\n  fontStyle;\n  foreground;\n  background;\n  constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    this.scopeDepth = scopeDepth;\n    this.parentScopes = parentScopes || emptyParentScopes;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n  clone() {\n    return new _ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n  }\n  static cloneArr(arr) {\n    let r = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n      r[i] = arr[i].clone();\n    }\n    return r;\n  }\n  acceptOverwrite(scopeDepth, fontStyle, foreground, background) {\n    if (this.scopeDepth > scopeDepth) {\n      console.log(\"how did this happen?\");\n    } else {\n      this.scopeDepth = scopeDepth;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      this.fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      this.foreground = foreground;\n    }\n    if (background !== 0) {\n      this.background = background;\n    }\n  }\n};\nvar ThemeTrieElement = class _ThemeTrieElement {\n  constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {\n    this._mainRule = _mainRule;\n    this._children = _children;\n    this._rulesWithParentScopes = rulesWithParentScopes;\n  }\n  _rulesWithParentScopes;\n  static _cmpBySpecificity(a, b) {\n    if (a.scopeDepth !== b.scopeDepth) {\n      return b.scopeDepth - a.scopeDepth;\n    }\n    let aParentIndex = 0;\n    let bParentIndex = 0;\n    while (true) {\n      if (a.parentScopes[aParentIndex] === \">\") {\n        aParentIndex++;\n      }\n      if (b.parentScopes[bParentIndex] === \">\") {\n        bParentIndex++;\n      }\n      if (aParentIndex >= a.parentScopes.length || bParentIndex >= b.parentScopes.length) {\n        break;\n      }\n      const parentScopeLengthDiff = b.parentScopes[bParentIndex].length - a.parentScopes[aParentIndex].length;\n      if (parentScopeLengthDiff !== 0) {\n        return parentScopeLengthDiff;\n      }\n      aParentIndex++;\n      bParentIndex++;\n    }\n    return b.parentScopes.length - a.parentScopes.length;\n  }\n  match(scope) {\n    if (scope !== \"\") {\n      let dotIndex = scope.indexOf(\".\");\n      let head;\n      let tail;\n      if (dotIndex === -1) {\n        head = scope;\n        tail = \"\";\n      } else {\n        head = scope.substring(0, dotIndex);\n        tail = scope.substring(dotIndex + 1);\n      }\n      if (this._children.hasOwnProperty(head)) {\n        return this._children[head].match(tail);\n      }\n    }\n    const rules = this._rulesWithParentScopes.concat(this._mainRule);\n    rules.sort(_ThemeTrieElement._cmpBySpecificity);\n    return rules;\n  }\n  insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {\n    if (scope === \"\") {\n      this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n      return;\n    }\n    let dotIndex = scope.indexOf(\".\");\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = scope;\n      tail = \"\";\n    } else {\n      head = scope.substring(0, dotIndex);\n      tail = scope.substring(dotIndex + 1);\n    }\n    let child;\n    if (this._children.hasOwnProperty(head)) {\n      child = this._children[head];\n    } else {\n      child = new _ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n      this._children[head] = child;\n    }\n    child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n  }\n  _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    if (parentScopes === null) {\n      this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n      return;\n    }\n    for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n      let rule = this._rulesWithParentScopes[i];\n      if (strArrCmp(rule.parentScopes, parentScopes) === 0) {\n        rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n        return;\n      }\n    }\n    if (fontStyle === -1 /* NotSet */) {\n      fontStyle = this._mainRule.fontStyle;\n    }\n    if (foreground === 0) {\n      foreground = this._mainRule.foreground;\n    }\n    if (background === 0) {\n      background = this._mainRule.background;\n    }\n    this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n  }\n};\n\n// src/encodedTokenAttributes.ts\nvar EncodedTokenMetadata = class _EncodedTokenMetadata {\n  static toBinaryStr(encodedTokenAttributes) {\n    return encodedTokenAttributes.toString(2).padStart(32, \"0\");\n  }\n  static print(encodedTokenAttributes) {\n    const languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    const tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    const fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    const foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    const background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    console.log({\n      languageId,\n      tokenType,\n      fontStyle,\n      foreground,\n      background\n    });\n  }\n  static getLanguageId(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;\n  }\n  static getTokenType(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 768 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;\n  }\n  static containsBalancedBrackets(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 1024 /* BALANCED_BRACKETS_MASK */) !== 0;\n  }\n  static getFontStyle(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 30720 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;\n  }\n  static getForeground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 16744448 /* FOREGROUND_MASK */) >>> 15 /* FOREGROUND_OFFSET */;\n  }\n  static getBackground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 4278190080 /* BACKGROUND_MASK */) >>> 24 /* BACKGROUND_OFFSET */;\n  }\n  /**\n   * Updates the fields in `metadata`.\n   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.\n   */\n  static set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets, fontStyle, foreground, background) {\n    let _languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    let _tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    let _containsBalancedBracketsBit = _EncodedTokenMetadata.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;\n    let _fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    let _foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    let _background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    if (languageId !== 0) {\n      _languageId = languageId;\n    }\n    if (tokenType !== 8 /* NotSet */) {\n      _tokenType = fromOptionalTokenType(tokenType);\n    }\n    if (containsBalancedBrackets !== null) {\n      _containsBalancedBracketsBit = containsBalancedBrackets ? 1 : 0;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      _fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      _foreground = foreground;\n    }\n    if (background !== 0) {\n      _background = background;\n    }\n    return (_languageId << 0 /* LANGUAGEID_OFFSET */ | _tokenType << 8 /* TOKEN_TYPE_OFFSET */ | _containsBalancedBracketsBit << 10 /* BALANCED_BRACKETS_OFFSET */ | _fontStyle << 11 /* FONT_STYLE_OFFSET */ | _foreground << 15 /* FOREGROUND_OFFSET */ | _background << 24 /* BACKGROUND_OFFSET */) >>> 0;\n  }\n};\nfunction toOptionalTokenType(standardType) {\n  return standardType;\n}\nfunction fromOptionalTokenType(standardType) {\n  return standardType;\n}\n\n// src/matcher.ts\nfunction createMatchers(selector, matchesName) {\n  const results = [];\n  const tokenizer = newTokenizer(selector);\n  let token = tokenizer.next();\n  while (token !== null) {\n    let priority = 0;\n    if (token.length === 2 && token.charAt(1) === \":\") {\n      switch (token.charAt(0)) {\n        case \"R\":\n          priority = 1;\n          break;\n        case \"L\":\n          priority = -1;\n          break;\n        default:\n          console.log(`Unknown priority ${token} in scope selector`);\n      }\n      token = tokenizer.next();\n    }\n    let matcher = parseConjunction();\n    results.push({ matcher, priority });\n    if (token !== \",\") {\n      break;\n    }\n    token = tokenizer.next();\n  }\n  return results;\n  function parseOperand() {\n    if (token === \"-\") {\n      token = tokenizer.next();\n      const expressionToNegate = parseOperand();\n      return (matcherInput) => !!expressionToNegate && !expressionToNegate(matcherInput);\n    }\n    if (token === \"(\") {\n      token = tokenizer.next();\n      const expressionInParents = parseInnerExpression();\n      if (token === \")\") {\n        token = tokenizer.next();\n      }\n      return expressionInParents;\n    }\n    if (isIdentifier(token)) {\n      const identifiers = [];\n      do {\n        identifiers.push(token);\n        token = tokenizer.next();\n      } while (isIdentifier(token));\n      return (matcherInput) => matchesName(identifiers, matcherInput);\n    }\n    return null;\n  }\n  function parseConjunction() {\n    const matchers = [];\n    let matcher = parseOperand();\n    while (matcher) {\n      matchers.push(matcher);\n      matcher = parseOperand();\n    }\n    return (matcherInput) => matchers.every((matcher2) => matcher2(matcherInput));\n  }\n  function parseInnerExpression() {\n    const matchers = [];\n    let matcher = parseConjunction();\n    while (matcher) {\n      matchers.push(matcher);\n      if (token === \"|\" || token === \",\") {\n        do {\n          token = tokenizer.next();\n        } while (token === \"|\" || token === \",\");\n      } else {\n        break;\n      }\n      matcher = parseConjunction();\n    }\n    return (matcherInput) => matchers.some((matcher2) => matcher2(matcherInput));\n  }\n}\nfunction isIdentifier(token) {\n  return !!token && !!token.match(/[\\w\\.:]+/);\n}\nfunction newTokenizer(input) {\n  let regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n  let match = regex.exec(input);\n  return {\n    next: () => {\n      if (!match) {\n        return null;\n      }\n      const res = match[0];\n      match = regex.exec(input);\n      return res;\n    }\n  };\n}\n\n// src/onigLib.ts\nvar FindOption = /* @__PURE__ */ ((FindOption2) => {\n  FindOption2[FindOption2[\"None\"] = 0] = \"None\";\n  FindOption2[FindOption2[\"NotBeginString\"] = 1] = \"NotBeginString\";\n  FindOption2[FindOption2[\"NotEndString\"] = 2] = \"NotEndString\";\n  FindOption2[FindOption2[\"NotBeginPosition\"] = 4] = \"NotBeginPosition\";\n  FindOption2[FindOption2[\"DebugCall\"] = 8] = \"DebugCall\";\n  return FindOption2;\n})(FindOption || {});\nfunction disposeOnigString(str) {\n  if (typeof str.dispose === \"function\") {\n    str.dispose();\n  }\n}\n\n// src/grammar/grammarDependencies.ts\nvar TopLevelRuleReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  toKey() {\n    return this.scopeName;\n  }\n};\nvar TopLevelRepositoryRuleReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  toKey() {\n    return `${this.scopeName}#${this.ruleName}`;\n  }\n};\nvar ExternalReferenceCollector = class {\n  _references = [];\n  _seenReferenceKeys = /* @__PURE__ */ new Set();\n  get references() {\n    return this._references;\n  }\n  visitedRule = /* @__PURE__ */ new Set();\n  add(reference) {\n    const key = reference.toKey();\n    if (this._seenReferenceKeys.has(key)) {\n      return;\n    }\n    this._seenReferenceKeys.add(key);\n    this._references.push(reference);\n  }\n};\nvar ScopeDependencyProcessor = class {\n  constructor(repo, initialScopeName) {\n    this.repo = repo;\n    this.initialScopeName = initialScopeName;\n    this.seenFullScopeRequests.add(this.initialScopeName);\n    this.Q = [new TopLevelRuleReference(this.initialScopeName)];\n  }\n  seenFullScopeRequests = /* @__PURE__ */ new Set();\n  seenPartialScopeRequests = /* @__PURE__ */ new Set();\n  Q;\n  processQueue() {\n    const q = this.Q;\n    this.Q = [];\n    const deps = new ExternalReferenceCollector();\n    for (const dep of q) {\n      collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);\n    }\n    for (const dep of deps.references) {\n      if (dep instanceof TopLevelRuleReference) {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        this.seenFullScopeRequests.add(dep.scopeName);\n        this.Q.push(dep);\n      } else {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        if (this.seenPartialScopeRequests.has(dep.toKey())) {\n          continue;\n        }\n        this.seenPartialScopeRequests.add(dep.toKey());\n        this.Q.push(dep);\n      }\n    }\n  }\n};\nfunction collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {\n  const selfGrammar = repo.lookup(reference.scopeName);\n  if (!selfGrammar) {\n    if (reference.scopeName === baseGrammarScopeName) {\n      throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);\n    }\n    return;\n  }\n  const baseGrammar = repo.lookup(baseGrammarScopeName);\n  if (reference instanceof TopLevelRuleReference) {\n    collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);\n  } else {\n    collectExternalReferencesInTopLevelRepositoryRule(\n      reference.ruleName,\n      { baseGrammar, selfGrammar, repository: selfGrammar.repository },\n      result\n    );\n  }\n  const injections = repo.injections(reference.scopeName);\n  if (injections) {\n    for (const injection of injections) {\n      result.add(new TopLevelRuleReference(injection));\n    }\n  }\n}\nfunction collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {\n  if (context.repository && context.repository[ruleName]) {\n    const rule = context.repository[ruleName];\n    collectExternalReferencesInRules([rule], context, result);\n  }\n}\nfunction collectExternalReferencesInTopLevelRule(context, result) {\n  if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {\n    collectExternalReferencesInRules(\n      context.selfGrammar.patterns,\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n  if (context.selfGrammar.injections) {\n    collectExternalReferencesInRules(\n      Object.values(context.selfGrammar.injections),\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n}\nfunction collectExternalReferencesInRules(rules, context, result) {\n  for (const rule of rules) {\n    if (result.visitedRule.has(rule)) {\n      continue;\n    }\n    result.visitedRule.add(rule);\n    const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;\n    if (Array.isArray(rule.patterns)) {\n      collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);\n    }\n    const include = rule.include;\n    if (!include) {\n      continue;\n    }\n    const reference = parseInclude(include);\n    switch (reference.kind) {\n      case 0 /* Base */:\n        collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);\n        break;\n      case 1 /* Self */:\n        collectExternalReferencesInTopLevelRule(context, result);\n        break;\n      case 2 /* RelativeReference */:\n        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);\n        break;\n      case 3 /* TopLevelReference */:\n      case 4 /* TopLevelRepositoryReference */:\n        const selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;\n        if (selfGrammar) {\n          const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);\n          } else {\n            collectExternalReferencesInTopLevelRule(newContext, result);\n          }\n        } else {\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));\n          } else {\n            result.add(new TopLevelRuleReference(reference.scopeName));\n          }\n        }\n        break;\n    }\n  }\n}\nvar BaseReference = class {\n  kind = 0 /* Base */;\n};\nvar SelfReference = class {\n  kind = 1 /* Self */;\n};\nvar RelativeReference = class {\n  constructor(ruleName) {\n    this.ruleName = ruleName;\n  }\n  kind = 2 /* RelativeReference */;\n};\nvar TopLevelReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  kind = 3 /* TopLevelReference */;\n};\nvar TopLevelRepositoryReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  kind = 4 /* TopLevelRepositoryReference */;\n};\nfunction parseInclude(include) {\n  if (include === \"$base\") {\n    return new BaseReference();\n  } else if (include === \"$self\") {\n    return new SelfReference();\n  }\n  const indexOfSharp = include.indexOf(\"#\");\n  if (indexOfSharp === -1) {\n    return new TopLevelReference(include);\n  } else if (indexOfSharp === 0) {\n    return new RelativeReference(include.substring(1));\n  } else {\n    const scopeName = include.substring(0, indexOfSharp);\n    const ruleName = include.substring(indexOfSharp + 1);\n    return new TopLevelRepositoryReference(scopeName, ruleName);\n  }\n}\n\n// src/rule.ts\nvar HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nvar BACK_REFERENCING_END = /\\\\(\\d+)/g;\nvar ruleIdSymbol = Symbol(\"RuleId\");\nvar endRuleId = -1;\nvar whileRuleId = -2;\nfunction ruleIdFromNumber(id) {\n  return id;\n}\nfunction ruleIdToNumber(id) {\n  return id;\n}\nvar Rule = class {\n  $location;\n  id;\n  _nameIsCapturing;\n  _name;\n  _contentNameIsCapturing;\n  _contentName;\n  constructor($location, id, name, contentName) {\n    this.$location = $location;\n    this.id = id;\n    this._name = name || null;\n    this._nameIsCapturing = RegexSource.hasCaptures(this._name);\n    this._contentName = contentName || null;\n    this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);\n  }\n  get debugName() {\n    const location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : \"unknown\";\n    return `${this.constructor.name}#${this.id} @ ${location}`;\n  }\n  getName(lineText, captureIndices) {\n    if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {\n      return this._name;\n    }\n    return RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n  }\n  getContentName(lineText, captureIndices) {\n    if (!this._contentNameIsCapturing || this._contentName === null) {\n      return this._contentName;\n    }\n    return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n  }\n};\nvar CaptureRule = class extends Rule {\n  retokenizeCapturedWithRuleId;\n  constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {\n    super($location, id, name, contentName);\n    this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n  }\n  dispose() {\n  }\n  collectPatterns(grammar, out) {\n    throw new Error(\"Not supported!\");\n  }\n  compile(grammar, endRegexSource) {\n    throw new Error(\"Not supported!\");\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    throw new Error(\"Not supported!\");\n  }\n};\nvar MatchRule = class extends Rule {\n  _match;\n  captures;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, match, captures) {\n    super($location, id, name, null);\n    this._match = new RegExpSource(match, this.id);\n    this.captures = captures;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugMatchRegExp() {\n    return `${this._match.source}`;\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._match);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar IncludeOnlyRule = class extends Rule {\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, patterns) {\n    super($location, id, name, contentName);\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  collectPatterns(grammar, out) {\n    for (const pattern of this.patterns) {\n      const rule = grammar.getRule(pattern);\n      rule.collectPatterns(grammar, out);\n    }\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginEndRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  _end;\n  endHasBackReferences;\n  endCaptures;\n  applyEndPatternLast;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this._end = new RegExpSource(end ? end : \"\\uFFFF\", -1);\n    this.endHasBackReferences = this._end.hasBackReferences;\n    this.endCaptures = endCaptures;\n    this.applyEndPatternLast = applyEndPatternLast || false;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugEndRegExp() {\n    return `${this._end.source}`;\n  }\n  getEndWithResolvedBackReferences(lineText, captureIndices) {\n    return this._end.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n      } else {\n        this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n      }\n    }\n    if (this._end.hasBackReferences) {\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);\n      } else {\n        this._cachedCompiledPatterns.setSource(0, endRegexSource);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginWhileRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  whileCaptures;\n  _while;\n  whileHasBackReferences;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  _cachedCompiledWhilePatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this.whileCaptures = whileCaptures;\n    this._while = new RegExpSource(_while, whileRuleId);\n    this.whileHasBackReferences = this._while.hasBackReferences;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n    this._cachedCompiledWhilePatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n    if (this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns.dispose();\n      this._cachedCompiledWhilePatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugWhileRegExp() {\n    return `${this._while.source}`;\n  }\n  getWhileWithResolvedBackReferences(lineText, captureIndices) {\n    return this._while.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n  compileWhile(grammar, endRegexSource) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileWhileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledWhilePatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns = new RegExpSourceList();\n      this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n    }\n    if (this._while.hasBackReferences) {\n      this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : \"\\uFFFF\");\n    }\n    return this._cachedCompiledWhilePatterns;\n  }\n};\nvar RuleFactory = class _RuleFactory {\n  static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {\n    return helper.registerRule((id) => {\n      return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n    });\n  }\n  static getCompiledRuleId(desc, helper, repository) {\n    if (!desc.id) {\n      helper.registerRule((id) => {\n        desc.id = id;\n        if (desc.match) {\n          return new MatchRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.match,\n            _RuleFactory._compileCaptures(desc.captures, helper, repository)\n          );\n        }\n        if (typeof desc.begin === \"undefined\") {\n          if (desc.repository) {\n            repository = mergeObjects({}, repository, desc.repository);\n          }\n          let patterns = desc.patterns;\n          if (typeof patterns === \"undefined\" && desc.include) {\n            patterns = [{ include: desc.include }];\n          }\n          return new IncludeOnlyRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            _RuleFactory._compilePatterns(patterns, helper, repository)\n          );\n        }\n        if (desc.while) {\n          return new BeginWhileRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            desc.begin,\n            _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n            desc.while,\n            _RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository),\n            _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n          );\n        }\n        return new BeginEndRule(\n          desc.$vscodeTextmateLocation,\n          desc.id,\n          desc.name,\n          desc.contentName,\n          desc.begin,\n          _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n          desc.end,\n          _RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository),\n          desc.applyEndPatternLast,\n          _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n        );\n      });\n    }\n    return desc.id;\n  }\n  static _compileCaptures(captures, helper, repository) {\n    let r = [];\n    if (captures) {\n      let maximumCaptureId = 0;\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        if (numericCaptureId > maximumCaptureId) {\n          maximumCaptureId = numericCaptureId;\n        }\n      }\n      for (let i = 0; i <= maximumCaptureId; i++) {\n        r[i] = null;\n      }\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        let retokenizeCapturedWithRuleId = 0;\n        if (captures[captureId].patterns) {\n          retokenizeCapturedWithRuleId = _RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n        }\n        r[numericCaptureId] = _RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n      }\n    }\n    return r;\n  }\n  static _compilePatterns(patterns, helper, repository) {\n    let r = [];\n    if (patterns) {\n      for (let i = 0, len = patterns.length; i < len; i++) {\n        const pattern = patterns[i];\n        let ruleId = -1;\n        if (pattern.include) {\n          const reference = parseInclude(pattern.include);\n          switch (reference.kind) {\n            case 0 /* Base */:\n            case 1 /* Self */:\n              ruleId = _RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n              break;\n            case 2 /* RelativeReference */:\n              let localIncludedRule = repository[reference.ruleName];\n              if (localIncludedRule) {\n                ruleId = _RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n              } else {\n              }\n              break;\n            case 3 /* TopLevelReference */:\n            case 4 /* TopLevelRepositoryReference */:\n              const externalGrammarName = reference.scopeName;\n              const externalGrammarInclude = reference.kind === 4 /* TopLevelRepositoryReference */ ? reference.ruleName : null;\n              const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n              if (externalGrammar) {\n                if (externalGrammarInclude) {\n                  let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n                  if (externalIncludedRule) {\n                    ruleId = _RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n                  } else {\n                  }\n                } else {\n                  ruleId = _RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n                }\n              } else {\n              }\n              break;\n          }\n        } else {\n          ruleId = _RuleFactory.getCompiledRuleId(pattern, helper, repository);\n        }\n        if (ruleId !== -1) {\n          const rule = helper.getRule(ruleId);\n          let skipRule = false;\n          if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n            if (rule.hasMissingPatterns && rule.patterns.length === 0) {\n              skipRule = true;\n            }\n          }\n          if (skipRule) {\n            continue;\n          }\n          r.push(ruleId);\n        }\n      }\n    }\n    return {\n      patterns: r,\n      hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length\n    };\n  }\n};\nvar RegExpSource = class _RegExpSource {\n  source;\n  ruleId;\n  hasAnchor;\n  hasBackReferences;\n  _anchorCache;\n  constructor(regExpSource, ruleId) {\n    if (regExpSource && typeof regExpSource === \"string\") {\n      const len = regExpSource.length;\n      let lastPushedPos = 0;\n      let output = [];\n      let hasAnchor = false;\n      for (let pos = 0; pos < len; pos++) {\n        const ch = regExpSource.charAt(pos);\n        if (ch === \"\\\\\") {\n          if (pos + 1 < len) {\n            const nextCh = regExpSource.charAt(pos + 1);\n            if (nextCh === \"z\") {\n              output.push(regExpSource.substring(lastPushedPos, pos));\n              output.push(\"$(?!\\\\n)(?<!\\\\n)\");\n              lastPushedPos = pos + 2;\n            } else if (nextCh === \"A\" || nextCh === \"G\") {\n              hasAnchor = true;\n            }\n            pos++;\n          }\n        }\n      }\n      this.hasAnchor = hasAnchor;\n      if (lastPushedPos === 0) {\n        this.source = regExpSource;\n      } else {\n        output.push(regExpSource.substring(lastPushedPos, len));\n        this.source = output.join(\"\");\n      }\n    } else {\n      this.hasAnchor = false;\n      this.source = regExpSource;\n    }\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    } else {\n      this._anchorCache = null;\n    }\n    this.ruleId = ruleId;\n    if (typeof this.source === \"string\") {\n      this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n    } else {\n      this.hasBackReferences = false;\n    }\n  }\n  clone() {\n    return new _RegExpSource(this.source, this.ruleId);\n  }\n  setSource(newSource) {\n    if (this.source === newSource) {\n      return;\n    }\n    this.source = newSource;\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    }\n  }\n  resolveBackReferences(lineText, captureIndices) {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let capturedValues = captureIndices.map((capture) => {\n      return lineText.substring(capture.start, capture.end);\n    });\n    BACK_REFERENCING_END.lastIndex = 0;\n    return this.source.replace(BACK_REFERENCING_END, (match, g1) => {\n      return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || \"\");\n    });\n  }\n  _buildAnchorCache() {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let A0_G0_result = [];\n    let A0_G1_result = [];\n    let A1_G0_result = [];\n    let A1_G1_result = [];\n    let pos, len, ch, nextCh;\n    for (pos = 0, len = this.source.length; pos < len; pos++) {\n      ch = this.source.charAt(pos);\n      A0_G0_result[pos] = ch;\n      A0_G1_result[pos] = ch;\n      A1_G0_result[pos] = ch;\n      A1_G1_result[pos] = ch;\n      if (ch === \"\\\\\") {\n        if (pos + 1 < len) {\n          nextCh = this.source.charAt(pos + 1);\n          if (nextCh === \"A\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"\\uFFFF\";\n            A1_G0_result[pos + 1] = \"A\";\n            A1_G1_result[pos + 1] = \"A\";\n          } else if (nextCh === \"G\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"G\";\n            A1_G0_result[pos + 1] = \"\\uFFFF\";\n            A1_G1_result[pos + 1] = \"G\";\n          } else {\n            A0_G0_result[pos + 1] = nextCh;\n            A0_G1_result[pos + 1] = nextCh;\n            A1_G0_result[pos + 1] = nextCh;\n            A1_G1_result[pos + 1] = nextCh;\n          }\n          pos++;\n        }\n      }\n    }\n    return {\n      A0_G0: A0_G0_result.join(\"\"),\n      A0_G1: A0_G1_result.join(\"\"),\n      A1_G0: A1_G0_result.join(\"\"),\n      A1_G1: A1_G1_result.join(\"\")\n    };\n  }\n  resolveAnchors(allowA, allowG) {\n    if (!this.hasAnchor || !this._anchorCache || typeof this.source !== \"string\") {\n      return this.source;\n    }\n    if (allowA) {\n      if (allowG) {\n        return this._anchorCache.A1_G1;\n      } else {\n        return this._anchorCache.A1_G0;\n      }\n    } else {\n      if (allowG) {\n        return this._anchorCache.A0_G1;\n      } else {\n        return this._anchorCache.A0_G0;\n      }\n    }\n  }\n};\nvar RegExpSourceList = class {\n  _items;\n  _hasAnchors;\n  _cached;\n  _anchorCache;\n  constructor() {\n    this._items = [];\n    this._hasAnchors = false;\n    this._cached = null;\n    this._anchorCache = {\n      A0_G0: null,\n      A0_G1: null,\n      A1_G0: null,\n      A1_G1: null\n    };\n  }\n  dispose() {\n    this._disposeCaches();\n  }\n  _disposeCaches() {\n    if (this._cached) {\n      this._cached.dispose();\n      this._cached = null;\n    }\n    if (this._anchorCache.A0_G0) {\n      this._anchorCache.A0_G0.dispose();\n      this._anchorCache.A0_G0 = null;\n    }\n    if (this._anchorCache.A0_G1) {\n      this._anchorCache.A0_G1.dispose();\n      this._anchorCache.A0_G1 = null;\n    }\n    if (this._anchorCache.A1_G0) {\n      this._anchorCache.A1_G0.dispose();\n      this._anchorCache.A1_G0 = null;\n    }\n    if (this._anchorCache.A1_G1) {\n      this._anchorCache.A1_G1.dispose();\n      this._anchorCache.A1_G1 = null;\n    }\n  }\n  push(item) {\n    this._items.push(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  unshift(item) {\n    this._items.unshift(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  length() {\n    return this._items.length;\n  }\n  setSource(index, newSource) {\n    if (this._items[index].source !== newSource) {\n      this._disposeCaches();\n      this._items[index].setSource(newSource);\n    }\n  }\n  compile(onigLib) {\n    if (!this._cached) {\n      let regExps = this._items.map((e) => e.source);\n      this._cached = new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n    }\n    return this._cached;\n  }\n  compileAG(onigLib, allowA, allowG) {\n    if (!this._hasAnchors) {\n      return this.compile(onigLib);\n    } else {\n      if (allowA) {\n        if (allowG) {\n          if (!this._anchorCache.A1_G1) {\n            this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G1;\n        } else {\n          if (!this._anchorCache.A1_G0) {\n            this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G0;\n        }\n      } else {\n        if (allowG) {\n          if (!this._anchorCache.A0_G1) {\n            this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G1;\n        } else {\n          if (!this._anchorCache.A0_G0) {\n            this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G0;\n        }\n      }\n    }\n  }\n  _resolveAnchors(onigLib, allowA, allowG) {\n    let regExps = this._items.map((e) => e.resolveAnchors(allowA, allowG));\n    return new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n  }\n};\nvar CompiledRule = class {\n  constructor(onigLib, regExps, rules) {\n    this.regExps = regExps;\n    this.rules = rules;\n    this.scanner = onigLib.createOnigScanner(regExps);\n  }\n  scanner;\n  dispose() {\n    if (typeof this.scanner.dispose === \"function\") {\n      this.scanner.dispose();\n    }\n  }\n  toString() {\n    const r = [];\n    for (let i = 0, len = this.rules.length; i < len; i++) {\n      r.push(\"   - \" + this.rules[i] + \": \" + this.regExps[i]);\n    }\n    return r.join(\"\\n\");\n  }\n  findNextMatchSync(string, startPosition, options) {\n    const result = this.scanner.findNextMatchSync(string, startPosition, options);\n    if (!result) {\n      return null;\n    }\n    return {\n      ruleId: this.rules[result.index],\n      captureIndices: result.captureIndices\n    };\n  }\n};\n\n// src/grammar/basicScopesAttributeProvider.ts\nvar BasicScopeAttributes = class {\n  constructor(languageId, tokenType) {\n    this.languageId = languageId;\n    this.tokenType = tokenType;\n  }\n};\nvar BasicScopeAttributesProvider = class _BasicScopeAttributesProvider {\n  _defaultAttributes;\n  _embeddedLanguagesMatcher;\n  constructor(initialLanguageId, embeddedLanguages) {\n    this._defaultAttributes = new BasicScopeAttributes(initialLanguageId, 8 /* NotSet */);\n    this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));\n  }\n  getDefaultAttributes() {\n    return this._defaultAttributes;\n  }\n  getBasicScopeAttributes(scopeName) {\n    if (scopeName === null) {\n      return _BasicScopeAttributesProvider._NULL_SCOPE_METADATA;\n    }\n    return this._getBasicScopeAttributes.get(scopeName);\n  }\n  static _NULL_SCOPE_METADATA = new BasicScopeAttributes(0, 0);\n  _getBasicScopeAttributes = new CachedFn((scopeName) => {\n    const languageId = this._scopeToLanguage(scopeName);\n    const standardTokenType = this._toStandardTokenType(scopeName);\n    return new BasicScopeAttributes(languageId, standardTokenType);\n  });\n  /**\n   * Given a produced TM scope, return the language that token describes or null if unknown.\n   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n   */\n  _scopeToLanguage(scope) {\n    return this._embeddedLanguagesMatcher.match(scope) || 0;\n  }\n  _toStandardTokenType(scopeName) {\n    const m = scopeName.match(_BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n      return 8 /* NotSet */;\n    }\n    switch (m[1]) {\n      case \"comment\":\n        return 1 /* Comment */;\n      case \"string\":\n        return 2 /* String */;\n      case \"regex\":\n        return 3 /* RegEx */;\n      case \"meta.embedded\":\n        return 0 /* Other */;\n    }\n    throw new Error(\"Unexpected match for standard token type!\");\n  }\n  static STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\n};\nvar ScopeMatcher = class {\n  values;\n  scopesRegExp;\n  constructor(values) {\n    if (values.length === 0) {\n      this.values = null;\n      this.scopesRegExp = null;\n    } else {\n      this.values = new Map(values);\n      const escapedScopes = values.map(\n        ([scopeName, value]) => escapeRegExpCharacters(scopeName)\n      );\n      escapedScopes.sort();\n      escapedScopes.reverse();\n      this.scopesRegExp = new RegExp(\n        `^((${escapedScopes.join(\")|(\")}))($|\\\\.)`,\n        \"\"\n      );\n    }\n  }\n  match(scope) {\n    if (!this.scopesRegExp) {\n      return void 0;\n    }\n    const m = scope.match(this.scopesRegExp);\n    if (!m) {\n      return void 0;\n    }\n    return this.values.get(m[1]);\n  }\n};\n\n// src/debug.ts\nvar DebugFlags = {\n  InDebugMode: typeof process !== \"undefined\" && !!process.env[\"VSCODE_TEXTMATE_DEBUG\"]\n};\nvar UseOnigurumaFindOptions = false;\n\n// src/grammar/tokenizeString.ts\nvar TokenizeStringResult = class {\n  constructor(stack, stoppedEarly) {\n    this.stack = stack;\n    this.stoppedEarly = stoppedEarly;\n  }\n};\nfunction _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {\n  const lineLength = lineText.content.length;\n  let STOP = false;\n  let anchorPosition = -1;\n  if (checkWhileConditions) {\n    const whileCheckResult = _checkWhileConditions(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      lineTokens\n    );\n    stack = whileCheckResult.stack;\n    linePos = whileCheckResult.linePos;\n    isFirstLine = whileCheckResult.isFirstLine;\n    anchorPosition = whileCheckResult.anchorPosition;\n  }\n  const startTime = Date.now();\n  while (!STOP) {\n    if (timeLimit !== 0) {\n      const elapsedTime = Date.now() - startTime;\n      if (elapsedTime > timeLimit) {\n        return new TokenizeStringResult(stack, true);\n      }\n    }\n    scanNext();\n  }\n  return new TokenizeStringResult(stack, false);\n  function scanNext() {\n    if (false) {}\n    const r = matchRuleOrInjections(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      anchorPosition\n    );\n    if (!r) {\n      lineTokens.produce(stack, lineLength);\n      STOP = true;\n      return;\n    }\n    const captureIndices = r.captureIndices;\n    const matchedRuleId = r.matchedRuleId;\n    const hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : false;\n    if (matchedRuleId === endRuleId) {\n      const poppedRule = stack.getRule(grammar);\n      if (false) {}\n      lineTokens.produce(stack, captureIndices[0].start);\n      stack = stack.withContentNameScopesList(stack.nameScopesList);\n      handleCaptures(\n        grammar,\n        lineText,\n        isFirstLine,\n        stack,\n        lineTokens,\n        poppedRule.endCaptures,\n        captureIndices\n      );\n      lineTokens.produce(stack, captureIndices[0].end);\n      const popped = stack;\n      stack = stack.parent;\n      anchorPosition = popped.getAnchorPos();\n      if (!hasAdvanced && popped.getEnterPos() === linePos) {\n        if (false) {}\n        stack = popped;\n        lineTokens.produce(stack, lineLength);\n        STOP = true;\n        return;\n      }\n    } else {\n      const _rule = grammar.getRule(matchedRuleId);\n      lineTokens.produce(stack, captureIndices[0].start);\n      const beforePush = stack;\n      const scopeName = _rule.getName(lineText.content, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(\n        scopeName,\n        grammar\n      );\n      stack = stack.push(\n        matchedRuleId,\n        linePos,\n        anchorPosition,\n        captureIndices[0].end === lineLength,\n        null,\n        nameScopesList,\n        nameScopesList\n      );\n      if (_rule instanceof BeginEndRule) {\n        const pushedRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.endHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getEndWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {}\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else if (_rule instanceof BeginWhileRule) {\n        const pushedRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.whileHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getWhileWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {}\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else {\n        const matchingRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          matchingRule.captures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        stack = stack.pop();\n        if (!hasAdvanced) {\n          if (false) {}\n          stack = stack.safePop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      }\n    }\n    if (captureIndices[0].end > linePos) {\n      linePos = captureIndices[0].end;\n      isFirstLine = false;\n    }\n  }\n}\nfunction _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n  let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1;\n  const whileRules = [];\n  for (let node = stack; node; node = node.pop()) {\n    const nodeRule = node.getRule(grammar);\n    if (nodeRule instanceof BeginWhileRule) {\n      whileRules.push({\n        rule: nodeRule,\n        stack: node\n      });\n    }\n  }\n  for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n    const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);\n    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (false) {}\n    if (r) {\n      const matchedRuleId = r.ruleId;\n      if (matchedRuleId !== whileRuleId) {\n        stack = whileRule.stack.pop();\n        break;\n      }\n      if (r.captureIndices && r.captureIndices.length) {\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n        handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n        anchorPosition = r.captureIndices[0].end;\n        if (r.captureIndices[0].end > linePos) {\n          linePos = r.captureIndices[0].end;\n          isFirstLine = false;\n        }\n      }\n    } else {\n      if (false) {}\n      stack = whileRule.stack.pop();\n      break;\n    }\n  }\n  return { stack, linePos, anchorPosition, isFirstLine };\n}\nfunction matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  const injections = grammar.getInjections();\n  if (injections.length === 0) {\n    return matchResult;\n  }\n  const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  if (!injectionResult) {\n    return matchResult;\n  }\n  if (!matchResult) {\n    return injectionResult;\n  }\n  const matchResultScore = matchResult.captureIndices[0].start;\n  const injectionResultScore = injectionResult.captureIndices[0].start;\n  if (injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore) {\n    return injectionResult;\n  }\n  return matchResult;\n}\nfunction matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const rule = stack.getRule(grammar);\n  const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n  const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n  if (r) {\n    return {\n      captureIndices: r.captureIndices,\n      matchedRuleId: r.ruleId\n    };\n  }\n  return null;\n}\nfunction matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  let bestMatchRating = Number.MAX_VALUE;\n  let bestMatchCaptureIndices = null;\n  let bestMatchRuleId;\n  let bestMatchResultPriority = 0;\n  const scopes = stack.contentNameScopesList.getScopeNames();\n  for (let i = 0, len = injections.length; i < len; i++) {\n    const injection = injections[i];\n    if (!injection.matcher(scopes)) {\n      continue;\n    }\n    const rule = grammar.getRule(injection.ruleId);\n    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);\n    const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (!matchResult) {\n      continue;\n    }\n    if (false) {}\n    const matchRating = matchResult.captureIndices[0].start;\n    if (matchRating >= bestMatchRating) {\n      continue;\n    }\n    bestMatchRating = matchRating;\n    bestMatchCaptureIndices = matchResult.captureIndices;\n    bestMatchRuleId = matchResult.ruleId;\n    bestMatchResultPriority = injection.priority;\n    if (bestMatchRating === linePos) {\n      break;\n    }\n  }\n  if (bestMatchCaptureIndices) {\n    return {\n      priorityMatch: bestMatchResultPriority === -1,\n      captureIndices: bestMatchCaptureIndices,\n      matchedRuleId: bestMatchRuleId\n    };\n  }\n  return null;\n}\nfunction prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compileWhile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction getFindOptions(allowA, allowG) {\n  let options = 0 /* None */;\n  if (!allowA) {\n    options |= 1 /* NotBeginString */;\n  }\n  if (!allowG) {\n    options |= 4 /* NotBeginPosition */;\n  }\n  return options;\n}\nfunction handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {\n  if (captures.length === 0) {\n    return;\n  }\n  const lineTextContent = lineText.content;\n  const len = Math.min(captures.length, captureIndices.length);\n  const localStack = [];\n  const maxEnd = captureIndices[0].end;\n  for (let i = 0; i < len; i++) {\n    const captureRule = captures[i];\n    if (captureRule === null) {\n      continue;\n    }\n    const captureIndex = captureIndices[i];\n    if (captureIndex.length === 0) {\n      continue;\n    }\n    if (captureIndex.start > maxEnd) {\n      break;\n    }\n    while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n      localStack.pop();\n    }\n    if (localStack.length > 0) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n    } else {\n      lineTokens.produce(stack, captureIndex.start);\n    }\n    if (captureRule.retokenizeCapturedWithRuleId) {\n      const scopeName = captureRule.getName(lineTextContent, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n      const contentName = captureRule.getContentName(lineTextContent, captureIndices);\n      const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n      const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);\n      const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));\n      _tokenizeString(\n        grammar,\n        onigSubStr,\n        isFirstLine && captureIndex.start === 0,\n        captureIndex.start,\n        stackClone,\n        lineTokens,\n        false,\n        /* no time limit */\n        0\n      );\n      disposeOnigString(onigSubStr);\n      continue;\n    }\n    const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);\n    if (captureRuleScopeName !== null) {\n      const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n      const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);\n      localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n    }\n  }\n  while (localStack.length > 0) {\n    lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n    localStack.pop();\n  }\n}\nvar LocalStackElement = class {\n  scopes;\n  endPos;\n  constructor(scopes, endPos) {\n    this.scopes = scopes;\n    this.endPos = endPos;\n  }\n};\n\n// src/grammar/grammar.ts\nfunction createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {\n  return new Grammar(\n    scopeName,\n    grammar,\n    initialLanguage,\n    embeddedLanguages,\n    tokenTypes,\n    balancedBracketSelectors,\n    grammarRepository,\n    onigLib\n  );\n}\nfunction collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {\n  const matchers = createMatchers(selector, nameMatcher);\n  const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n  for (const matcher of matchers) {\n    result.push({\n      debugSelector: selector,\n      matcher: matcher.matcher,\n      ruleId,\n      grammar,\n      priority: matcher.priority\n    });\n  }\n}\nfunction nameMatcher(identifers, scopes) {\n  if (scopes.length < identifers.length) {\n    return false;\n  }\n  let lastIndex = 0;\n  return identifers.every((identifier) => {\n    for (let i = lastIndex; i < scopes.length; i++) {\n      if (scopesAreMatching(scopes[i], identifier)) {\n        lastIndex = i + 1;\n        return true;\n      }\n    }\n    return false;\n  });\n}\nfunction scopesAreMatching(thisScopeName, scopeName) {\n  if (!thisScopeName) {\n    return false;\n  }\n  if (thisScopeName === scopeName) {\n    return true;\n  }\n  const len = scopeName.length;\n  return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === \".\";\n}\nvar Grammar = class {\n  constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {\n    this._rootScopeName = _rootScopeName;\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._onigLib = _onigLib;\n    this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(\n      initialLanguage,\n      embeddedLanguages\n    );\n    this._rootId = -1;\n    this._lastRuleId = 0;\n    this._ruleId2desc = [null];\n    this._includedGrammars = {};\n    this._grammarRepository = grammarRepository;\n    this._grammar = initGrammar(grammar, null);\n    this._injections = null;\n    this._tokenTypeMatchers = [];\n    if (tokenTypes) {\n      for (const selector of Object.keys(tokenTypes)) {\n        const matchers = createMatchers(selector, nameMatcher);\n        for (const matcher of matchers) {\n          this._tokenTypeMatchers.push({\n            matcher: matcher.matcher,\n            type: tokenTypes[selector]\n          });\n        }\n      }\n    }\n  }\n  _rootId;\n  _lastRuleId;\n  _ruleId2desc;\n  _includedGrammars;\n  _grammarRepository;\n  _grammar;\n  _injections;\n  _basicScopeAttributesProvider;\n  _tokenTypeMatchers;\n  get themeProvider() {\n    return this._grammarRepository;\n  }\n  dispose() {\n    for (const rule of this._ruleId2desc) {\n      if (rule) {\n        rule.dispose();\n      }\n    }\n  }\n  createOnigScanner(sources) {\n    return this._onigLib.createOnigScanner(sources);\n  }\n  createOnigString(sources) {\n    return this._onigLib.createOnigString(sources);\n  }\n  getMetadataForScope(scope) {\n    return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);\n  }\n  _collectInjections() {\n    const grammarRepository = {\n      lookup: (scopeName2) => {\n        if (scopeName2 === this._rootScopeName) {\n          return this._grammar;\n        }\n        return this.getExternalGrammar(scopeName2);\n      },\n      injections: (scopeName2) => {\n        return this._grammarRepository.injections(scopeName2);\n      }\n    };\n    const result = [];\n    const scopeName = this._rootScopeName;\n    const grammar = grammarRepository.lookup(scopeName);\n    if (grammar) {\n      const rawInjections = grammar.injections;\n      if (rawInjections) {\n        for (let expression in rawInjections) {\n          collectInjections(\n            result,\n            expression,\n            rawInjections[expression],\n            this,\n            grammar\n          );\n        }\n      }\n      const injectionScopeNames = this._grammarRepository.injections(scopeName);\n      if (injectionScopeNames) {\n        injectionScopeNames.forEach((injectionScopeName) => {\n          const injectionGrammar = this.getExternalGrammar(injectionScopeName);\n          if (injectionGrammar) {\n            const selector = injectionGrammar.injectionSelector;\n            if (selector) {\n              collectInjections(\n                result,\n                selector,\n                injectionGrammar,\n                this,\n                injectionGrammar\n              );\n            }\n          }\n        });\n      }\n    }\n    result.sort((i1, i2) => i1.priority - i2.priority);\n    return result;\n  }\n  getInjections() {\n    if (this._injections === null) {\n      this._injections = this._collectInjections();\n    }\n    return this._injections;\n  }\n  registerRule(factory) {\n    const id = ++this._lastRuleId;\n    const result = factory(ruleIdFromNumber(id));\n    this._ruleId2desc[id] = result;\n    return result;\n  }\n  getRule(ruleId) {\n    return this._ruleId2desc[ruleIdToNumber(ruleId)];\n  }\n  getExternalGrammar(scopeName, repository) {\n    if (this._includedGrammars[scopeName]) {\n      return this._includedGrammars[scopeName];\n    } else if (this._grammarRepository) {\n      const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n      if (rawIncludedGrammar) {\n        this._includedGrammars[scopeName] = initGrammar(\n          rawIncludedGrammar,\n          repository && repository.$base\n        );\n        return this._includedGrammars[scopeName];\n      }\n    }\n    return void 0;\n  }\n  tokenizeLine(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, false, timeLimit);\n    return {\n      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  tokenizeLine2(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, true, timeLimit);\n    return {\n      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {\n    if (this._rootId === -1) {\n      this._rootId = RuleFactory.getCompiledRuleId(\n        this._grammar.repository.$self,\n        this,\n        this._grammar.repository\n      );\n      this.getInjections();\n    }\n    let isFirstLine;\n    if (!prevState || prevState === StateStackImpl.NULL) {\n      isFirstLine = true;\n      const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();\n      const defaultStyle = this.themeProvider.getDefaults();\n      const defaultMetadata = EncodedTokenMetadata.set(\n        0,\n        rawDefaultMetadata.languageId,\n        rawDefaultMetadata.tokenType,\n        null,\n        defaultStyle.fontStyle,\n        defaultStyle.foregroundId,\n        defaultStyle.backgroundId\n      );\n      const rootScopeName = this.getRule(this._rootId).getName(\n        null,\n        null\n      );\n      let scopeList;\n      if (rootScopeName) {\n        scopeList = AttributedScopeStack.createRootAndLookUpScopeName(\n          rootScopeName,\n          defaultMetadata,\n          this\n        );\n      } else {\n        scopeList = AttributedScopeStack.createRoot(\n          \"unknown\",\n          defaultMetadata\n        );\n      }\n      prevState = new StateStackImpl(\n        null,\n        this._rootId,\n        -1,\n        -1,\n        false,\n        null,\n        scopeList,\n        scopeList\n      );\n    } else {\n      isFirstLine = false;\n      prevState.reset();\n    }\n    lineText = lineText + \"\\n\";\n    const onigLineText = this.createOnigString(lineText);\n    const lineLength = onigLineText.content.length;\n    const lineTokens = new LineTokens(\n      emitBinaryTokens,\n      lineText,\n      this._tokenTypeMatchers,\n      this.balancedBracketSelectors\n    );\n    const r = _tokenizeString(\n      this,\n      onigLineText,\n      isFirstLine,\n      0,\n      prevState,\n      lineTokens,\n      true,\n      timeLimit\n    );\n    disposeOnigString(onigLineText);\n    return {\n      lineLength,\n      lineTokens,\n      ruleStack: r.stack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n};\nfunction initGrammar(grammar, base) {\n  grammar = clone(grammar);\n  grammar.repository = grammar.repository || {};\n  grammar.repository.$self = {\n    $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n    patterns: grammar.patterns,\n    name: grammar.scopeName\n  };\n  grammar.repository.$base = base || grammar.repository.$self;\n  return grammar;\n}\nvar AttributedScopeStack = class _AttributedScopeStack {\n  /**\n   * Invariant:\n   * ```\n   * if (parent && !scopePath.extends(parent.scopePath)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, scopePath, tokenAttributes) {\n    this.parent = parent;\n    this.scopePath = scopePath;\n    this.tokenAttributes = tokenAttributes;\n  }\n  static fromExtension(namesScopeList, contentNameScopesList) {\n    let current = namesScopeList;\n    let scopeNames = namesScopeList?.scopePath ?? null;\n    for (const frame of contentNameScopesList) {\n      scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);\n      current = new _AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);\n    }\n    return current;\n  }\n  static createRoot(scopeName, tokenAttributes) {\n    return new _AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);\n  }\n  static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {\n    const rawRootMetadata = grammar.getMetadataForScope(scopeName);\n    const scopePath = new ScopeStack(null, scopeName);\n    const rootStyle = grammar.themeProvider.themeMatch(scopePath);\n    const resolvedTokenAttributes = _AttributedScopeStack.mergeAttributes(\n      tokenAttributes,\n      rawRootMetadata,\n      rootStyle\n    );\n    return new _AttributedScopeStack(null, scopePath, resolvedTokenAttributes);\n  }\n  get scopeName() {\n    return this.scopePath.scopeName;\n  }\n  toString() {\n    return this.getScopeNames().join(\" \");\n  }\n  equals(other) {\n    return _AttributedScopeStack.equals(this, other);\n  }\n  static equals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {\n    let fontStyle = -1 /* NotSet */;\n    let foreground = 0;\n    let background = 0;\n    if (styleAttributes !== null) {\n      fontStyle = styleAttributes.fontStyle;\n      foreground = styleAttributes.foregroundId;\n      background = styleAttributes.backgroundId;\n    }\n    return EncodedTokenMetadata.set(\n      existingTokenAttributes,\n      basicScopeAttributes.languageId,\n      basicScopeAttributes.tokenType,\n      null,\n      fontStyle,\n      foreground,\n      background\n    );\n  }\n  pushAttributed(scopePath, grammar) {\n    if (scopePath === null) {\n      return this;\n    }\n    if (scopePath.indexOf(\" \") === -1) {\n      return _AttributedScopeStack._pushAttributed(this, scopePath, grammar);\n    }\n    const scopes = scopePath.split(/ /g);\n    let result = this;\n    for (const scope of scopes) {\n      result = _AttributedScopeStack._pushAttributed(result, scope, grammar);\n    }\n    return result;\n  }\n  static _pushAttributed(target, scopeName, grammar) {\n    const rawMetadata = grammar.getMetadataForScope(scopeName);\n    const newPath = target.scopePath.push(scopeName);\n    const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);\n    const metadata = _AttributedScopeStack.mergeAttributes(\n      target.tokenAttributes,\n      rawMetadata,\n      scopeThemeMatchResult\n    );\n    return new _AttributedScopeStack(target, newPath, metadata);\n  }\n  getScopeNames() {\n    return this.scopePath.getSegments();\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let self = this;\n    while (self && self !== base) {\n      result.push({\n        encodedTokenAttributes: self.tokenAttributes,\n        scopeNames: self.scopePath.getExtensionIfDefined(self.parent?.scopePath ?? null)\n      });\n      self = self.parent;\n    }\n    return self === base ? result.reverse() : void 0;\n  }\n};\nvar StateStackImpl = class _StateStackImpl {\n  /**\n   * Invariant:\n   * ```\n   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {\n   * \tthrow new Error();\n   * }\n   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    this.parent = parent;\n    this.ruleId = ruleId;\n    this.beginRuleCapturedEOL = beginRuleCapturedEOL;\n    this.endRule = endRule;\n    this.nameScopesList = nameScopesList;\n    this.contentNameScopesList = contentNameScopesList;\n    this.depth = this.parent ? this.parent.depth + 1 : 1;\n    this._enterPos = enterPos;\n    this._anchorPos = anchorPos;\n  }\n  _stackElementBrand = void 0;\n  // TODO remove me\n  static NULL = new _StateStackImpl(\n    null,\n    0,\n    0,\n    0,\n    false,\n    null,\n    null,\n    null\n  );\n  /**\n   * The position on the current line where this state was pushed.\n   * This is relevant only while tokenizing a line, to detect endless loops.\n   * Its value is meaningless across lines.\n   */\n  _enterPos;\n  /**\n   * The captured anchor position when this stack element was pushed.\n   * This is relevant only while tokenizing a line, to restore the anchor position when popping.\n   * Its value is meaningless across lines.\n   */\n  _anchorPos;\n  /**\n   * The depth of the stack.\n   */\n  depth;\n  equals(other) {\n    if (other === null) {\n      return false;\n    }\n    return _StateStackImpl._equals(this, other);\n  }\n  static _equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (!this._structuralEquals(a, b)) {\n      return false;\n    }\n    return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);\n  }\n  /**\n   * A structural equals check. Does not take into account `scopes`.\n   */\n  static _structuralEquals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  clone() {\n    return this;\n  }\n  static _reset(el) {\n    while (el) {\n      el._enterPos = -1;\n      el._anchorPos = -1;\n      el = el.parent;\n    }\n  }\n  reset() {\n    _StateStackImpl._reset(this);\n  }\n  pop() {\n    return this.parent;\n  }\n  safePop() {\n    if (this.parent) {\n      return this.parent;\n    }\n    return this;\n  }\n  push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    return new _StateStackImpl(\n      this,\n      ruleId,\n      enterPos,\n      anchorPos,\n      beginRuleCapturedEOL,\n      endRule,\n      nameScopesList,\n      contentNameScopesList\n    );\n  }\n  getEnterPos() {\n    return this._enterPos;\n  }\n  getAnchorPos() {\n    return this._anchorPos;\n  }\n  getRule(grammar) {\n    return grammar.getRule(this.ruleId);\n  }\n  toString() {\n    const r = [];\n    this._writeString(r, 0);\n    return \"[\" + r.join(\",\") + \"]\";\n  }\n  _writeString(res, outIndex) {\n    if (this.parent) {\n      outIndex = this.parent._writeString(res, outIndex);\n    }\n    res[outIndex++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`;\n    return outIndex;\n  }\n  withContentNameScopesList(contentNameScopeStack) {\n    if (this.contentNameScopesList === contentNameScopeStack) {\n      return this;\n    }\n    return this.parent.push(\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      this.endRule,\n      this.nameScopesList,\n      contentNameScopeStack\n    );\n  }\n  withEndRule(endRule) {\n    if (this.endRule === endRule) {\n      return this;\n    }\n    return new _StateStackImpl(\n      this.parent,\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      endRule,\n      this.nameScopesList,\n      this.contentNameScopesList\n    );\n  }\n  // Used to warn of endless loops\n  hasSameRuleAs(other) {\n    let el = this;\n    while (el && el._enterPos === other._enterPos) {\n      if (el.ruleId === other.ruleId) {\n        return true;\n      }\n      el = el.parent;\n    }\n    return false;\n  }\n  toStateStackFrame() {\n    return {\n      ruleId: ruleIdToNumber(this.ruleId),\n      beginRuleCapturedEOL: this.beginRuleCapturedEOL,\n      endRule: this.endRule,\n      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],\n      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []\n    };\n  }\n  static pushFrame(self, frame) {\n    const namesScopeList = AttributedScopeStack.fromExtension(self?.nameScopesList ?? null, frame.nameScopesList);\n    return new _StateStackImpl(\n      self,\n      ruleIdFromNumber(frame.ruleId),\n      frame.enterPos ?? -1,\n      frame.anchorPos ?? -1,\n      frame.beginRuleCapturedEOL,\n      frame.endRule,\n      namesScopeList,\n      AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList)\n    );\n  }\n};\nvar BalancedBracketSelectors = class {\n  balancedBracketScopes;\n  unbalancedBracketScopes;\n  allowAny = false;\n  constructor(balancedBracketScopes, unbalancedBracketScopes) {\n    this.balancedBracketScopes = balancedBracketScopes.flatMap(\n      (selector) => {\n        if (selector === \"*\") {\n          this.allowAny = true;\n          return [];\n        }\n        return createMatchers(selector, nameMatcher).map((m) => m.matcher);\n      }\n    );\n    this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap(\n      (selector) => createMatchers(selector, nameMatcher).map((m) => m.matcher)\n    );\n  }\n  get matchesAlways() {\n    return this.allowAny && this.unbalancedBracketScopes.length === 0;\n  }\n  get matchesNever() {\n    return this.balancedBracketScopes.length === 0 && !this.allowAny;\n  }\n  match(scopes) {\n    for (const excluder of this.unbalancedBracketScopes) {\n      if (excluder(scopes)) {\n        return false;\n      }\n    }\n    for (const includer of this.balancedBracketScopes) {\n      if (includer(scopes)) {\n        return true;\n      }\n    }\n    return this.allowAny;\n  }\n};\nvar LineTokens = class {\n  constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._emitBinaryTokens = emitBinaryTokens;\n    this._tokenTypeOverrides = tokenTypeOverrides;\n    if (false) {} else {\n      this._lineText = null;\n    }\n    this._tokens = [];\n    this._binaryTokens = [];\n    this._lastTokenEndIndex = 0;\n  }\n  _emitBinaryTokens;\n  /**\n   * defined only if `false`.\n   */\n  _lineText;\n  /**\n   * used only if `_emitBinaryTokens` is false.\n   */\n  _tokens;\n  /**\n   * used only if `_emitBinaryTokens` is true.\n   */\n  _binaryTokens;\n  _lastTokenEndIndex;\n  _tokenTypeOverrides;\n  produce(stack, endIndex) {\n    this.produceFromScopes(stack.contentNameScopesList, endIndex);\n  }\n  produceFromScopes(scopesList, endIndex) {\n    if (this._lastTokenEndIndex >= endIndex) {\n      return;\n    }\n    if (this._emitBinaryTokens) {\n      let metadata = scopesList?.tokenAttributes ?? 0;\n      let containsBalancedBrackets = false;\n      if (this.balancedBracketSelectors?.matchesAlways) {\n        containsBalancedBrackets = true;\n      }\n      if (this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {\n        const scopes2 = scopesList?.getScopeNames() ?? [];\n        for (const tokenType of this._tokenTypeOverrides) {\n          if (tokenType.matcher(scopes2)) {\n            metadata = EncodedTokenMetadata.set(\n              metadata,\n              0,\n              toOptionalTokenType(tokenType.type),\n              null,\n              -1 /* NotSet */,\n              0,\n              0\n            );\n          }\n        }\n        if (this.balancedBracketSelectors) {\n          containsBalancedBrackets = this.balancedBracketSelectors.match(scopes2);\n        }\n      }\n      if (containsBalancedBrackets) {\n        metadata = EncodedTokenMetadata.set(\n          metadata,\n          0,\n          8 /* NotSet */,\n          containsBalancedBrackets,\n          -1 /* NotSet */,\n          0,\n          0\n        );\n      }\n      if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n        this._lastTokenEndIndex = endIndex;\n        return;\n      }\n      this._binaryTokens.push(this._lastTokenEndIndex);\n      this._binaryTokens.push(metadata);\n      this._lastTokenEndIndex = endIndex;\n      return;\n    }\n    const scopes = scopesList?.getScopeNames() ?? [];\n    this._tokens.push({\n      startIndex: this._lastTokenEndIndex,\n      endIndex,\n      // value: lineText.substring(lastTokenEndIndex, endIndex),\n      scopes\n    });\n    this._lastTokenEndIndex = endIndex;\n  }\n  getResult(stack, lineLength) {\n    if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n      this._tokens.pop();\n    }\n    if (this._tokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._tokens[this._tokens.length - 1].startIndex = 0;\n    }\n    return this._tokens;\n  }\n  getBinaryResult(stack, lineLength) {\n    if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n      this._binaryTokens.pop();\n      this._binaryTokens.pop();\n    }\n    if (this._binaryTokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._binaryTokens[this._binaryTokens.length - 2] = 0;\n    }\n    const result = new Uint32Array(this._binaryTokens.length);\n    for (let i = 0, len = this._binaryTokens.length; i < len; i++) {\n      result[i] = this._binaryTokens[i];\n    }\n    return result;\n  }\n};\n\n// src/registry.ts\nvar SyncRegistry = class {\n  constructor(theme, _onigLib) {\n    this._onigLib = _onigLib;\n    this._theme = theme;\n  }\n  _grammars = /* @__PURE__ */ new Map();\n  _rawGrammars = /* @__PURE__ */ new Map();\n  _injectionGrammars = /* @__PURE__ */ new Map();\n  _theme;\n  dispose() {\n    for (const grammar of this._grammars.values()) {\n      grammar.dispose();\n    }\n  }\n  setTheme(theme) {\n    this._theme = theme;\n  }\n  getColorMap() {\n    return this._theme.getColorMap();\n  }\n  /**\n   * Add `grammar` to registry and return a list of referenced scope names\n   */\n  addGrammar(grammar, injectionScopeNames) {\n    this._rawGrammars.set(grammar.scopeName, grammar);\n    if (injectionScopeNames) {\n      this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);\n    }\n  }\n  /**\n   * Lookup a raw grammar.\n   */\n  lookup(scopeName) {\n    return this._rawGrammars.get(scopeName);\n  }\n  /**\n   * Returns the injections for the given grammar\n   */\n  injections(targetScope) {\n    return this._injectionGrammars.get(targetScope);\n  }\n  /**\n   * Get the default theme settings\n   */\n  getDefaults() {\n    return this._theme.getDefaults();\n  }\n  /**\n   * Match a scope in the theme.\n   */\n  themeMatch(scopePath) {\n    return this._theme.match(scopePath);\n  }\n  /**\n   * Lookup a grammar.\n   */\n  grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    if (!this._grammars.has(scopeName)) {\n      let rawGrammar = this._rawGrammars.get(scopeName);\n      if (!rawGrammar) {\n        return null;\n      }\n      this._grammars.set(scopeName, createGrammar(\n        scopeName,\n        rawGrammar,\n        initialLanguage,\n        embeddedLanguages,\n        tokenTypes,\n        balancedBracketSelectors,\n        this,\n        this._onigLib\n      ));\n    }\n    return this._grammars.get(scopeName);\n  }\n};\n\n// src/index.ts\nvar Registry = class {\n  _options;\n  _syncRegistry;\n  _ensureGrammarCache;\n  constructor(options) {\n    this._options = options;\n    this._syncRegistry = new SyncRegistry(\n      Theme.createFromRawTheme(options.theme, options.colorMap),\n      options.onigLib\n    );\n    this._ensureGrammarCache = /* @__PURE__ */ new Map();\n  }\n  dispose() {\n    this._syncRegistry.dispose();\n  }\n  /**\n   * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n   */\n  setTheme(theme, colorMap) {\n    this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));\n  }\n  /**\n   * Returns a lookup array for color ids.\n   */\n  getColorMap() {\n    return this._syncRegistry.getColorMap();\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {\n    return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {\n    return this._loadGrammar(\n      initialScopeName,\n      initialLanguage,\n      configuration.embeddedLanguages,\n      configuration.tokenTypes,\n      new BalancedBracketSelectors(\n        configuration.balancedBracketSelectors || [],\n        configuration.unbalancedBracketSelectors || []\n      )\n    );\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   */\n  loadGrammar(initialScopeName) {\n    return this._loadGrammar(initialScopeName, 0, null, null, null);\n  }\n  _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);\n    while (dependencyProcessor.Q.length > 0) {\n      dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName));\n      dependencyProcessor.processQueue();\n    }\n    return this._grammarForScopeName(\n      initialScopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n  _loadSingleGrammar(scopeName) {\n    if (!this._ensureGrammarCache.has(scopeName)) {\n      this._doLoadSingleGrammar(scopeName);\n      this._ensureGrammarCache.set(scopeName, true);\n    }\n  }\n  _doLoadSingleGrammar(scopeName) {\n    const grammar = this._options.loadGrammar(scopeName);\n    if (grammar) {\n      const injections = typeof this._options.getInjections === \"function\" ? this._options.getInjections(scopeName) : void 0;\n      this._syncRegistry.addGrammar(grammar, injections);\n    }\n  }\n  /**\n   * Adds a rawGrammar.\n   */\n  addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {\n    this._syncRegistry.addGrammar(rawGrammar, injections);\n    return this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);\n  }\n  /**\n   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.\n   */\n  _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {\n    return this._syncRegistry.grammarForScopeName(\n      scopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n};\nvar INITIAL = StateStackImpl.NULL;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcyt2c2NvZGUtdGV4dG1hdGVAMTAuMC4xL25vZGVfbW9kdWxlcy9Ac2hpa2lqcy92c2NvZGUtdGV4dG1hdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sc0JBQXNCLE9BQU87QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSyxFQUFFLEVBS1Y7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUssRUFBRSxFQUlWO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUssRUFBRSxFQUlWO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyxFQUFFLEVBSVY7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLLEVBQUUsRUFJVjtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxZQUFZLEtBQUssRUFBRSxFQUVWO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxFQUFFLEVBSVY7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsWUFBWSxLQUFLLEVBQUUsRUFJVjtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxFQUFFLEVBSVY7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BELFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0EsUUFBUSxLQUFLLEVBQUUsRUFHVjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFVBQVUsS0FBSyxFQUFFLEVBRVY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLLEVBQUUsRUFHVjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZLElBQUksZ0NBQWdDLElBQUksdUNBQXVDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSyxFQUFFLEVBRVYsQ0FBQztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsbUJBQW1CO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTRSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcyt2c2NvZGUtdGV4dG1hdGVAMTAuMC4xL25vZGVfbW9kdWxlcy9Ac2hpa2lqcy92c2NvZGUtdGV4dG1hdGUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIGNsb25lKHNvbWV0aGluZykge1xuICByZXR1cm4gZG9DbG9uZShzb21ldGhpbmcpO1xufVxuZnVuY3Rpb24gZG9DbG9uZShzb21ldGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc29tZXRoaW5nKSkge1xuICAgIHJldHVybiBjbG9uZUFycmF5KHNvbWV0aGluZyk7XG4gIH1cbiAgaWYgKHNvbWV0aGluZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBzb21ldGhpbmc7XG4gIH1cbiAgaWYgKHR5cGVvZiBzb21ldGhpbmcgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gY2xvbmVPYmooc29tZXRoaW5nKTtcbiAgfVxuICByZXR1cm4gc29tZXRoaW5nO1xufVxuZnVuY3Rpb24gY2xvbmVBcnJheShhcnIpIHtcbiAgbGV0IHIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJbaV0gPSBkb0Nsb25lKGFycltpXSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBjbG9uZU9iaihvYmopIHtcbiAgbGV0IHIgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgIHJba2V5XSA9IGRvQ2xvbmUob2JqW2tleV0pO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKHRhcmdldCwgLi4uc291cmNlcykge1xuICBzb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgY29uc3QgaWR4ID0gfnBhdGgubGFzdEluZGV4T2YoXCIvXCIpIHx8IH5wYXRoLmxhc3RJbmRleE9mKFwiXFxcXFwiKTtcbiAgaWYgKGlkeCA9PT0gMCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9IGVsc2UgaWYgKH5pZHggPT09IHBhdGgubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBiYXNlbmFtZShwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aC5zdWJzdHIofmlkeCArIDEpO1xuICB9XG59XG52YXIgQ0FQVFVSSU5HX1JFR0VYX1NPVVJDRSA9IC9cXCQoXFxkKyl8XFwkeyhcXGQrKTpcXC8oZG93bmNhc2V8dXBjYXNlKX0vZztcbnZhciBSZWdleFNvdXJjZSA9IGNsYXNzIHtcbiAgc3RhdGljIGhhc0NhcHR1cmVzKHJlZ2V4U291cmNlKSB7XG4gICAgaWYgKHJlZ2V4U291cmNlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIENBUFRVUklOR19SRUdFWF9TT1VSQ0UubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gQ0FQVFVSSU5HX1JFR0VYX1NPVVJDRS50ZXN0KHJlZ2V4U291cmNlKTtcbiAgfVxuICBzdGF0aWMgcmVwbGFjZUNhcHR1cmVzKHJlZ2V4U291cmNlLCBjYXB0dXJlU291cmNlLCBjYXB0dXJlSW5kaWNlcykge1xuICAgIHJldHVybiByZWdleFNvdXJjZS5yZXBsYWNlKENBUFRVUklOR19SRUdFWF9TT1VSQ0UsIChtYXRjaCwgaW5kZXgsIGNvbW1hbmRJbmRleCwgY29tbWFuZCkgPT4ge1xuICAgICAgbGV0IGNhcHR1cmUgPSBjYXB0dXJlSW5kaWNlc1twYXJzZUludChpbmRleCB8fCBjb21tYW5kSW5kZXgsIDEwKV07XG4gICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gY2FwdHVyZVNvdXJjZS5zdWJzdHJpbmcoY2FwdHVyZS5zdGFydCwgY2FwdHVyZS5lbmQpO1xuICAgICAgICB3aGlsZSAocmVzdWx0WzBdID09PSBcIi5cIikge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgY2FzZSBcImRvd25jYXNlXCI6XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgY2FzZSBcInVwY2FzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzdHJjbXAoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBzdHJBcnJDbXAoYSwgYikge1xuICBpZiAoYSA9PT0gbnVsbCAmJiBiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKCFhKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICghYikge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGxldCBsZW4xID0gYS5sZW5ndGg7XG4gIGxldCBsZW4yID0gYi5sZW5ndGg7XG4gIGlmIChsZW4xID09PSBsZW4yKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICAgIGxldCByZXMgPSBzdHJjbXAoYVtpXSwgYltpXSk7XG4gICAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBsZW4xIC0gbGVuMjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRIZXhDb2xvcihoZXgpIHtcbiAgaWYgKC9eI1swLTlhLWZdezZ9JC9pLnRlc3QoaGV4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgvXiNbMC05YS1mXXs4fSQvaS50ZXN0KGhleCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoL14jWzAtOWEtZl17M30kL2kudGVzdChoZXgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKC9eI1swLTlhLWZdezR9JC9pLnRlc3QoaGV4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cENoYXJhY3RlcnModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFxcXFx7XFx9XFwqXFwrXFw/XFx8XFxeXFwkXFwuXFwsXFxbXFxdXFwoXFwpXFwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cbnZhciBDYWNoZWRGbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZm4pIHtcbiAgICB0aGlzLmZuID0gZm47XG4gIH1cbiAgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBnZXQoa2V5KSB7XG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZm4oa2V5KTtcbiAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy90aGVtZS50c1xudmFyIFRoZW1lID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfY29sb3JNYXAsIF9kZWZhdWx0cywgX3Jvb3QpIHtcbiAgICB0aGlzLl9jb2xvck1hcCA9IF9jb2xvck1hcDtcbiAgICB0aGlzLl9kZWZhdWx0cyA9IF9kZWZhdWx0cztcbiAgICB0aGlzLl9yb290ID0gX3Jvb3Q7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUZyb21SYXdUaGVtZShzb3VyY2UsIGNvbG9yTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRnJvbVBhcnNlZFRoZW1lKHBhcnNlVGhlbWUoc291cmNlKSwgY29sb3JNYXApO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVGcm9tUGFyc2VkVGhlbWUoc291cmNlLCBjb2xvck1hcCkge1xuICAgIHJldHVybiByZXNvbHZlUGFyc2VkVGhlbWVSdWxlcyhzb3VyY2UsIGNvbG9yTWFwKTtcbiAgfVxuICBfY2FjaGVkTWF0Y2hSb290ID0gbmV3IENhY2hlZEZuKFxuICAgIChzY29wZU5hbWUpID0+IHRoaXMuX3Jvb3QubWF0Y2goc2NvcGVOYW1lKVxuICApO1xuICBnZXRDb2xvck1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3JNYXAuZ2V0Q29sb3JNYXAoKTtcbiAgfVxuICBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHM7XG4gIH1cbiAgbWF0Y2goc2NvcGVQYXRoKSB7XG4gICAgaWYgKHNjb3BlUGF0aCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzO1xuICAgIH1cbiAgICBjb25zdCBzY29wZU5hbWUgPSBzY29wZVBhdGguc2NvcGVOYW1lO1xuICAgIGNvbnN0IG1hdGNoaW5nVHJpZUVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWF0Y2hSb290LmdldChzY29wZU5hbWUpO1xuICAgIGNvbnN0IGVmZmVjdGl2ZVJ1bGUgPSBtYXRjaGluZ1RyaWVFbGVtZW50cy5maW5kKFxuICAgICAgKHYpID0+IF9zY29wZVBhdGhNYXRjaGVzUGFyZW50U2NvcGVzKHNjb3BlUGF0aC5wYXJlbnQsIHYucGFyZW50U2NvcGVzKVxuICAgICk7XG4gICAgaWYgKCFlZmZlY3RpdmVSdWxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHlsZUF0dHJpYnV0ZXMoXG4gICAgICBlZmZlY3RpdmVSdWxlLmZvbnRTdHlsZSxcbiAgICAgIGVmZmVjdGl2ZVJ1bGUuZm9yZWdyb3VuZCxcbiAgICAgIGVmZmVjdGl2ZVJ1bGUuYmFja2dyb3VuZFxuICAgICk7XG4gIH1cbn07XG52YXIgU2NvcGVTdGFjayA9IGNsYXNzIF9TY29wZVN0YWNrIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBzY29wZU5hbWUpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgfVxuICBzdGF0aWMgcHVzaChwYXRoLCBzY29wZU5hbWVzKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNjb3BlTmFtZXMpIHtcbiAgICAgIHBhdGggPSBuZXcgX1Njb3BlU3RhY2socGF0aCwgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIHN0YXRpYyBmcm9tKC4uLnNlZ21lbnRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ID0gbmV3IF9TY29wZVN0YWNrKHJlc3VsdCwgc2VnbWVudHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHB1c2goc2NvcGVOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfU2NvcGVTdGFjayh0aGlzLCBzY29wZU5hbWUpO1xuICB9XG4gIGdldFNlZ21lbnRzKCkge1xuICAgIGxldCBpdGVtID0gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgcmVzdWx0LnB1c2goaXRlbS5zY29wZU5hbWUpO1xuICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50O1xuICAgIH1cbiAgICByZXN1bHQucmV2ZXJzZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VnbWVudHMoKS5qb2luKFwiIFwiKTtcbiAgfVxuICBleHRlbmRzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcmVudC5leHRlbmRzKG90aGVyKTtcbiAgfVxuICBnZXRFeHRlbnNpb25JZkRlZmluZWQoYmFzZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpdGVtID0gdGhpcztcbiAgICB3aGlsZSAoaXRlbSAmJiBpdGVtICE9PSBiYXNlKSB7XG4gICAgICByZXN1bHQucHVzaChpdGVtLnNjb3BlTmFtZSk7XG4gICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBpdGVtID09PSBiYXNlID8gcmVzdWx0LnJldmVyc2UoKSA6IHZvaWQgMDtcbiAgfVxufTtcbmZ1bmN0aW9uIF9zY29wZVBhdGhNYXRjaGVzUGFyZW50U2NvcGVzKHNjb3BlUGF0aCwgcGFyZW50U2NvcGVzKSB7XG4gIGlmIChwYXJlbnRTY29wZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhcmVudFNjb3Blcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgc2NvcGVQYXR0ZXJuID0gcGFyZW50U2NvcGVzW2luZGV4XTtcbiAgICBsZXQgc2NvcGVNdXN0TWF0Y2ggPSBmYWxzZTtcbiAgICBpZiAoc2NvcGVQYXR0ZXJuID09PSBcIj5cIikge1xuICAgICAgaWYgKGluZGV4ID09PSBwYXJlbnRTY29wZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzY29wZVBhdHRlcm4gPSBwYXJlbnRTY29wZXNbKytpbmRleF07XG4gICAgICBzY29wZU11c3RNYXRjaCA9IHRydWU7XG4gICAgfVxuICAgIHdoaWxlIChzY29wZVBhdGgpIHtcbiAgICAgIGlmIChfbWF0Y2hlc1Njb3BlKHNjb3BlUGF0aC5zY29wZU5hbWUsIHNjb3BlUGF0dGVybikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGVNdXN0TWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc2NvcGVQYXRoID0gc2NvcGVQYXRoLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFzY29wZVBhdGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2NvcGVQYXRoID0gc2NvcGVQYXRoLnBhcmVudDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIF9tYXRjaGVzU2NvcGUoc2NvcGVOYW1lLCBzY29wZVBhdHRlcm4pIHtcbiAgcmV0dXJuIHNjb3BlUGF0dGVybiA9PT0gc2NvcGVOYW1lIHx8IHNjb3BlTmFtZS5zdGFydHNXaXRoKHNjb3BlUGF0dGVybikgJiYgc2NvcGVOYW1lW3Njb3BlUGF0dGVybi5sZW5ndGhdID09PSBcIi5cIjtcbn1cbnZhciBTdHlsZUF0dHJpYnV0ZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZvbnRTdHlsZSwgZm9yZWdyb3VuZElkLCBiYWNrZ3JvdW5kSWQpIHtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICB0aGlzLmZvcmVncm91bmRJZCA9IGZvcmVncm91bmRJZDtcbiAgICB0aGlzLmJhY2tncm91bmRJZCA9IGJhY2tncm91bmRJZDtcbiAgfVxufTtcbmZ1bmN0aW9uIHBhcnNlVGhlbWUoc291cmNlKSB7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghc291cmNlLnNldHRpbmdzIHx8ICFBcnJheS5pc0FycmF5KHNvdXJjZS5zZXR0aW5ncykpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbGV0IHNldHRpbmdzID0gc291cmNlLnNldHRpbmdzO1xuICBsZXQgcmVzdWx0ID0gW10sIHJlc3VsdExlbiA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzZXR0aW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBlbnRyeSA9IHNldHRpbmdzW2ldO1xuICAgIGlmICghZW50cnkuc2V0dGluZ3MpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgc2NvcGVzO1xuICAgIGlmICh0eXBlb2YgZW50cnkuc2NvcGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxldCBfc2NvcGUgPSBlbnRyeS5zY29wZTtcbiAgICAgIF9zY29wZSA9IF9zY29wZS5yZXBsYWNlKC9eWyxdKy8sIFwiXCIpO1xuICAgICAgX3Njb3BlID0gX3Njb3BlLnJlcGxhY2UoL1ssXSskLywgXCJcIik7XG4gICAgICBzY29wZXMgPSBfc2NvcGUuc3BsaXQoXCIsXCIpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbnRyeS5zY29wZSkpIHtcbiAgICAgIHNjb3BlcyA9IGVudHJ5LnNjb3BlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY29wZXMgPSBbXCJcIl07XG4gICAgfVxuICAgIGxldCBmb250U3R5bGUgPSAtMSAvKiBOb3RTZXQgKi87XG4gICAgaWYgKHR5cGVvZiBlbnRyeS5zZXR0aW5ncy5mb250U3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvbnRTdHlsZSA9IDAgLyogTm9uZSAqLztcbiAgICAgIGxldCBzZWdtZW50cyA9IGVudHJ5LnNldHRpbmdzLmZvbnRTdHlsZS5zcGxpdChcIiBcIik7XG4gICAgICBmb3IgKGxldCBqID0gMCwgbGVuSiA9IHNlZ21lbnRzLmxlbmd0aDsgaiA8IGxlbko7IGorKykge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHNlZ21lbnRzW2pdO1xuICAgICAgICBzd2l0Y2ggKHNlZ21lbnQpIHtcbiAgICAgICAgICBjYXNlIFwiaXRhbGljXCI6XG4gICAgICAgICAgICBmb250U3R5bGUgPSBmb250U3R5bGUgfCAxIC8qIEl0YWxpYyAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJib2xkXCI6XG4gICAgICAgICAgICBmb250U3R5bGUgPSBmb250U3R5bGUgfCAyIC8qIEJvbGQgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidW5kZXJsaW5lXCI6XG4gICAgICAgICAgICBmb250U3R5bGUgPSBmb250U3R5bGUgfCA0IC8qIFVuZGVybGluZSAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdHJpa2V0aHJvdWdoXCI6XG4gICAgICAgICAgICBmb250U3R5bGUgPSBmb250U3R5bGUgfCA4IC8qIFN0cmlrZXRocm91Z2ggKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZm9yZWdyb3VuZCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBlbnRyeS5zZXR0aW5ncy5mb3JlZ3JvdW5kID09PSBcInN0cmluZ1wiICYmIGlzVmFsaWRIZXhDb2xvcihlbnRyeS5zZXR0aW5ncy5mb3JlZ3JvdW5kKSkge1xuICAgICAgZm9yZWdyb3VuZCA9IGVudHJ5LnNldHRpbmdzLmZvcmVncm91bmQ7XG4gICAgfVxuICAgIGxldCBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGVudHJ5LnNldHRpbmdzLmJhY2tncm91bmQgPT09IFwic3RyaW5nXCIgJiYgaXNWYWxpZEhleENvbG9yKGVudHJ5LnNldHRpbmdzLmJhY2tncm91bmQpKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gZW50cnkuc2V0dGluZ3MuYmFja2dyb3VuZDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDAsIGxlbkogPSBzY29wZXMubGVuZ3RoOyBqIDwgbGVuSjsgaisrKSB7XG4gICAgICBsZXQgX3Njb3BlID0gc2NvcGVzW2pdLnRyaW0oKTtcbiAgICAgIGxldCBzZWdtZW50cyA9IF9zY29wZS5zcGxpdChcIiBcIik7XG4gICAgICBsZXQgc2NvcGUgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIGxldCBwYXJlbnRTY29wZXMgPSBudWxsO1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGFyZW50U2NvcGVzID0gc2VnbWVudHMuc2xpY2UoMCwgc2VnbWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHBhcmVudFNjb3Blcy5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gbmV3IFBhcnNlZFRoZW1lUnVsZShcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIHBhcmVudFNjb3BlcyxcbiAgICAgICAgaSxcbiAgICAgICAgZm9udFN0eWxlLFxuICAgICAgICBmb3JlZ3JvdW5kLFxuICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFBhcnNlZFRoZW1lUnVsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2NvcGUsIHBhcmVudFNjb3BlcywgaW5kZXgsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhcmVudFNjb3BlcyA9IHBhcmVudFNjb3BlcztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICB9XG59O1xudmFyIEZvbnRTdHlsZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEZvbnRTdHlsZTIpID0+IHtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiTm90U2V0XCJdID0gLTFdID0gXCJOb3RTZXRcIjtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIEZvbnRTdHlsZTJbRm9udFN0eWxlMltcIkl0YWxpY1wiXSA9IDFdID0gXCJJdGFsaWNcIjtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiQm9sZFwiXSA9IDJdID0gXCJCb2xkXCI7XG4gIEZvbnRTdHlsZTJbRm9udFN0eWxlMltcIlVuZGVybGluZVwiXSA9IDRdID0gXCJVbmRlcmxpbmVcIjtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiU3RyaWtldGhyb3VnaFwiXSA9IDhdID0gXCJTdHJpa2V0aHJvdWdoXCI7XG4gIHJldHVybiBGb250U3R5bGUyO1xufSkoRm9udFN0eWxlIHx8IHt9KTtcbmZ1bmN0aW9uIHJlc29sdmVQYXJzZWRUaGVtZVJ1bGVzKHBhcnNlZFRoZW1lUnVsZXMsIF9jb2xvck1hcCkge1xuICBwYXJzZWRUaGVtZVJ1bGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBsZXQgciA9IHN0cmNtcChhLnNjb3BlLCBiLnNjb3BlKTtcbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHIgPSBzdHJBcnJDbXAoYS5wYXJlbnRTY29wZXMsIGIucGFyZW50U2NvcGVzKTtcbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfSk7XG4gIGxldCBkZWZhdWx0Rm9udFN0eWxlID0gMCAvKiBOb25lICovO1xuICBsZXQgZGVmYXVsdEZvcmVncm91bmQgPSBcIiMwMDAwMDBcIjtcbiAgbGV0IGRlZmF1bHRCYWNrZ3JvdW5kID0gXCIjZmZmZmZmXCI7XG4gIHdoaWxlIChwYXJzZWRUaGVtZVJ1bGVzLmxlbmd0aCA+PSAxICYmIHBhcnNlZFRoZW1lUnVsZXNbMF0uc2NvcGUgPT09IFwiXCIpIHtcbiAgICBsZXQgaW5jb21pbmdEZWZhdWx0cyA9IHBhcnNlZFRoZW1lUnVsZXMuc2hpZnQoKTtcbiAgICBpZiAoaW5jb21pbmdEZWZhdWx0cy5mb250U3R5bGUgIT09IC0xIC8qIE5vdFNldCAqLykge1xuICAgICAgZGVmYXVsdEZvbnRTdHlsZSA9IGluY29taW5nRGVmYXVsdHMuZm9udFN0eWxlO1xuICAgIH1cbiAgICBpZiAoaW5jb21pbmdEZWZhdWx0cy5mb3JlZ3JvdW5kICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0Rm9yZWdyb3VuZCA9IGluY29taW5nRGVmYXVsdHMuZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgaWYgKGluY29taW5nRGVmYXVsdHMuYmFja2dyb3VuZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdEJhY2tncm91bmQgPSBpbmNvbWluZ0RlZmF1bHRzLmJhY2tncm91bmQ7XG4gICAgfVxuICB9XG4gIGxldCBjb2xvck1hcCA9IG5ldyBDb2xvck1hcChfY29sb3JNYXApO1xuICBsZXQgZGVmYXVsdHMgPSBuZXcgU3R5bGVBdHRyaWJ1dGVzKGRlZmF1bHRGb250U3R5bGUsIGNvbG9yTWFwLmdldElkKGRlZmF1bHRGb3JlZ3JvdW5kKSwgY29sb3JNYXAuZ2V0SWQoZGVmYXVsdEJhY2tncm91bmQpKTtcbiAgbGV0IHJvb3QgPSBuZXcgVGhlbWVUcmllRWxlbWVudChuZXcgVGhlbWVUcmllRWxlbWVudFJ1bGUoMCwgbnVsbCwgLTEgLyogTm90U2V0ICovLCAwLCAwKSwgW10pO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFyc2VkVGhlbWVSdWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBydWxlID0gcGFyc2VkVGhlbWVSdWxlc1tpXTtcbiAgICByb290Lmluc2VydCgwLCBydWxlLnNjb3BlLCBydWxlLnBhcmVudFNjb3BlcywgcnVsZS5mb250U3R5bGUsIGNvbG9yTWFwLmdldElkKHJ1bGUuZm9yZWdyb3VuZCksIGNvbG9yTWFwLmdldElkKHJ1bGUuYmFja2dyb3VuZCkpO1xuICB9XG4gIHJldHVybiBuZXcgVGhlbWUoY29sb3JNYXAsIGRlZmF1bHRzLCByb290KTtcbn1cbnZhciBDb2xvck1hcCA9IGNsYXNzIHtcbiAgX2lzRnJvemVuO1xuICBfbGFzdENvbG9ySWQ7XG4gIF9pZDJjb2xvcjtcbiAgX2NvbG9yMmlkO1xuICBjb25zdHJ1Y3RvcihfY29sb3JNYXApIHtcbiAgICB0aGlzLl9sYXN0Q29sb3JJZCA9IDA7XG4gICAgdGhpcy5faWQyY29sb3IgPSBbXTtcbiAgICB0aGlzLl9jb2xvcjJpZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KF9jb2xvck1hcCkpIHtcbiAgICAgIHRoaXMuX2lzRnJvemVuID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBfY29sb3JNYXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY29sb3IyaWRbX2NvbG9yTWFwW2ldXSA9IGk7XG4gICAgICAgIHRoaXMuX2lkMmNvbG9yW2ldID0gX2NvbG9yTWFwW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc0Zyb3plbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBnZXRJZChjb2xvcikge1xuICAgIGlmIChjb2xvciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbG9yID0gY29sb3IudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLl9jb2xvcjJpZFtjb2xvcl07XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc0Zyb3plbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGNvbG9yIGluIGNvbG9yIG1hcCAtICR7Y29sb3J9YCk7XG4gICAgfVxuICAgIHZhbHVlID0gKyt0aGlzLl9sYXN0Q29sb3JJZDtcbiAgICB0aGlzLl9jb2xvcjJpZFtjb2xvcl0gPSB2YWx1ZTtcbiAgICB0aGlzLl9pZDJjb2xvclt2YWx1ZV0gPSBjb2xvcjtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZ2V0Q29sb3JNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkMmNvbG9yLnNsaWNlKDApO1xuICB9XG59O1xudmFyIGVtcHR5UGFyZW50U2NvcGVzID0gT2JqZWN0LmZyZWV6ZShbXSk7XG52YXIgVGhlbWVUcmllRWxlbWVudFJ1bGUgPSBjbGFzcyBfVGhlbWVUcmllRWxlbWVudFJ1bGUge1xuICBzY29wZURlcHRoO1xuICBwYXJlbnRTY29wZXM7XG4gIGZvbnRTdHlsZTtcbiAgZm9yZWdyb3VuZDtcbiAgYmFja2dyb3VuZDtcbiAgY29uc3RydWN0b3Ioc2NvcGVEZXB0aCwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICB0aGlzLnNjb3BlRGVwdGggPSBzY29wZURlcHRoO1xuICAgIHRoaXMucGFyZW50U2NvcGVzID0gcGFyZW50U2NvcGVzIHx8IGVtcHR5UGFyZW50U2NvcGVzO1xuICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9UaGVtZVRyaWVFbGVtZW50UnVsZSh0aGlzLnNjb3BlRGVwdGgsIHRoaXMucGFyZW50U2NvcGVzLCB0aGlzLmZvbnRTdHlsZSwgdGhpcy5mb3JlZ3JvdW5kLCB0aGlzLmJhY2tncm91bmQpO1xuICB9XG4gIHN0YXRpYyBjbG9uZUFycihhcnIpIHtcbiAgICBsZXQgciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJbaV0gPSBhcnJbaV0uY2xvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgYWNjZXB0T3ZlcndyaXRlKHNjb3BlRGVwdGgsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIGlmICh0aGlzLnNjb3BlRGVwdGggPiBzY29wZURlcHRoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImhvdyBkaWQgdGhpcyBoYXBwZW4/XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjb3BlRGVwdGggPSBzY29wZURlcHRoO1xuICAgIH1cbiAgICBpZiAoZm9udFN0eWxlICE9PSAtMSAvKiBOb3RTZXQgKi8pIHtcbiAgICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgIH1cbiAgICBpZiAoZm9yZWdyb3VuZCAhPT0gMCkge1xuICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgaWYgKGJhY2tncm91bmQgIT09IDApIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgfVxuICB9XG59O1xudmFyIFRoZW1lVHJpZUVsZW1lbnQgPSBjbGFzcyBfVGhlbWVUcmllRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKF9tYWluUnVsZSwgcnVsZXNXaXRoUGFyZW50U2NvcGVzID0gW10sIF9jaGlsZHJlbiA9IHt9KSB7XG4gICAgdGhpcy5fbWFpblJ1bGUgPSBfbWFpblJ1bGU7XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBfY2hpbGRyZW47XG4gICAgdGhpcy5fcnVsZXNXaXRoUGFyZW50U2NvcGVzID0gcnVsZXNXaXRoUGFyZW50U2NvcGVzO1xuICB9XG4gIF9ydWxlc1dpdGhQYXJlbnRTY29wZXM7XG4gIHN0YXRpYyBfY21wQnlTcGVjaWZpY2l0eShhLCBiKSB7XG4gICAgaWYgKGEuc2NvcGVEZXB0aCAhPT0gYi5zY29wZURlcHRoKSB7XG4gICAgICByZXR1cm4gYi5zY29wZURlcHRoIC0gYS5zY29wZURlcHRoO1xuICAgIH1cbiAgICBsZXQgYVBhcmVudEluZGV4ID0gMDtcbiAgICBsZXQgYlBhcmVudEluZGV4ID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGEucGFyZW50U2NvcGVzW2FQYXJlbnRJbmRleF0gPT09IFwiPlwiKSB7XG4gICAgICAgIGFQYXJlbnRJbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKGIucGFyZW50U2NvcGVzW2JQYXJlbnRJbmRleF0gPT09IFwiPlwiKSB7XG4gICAgICAgIGJQYXJlbnRJbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKGFQYXJlbnRJbmRleCA+PSBhLnBhcmVudFNjb3Blcy5sZW5ndGggfHwgYlBhcmVudEluZGV4ID49IGIucGFyZW50U2NvcGVzLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudFNjb3BlTGVuZ3RoRGlmZiA9IGIucGFyZW50U2NvcGVzW2JQYXJlbnRJbmRleF0ubGVuZ3RoIC0gYS5wYXJlbnRTY29wZXNbYVBhcmVudEluZGV4XS5sZW5ndGg7XG4gICAgICBpZiAocGFyZW50U2NvcGVMZW5ndGhEaWZmICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRTY29wZUxlbmd0aERpZmY7XG4gICAgICB9XG4gICAgICBhUGFyZW50SW5kZXgrKztcbiAgICAgIGJQYXJlbnRJbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gYi5wYXJlbnRTY29wZXMubGVuZ3RoIC0gYS5wYXJlbnRTY29wZXMubGVuZ3RoO1xuICB9XG4gIG1hdGNoKHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlICE9PSBcIlwiKSB7XG4gICAgICBsZXQgZG90SW5kZXggPSBzY29wZS5pbmRleE9mKFwiLlwiKTtcbiAgICAgIGxldCBoZWFkO1xuICAgICAgbGV0IHRhaWw7XG4gICAgICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgICAgIGhlYWQgPSBzY29wZTtcbiAgICAgICAgdGFpbCA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkID0gc2NvcGUuc3Vic3RyaW5nKDAsIGRvdEluZGV4KTtcbiAgICAgICAgdGFpbCA9IHNjb3BlLnN1YnN0cmluZyhkb3RJbmRleCArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuLmhhc093blByb3BlcnR5KGhlYWQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltoZWFkXS5tYXRjaCh0YWlsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcnVsZXMgPSB0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXMuY29uY2F0KHRoaXMuX21haW5SdWxlKTtcbiAgICBydWxlcy5zb3J0KF9UaGVtZVRyaWVFbGVtZW50Ll9jbXBCeVNwZWNpZmljaXR5KTtcbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cbiAgaW5zZXJ0KHNjb3BlRGVwdGgsIHNjb3BlLCBwYXJlbnRTY29wZXMsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIGlmIChzY29wZSA9PT0gXCJcIikge1xuICAgICAgdGhpcy5fZG9JbnNlcnRIZXJlKHNjb3BlRGVwdGgsIHBhcmVudFNjb3BlcywgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRvdEluZGV4ID0gc2NvcGUuaW5kZXhPZihcIi5cIik7XG4gICAgbGV0IGhlYWQ7XG4gICAgbGV0IHRhaWw7XG4gICAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgICAgaGVhZCA9IHNjb3BlO1xuICAgICAgdGFpbCA9IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQgPSBzY29wZS5zdWJzdHJpbmcoMCwgZG90SW5kZXgpO1xuICAgICAgdGFpbCA9IHNjb3BlLnN1YnN0cmluZyhkb3RJbmRleCArIDEpO1xuICAgIH1cbiAgICBsZXQgY2hpbGQ7XG4gICAgaWYgKHRoaXMuX2NoaWxkcmVuLmhhc093blByb3BlcnR5KGhlYWQpKSB7XG4gICAgICBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2hlYWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZCA9IG5ldyBfVGhlbWVUcmllRWxlbWVudCh0aGlzLl9tYWluUnVsZS5jbG9uZSgpLCBUaGVtZVRyaWVFbGVtZW50UnVsZS5jbG9uZUFycih0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXMpKTtcbiAgICAgIHRoaXMuX2NoaWxkcmVuW2hlYWRdID0gY2hpbGQ7XG4gICAgfVxuICAgIGNoaWxkLmluc2VydChzY29wZURlcHRoICsgMSwgdGFpbCwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpO1xuICB9XG4gIF9kb0luc2VydEhlcmUoc2NvcGVEZXB0aCwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICBpZiAocGFyZW50U2NvcGVzID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9tYWluUnVsZS5hY2NlcHRPdmVyd3JpdGUoc2NvcGVEZXB0aCwgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX3J1bGVzV2l0aFBhcmVudFNjb3Blcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IHJ1bGUgPSB0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXNbaV07XG4gICAgICBpZiAoc3RyQXJyQ21wKHJ1bGUucGFyZW50U2NvcGVzLCBwYXJlbnRTY29wZXMpID09PSAwKSB7XG4gICAgICAgIHJ1bGUuYWNjZXB0T3ZlcndyaXRlKHNjb3BlRGVwdGgsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvbnRTdHlsZSA9PT0gLTEgLyogTm90U2V0ICovKSB7XG4gICAgICBmb250U3R5bGUgPSB0aGlzLl9tYWluUnVsZS5mb250U3R5bGU7XG4gICAgfVxuICAgIGlmIChmb3JlZ3JvdW5kID09PSAwKSB7XG4gICAgICBmb3JlZ3JvdW5kID0gdGhpcy5fbWFpblJ1bGUuZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgaWYgKGJhY2tncm91bmQgPT09IDApIHtcbiAgICAgIGJhY2tncm91bmQgPSB0aGlzLl9tYWluUnVsZS5iYWNrZ3JvdW5kO1xuICAgIH1cbiAgICB0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXMucHVzaChuZXcgVGhlbWVUcmllRWxlbWVudFJ1bGUoc2NvcGVEZXB0aCwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpKTtcbiAgfVxufTtcblxuLy8gc3JjL2VuY29kZWRUb2tlbkF0dHJpYnV0ZXMudHNcbnZhciBFbmNvZGVkVG9rZW5NZXRhZGF0YSA9IGNsYXNzIF9FbmNvZGVkVG9rZW5NZXRhZGF0YSB7XG4gIHN0YXRpYyB0b0JpbmFyeVN0cihlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMudG9TdHJpbmcoMikucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgfVxuICBzdGF0aWMgcHJpbnQoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIGNvbnN0IGxhbmd1YWdlSWQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0TGFuZ3VhZ2VJZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBjb25zdCB0b2tlblR5cGUgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0VG9rZW5UeXBlKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGZvbnRTdHlsZSA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb250U3R5bGUoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgY29uc3QgZm9yZWdyb3VuZCA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb3JlZ3JvdW5kKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0QmFja2dyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBjb25zb2xlLmxvZyh7XG4gICAgICBsYW5ndWFnZUlkLFxuICAgICAgdG9rZW5UeXBlLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9yZWdyb3VuZCxcbiAgICAgIGJhY2tncm91bmRcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0TGFuZ3VhZ2VJZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgMjU1IC8qIExBTkdVQUdFSURfTUFTSyAqLykgPj4+IDAgLyogTEFOR1VBR0VJRF9PRkZTRVQgKi87XG4gIH1cbiAgc3RhdGljIGdldFRva2VuVHlwZShlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgNzY4IC8qIFRPS0VOX1RZUEVfTUFTSyAqLykgPj4+IDggLyogVE9LRU5fVFlQRV9PRkZTRVQgKi87XG4gIH1cbiAgc3RhdGljIGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyhlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgMTAyNCAvKiBCQUxBTkNFRF9CUkFDS0VUU19NQVNLICovKSAhPT0gMDtcbiAgfVxuICBzdGF0aWMgZ2V0Rm9udFN0eWxlKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMgJiAzMDcyMCAvKiBGT05UX1NUWUxFX01BU0sgKi8pID4+PiAxMSAvKiBGT05UX1NUWUxFX09GRlNFVCAqLztcbiAgfVxuICBzdGF0aWMgZ2V0Rm9yZWdyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgMTY3NDQ0NDggLyogRk9SRUdST1VORF9NQVNLICovKSA+Pj4gMTUgLyogRk9SRUdST1VORF9PRkZTRVQgKi87XG4gIH1cbiAgc3RhdGljIGdldEJhY2tncm91bmQoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiAoZW5jb2RlZFRva2VuQXR0cmlidXRlcyAmIDQyNzgxOTAwODAgLyogQkFDS0dST1VORF9NQVNLICovKSA+Pj4gMjQgLyogQkFDS0dST1VORF9PRkZTRVQgKi87XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGZpZWxkcyBpbiBgbWV0YWRhdGFgLlxuICAgKiBBIHZhbHVlIG9mIGAwYCwgYE5vdFNldGAgb3IgYG51bGxgIGluZGljYXRlcyB0aGF0IHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkIHNob3VsZCBiZSBsZWZ0IGFzIGlzLlxuICAgKi9cbiAgc3RhdGljIHNldChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzLCBsYW5ndWFnZUlkLCB0b2tlblR5cGUsIGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cywgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gICAgbGV0IF9sYW5ndWFnZUlkID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldExhbmd1YWdlSWQoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgbGV0IF90b2tlblR5cGUgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0VG9rZW5UeXBlKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGxldCBfY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzQml0ID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyhlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSA/IDEgOiAwO1xuICAgIGxldCBfZm9udFN0eWxlID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldEZvbnRTdHlsZShlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBsZXQgX2ZvcmVncm91bmQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0Rm9yZWdyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBsZXQgX2JhY2tncm91bmQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0QmFja2dyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBpZiAobGFuZ3VhZ2VJZCAhPT0gMCkge1xuICAgICAgX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgIH1cbiAgICBpZiAodG9rZW5UeXBlICE9PSA4IC8qIE5vdFNldCAqLykge1xuICAgICAgX3Rva2VuVHlwZSA9IGZyb21PcHRpb25hbFRva2VuVHlwZSh0b2tlblR5cGUpO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzICE9PSBudWxsKSB7XG4gICAgICBfY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzQml0ID0gY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzID8gMSA6IDA7XG4gICAgfVxuICAgIGlmIChmb250U3R5bGUgIT09IC0xIC8qIE5vdFNldCAqLykge1xuICAgICAgX2ZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICB9XG4gICAgaWYgKGZvcmVncm91bmQgIT09IDApIHtcbiAgICAgIF9mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgaWYgKGJhY2tncm91bmQgIT09IDApIHtcbiAgICAgIF9iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICB9XG4gICAgcmV0dXJuIChfbGFuZ3VhZ2VJZCA8PCAwIC8qIExBTkdVQUdFSURfT0ZGU0VUICovIHwgX3Rva2VuVHlwZSA8PCA4IC8qIFRPS0VOX1RZUEVfT0ZGU0VUICovIHwgX2NvbnRhaW5zQmFsYW5jZWRCcmFja2V0c0JpdCA8PCAxMCAvKiBCQUxBTkNFRF9CUkFDS0VUU19PRkZTRVQgKi8gfCBfZm9udFN0eWxlIDw8IDExIC8qIEZPTlRfU1RZTEVfT0ZGU0VUICovIHwgX2ZvcmVncm91bmQgPDwgMTUgLyogRk9SRUdST1VORF9PRkZTRVQgKi8gfCBfYmFja2dyb3VuZCA8PCAyNCAvKiBCQUNLR1JPVU5EX09GRlNFVCAqLykgPj4+IDA7XG4gIH1cbn07XG5mdW5jdGlvbiB0b09wdGlvbmFsVG9rZW5UeXBlKHN0YW5kYXJkVHlwZSkge1xuICByZXR1cm4gc3RhbmRhcmRUeXBlO1xufVxuZnVuY3Rpb24gZnJvbU9wdGlvbmFsVG9rZW5UeXBlKHN0YW5kYXJkVHlwZSkge1xuICByZXR1cm4gc3RhbmRhcmRUeXBlO1xufVxuXG4vLyBzcmMvbWF0Y2hlci50c1xuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlcnMoc2VsZWN0b3IsIG1hdGNoZXNOYW1lKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgdG9rZW5pemVyID0gbmV3VG9rZW5pemVyKHNlbGVjdG9yKTtcbiAgbGV0IHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgd2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gICAgbGV0IHByaW9yaXR5ID0gMDtcbiAgICBpZiAodG9rZW4ubGVuZ3RoID09PSAyICYmIHRva2VuLmNoYXJBdCgxKSA9PT0gXCI6XCIpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4uY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgXCJSXCI6XG4gICAgICAgICAgcHJpb3JpdHkgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgIHByaW9yaXR5ID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5sb2coYFVua25vd24gcHJpb3JpdHkgJHt0b2tlbn0gaW4gc2NvcGUgc2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICB9XG4gICAgbGV0IG1hdGNoZXIgPSBwYXJzZUNvbmp1bmN0aW9uKCk7XG4gICAgcmVzdWx0cy5wdXNoKHsgbWF0Y2hlciwgcHJpb3JpdHkgfSk7XG4gICAgaWYgKHRva2VuICE9PSBcIixcIikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbiAgZnVuY3Rpb24gcGFyc2VPcGVyYW5kKCkge1xuICAgIGlmICh0b2tlbiA9PT0gXCItXCIpIHtcbiAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb25Ub05lZ2F0ZSA9IHBhcnNlT3BlcmFuZCgpO1xuICAgICAgcmV0dXJuIChtYXRjaGVySW5wdXQpID0+ICEhZXhwcmVzc2lvblRvTmVnYXRlICYmICFleHByZXNzaW9uVG9OZWdhdGUobWF0Y2hlcklucHV0KTtcbiAgICB9XG4gICAgaWYgKHRva2VuID09PSBcIihcIikge1xuICAgICAgdG9rZW4gPSB0b2tlbml6ZXIubmV4dCgpO1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkluUGFyZW50cyA9IHBhcnNlSW5uZXJFeHByZXNzaW9uKCk7XG4gICAgICBpZiAodG9rZW4gPT09IFwiKVwiKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHByZXNzaW9uSW5QYXJlbnRzO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyKHRva2VuKSkge1xuICAgICAgY29uc3QgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIGRvIHtcbiAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0b2tlbik7XG4gICAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICAgIH0gd2hpbGUgKGlzSWRlbnRpZmllcih0b2tlbikpO1xuICAgICAgcmV0dXJuIChtYXRjaGVySW5wdXQpID0+IG1hdGNoZXNOYW1lKGlkZW50aWZpZXJzLCBtYXRjaGVySW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUNvbmp1bmN0aW9uKCkge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gW107XG4gICAgbGV0IG1hdGNoZXIgPSBwYXJzZU9wZXJhbmQoKTtcbiAgICB3aGlsZSAobWF0Y2hlcikge1xuICAgICAgbWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgIG1hdGNoZXIgPSBwYXJzZU9wZXJhbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIChtYXRjaGVySW5wdXQpID0+IG1hdGNoZXJzLmV2ZXJ5KChtYXRjaGVyMikgPT4gbWF0Y2hlcjIobWF0Y2hlcklucHV0KSk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VJbm5lckV4cHJlc3Npb24oKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBbXTtcbiAgICBsZXQgbWF0Y2hlciA9IHBhcnNlQ29uanVuY3Rpb24oKTtcbiAgICB3aGlsZSAobWF0Y2hlcikge1xuICAgICAgbWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgIGlmICh0b2tlbiA9PT0gXCJ8XCIgfHwgdG9rZW4gPT09IFwiLFwiKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG4gICAgICAgIH0gd2hpbGUgKHRva2VuID09PSBcInxcIiB8fCB0b2tlbiA9PT0gXCIsXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXRjaGVyID0gcGFyc2VDb25qdW5jdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gKG1hdGNoZXJJbnB1dCkgPT4gbWF0Y2hlcnMuc29tZSgobWF0Y2hlcjIpID0+IG1hdGNoZXIyKG1hdGNoZXJJbnB1dCkpO1xuICB9XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXIodG9rZW4pIHtcbiAgcmV0dXJuICEhdG9rZW4gJiYgISF0b2tlbi5tYXRjaCgvW1xcd1xcLjpdKy8pO1xufVxuZnVuY3Rpb24gbmV3VG9rZW5pemVyKGlucHV0KSB7XG4gIGxldCByZWdleCA9IC8oW0xSXTp8W1xcd1xcLjpdW1xcd1xcLjpcXC1dKnxbXFwsXFx8XFwtXFwoXFwpXSkvZztcbiAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhpbnB1dCk7XG4gIHJldHVybiB7XG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcyA9IG1hdGNoWzBdO1xuICAgICAgbWF0Y2ggPSByZWdleC5leGVjKGlucHV0KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvb25pZ0xpYi50c1xudmFyIEZpbmRPcHRpb24gPSAvKiBAX19QVVJFX18gKi8gKChGaW5kT3B0aW9uMikgPT4ge1xuICBGaW5kT3B0aW9uMltGaW5kT3B0aW9uMltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICBGaW5kT3B0aW9uMltGaW5kT3B0aW9uMltcIk5vdEJlZ2luU3RyaW5nXCJdID0gMV0gPSBcIk5vdEJlZ2luU3RyaW5nXCI7XG4gIEZpbmRPcHRpb24yW0ZpbmRPcHRpb24yW1wiTm90RW5kU3RyaW5nXCJdID0gMl0gPSBcIk5vdEVuZFN0cmluZ1wiO1xuICBGaW5kT3B0aW9uMltGaW5kT3B0aW9uMltcIk5vdEJlZ2luUG9zaXRpb25cIl0gPSA0XSA9IFwiTm90QmVnaW5Qb3NpdGlvblwiO1xuICBGaW5kT3B0aW9uMltGaW5kT3B0aW9uMltcIkRlYnVnQ2FsbFwiXSA9IDhdID0gXCJEZWJ1Z0NhbGxcIjtcbiAgcmV0dXJuIEZpbmRPcHRpb24yO1xufSkoRmluZE9wdGlvbiB8fCB7fSk7XG5mdW5jdGlvbiBkaXNwb3NlT25pZ1N0cmluZyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIuZGlzcG9zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgc3RyLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG4vLyBzcmMvZ3JhbW1hci9ncmFtbWFyRGVwZW5kZW5jaWVzLnRzXG52YXIgVG9wTGV2ZWxSdWxlUmVmZXJlbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY29wZU5hbWUpIHtcbiAgICB0aGlzLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgfVxuICB0b0tleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZU5hbWU7XG4gIH1cbn07XG52YXIgVG9wTGV2ZWxSZXBvc2l0b3J5UnVsZVJlZmVyZW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2NvcGVOYW1lLCBydWxlTmFtZSkge1xuICAgIHRoaXMuc2NvcGVOYW1lID0gc2NvcGVOYW1lO1xuICAgIHRoaXMucnVsZU5hbWUgPSBydWxlTmFtZTtcbiAgfVxuICB0b0tleSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5zY29wZU5hbWV9IyR7dGhpcy5ydWxlTmFtZX1gO1xuICB9XG59O1xudmFyIEV4dGVybmFsUmVmZXJlbmNlQ29sbGVjdG9yID0gY2xhc3Mge1xuICBfcmVmZXJlbmNlcyA9IFtdO1xuICBfc2VlblJlZmVyZW5jZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBnZXQgcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlcztcbiAgfVxuICB2aXNpdGVkUnVsZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGFkZChyZWZlcmVuY2UpIHtcbiAgICBjb25zdCBrZXkgPSByZWZlcmVuY2UudG9LZXkoKTtcbiAgICBpZiAodGhpcy5fc2VlblJlZmVyZW5jZUtleXMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2VlblJlZmVyZW5jZUtleXMuYWRkKGtleSk7XG4gICAgdGhpcy5fcmVmZXJlbmNlcy5wdXNoKHJlZmVyZW5jZSk7XG4gIH1cbn07XG52YXIgU2NvcGVEZXBlbmRlbmN5UHJvY2Vzc29yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXBvLCBpbml0aWFsU2NvcGVOYW1lKSB7XG4gICAgdGhpcy5yZXBvID0gcmVwbztcbiAgICB0aGlzLmluaXRpYWxTY29wZU5hbWUgPSBpbml0aWFsU2NvcGVOYW1lO1xuICAgIHRoaXMuc2VlbkZ1bGxTY29wZVJlcXVlc3RzLmFkZCh0aGlzLmluaXRpYWxTY29wZU5hbWUpO1xuICAgIHRoaXMuUSA9IFtuZXcgVG9wTGV2ZWxSdWxlUmVmZXJlbmNlKHRoaXMuaW5pdGlhbFNjb3BlTmFtZSldO1xuICB9XG4gIHNlZW5GdWxsU2NvcGVSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHNlZW5QYXJ0aWFsU2NvcGVSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIFE7XG4gIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICBjb25zdCBxID0gdGhpcy5RO1xuICAgIHRoaXMuUSA9IFtdO1xuICAgIGNvbnN0IGRlcHMgPSBuZXcgRXh0ZXJuYWxSZWZlcmVuY2VDb2xsZWN0b3IoKTtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBxKSB7XG4gICAgICBjb2xsZWN0UmVmZXJlbmNlc09mUmVmZXJlbmNlKGRlcCwgdGhpcy5pbml0aWFsU2NvcGVOYW1lLCB0aGlzLnJlcG8sIGRlcHMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzLnJlZmVyZW5jZXMpIHtcbiAgICAgIGlmIChkZXAgaW5zdGFuY2VvZiBUb3BMZXZlbFJ1bGVSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VlbkZ1bGxTY29wZVJlcXVlc3RzLmhhcyhkZXAuc2NvcGVOYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VlbkZ1bGxTY29wZVJlcXVlc3RzLmFkZChkZXAuc2NvcGVOYW1lKTtcbiAgICAgICAgdGhpcy5RLnB1c2goZGVwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnNlZW5GdWxsU2NvcGVSZXF1ZXN0cy5oYXMoZGVwLnNjb3BlTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWVuUGFydGlhbFNjb3BlUmVxdWVzdHMuaGFzKGRlcC50b0tleSgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VlblBhcnRpYWxTY29wZVJlcXVlc3RzLmFkZChkZXAudG9LZXkoKSk7XG4gICAgICAgIHRoaXMuUS5wdXNoKGRlcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gY29sbGVjdFJlZmVyZW5jZXNPZlJlZmVyZW5jZShyZWZlcmVuY2UsIGJhc2VHcmFtbWFyU2NvcGVOYW1lLCByZXBvLCByZXN1bHQpIHtcbiAgY29uc3Qgc2VsZkdyYW1tYXIgPSByZXBvLmxvb2t1cChyZWZlcmVuY2Uuc2NvcGVOYW1lKTtcbiAgaWYgKCFzZWxmR3JhbW1hcikge1xuICAgIGlmIChyZWZlcmVuY2Uuc2NvcGVOYW1lID09PSBiYXNlR3JhbW1hclNjb3BlTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBncmFtbWFyIHByb3ZpZGVkIGZvciA8JHtiYXNlR3JhbW1hclNjb3BlTmFtZX0+YCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBiYXNlR3JhbW1hciA9IHJlcG8ubG9va3VwKGJhc2VHcmFtbWFyU2NvcGVOYW1lKTtcbiAgaWYgKHJlZmVyZW5jZSBpbnN0YW5jZW9mIFRvcExldmVsUnVsZVJlZmVyZW5jZSkge1xuICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUnVsZSh7IGJhc2VHcmFtbWFyLCBzZWxmR3JhbW1hciB9LCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUmVwb3NpdG9yeVJ1bGUoXG4gICAgICByZWZlcmVuY2UucnVsZU5hbWUsXG4gICAgICB7IGJhc2VHcmFtbWFyLCBzZWxmR3JhbW1hciwgcmVwb3NpdG9yeTogc2VsZkdyYW1tYXIucmVwb3NpdG9yeSB9LFxuICAgICAgcmVzdWx0XG4gICAgKTtcbiAgfVxuICBjb25zdCBpbmplY3Rpb25zID0gcmVwby5pbmplY3Rpb25zKHJlZmVyZW5jZS5zY29wZU5hbWUpO1xuICBpZiAoaW5qZWN0aW9ucykge1xuICAgIGZvciAoY29uc3QgaW5qZWN0aW9uIG9mIGluamVjdGlvbnMpIHtcbiAgICAgIHJlc3VsdC5hZGQobmV3IFRvcExldmVsUnVsZVJlZmVyZW5jZShpbmplY3Rpb24pKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUmVwb3NpdG9yeVJ1bGUocnVsZU5hbWUsIGNvbnRleHQsIHJlc3VsdCkge1xuICBpZiAoY29udGV4dC5yZXBvc2l0b3J5ICYmIGNvbnRleHQucmVwb3NpdG9yeVtydWxlTmFtZV0pIHtcbiAgICBjb25zdCBydWxlID0gY29udGV4dC5yZXBvc2l0b3J5W3J1bGVOYW1lXTtcbiAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5SdWxlcyhbcnVsZV0sIGNvbnRleHQsIHJlc3VsdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUnVsZShjb250ZXh0LCByZXN1bHQpIHtcbiAgaWYgKGNvbnRleHQuc2VsZkdyYW1tYXIucGF0dGVybnMgJiYgQXJyYXkuaXNBcnJheShjb250ZXh0LnNlbGZHcmFtbWFyLnBhdHRlcm5zKSkge1xuICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblJ1bGVzKFxuICAgICAgY29udGV4dC5zZWxmR3JhbW1hci5wYXR0ZXJucyxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVwb3NpdG9yeTogY29udGV4dC5zZWxmR3JhbW1hci5yZXBvc2l0b3J5IH0sXG4gICAgICByZXN1bHRcbiAgICApO1xuICB9XG4gIGlmIChjb250ZXh0LnNlbGZHcmFtbWFyLmluamVjdGlvbnMpIHtcbiAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5SdWxlcyhcbiAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5zZWxmR3JhbW1hci5pbmplY3Rpb25zKSxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVwb3NpdG9yeTogY29udGV4dC5zZWxmR3JhbW1hci5yZXBvc2l0b3J5IH0sXG4gICAgICByZXN1bHRcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5SdWxlcyhydWxlcywgY29udGV4dCwgcmVzdWx0KSB7XG4gIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgIGlmIChyZXN1bHQudmlzaXRlZFJ1bGUuaGFzKHJ1bGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnZpc2l0ZWRSdWxlLmFkZChydWxlKTtcbiAgICBjb25zdCBwYXR0ZXJuUmVwb3NpdG9yeSA9IHJ1bGUucmVwb3NpdG9yeSA/IG1lcmdlT2JqZWN0cyh7fSwgY29udGV4dC5yZXBvc2l0b3J5LCBydWxlLnJlcG9zaXRvcnkpIDogY29udGV4dC5yZXBvc2l0b3J5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUucGF0dGVybnMpKSB7XG4gICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5SdWxlcyhydWxlLnBhdHRlcm5zLCB7IC4uLmNvbnRleHQsIHJlcG9zaXRvcnk6IHBhdHRlcm5SZXBvc2l0b3J5IH0sIHJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGluY2x1ZGUgPSBydWxlLmluY2x1ZGU7XG4gICAgaWYgKCFpbmNsdWRlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcmVmZXJlbmNlID0gcGFyc2VJbmNsdWRlKGluY2x1ZGUpO1xuICAgIHN3aXRjaCAocmVmZXJlbmNlLmtpbmQpIHtcbiAgICAgIGNhc2UgMCAvKiBCYXNlICovOlxuICAgICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJ1bGUoeyAuLi5jb250ZXh0LCBzZWxmR3JhbW1hcjogY29udGV4dC5iYXNlR3JhbW1hciB9LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBTZWxmICovOlxuICAgICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJ1bGUoY29udGV4dCwgcmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIgLyogUmVsYXRpdmVSZWZlcmVuY2UgKi86XG4gICAgICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUmVwb3NpdG9yeVJ1bGUocmVmZXJlbmNlLnJ1bGVOYW1lLCB7IC4uLmNvbnRleHQsIHJlcG9zaXRvcnk6IHBhdHRlcm5SZXBvc2l0b3J5IH0sIHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzIC8qIFRvcExldmVsUmVmZXJlbmNlICovOlxuICAgICAgY2FzZSA0IC8qIFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZSAqLzpcbiAgICAgICAgY29uc3Qgc2VsZkdyYW1tYXIgPSByZWZlcmVuY2Uuc2NvcGVOYW1lID09PSBjb250ZXh0LnNlbGZHcmFtbWFyLnNjb3BlTmFtZSA/IGNvbnRleHQuc2VsZkdyYW1tYXIgOiByZWZlcmVuY2Uuc2NvcGVOYW1lID09PSBjb250ZXh0LmJhc2VHcmFtbWFyLnNjb3BlTmFtZSA/IGNvbnRleHQuYmFzZUdyYW1tYXIgOiB2b2lkIDA7XG4gICAgICAgIGlmIChzZWxmR3JhbW1hcikge1xuICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSB7IGJhc2VHcmFtbWFyOiBjb250ZXh0LmJhc2VHcmFtbWFyLCBzZWxmR3JhbW1hciwgcmVwb3NpdG9yeTogcGF0dGVyblJlcG9zaXRvcnkgfTtcbiAgICAgICAgICBpZiAocmVmZXJlbmNlLmtpbmQgPT09IDQgLyogVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlICovKSB7XG4gICAgICAgICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJlcG9zaXRvcnlSdWxlKHJlZmVyZW5jZS5ydWxlTmFtZSwgbmV3Q29udGV4dCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSdWxlKG5ld0NvbnRleHQsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZWZlcmVuY2Uua2luZCA9PT0gNCAvKiBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2UgKi8pIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQobmV3IFRvcExldmVsUmVwb3NpdG9yeVJ1bGVSZWZlcmVuY2UocmVmZXJlbmNlLnNjb3BlTmFtZSwgcmVmZXJlbmNlLnJ1bGVOYW1lKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQobmV3IFRvcExldmVsUnVsZVJlZmVyZW5jZShyZWZlcmVuY2Uuc2NvcGVOYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxudmFyIEJhc2VSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGtpbmQgPSAwIC8qIEJhc2UgKi87XG59O1xudmFyIFNlbGZSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGtpbmQgPSAxIC8qIFNlbGYgKi87XG59O1xudmFyIFJlbGF0aXZlUmVmZXJlbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihydWxlTmFtZSkge1xuICAgIHRoaXMucnVsZU5hbWUgPSBydWxlTmFtZTtcbiAgfVxuICBraW5kID0gMiAvKiBSZWxhdGl2ZVJlZmVyZW5jZSAqLztcbn07XG52YXIgVG9wTGV2ZWxSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlTmFtZSkge1xuICAgIHRoaXMuc2NvcGVOYW1lID0gc2NvcGVOYW1lO1xuICB9XG4gIGtpbmQgPSAzIC8qIFRvcExldmVsUmVmZXJlbmNlICovO1xufTtcbnZhciBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlTmFtZSwgcnVsZU5hbWUpIHtcbiAgICB0aGlzLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gIH1cbiAga2luZCA9IDQgLyogVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlICovO1xufTtcbmZ1bmN0aW9uIHBhcnNlSW5jbHVkZShpbmNsdWRlKSB7XG4gIGlmIChpbmNsdWRlID09PSBcIiRiYXNlXCIpIHtcbiAgICByZXR1cm4gbmV3IEJhc2VSZWZlcmVuY2UoKTtcbiAgfSBlbHNlIGlmIChpbmNsdWRlID09PSBcIiRzZWxmXCIpIHtcbiAgICByZXR1cm4gbmV3IFNlbGZSZWZlcmVuY2UoKTtcbiAgfVxuICBjb25zdCBpbmRleE9mU2hhcnAgPSBpbmNsdWRlLmluZGV4T2YoXCIjXCIpO1xuICBpZiAoaW5kZXhPZlNoYXJwID09PSAtMSkge1xuICAgIHJldHVybiBuZXcgVG9wTGV2ZWxSZWZlcmVuY2UoaW5jbHVkZSk7XG4gIH0gZWxzZSBpZiAoaW5kZXhPZlNoYXJwID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBSZWxhdGl2ZVJlZmVyZW5jZShpbmNsdWRlLnN1YnN0cmluZygxKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2NvcGVOYW1lID0gaW5jbHVkZS5zdWJzdHJpbmcoMCwgaW5kZXhPZlNoYXJwKTtcbiAgICBjb25zdCBydWxlTmFtZSA9IGluY2x1ZGUuc3Vic3RyaW5nKGluZGV4T2ZTaGFycCArIDEpO1xuICAgIHJldHVybiBuZXcgVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlKHNjb3BlTmFtZSwgcnVsZU5hbWUpO1xuICB9XG59XG5cbi8vIHNyYy9ydWxlLnRzXG52YXIgSEFTX0JBQ0tfUkVGRVJFTkNFUyA9IC9cXFxcKFxcZCspLztcbnZhciBCQUNLX1JFRkVSRU5DSU5HX0VORCA9IC9cXFxcKFxcZCspL2c7XG52YXIgcnVsZUlkU3ltYm9sID0gU3ltYm9sKFwiUnVsZUlkXCIpO1xudmFyIGVuZFJ1bGVJZCA9IC0xO1xudmFyIHdoaWxlUnVsZUlkID0gLTI7XG5mdW5jdGlvbiBydWxlSWRGcm9tTnVtYmVyKGlkKSB7XG4gIHJldHVybiBpZDtcbn1cbmZ1bmN0aW9uIHJ1bGVJZFRvTnVtYmVyKGlkKSB7XG4gIHJldHVybiBpZDtcbn1cbnZhciBSdWxlID0gY2xhc3Mge1xuICAkbG9jYXRpb247XG4gIGlkO1xuICBfbmFtZUlzQ2FwdHVyaW5nO1xuICBfbmFtZTtcbiAgX2NvbnRlbnROYW1lSXNDYXB0dXJpbmc7XG4gIF9jb250ZW50TmFtZTtcbiAgY29uc3RydWN0b3IoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUpIHtcbiAgICB0aGlzLiRsb2NhdGlvbiA9ICRsb2NhdGlvbjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLl9uYW1lSXNDYXB0dXJpbmcgPSBSZWdleFNvdXJjZS5oYXNDYXB0dXJlcyh0aGlzLl9uYW1lKTtcbiAgICB0aGlzLl9jb250ZW50TmFtZSA9IGNvbnRlbnROYW1lIHx8IG51bGw7XG4gICAgdGhpcy5fY29udGVudE5hbWVJc0NhcHR1cmluZyA9IFJlZ2V4U291cmNlLmhhc0NhcHR1cmVzKHRoaXMuX2NvbnRlbnROYW1lKTtcbiAgfVxuICBnZXQgZGVidWdOYW1lKCkge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy4kbG9jYXRpb24gPyBgJHtiYXNlbmFtZSh0aGlzLiRsb2NhdGlvbi5maWxlbmFtZSl9OiR7dGhpcy4kbG9jYXRpb24ubGluZX1gIDogXCJ1bmtub3duXCI7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0jJHt0aGlzLmlkfSBAICR7bG9jYXRpb259YDtcbiAgfVxuICBnZXROYW1lKGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcykge1xuICAgIGlmICghdGhpcy5fbmFtZUlzQ2FwdHVyaW5nIHx8IHRoaXMuX25hbWUgPT09IG51bGwgfHwgbGluZVRleHQgPT09IG51bGwgfHwgY2FwdHVyZUluZGljZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gUmVnZXhTb3VyY2UucmVwbGFjZUNhcHR1cmVzKHRoaXMuX25hbWUsIGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcyk7XG4gIH1cbiAgZ2V0Q29udGVudE5hbWUobGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKSB7XG4gICAgaWYgKCF0aGlzLl9jb250ZW50TmFtZUlzQ2FwdHVyaW5nIHx8IHRoaXMuX2NvbnRlbnROYW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudE5hbWU7XG4gICAgfVxuICAgIHJldHVybiBSZWdleFNvdXJjZS5yZXBsYWNlQ2FwdHVyZXModGhpcy5fY29udGVudE5hbWUsIGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcyk7XG4gIH1cbn07XG52YXIgQ2FwdHVyZVJ1bGUgPSBjbGFzcyBleHRlbmRzIFJ1bGUge1xuICByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkO1xuICBjb25zdHJ1Y3RvcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSwgcmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCkge1xuICAgIHN1cGVyKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lKTtcbiAgICB0aGlzLnJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQgPSByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gIH1cbiAgY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIG91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQhXCIpO1xuICB9XG4gIGNvbXBpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIVwiKTtcbiAgfVxuICBjb21waWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCFcIik7XG4gIH1cbn07XG52YXIgTWF0Y2hSdWxlID0gY2xhc3MgZXh0ZW5kcyBSdWxlIHtcbiAgX21hdGNoO1xuICBjYXB0dXJlcztcbiAgX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIGNvbnN0cnVjdG9yKCRsb2NhdGlvbiwgaWQsIG5hbWUsIG1hdGNoLCBjYXB0dXJlcykge1xuICAgIHN1cGVyKCRsb2NhdGlvbiwgaWQsIG5hbWUsIG51bGwpO1xuICAgIHRoaXMuX21hdGNoID0gbmV3IFJlZ0V4cFNvdXJjZShtYXRjaCwgdGhpcy5pZCk7XG4gICAgdGhpcy5jYXB0dXJlcyA9IGNhcHR1cmVzO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBkZWJ1Z01hdGNoUmVnRXhwKCkge1xuICAgIHJldHVybiBgJHt0aGlzLl9tYXRjaC5zb3VyY2V9YDtcbiAgfVxuICBjb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgb3V0KSB7XG4gICAgb3V0LnB1c2godGhpcy5fbWF0Y2gpO1xuICB9XG4gIGNvbXBpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlKGdyYW1tYXIpO1xuICB9XG4gIGNvbXBpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlQUcoZ3JhbW1hciwgYWxsb3dBLCBhbGxvd0cpO1xuICB9XG4gIF9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBuZXcgUmVnRXhwU291cmNlTGlzdCgpO1xuICAgICAgdGhpcy5jb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICB9XG59O1xudmFyIEluY2x1ZGVPbmx5UnVsZSA9IGNsYXNzIGV4dGVuZHMgUnVsZSB7XG4gIGhhc01pc3NpbmdQYXR0ZXJucztcbiAgcGF0dGVybnM7XG4gIF9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICBjb25zdHJ1Y3RvcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSwgcGF0dGVybnMpIHtcbiAgICBzdXBlcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSk7XG4gICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zLnBhdHRlcm5zO1xuICAgIHRoaXMuaGFzTWlzc2luZ1BhdHRlcm5zID0gcGF0dGVybnMuaGFzTWlzc2luZ1BhdHRlcm5zO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCBvdXQpIHtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5wYXR0ZXJucykge1xuICAgICAgY29uc3QgcnVsZSA9IGdyYW1tYXIuZ2V0UnVsZShwYXR0ZXJuKTtcbiAgICAgIHJ1bGUuY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIG91dCk7XG4gICAgfVxuICB9XG4gIGNvbXBpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlKGdyYW1tYXIpO1xuICB9XG4gIGNvbXBpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlQUcoZ3JhbW1hciwgYWxsb3dBLCBhbGxvd0cpO1xuICB9XG4gIF9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBuZXcgUmVnRXhwU291cmNlTGlzdCgpO1xuICAgICAgdGhpcy5jb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICB9XG59O1xudmFyIEJlZ2luRW5kUnVsZSA9IGNsYXNzIGV4dGVuZHMgUnVsZSB7XG4gIF9iZWdpbjtcbiAgYmVnaW5DYXB0dXJlcztcbiAgX2VuZDtcbiAgZW5kSGFzQmFja1JlZmVyZW5jZXM7XG4gIGVuZENhcHR1cmVzO1xuICBhcHBseUVuZFBhdHRlcm5MYXN0O1xuICBoYXNNaXNzaW5nUGF0dGVybnM7XG4gIHBhdHRlcm5zO1xuICBfY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgY29uc3RydWN0b3IoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUsIGJlZ2luLCBiZWdpbkNhcHR1cmVzLCBlbmQsIGVuZENhcHR1cmVzLCBhcHBseUVuZFBhdHRlcm5MYXN0LCBwYXR0ZXJucykge1xuICAgIHN1cGVyKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lKTtcbiAgICB0aGlzLl9iZWdpbiA9IG5ldyBSZWdFeHBTb3VyY2UoYmVnaW4sIHRoaXMuaWQpO1xuICAgIHRoaXMuYmVnaW5DYXB0dXJlcyA9IGJlZ2luQ2FwdHVyZXM7XG4gICAgdGhpcy5fZW5kID0gbmV3IFJlZ0V4cFNvdXJjZShlbmQgPyBlbmQgOiBcIlxcdUZGRkZcIiwgLTEpO1xuICAgIHRoaXMuZW5kSGFzQmFja1JlZmVyZW5jZXMgPSB0aGlzLl9lbmQuaGFzQmFja1JlZmVyZW5jZXM7XG4gICAgdGhpcy5lbmRDYXB0dXJlcyA9IGVuZENhcHR1cmVzO1xuICAgIHRoaXMuYXBwbHlFbmRQYXR0ZXJuTGFzdCA9IGFwcGx5RW5kUGF0dGVybkxhc3QgfHwgZmFsc2U7XG4gICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zLnBhdHRlcm5zO1xuICAgIHRoaXMuaGFzTWlzc2luZ1BhdHRlcm5zID0gcGF0dGVybnMuaGFzTWlzc2luZ1BhdHRlcm5zO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBkZWJ1Z0JlZ2luUmVnRXhwKCkge1xuICAgIHJldHVybiBgJHt0aGlzLl9iZWdpbi5zb3VyY2V9YDtcbiAgfVxuICBnZXQgZGVidWdFbmRSZWdFeHAoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX2VuZC5zb3VyY2V9YDtcbiAgfVxuICBnZXRFbmRXaXRoUmVzb2x2ZWRCYWNrUmVmZXJlbmNlcyhsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kLnJlc29sdmVCYWNrUmVmZXJlbmNlcyhsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpO1xuICB9XG4gIGNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCBvdXQpIHtcbiAgICBvdXQucHVzaCh0aGlzLl9iZWdpbik7XG4gIH1cbiAgY29tcGlsZShncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKS5jb21waWxlKGdyYW1tYXIpO1xuICB9XG4gIGNvbXBpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkuY29tcGlsZUFHKGdyYW1tYXIsIGFsbG93QSwgYWxsb3dHKTtcbiAgfVxuICBfZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG5ldyBSZWdFeHBTb3VyY2VMaXN0KCk7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5wYXR0ZXJucykge1xuICAgICAgICBjb25zdCBydWxlID0gZ3JhbW1hci5nZXRSdWxlKHBhdHRlcm4pO1xuICAgICAgICBydWxlLmNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFwcGx5RW5kUGF0dGVybkxhc3QpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5wdXNoKHRoaXMuX2VuZC5oYXNCYWNrUmVmZXJlbmNlcyA/IHRoaXMuX2VuZC5jbG9uZSgpIDogdGhpcy5fZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMudW5zaGlmdCh0aGlzLl9lbmQuaGFzQmFja1JlZmVyZW5jZXMgPyB0aGlzLl9lbmQuY2xvbmUoKSA6IHRoaXMuX2VuZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbmQuaGFzQmFja1JlZmVyZW5jZXMpIHtcbiAgICAgIGlmICh0aGlzLmFwcGx5RW5kUGF0dGVybkxhc3QpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5zZXRTb3VyY2UodGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5sZW5ndGgoKSAtIDEsIGVuZFJlZ2V4U291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuc2V0U291cmNlKDAsIGVuZFJlZ2V4U291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIH1cbn07XG52YXIgQmVnaW5XaGlsZVJ1bGUgPSBjbGFzcyBleHRlbmRzIFJ1bGUge1xuICBfYmVnaW47XG4gIGJlZ2luQ2FwdHVyZXM7XG4gIHdoaWxlQ2FwdHVyZXM7XG4gIF93aGlsZTtcbiAgd2hpbGVIYXNCYWNrUmVmZXJlbmNlcztcbiAgaGFzTWlzc2luZ1BhdHRlcm5zO1xuICBwYXR0ZXJucztcbiAgX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIF9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnM7XG4gIGNvbnN0cnVjdG9yKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lLCBiZWdpbiwgYmVnaW5DYXB0dXJlcywgX3doaWxlLCB3aGlsZUNhcHR1cmVzLCBwYXR0ZXJucykge1xuICAgIHN1cGVyKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lKTtcbiAgICB0aGlzLl9iZWdpbiA9IG5ldyBSZWdFeHBTb3VyY2UoYmVnaW4sIHRoaXMuaWQpO1xuICAgIHRoaXMuYmVnaW5DYXB0dXJlcyA9IGJlZ2luQ2FwdHVyZXM7XG4gICAgdGhpcy53aGlsZUNhcHR1cmVzID0gd2hpbGVDYXB0dXJlcztcbiAgICB0aGlzLl93aGlsZSA9IG5ldyBSZWdFeHBTb3VyY2UoX3doaWxlLCB3aGlsZVJ1bGVJZCk7XG4gICAgdGhpcy53aGlsZUhhc0JhY2tSZWZlcmVuY2VzID0gdGhpcy5fd2hpbGUuaGFzQmFja1JlZmVyZW5jZXM7XG4gICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zLnBhdHRlcm5zO1xuICAgIHRoaXMuaGFzTWlzc2luZ1BhdHRlcm5zID0gcGF0dGVybnMuaGFzTWlzc2luZ1BhdHRlcm5zO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucyA9IG51bGw7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBkZWJ1Z0JlZ2luUmVnRXhwKCkge1xuICAgIHJldHVybiBgJHt0aGlzLl9iZWdpbi5zb3VyY2V9YDtcbiAgfVxuICBnZXQgZGVidWdXaGlsZVJlZ0V4cCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fd2hpbGUuc291cmNlfWA7XG4gIH1cbiAgZ2V0V2hpbGVXaXRoUmVzb2x2ZWRCYWNrUmVmZXJlbmNlcyhsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2hpbGUucmVzb2x2ZUJhY2tSZWZlcmVuY2VzKGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcyk7XG4gIH1cbiAgY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIG91dCkge1xuICAgIG91dC5wdXNoKHRoaXMuX2JlZ2luKTtcbiAgfVxuICBjb21waWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikuY29tcGlsZShncmFtbWFyKTtcbiAgfVxuICBjb21waWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikuY29tcGlsZUFHKGdyYW1tYXIsIGFsbG93QSwgYWxsb3dHKTtcbiAgfVxuICBfZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbmV3IFJlZ0V4cFNvdXJjZUxpc3QoKTtcbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnBhdHRlcm5zKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBncmFtbWFyLmdldFJ1bGUocGF0dGVybik7XG4gICAgICAgIHJ1bGUuY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgfVxuICBjb21waWxlV2hpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKS5jb21waWxlKGdyYW1tYXIpO1xuICB9XG4gIGNvbXBpbGVXaGlsZUFHKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Rykge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpLmNvbXBpbGVBRyhncmFtbWFyLCBhbGxvd0EsIGFsbG93Ryk7XG4gIH1cbiAgX2dldENhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMgPSBuZXcgUmVnRXhwU291cmNlTGlzdCgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zLnB1c2godGhpcy5fd2hpbGUuaGFzQmFja1JlZmVyZW5jZXMgPyB0aGlzLl93aGlsZS5jbG9uZSgpIDogdGhpcy5fd2hpbGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fd2hpbGUuaGFzQmFja1JlZmVyZW5jZXMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucy5zZXRTb3VyY2UoMCwgZW5kUmVnZXhTb3VyY2UgPyBlbmRSZWdleFNvdXJjZSA6IFwiXFx1RkZGRlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucztcbiAgfVxufTtcbnZhciBSdWxlRmFjdG9yeSA9IGNsYXNzIF9SdWxlRmFjdG9yeSB7XG4gIHN0YXRpYyBjcmVhdGVDYXB0dXJlUnVsZShoZWxwZXIsICRsb2NhdGlvbiwgbmFtZSwgY29udGVudE5hbWUsIHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQpIHtcbiAgICByZXR1cm4gaGVscGVyLnJlZ2lzdGVyUnVsZSgoaWQpID0+IHtcbiAgICAgIHJldHVybiBuZXcgQ2FwdHVyZVJ1bGUoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUsIHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRDb21waWxlZFJ1bGVJZChkZXNjLCBoZWxwZXIsIHJlcG9zaXRvcnkpIHtcbiAgICBpZiAoIWRlc2MuaWQpIHtcbiAgICAgIGhlbHBlci5yZWdpc3RlclJ1bGUoKGlkKSA9PiB7XG4gICAgICAgIGRlc2MuaWQgPSBpZDtcbiAgICAgICAgaWYgKGRlc2MubWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoUnVsZShcbiAgICAgICAgICAgIGRlc2MuJHZzY29kZVRleHRtYXRlTG9jYXRpb24sXG4gICAgICAgICAgICBkZXNjLmlkLFxuICAgICAgICAgICAgZGVzYy5uYW1lLFxuICAgICAgICAgICAgZGVzYy5tYXRjaCxcbiAgICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZUNhcHR1cmVzKGRlc2MuY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGVzYy5iZWdpbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGlmIChkZXNjLnJlcG9zaXRvcnkpIHtcbiAgICAgICAgICAgIHJlcG9zaXRvcnkgPSBtZXJnZU9iamVjdHMoe30sIHJlcG9zaXRvcnksIGRlc2MucmVwb3NpdG9yeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBwYXR0ZXJucyA9IGRlc2MucGF0dGVybnM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJucyA9PT0gXCJ1bmRlZmluZWRcIiAmJiBkZXNjLmluY2x1ZGUpIHtcbiAgICAgICAgICAgIHBhdHRlcm5zID0gW3sgaW5jbHVkZTogZGVzYy5pbmNsdWRlIH1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEluY2x1ZGVPbmx5UnVsZShcbiAgICAgICAgICAgIGRlc2MuJHZzY29kZVRleHRtYXRlTG9jYXRpb24sXG4gICAgICAgICAgICBkZXNjLmlkLFxuICAgICAgICAgICAgZGVzYy5uYW1lLFxuICAgICAgICAgICAgZGVzYy5jb250ZW50TmFtZSxcbiAgICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZVBhdHRlcm5zKHBhdHRlcm5zLCBoZWxwZXIsIHJlcG9zaXRvcnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYy53aGlsZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQmVnaW5XaGlsZVJ1bGUoXG4gICAgICAgICAgICBkZXNjLiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uLFxuICAgICAgICAgICAgZGVzYy5pZCxcbiAgICAgICAgICAgIGRlc2MubmFtZSxcbiAgICAgICAgICAgIGRlc2MuY29udGVudE5hbWUsXG4gICAgICAgICAgICBkZXNjLmJlZ2luLFxuICAgICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlQ2FwdHVyZXMoZGVzYy5iZWdpbkNhcHR1cmVzIHx8IGRlc2MuY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSksXG4gICAgICAgICAgICBkZXNjLndoaWxlLFxuICAgICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlQ2FwdHVyZXMoZGVzYy53aGlsZUNhcHR1cmVzIHx8IGRlc2MuY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSksXG4gICAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVQYXR0ZXJucyhkZXNjLnBhdHRlcm5zLCBoZWxwZXIsIHJlcG9zaXRvcnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJlZ2luRW5kUnVsZShcbiAgICAgICAgICBkZXNjLiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uLFxuICAgICAgICAgIGRlc2MuaWQsXG4gICAgICAgICAgZGVzYy5uYW1lLFxuICAgICAgICAgIGRlc2MuY29udGVudE5hbWUsXG4gICAgICAgICAgZGVzYy5iZWdpbixcbiAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVDYXB0dXJlcyhkZXNjLmJlZ2luQ2FwdHVyZXMgfHwgZGVzYy5jYXB0dXJlcywgaGVscGVyLCByZXBvc2l0b3J5KSxcbiAgICAgICAgICBkZXNjLmVuZCxcbiAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVDYXB0dXJlcyhkZXNjLmVuZENhcHR1cmVzIHx8IGRlc2MuY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSksXG4gICAgICAgICAgZGVzYy5hcHBseUVuZFBhdHRlcm5MYXN0LFxuICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZVBhdHRlcm5zKGRlc2MucGF0dGVybnMsIGhlbHBlciwgcmVwb3NpdG9yeSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzYy5pZDtcbiAgfVxuICBzdGF0aWMgX2NvbXBpbGVDYXB0dXJlcyhjYXB0dXJlcywgaGVscGVyLCByZXBvc2l0b3J5KSB7XG4gICAgbGV0IHIgPSBbXTtcbiAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgIGxldCBtYXhpbXVtQ2FwdHVyZUlkID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2FwdHVyZUlkIGluIGNhcHR1cmVzKSB7XG4gICAgICAgIGlmIChjYXB0dXJlSWQgPT09IFwiJHZzY29kZVRleHRtYXRlTG9jYXRpb25cIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bWVyaWNDYXB0dXJlSWQgPSBwYXJzZUludChjYXB0dXJlSWQsIDEwKTtcbiAgICAgICAgaWYgKG51bWVyaWNDYXB0dXJlSWQgPiBtYXhpbXVtQ2FwdHVyZUlkKSB7XG4gICAgICAgICAgbWF4aW11bUNhcHR1cmVJZCA9IG51bWVyaWNDYXB0dXJlSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1heGltdW1DYXB0dXJlSWQ7IGkrKykge1xuICAgICAgICByW2ldID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2FwdHVyZUlkIGluIGNhcHR1cmVzKSB7XG4gICAgICAgIGlmIChjYXB0dXJlSWQgPT09IFwiJHZzY29kZVRleHRtYXRlTG9jYXRpb25cIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bWVyaWNDYXB0dXJlSWQgPSBwYXJzZUludChjYXB0dXJlSWQsIDEwKTtcbiAgICAgICAgbGV0IHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQgPSAwO1xuICAgICAgICBpZiAoY2FwdHVyZXNbY2FwdHVyZUlkXS5wYXR0ZXJucykge1xuICAgICAgICAgIHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQoY2FwdHVyZXNbY2FwdHVyZUlkXSwgaGVscGVyLCByZXBvc2l0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByW251bWVyaWNDYXB0dXJlSWRdID0gX1J1bGVGYWN0b3J5LmNyZWF0ZUNhcHR1cmVSdWxlKGhlbHBlciwgY2FwdHVyZXNbY2FwdHVyZUlkXS4kdnNjb2RlVGV4dG1hdGVMb2NhdGlvbiwgY2FwdHVyZXNbY2FwdHVyZUlkXS5uYW1lLCBjYXB0dXJlc1tjYXB0dXJlSWRdLmNvbnRlbnROYW1lLCByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc3RhdGljIF9jb21waWxlUGF0dGVybnMocGF0dGVybnMsIGhlbHBlciwgcmVwb3NpdG9yeSkge1xuICAgIGxldCByID0gW107XG4gICAgaWYgKHBhdHRlcm5zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0dGVybnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuICAgICAgICBsZXQgcnVsZUlkID0gLTE7XG4gICAgICAgIGlmIChwYXR0ZXJuLmluY2x1ZGUpIHtcbiAgICAgICAgICBjb25zdCByZWZlcmVuY2UgPSBwYXJzZUluY2x1ZGUocGF0dGVybi5pbmNsdWRlKTtcbiAgICAgICAgICBzd2l0Y2ggKHJlZmVyZW5jZS5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogQmFzZSAqLzpcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTZWxmICovOlxuICAgICAgICAgICAgICBydWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQocmVwb3NpdG9yeVtwYXR0ZXJuLmluY2x1ZGVdLCBoZWxwZXIsIHJlcG9zaXRvcnkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBSZWxhdGl2ZVJlZmVyZW5jZSAqLzpcbiAgICAgICAgICAgICAgbGV0IGxvY2FsSW5jbHVkZWRSdWxlID0gcmVwb3NpdG9yeVtyZWZlcmVuY2UucnVsZU5hbWVdO1xuICAgICAgICAgICAgICBpZiAobG9jYWxJbmNsdWRlZFJ1bGUpIHtcbiAgICAgICAgICAgICAgICBydWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQobG9jYWxJbmNsdWRlZFJ1bGUsIGhlbHBlciwgcmVwb3NpdG9yeSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMgLyogVG9wTGV2ZWxSZWZlcmVuY2UgKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlICovOlxuICAgICAgICAgICAgICBjb25zdCBleHRlcm5hbEdyYW1tYXJOYW1lID0gcmVmZXJlbmNlLnNjb3BlTmFtZTtcbiAgICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWxHcmFtbWFySW5jbHVkZSA9IHJlZmVyZW5jZS5raW5kID09PSA0IC8qIFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZSAqLyA/IHJlZmVyZW5jZS5ydWxlTmFtZSA6IG51bGw7XG4gICAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsR3JhbW1hciA9IGhlbHBlci5nZXRFeHRlcm5hbEdyYW1tYXIoZXh0ZXJuYWxHcmFtbWFyTmFtZSwgcmVwb3NpdG9yeSk7XG4gICAgICAgICAgICAgIGlmIChleHRlcm5hbEdyYW1tYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWxHcmFtbWFySW5jbHVkZSkge1xuICAgICAgICAgICAgICAgICAgbGV0IGV4dGVybmFsSW5jbHVkZWRSdWxlID0gZXh0ZXJuYWxHcmFtbWFyLnJlcG9zaXRvcnlbZXh0ZXJuYWxHcmFtbWFySW5jbHVkZV07XG4gICAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWxJbmNsdWRlZFJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkID0gX1J1bGVGYWN0b3J5LmdldENvbXBpbGVkUnVsZUlkKGV4dGVybmFsSW5jbHVkZWRSdWxlLCBoZWxwZXIsIGV4dGVybmFsR3JhbW1hci5yZXBvc2l0b3J5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJ1bGVJZCA9IF9SdWxlRmFjdG9yeS5nZXRDb21waWxlZFJ1bGVJZChleHRlcm5hbEdyYW1tYXIucmVwb3NpdG9yeS4kc2VsZiwgaGVscGVyLCBleHRlcm5hbEdyYW1tYXIucmVwb3NpdG9yeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQocGF0dGVybiwgaGVscGVyLCByZXBvc2l0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVsZUlkICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHJ1bGUgPSBoZWxwZXIuZ2V0UnVsZShydWxlSWQpO1xuICAgICAgICAgIGxldCBza2lwUnVsZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgSW5jbHVkZU9ubHlSdWxlIHx8IHJ1bGUgaW5zdGFuY2VvZiBCZWdpbkVuZFJ1bGUgfHwgcnVsZSBpbnN0YW5jZW9mIEJlZ2luV2hpbGVSdWxlKSB7XG4gICAgICAgICAgICBpZiAocnVsZS5oYXNNaXNzaW5nUGF0dGVybnMgJiYgcnVsZS5wYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgc2tpcFJ1bGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2tpcFJ1bGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByLnB1c2gocnVsZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0dGVybnM6IHIsXG4gICAgICBoYXNNaXNzaW5nUGF0dGVybnM6IChwYXR0ZXJucyA/IHBhdHRlcm5zLmxlbmd0aCA6IDApICE9PSByLmxlbmd0aFxuICAgIH07XG4gIH1cbn07XG52YXIgUmVnRXhwU291cmNlID0gY2xhc3MgX1JlZ0V4cFNvdXJjZSB7XG4gIHNvdXJjZTtcbiAgcnVsZUlkO1xuICBoYXNBbmNob3I7XG4gIGhhc0JhY2tSZWZlcmVuY2VzO1xuICBfYW5jaG9yQ2FjaGU7XG4gIGNvbnN0cnVjdG9yKHJlZ0V4cFNvdXJjZSwgcnVsZUlkKSB7XG4gICAgaWYgKHJlZ0V4cFNvdXJjZSAmJiB0eXBlb2YgcmVnRXhwU291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBsZW4gPSByZWdFeHBTb3VyY2UubGVuZ3RoO1xuICAgICAgbGV0IGxhc3RQdXNoZWRQb3MgPSAwO1xuICAgICAgbGV0IG91dHB1dCA9IFtdO1xuICAgICAgbGV0IGhhc0FuY2hvciA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgICAgICBjb25zdCBjaCA9IHJlZ0V4cFNvdXJjZS5jaGFyQXQocG9zKTtcbiAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgIGlmIChwb3MgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2ggPSByZWdFeHBTb3VyY2UuY2hhckF0KHBvcyArIDEpO1xuICAgICAgICAgICAgaWYgKG5leHRDaCA9PT0gXCJ6XCIpIHtcbiAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocmVnRXhwU291cmNlLnN1YnN0cmluZyhsYXN0UHVzaGVkUG9zLCBwb3MpKTtcbiAgICAgICAgICAgICAgb3V0cHV0LnB1c2goXCIkKD8hXFxcXG4pKD88IVxcXFxuKVwiKTtcbiAgICAgICAgICAgICAgbGFzdFB1c2hlZFBvcyA9IHBvcyArIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaCA9PT0gXCJBXCIgfHwgbmV4dENoID09PSBcIkdcIikge1xuICAgICAgICAgICAgICBoYXNBbmNob3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmhhc0FuY2hvciA9IGhhc0FuY2hvcjtcbiAgICAgIGlmIChsYXN0UHVzaGVkUG9zID09PSAwKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gcmVnRXhwU291cmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocmVnRXhwU291cmNlLnN1YnN0cmluZyhsYXN0UHVzaGVkUG9zLCBsZW4pKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBvdXRwdXQuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYXNBbmNob3IgPSBmYWxzZTtcbiAgICAgIHRoaXMuc291cmNlID0gcmVnRXhwU291cmNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNBbmNob3IpIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlID0gdGhpcy5fYnVpbGRBbmNob3JDYWNoZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucnVsZUlkID0gcnVsZUlkO1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuaGFzQmFja1JlZmVyZW5jZXMgPSBIQVNfQkFDS19SRUZFUkVOQ0VTLnRlc3QodGhpcy5zb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhc0JhY2tSZWZlcmVuY2VzID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX1JlZ0V4cFNvdXJjZSh0aGlzLnNvdXJjZSwgdGhpcy5ydWxlSWQpO1xuICB9XG4gIHNldFNvdXJjZShuZXdTb3VyY2UpIHtcbiAgICBpZiAodGhpcy5zb3VyY2UgPT09IG5ld1NvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZSA9IG5ld1NvdXJjZTtcbiAgICBpZiAodGhpcy5oYXNBbmNob3IpIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlID0gdGhpcy5fYnVpbGRBbmNob3JDYWNoZSgpO1xuICAgIH1cbiAgfVxuICByZXNvbHZlQmFja1JlZmVyZW5jZXMobGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBzb3VyY2UgaXMgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIGxldCBjYXB0dXJlZFZhbHVlcyA9IGNhcHR1cmVJbmRpY2VzLm1hcCgoY2FwdHVyZSkgPT4ge1xuICAgICAgcmV0dXJuIGxpbmVUZXh0LnN1YnN0cmluZyhjYXB0dXJlLnN0YXJ0LCBjYXB0dXJlLmVuZCk7XG4gICAgfSk7XG4gICAgQkFDS19SRUZFUkVOQ0lOR19FTkQubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UucmVwbGFjZShCQUNLX1JFRkVSRU5DSU5HX0VORCwgKG1hdGNoLCBnMSkgPT4ge1xuICAgICAgcmV0dXJuIGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoY2FwdHVyZWRWYWx1ZXNbcGFyc2VJbnQoZzEsIDEwKV0gfHwgXCJcIik7XG4gICAgfSk7XG4gIH1cbiAgX2J1aWxkQW5jaG9yQ2FjaGUoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBzb3VyY2UgaXMgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIGxldCBBMF9HMF9yZXN1bHQgPSBbXTtcbiAgICBsZXQgQTBfRzFfcmVzdWx0ID0gW107XG4gICAgbGV0IEExX0cwX3Jlc3VsdCA9IFtdO1xuICAgIGxldCBBMV9HMV9yZXN1bHQgPSBbXTtcbiAgICBsZXQgcG9zLCBsZW4sIGNoLCBuZXh0Q2g7XG4gICAgZm9yIChwb3MgPSAwLCBsZW4gPSB0aGlzLnNvdXJjZS5sZW5ndGg7IHBvcyA8IGxlbjsgcG9zKyspIHtcbiAgICAgIGNoID0gdGhpcy5zb3VyY2UuY2hhckF0KHBvcyk7XG4gICAgICBBMF9HMF9yZXN1bHRbcG9zXSA9IGNoO1xuICAgICAgQTBfRzFfcmVzdWx0W3Bvc10gPSBjaDtcbiAgICAgIEExX0cwX3Jlc3VsdFtwb3NdID0gY2g7XG4gICAgICBBMV9HMV9yZXN1bHRbcG9zXSA9IGNoO1xuICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICBpZiAocG9zICsgMSA8IGxlbikge1xuICAgICAgICAgIG5leHRDaCA9IHRoaXMuc291cmNlLmNoYXJBdChwb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dENoID09PSBcIkFcIikge1xuICAgICAgICAgICAgQTBfRzBfcmVzdWx0W3BvcyArIDFdID0gXCJcXHVGRkZGXCI7XG4gICAgICAgICAgICBBMF9HMV9yZXN1bHRbcG9zICsgMV0gPSBcIlxcdUZGRkZcIjtcbiAgICAgICAgICAgIEExX0cwX3Jlc3VsdFtwb3MgKyAxXSA9IFwiQVwiO1xuICAgICAgICAgICAgQTFfRzFfcmVzdWx0W3BvcyArIDFdID0gXCJBXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2ggPT09IFwiR1wiKSB7XG4gICAgICAgICAgICBBMF9HMF9yZXN1bHRbcG9zICsgMV0gPSBcIlxcdUZGRkZcIjtcbiAgICAgICAgICAgIEEwX0cxX3Jlc3VsdFtwb3MgKyAxXSA9IFwiR1wiO1xuICAgICAgICAgICAgQTFfRzBfcmVzdWx0W3BvcyArIDFdID0gXCJcXHVGRkZGXCI7XG4gICAgICAgICAgICBBMV9HMV9yZXN1bHRbcG9zICsgMV0gPSBcIkdcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQTBfRzBfcmVzdWx0W3BvcyArIDFdID0gbmV4dENoO1xuICAgICAgICAgICAgQTBfRzFfcmVzdWx0W3BvcyArIDFdID0gbmV4dENoO1xuICAgICAgICAgICAgQTFfRzBfcmVzdWx0W3BvcyArIDFdID0gbmV4dENoO1xuICAgICAgICAgICAgQTFfRzFfcmVzdWx0W3BvcyArIDFdID0gbmV4dENoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgQTBfRzA6IEEwX0cwX3Jlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgQTBfRzE6IEEwX0cxX3Jlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgQTFfRzA6IEExX0cwX3Jlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgQTFfRzE6IEExX0cxX3Jlc3VsdC5qb2luKFwiXCIpXG4gICAgfTtcbiAgfVxuICByZXNvbHZlQW5jaG9ycyhhbGxvd0EsIGFsbG93Rykge1xuICAgIGlmICghdGhpcy5oYXNBbmNob3IgfHwgIXRoaXMuX2FuY2hvckNhY2hlIHx8IHR5cGVvZiB0aGlzLnNvdXJjZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dBKSB7XG4gICAgICBpZiAoYWxsb3dHKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFsbG93Rykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzA7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIFJlZ0V4cFNvdXJjZUxpc3QgPSBjbGFzcyB7XG4gIF9pdGVtcztcbiAgX2hhc0FuY2hvcnM7XG4gIF9jYWNoZWQ7XG4gIF9hbmNob3JDYWNoZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB0aGlzLl9oYXNBbmNob3JzID0gZmFsc2U7XG4gICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICB0aGlzLl9hbmNob3JDYWNoZSA9IHtcbiAgICAgIEEwX0cwOiBudWxsLFxuICAgICAgQTBfRzE6IG51bGwsXG4gICAgICBBMV9HMDogbnVsbCxcbiAgICAgIEExX0cxOiBudWxsXG4gICAgfTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2Rpc3Bvc2VDYWNoZXMoKTtcbiAgfVxuICBfZGlzcG9zZUNhY2hlcygpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkKSB7XG4gICAgICB0aGlzLl9jYWNoZWQuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2FuY2hvckNhY2hlLkEwX0cwKSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hbmNob3JDYWNoZS5BMF9HMSkge1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzEuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzApIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkExX0cwLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkExX0cwID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2FuY2hvckNhY2hlLkExX0cxKSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHB1c2goaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5faGFzQW5jaG9ycyA9IHRoaXMuX2hhc0FuY2hvcnMgfHwgaXRlbS5oYXNBbmNob3I7XG4gIH1cbiAgdW5zaGlmdChpdGVtKSB7XG4gICAgdGhpcy5faXRlbXMudW5zaGlmdChpdGVtKTtcbiAgICB0aGlzLl9oYXNBbmNob3JzID0gdGhpcy5faGFzQW5jaG9ycyB8fCBpdGVtLmhhc0FuY2hvcjtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgfVxuICBzZXRTb3VyY2UoaW5kZXgsIG5ld1NvdXJjZSkge1xuICAgIGlmICh0aGlzLl9pdGVtc1tpbmRleF0uc291cmNlICE9PSBuZXdTb3VyY2UpIHtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VDYWNoZXMoKTtcbiAgICAgIHRoaXMuX2l0ZW1zW2luZGV4XS5zZXRTb3VyY2UobmV3U291cmNlKTtcbiAgICB9XG4gIH1cbiAgY29tcGlsZShvbmlnTGliKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWQpIHtcbiAgICAgIGxldCByZWdFeHBzID0gdGhpcy5faXRlbXMubWFwKChlKSA9PiBlLnNvdXJjZSk7XG4gICAgICB0aGlzLl9jYWNoZWQgPSBuZXcgQ29tcGlsZWRSdWxlKG9uaWdMaWIsIHJlZ0V4cHMsIHRoaXMuX2l0ZW1zLm1hcCgoZSkgPT4gZS5ydWxlSWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgfVxuICBjb21waWxlQUcob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICBpZiAoIXRoaXMuX2hhc0FuY2hvcnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGUob25pZ0xpYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGxvd0EpIHtcbiAgICAgICAgaWYgKGFsbG93Rykge1xuICAgICAgICAgIGlmICghdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzEpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkExX0cxID0gdGhpcy5fcmVzb2x2ZUFuY2hvcnMob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hbmNob3JDYWNoZS5BMV9HMCkge1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzAgPSB0aGlzLl9yZXNvbHZlQW5jaG9ycyhvbmlnTGliLCBhbGxvd0EsIGFsbG93Ryk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFsbG93Rykge1xuICAgICAgICAgIGlmICghdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzEpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cxID0gdGhpcy5fcmVzb2x2ZUFuY2hvcnMob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hbmNob3JDYWNoZS5BMF9HMCkge1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzAgPSB0aGlzLl9yZXNvbHZlQW5jaG9ycyhvbmlnTGliLCBhbGxvd0EsIGFsbG93Ryk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcmVzb2x2ZUFuY2hvcnMob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICBsZXQgcmVnRXhwcyA9IHRoaXMuX2l0ZW1zLm1hcCgoZSkgPT4gZS5yZXNvbHZlQW5jaG9ycyhhbGxvd0EsIGFsbG93RykpO1xuICAgIHJldHVybiBuZXcgQ29tcGlsZWRSdWxlKG9uaWdMaWIsIHJlZ0V4cHMsIHRoaXMuX2l0ZW1zLm1hcCgoZSkgPT4gZS5ydWxlSWQpKTtcbiAgfVxufTtcbnZhciBDb21waWxlZFJ1bGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9uaWdMaWIsIHJlZ0V4cHMsIHJ1bGVzKSB7XG4gICAgdGhpcy5yZWdFeHBzID0gcmVnRXhwcztcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy5zY2FubmVyID0gb25pZ0xpYi5jcmVhdGVPbmlnU2Nhbm5lcihyZWdFeHBzKTtcbiAgfVxuICBzY2FubmVyO1xuICBkaXNwb3NlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zY2FubmVyLmRpc3Bvc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5zY2FubmVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnJ1bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByLnB1c2goXCIgICAtIFwiICsgdGhpcy5ydWxlc1tpXSArIFwiOiBcIiArIHRoaXMucmVnRXhwc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgZmluZE5leHRNYXRjaFN5bmMoc3RyaW5nLCBzdGFydFBvc2l0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zY2FubmVyLmZpbmROZXh0TWF0Y2hTeW5jKHN0cmluZywgc3RhcnRQb3NpdGlvbiwgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcnVsZUlkOiB0aGlzLnJ1bGVzW3Jlc3VsdC5pbmRleF0sXG4gICAgICBjYXB0dXJlSW5kaWNlczogcmVzdWx0LmNhcHR1cmVJbmRpY2VzXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2dyYW1tYXIvYmFzaWNTY29wZXNBdHRyaWJ1dGVQcm92aWRlci50c1xudmFyIEJhc2ljU2NvcGVBdHRyaWJ1dGVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihsYW5ndWFnZUlkLCB0b2tlblR5cGUpIHtcbiAgICB0aGlzLmxhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICB9XG59O1xudmFyIEJhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIgPSBjbGFzcyBfQmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlciB7XG4gIF9kZWZhdWx0QXR0cmlidXRlcztcbiAgX2VtYmVkZGVkTGFuZ3VhZ2VzTWF0Y2hlcjtcbiAgY29uc3RydWN0b3IoaW5pdGlhbExhbmd1YWdlSWQsIGVtYmVkZGVkTGFuZ3VhZ2VzKSB7XG4gICAgdGhpcy5fZGVmYXVsdEF0dHJpYnV0ZXMgPSBuZXcgQmFzaWNTY29wZUF0dHJpYnV0ZXMoaW5pdGlhbExhbmd1YWdlSWQsIDggLyogTm90U2V0ICovKTtcbiAgICB0aGlzLl9lbWJlZGRlZExhbmd1YWdlc01hdGNoZXIgPSBuZXcgU2NvcGVNYXRjaGVyKE9iamVjdC5lbnRyaWVzKGVtYmVkZGVkTGFuZ3VhZ2VzIHx8IHt9KSk7XG4gIH1cbiAgZ2V0RGVmYXVsdEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRBdHRyaWJ1dGVzO1xuICB9XG4gIGdldEJhc2ljU2NvcGVBdHRyaWJ1dGVzKHNjb3BlTmFtZSkge1xuICAgIGlmIChzY29wZU5hbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBfQmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlci5fTlVMTF9TQ09QRV9NRVRBREFUQTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldEJhc2ljU2NvcGVBdHRyaWJ1dGVzLmdldChzY29wZU5hbWUpO1xuICB9XG4gIHN0YXRpYyBfTlVMTF9TQ09QRV9NRVRBREFUQSA9IG5ldyBCYXNpY1Njb3BlQXR0cmlidXRlcygwLCAwKTtcbiAgX2dldEJhc2ljU2NvcGVBdHRyaWJ1dGVzID0gbmV3IENhY2hlZEZuKChzY29wZU5hbWUpID0+IHtcbiAgICBjb25zdCBsYW5ndWFnZUlkID0gdGhpcy5fc2NvcGVUb0xhbmd1YWdlKHNjb3BlTmFtZSk7XG4gICAgY29uc3Qgc3RhbmRhcmRUb2tlblR5cGUgPSB0aGlzLl90b1N0YW5kYXJkVG9rZW5UeXBlKHNjb3BlTmFtZSk7XG4gICAgcmV0dXJuIG5ldyBCYXNpY1Njb3BlQXR0cmlidXRlcyhsYW5ndWFnZUlkLCBzdGFuZGFyZFRva2VuVHlwZSk7XG4gIH0pO1xuICAvKipcbiAgICogR2l2ZW4gYSBwcm9kdWNlZCBUTSBzY29wZSwgcmV0dXJuIHRoZSBsYW5ndWFnZSB0aGF0IHRva2VuIGRlc2NyaWJlcyBvciBudWxsIGlmIHVua25vd24uXG4gICAqIGUuZy4gc291cmNlLmh0bWwgPT4gaHRtbCwgc291cmNlLmNzcy5lbWJlZGRlZC5odG1sID0+IGNzcywgcHVuY3R1YXRpb24uZGVmaW5pdGlvbi50YWcuaHRtbCA9PiBudWxsXG4gICAqL1xuICBfc2NvcGVUb0xhbmd1YWdlKHNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtYmVkZGVkTGFuZ3VhZ2VzTWF0Y2hlci5tYXRjaChzY29wZSkgfHwgMDtcbiAgfVxuICBfdG9TdGFuZGFyZFRva2VuVHlwZShzY29wZU5hbWUpIHtcbiAgICBjb25zdCBtID0gc2NvcGVOYW1lLm1hdGNoKF9CYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyLlNUQU5EQVJEX1RPS0VOX1RZUEVfUkVHRVhQKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgIHJldHVybiA4IC8qIE5vdFNldCAqLztcbiAgICB9XG4gICAgc3dpdGNoIChtWzFdKSB7XG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICByZXR1cm4gMSAvKiBDb21tZW50ICovO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gMiAvKiBTdHJpbmcgKi87XG4gICAgICBjYXNlIFwicmVnZXhcIjpcbiAgICAgICAgcmV0dXJuIDMgLyogUmVnRXggKi87XG4gICAgICBjYXNlIFwibWV0YS5lbWJlZGRlZFwiOlxuICAgICAgICByZXR1cm4gMCAvKiBPdGhlciAqLztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtYXRjaCBmb3Igc3RhbmRhcmQgdG9rZW4gdHlwZSFcIik7XG4gIH1cbiAgc3RhdGljIFNUQU5EQVJEX1RPS0VOX1RZUEVfUkVHRVhQID0gL1xcYihjb21tZW50fHN0cmluZ3xyZWdleHxtZXRhXFwuZW1iZWRkZWQpXFxiLztcbn07XG52YXIgU2NvcGVNYXRjaGVyID0gY2xhc3Mge1xuICB2YWx1ZXM7XG4gIHNjb3Blc1JlZ0V4cDtcbiAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcbiAgICAgIHRoaXMuc2NvcGVzUmVnRXhwID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKHZhbHVlcyk7XG4gICAgICBjb25zdCBlc2NhcGVkU2NvcGVzID0gdmFsdWVzLm1hcChcbiAgICAgICAgKFtzY29wZU5hbWUsIHZhbHVlXSkgPT4gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyhzY29wZU5hbWUpXG4gICAgICApO1xuICAgICAgZXNjYXBlZFNjb3Blcy5zb3J0KCk7XG4gICAgICBlc2NhcGVkU2NvcGVzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc2NvcGVzUmVnRXhwID0gbmV3IFJlZ0V4cChcbiAgICAgICAgYF4oKCR7ZXNjYXBlZFNjb3Blcy5qb2luKFwiKXwoXCIpfSkpKCR8XFxcXC4pYCxcbiAgICAgICAgXCJcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbWF0Y2goc2NvcGUpIHtcbiAgICBpZiAoIXRoaXMuc2NvcGVzUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBtID0gc2NvcGUubWF0Y2godGhpcy5zY29wZXNSZWdFeHApO1xuICAgIGlmICghbSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzLmdldChtWzFdKTtcbiAgfVxufTtcblxuLy8gc3JjL2RlYnVnLnRzXG52YXIgRGVidWdGbGFncyA9IHtcbiAgSW5EZWJ1Z01vZGU6IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmICEhcHJvY2Vzcy5lbnZbXCJWU0NPREVfVEVYVE1BVEVfREVCVUdcIl1cbn07XG52YXIgVXNlT25pZ3VydW1hRmluZE9wdGlvbnMgPSBmYWxzZTtcblxuLy8gc3JjL2dyYW1tYXIvdG9rZW5pemVTdHJpbmcudHNcbnZhciBUb2tlbml6ZVN0cmluZ1Jlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RhY2ssIHN0b3BwZWRFYXJseSkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLnN0b3BwZWRFYXJseSA9IHN0b3BwZWRFYXJseTtcbiAgfVxufTtcbmZ1bmN0aW9uIF90b2tlbml6ZVN0cmluZyhncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIGxpbmVQb3MsIHN0YWNrLCBsaW5lVG9rZW5zLCBjaGVja1doaWxlQ29uZGl0aW9ucywgdGltZUxpbWl0KSB7XG4gIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lVGV4dC5jb250ZW50Lmxlbmd0aDtcbiAgbGV0IFNUT1AgPSBmYWxzZTtcbiAgbGV0IGFuY2hvclBvc2l0aW9uID0gLTE7XG4gIGlmIChjaGVja1doaWxlQ29uZGl0aW9ucykge1xuICAgIGNvbnN0IHdoaWxlQ2hlY2tSZXN1bHQgPSBfY2hlY2tXaGlsZUNvbmRpdGlvbnMoXG4gICAgICBncmFtbWFyLFxuICAgICAgbGluZVRleHQsXG4gICAgICBpc0ZpcnN0TGluZSxcbiAgICAgIGxpbmVQb3MsXG4gICAgICBzdGFjayxcbiAgICAgIGxpbmVUb2tlbnNcbiAgICApO1xuICAgIHN0YWNrID0gd2hpbGVDaGVja1Jlc3VsdC5zdGFjaztcbiAgICBsaW5lUG9zID0gd2hpbGVDaGVja1Jlc3VsdC5saW5lUG9zO1xuICAgIGlzRmlyc3RMaW5lID0gd2hpbGVDaGVja1Jlc3VsdC5pc0ZpcnN0TGluZTtcbiAgICBhbmNob3JQb3NpdGlvbiA9IHdoaWxlQ2hlY2tSZXN1bHQuYW5jaG9yUG9zaXRpb247XG4gIH1cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgd2hpbGUgKCFTVE9QKSB7XG4gICAgaWYgKHRpbWVMaW1pdCAhPT0gMCkge1xuICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgaWYgKGVsYXBzZWRUaW1lID4gdGltZUxpbWl0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5pemVTdHJpbmdSZXN1bHQoc3RhY2ssIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzY2FuTmV4dCgpO1xuICB9XG4gIHJldHVybiBuZXcgVG9rZW5pemVTdHJpbmdSZXN1bHQoc3RhY2ssIGZhbHNlKTtcbiAgZnVuY3Rpb24gc2Nhbk5leHQoKSB7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgQEBzY2FuTmV4dCAke2xpbmVQb3N9OiB8JHtsaW5lVGV4dC5jb250ZW50LnN1YnN0cihsaW5lUG9zKS5yZXBsYWNlKC9cXG4kLywgXCJcXFxcblwiKX18YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgciA9IG1hdGNoUnVsZU9ySW5qZWN0aW9ucyhcbiAgICAgIGdyYW1tYXIsXG4gICAgICBsaW5lVGV4dCxcbiAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgbGluZVBvcyxcbiAgICAgIHN0YWNrLFxuICAgICAgYW5jaG9yUG9zaXRpb25cbiAgICApO1xuICAgIGlmICghcikge1xuICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgIFNUT1AgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYXB0dXJlSW5kaWNlcyA9IHIuY2FwdHVyZUluZGljZXM7XG4gICAgY29uc3QgbWF0Y2hlZFJ1bGVJZCA9IHIubWF0Y2hlZFJ1bGVJZDtcbiAgICBjb25zdCBoYXNBZHZhbmNlZCA9IGNhcHR1cmVJbmRpY2VzICYmIGNhcHR1cmVJbmRpY2VzLmxlbmd0aCA+IDAgPyBjYXB0dXJlSW5kaWNlc1swXS5lbmQgPiBsaW5lUG9zIDogZmFsc2U7XG4gICAgaWYgKG1hdGNoZWRSdWxlSWQgPT09IGVuZFJ1bGVJZCkge1xuICAgICAgY29uc3QgcG9wcGVkUnVsZSA9IHN0YWNrLmdldFJ1bGUoZ3JhbW1hcik7XG4gICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCIgIHBvcHBpbmcgXCIgKyBwb3BwZWRSdWxlLmRlYnVnTmFtZSArIFwiIC0gXCIgKyBwb3BwZWRSdWxlLmRlYnVnRW5kUmVnRXhwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0KTtcbiAgICAgIHN0YWNrID0gc3RhY2sud2l0aENvbnRlbnROYW1lU2NvcGVzTGlzdChzdGFjay5uYW1lU2NvcGVzTGlzdCk7XG4gICAgICBoYW5kbGVDYXB0dXJlcyhcbiAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgbGluZVRleHQsXG4gICAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgICBzdGFjayxcbiAgICAgICAgbGluZVRva2VucyxcbiAgICAgICAgcG9wcGVkUnVsZS5lbmRDYXB0dXJlcyxcbiAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICk7XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRpY2VzWzBdLmVuZCk7XG4gICAgICBjb25zdCBwb3BwZWQgPSBzdGFjaztcbiAgICAgIHN0YWNrID0gc3RhY2sucGFyZW50O1xuICAgICAgYW5jaG9yUG9zaXRpb24gPSBwb3BwZWQuZ2V0QW5jaG9yUG9zKCk7XG4gICAgICBpZiAoIWhhc0FkdmFuY2VkICYmIHBvcHBlZC5nZXRFbnRlclBvcygpID09PSBsaW5lUG9zKSB7XG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlsxXSAtIEdyYW1tYXIgaXMgaW4gYW4gZW5kbGVzcyBsb29wIC0gR3JhbW1hciBwdXNoZWQgJiBwb3BwZWQgYSBydWxlIHdpdGhvdXQgYWR2YW5jaW5nXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrID0gcG9wcGVkO1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgICBTVE9QID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBfcnVsZSA9IGdyYW1tYXIuZ2V0UnVsZShtYXRjaGVkUnVsZUlkKTtcbiAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgY2FwdHVyZUluZGljZXNbMF0uc3RhcnQpO1xuICAgICAgY29uc3QgYmVmb3JlUHVzaCA9IHN0YWNrO1xuICAgICAgY29uc3Qgc2NvcGVOYW1lID0gX3J1bGUuZ2V0TmFtZShsaW5lVGV4dC5jb250ZW50LCBjYXB0dXJlSW5kaWNlcyk7XG4gICAgICBjb25zdCBuYW1lU2NvcGVzTGlzdCA9IHN0YWNrLmNvbnRlbnROYW1lU2NvcGVzTGlzdC5wdXNoQXR0cmlidXRlZChcbiAgICAgICAgc2NvcGVOYW1lLFxuICAgICAgICBncmFtbWFyXG4gICAgICApO1xuICAgICAgc3RhY2sgPSBzdGFjay5wdXNoKFxuICAgICAgICBtYXRjaGVkUnVsZUlkLFxuICAgICAgICBsaW5lUG9zLFxuICAgICAgICBhbmNob3JQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZUluZGljZXNbMF0uZW5kID09PSBsaW5lTGVuZ3RoLFxuICAgICAgICBudWxsLFxuICAgICAgICBuYW1lU2NvcGVzTGlzdCxcbiAgICAgICAgbmFtZVNjb3Blc0xpc3RcbiAgICAgICk7XG4gICAgICBpZiAoX3J1bGUgaW5zdGFuY2VvZiBCZWdpbkVuZFJ1bGUpIHtcbiAgICAgICAgY29uc3QgcHVzaGVkUnVsZSA9IF9ydWxlO1xuICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwiICBwdXNoaW5nIFwiICsgcHVzaGVkUnVsZS5kZWJ1Z05hbWUgKyBcIiAtIFwiICsgcHVzaGVkUnVsZS5kZWJ1Z0JlZ2luUmVnRXhwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVDYXB0dXJlcyhcbiAgICAgICAgICBncmFtbWFyLFxuICAgICAgICAgIGxpbmVUZXh0LFxuICAgICAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgIGxpbmVUb2tlbnMsXG4gICAgICAgICAgcHVzaGVkUnVsZS5iZWdpbkNhcHR1cmVzLFxuICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgY2FwdHVyZUluZGljZXNbMF0uZW5kKTtcbiAgICAgICAgYW5jaG9yUG9zaXRpb24gPSBjYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnROYW1lID0gcHVzaGVkUnVsZS5nZXRDb250ZW50TmFtZShcbiAgICAgICAgICBsaW5lVGV4dC5jb250ZW50LFxuICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnROYW1lU2NvcGVzTGlzdCA9IG5hbWVTY29wZXNMaXN0LnB1c2hBdHRyaWJ1dGVkKFxuICAgICAgICAgIGNvbnRlbnROYW1lLFxuICAgICAgICAgIGdyYW1tYXJcbiAgICAgICAgKTtcbiAgICAgICAgc3RhY2sgPSBzdGFjay53aXRoQ29udGVudE5hbWVTY29wZXNMaXN0KGNvbnRlbnROYW1lU2NvcGVzTGlzdCk7XG4gICAgICAgIGlmIChwdXNoZWRSdWxlLmVuZEhhc0JhY2tSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgc3RhY2sgPSBzdGFjay53aXRoRW5kUnVsZShcbiAgICAgICAgICAgIHB1c2hlZFJ1bGUuZ2V0RW5kV2l0aFJlc29sdmVkQmFja1JlZmVyZW5jZXMoXG4gICAgICAgICAgICAgIGxpbmVUZXh0LmNvbnRlbnQsXG4gICAgICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0FkdmFuY2VkICYmIGJlZm9yZVB1c2guaGFzU2FtZVJ1bGVBcyhzdGFjaykpIHtcbiAgICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWzJdIC0gR3JhbW1hciBpcyBpbiBhbiBlbmRsZXNzIGxvb3AgLSBHcmFtbWFyIHB1c2hlZCB0aGUgc2FtZSBydWxlIHdpdGhvdXQgYWR2YW5jaW5nXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICBTVE9QID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3J1bGUgaW5zdGFuY2VvZiBCZWdpbldoaWxlUnVsZSkge1xuICAgICAgICBjb25zdCBwdXNoZWRSdWxlID0gX3J1bGU7XG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiICBwdXNoaW5nIFwiICsgcHVzaGVkUnVsZS5kZWJ1Z05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUNhcHR1cmVzKFxuICAgICAgICAgIGdyYW1tYXIsXG4gICAgICAgICAgbGluZVRleHQsXG4gICAgICAgICAgaXNGaXJzdExpbmUsXG4gICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgbGluZVRva2VucyxcbiAgICAgICAgICBwdXNoZWRSdWxlLmJlZ2luQ2FwdHVyZXMsXG4gICAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBjYXB0dXJlSW5kaWNlc1swXS5lbmQpO1xuICAgICAgICBhbmNob3JQb3NpdGlvbiA9IGNhcHR1cmVJbmRpY2VzWzBdLmVuZDtcbiAgICAgICAgY29uc3QgY29udGVudE5hbWUgPSBwdXNoZWRSdWxlLmdldENvbnRlbnROYW1lKFxuICAgICAgICAgIGxpbmVUZXh0LmNvbnRlbnQsXG4gICAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29udGVudE5hbWVTY29wZXNMaXN0ID0gbmFtZVNjb3Blc0xpc3QucHVzaEF0dHJpYnV0ZWQoXG4gICAgICAgICAgY29udGVudE5hbWUsXG4gICAgICAgICAgZ3JhbW1hclxuICAgICAgICApO1xuICAgICAgICBzdGFjayA9IHN0YWNrLndpdGhDb250ZW50TmFtZVNjb3Blc0xpc3QoY29udGVudE5hbWVTY29wZXNMaXN0KTtcbiAgICAgICAgaWYgKHB1c2hlZFJ1bGUud2hpbGVIYXNCYWNrUmVmZXJlbmNlcykge1xuICAgICAgICAgIHN0YWNrID0gc3RhY2sud2l0aEVuZFJ1bGUoXG4gICAgICAgICAgICBwdXNoZWRSdWxlLmdldFdoaWxlV2l0aFJlc29sdmVkQmFja1JlZmVyZW5jZXMoXG4gICAgICAgICAgICAgIGxpbmVUZXh0LmNvbnRlbnQsXG4gICAgICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0FkdmFuY2VkICYmIGJlZm9yZVB1c2guaGFzU2FtZVJ1bGVBcyhzdGFjaykpIHtcbiAgICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWzNdIC0gR3JhbW1hciBpcyBpbiBhbiBlbmRsZXNzIGxvb3AgLSBHcmFtbWFyIHB1c2hlZCB0aGUgc2FtZSBydWxlIHdpdGhvdXQgYWR2YW5jaW5nXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICBTVE9QID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nUnVsZSA9IF9ydWxlO1xuICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwiICBtYXRjaGVkIFwiICsgbWF0Y2hpbmdSdWxlLmRlYnVnTmFtZSArIFwiIC0gXCIgKyBtYXRjaGluZ1J1bGUuZGVidWdNYXRjaFJlZ0V4cFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlQ2FwdHVyZXMoXG4gICAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgICBsaW5lVGV4dCxcbiAgICAgICAgICBpc0ZpcnN0TGluZSxcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgICBsaW5lVG9rZW5zLFxuICAgICAgICAgIG1hdGNoaW5nUnVsZS5jYXB0dXJlcyxcbiAgICAgICAgICBjYXB0dXJlSW5kaWNlc1xuICAgICAgICApO1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRpY2VzWzBdLmVuZCk7XG4gICAgICAgIHN0YWNrID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghaGFzQWR2YW5jZWQpIHtcbiAgICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWzRdIC0gR3JhbW1hciBpcyBpbiBhbiBlbmRsZXNzIGxvb3AgLSBHcmFtbWFyIGlzIG5vdCBhZHZhbmNpbmcsIG5vciBpcyBpdCBwdXNoaW5nL3BvcHBpbmdcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sgPSBzdGFjay5zYWZlUG9wKCk7XG4gICAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICBTVE9QID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhcHR1cmVJbmRpY2VzWzBdLmVuZCA+IGxpbmVQb3MpIHtcbiAgICAgIGxpbmVQb3MgPSBjYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gICAgICBpc0ZpcnN0TGluZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2NoZWNrV2hpbGVDb25kaXRpb25zKGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgbGluZVBvcywgc3RhY2ssIGxpbmVUb2tlbnMpIHtcbiAgbGV0IGFuY2hvclBvc2l0aW9uID0gc3RhY2suYmVnaW5SdWxlQ2FwdHVyZWRFT0wgPyAwIDogLTE7XG4gIGNvbnN0IHdoaWxlUnVsZXMgPSBbXTtcbiAgZm9yIChsZXQgbm9kZSA9IHN0YWNrOyBub2RlOyBub2RlID0gbm9kZS5wb3AoKSkge1xuICAgIGNvbnN0IG5vZGVSdWxlID0gbm9kZS5nZXRSdWxlKGdyYW1tYXIpO1xuICAgIGlmIChub2RlUnVsZSBpbnN0YW5jZW9mIEJlZ2luV2hpbGVSdWxlKSB7XG4gICAgICB3aGlsZVJ1bGVzLnB1c2goe1xuICAgICAgICBydWxlOiBub2RlUnVsZSxcbiAgICAgICAgc3RhY2s6IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCB3aGlsZVJ1bGUgPSB3aGlsZVJ1bGVzLnBvcCgpOyB3aGlsZVJ1bGU7IHdoaWxlUnVsZSA9IHdoaWxlUnVsZXMucG9wKCkpIHtcbiAgICBjb25zdCB7IHJ1bGVTY2FubmVyLCBmaW5kT3B0aW9ucyB9ID0gcHJlcGFyZVJ1bGVXaGlsZVNlYXJjaCh3aGlsZVJ1bGUucnVsZSwgZ3JhbW1hciwgd2hpbGVSdWxlLnN0YWNrLmVuZFJ1bGUsIGlzRmlyc3RMaW5lLCBsaW5lUG9zID09PSBhbmNob3JQb3NpdGlvbik7XG4gICAgY29uc3QgciA9IHJ1bGVTY2FubmVyLmZpbmROZXh0TWF0Y2hTeW5jKGxpbmVUZXh0LCBsaW5lUG9zLCBmaW5kT3B0aW9ucyk7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIiAgc2Nhbm5pbmcgZm9yIHdoaWxlIHJ1bGVcIik7XG4gICAgICBjb25zb2xlLmxvZyhydWxlU2Nhbm5lci50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IG1hdGNoZWRSdWxlSWQgPSByLnJ1bGVJZDtcbiAgICAgIGlmIChtYXRjaGVkUnVsZUlkICE9PSB3aGlsZVJ1bGVJZCkge1xuICAgICAgICBzdGFjayA9IHdoaWxlUnVsZS5zdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoci5jYXB0dXJlSW5kaWNlcyAmJiByLmNhcHR1cmVJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uod2hpbGVSdWxlLnN0YWNrLCByLmNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0KTtcbiAgICAgICAgaGFuZGxlQ2FwdHVyZXMoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCB3aGlsZVJ1bGUuc3RhY2ssIGxpbmVUb2tlbnMsIHdoaWxlUnVsZS5ydWxlLndoaWxlQ2FwdHVyZXMsIHIuY2FwdHVyZUluZGljZXMpO1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uod2hpbGVSdWxlLnN0YWNrLCByLmNhcHR1cmVJbmRpY2VzWzBdLmVuZCk7XG4gICAgICAgIGFuY2hvclBvc2l0aW9uID0gci5jYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gICAgICAgIGlmIChyLmNhcHR1cmVJbmRpY2VzWzBdLmVuZCA+IGxpbmVQb3MpIHtcbiAgICAgICAgICBsaW5lUG9zID0gci5jYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gICAgICAgICAgaXNGaXJzdExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCIgIHBvcHBpbmcgXCIgKyB3aGlsZVJ1bGUucnVsZS5kZWJ1Z05hbWUgKyBcIiAtIFwiICsgd2hpbGVSdWxlLnJ1bGUuZGVidWdXaGlsZVJlZ0V4cCk7XG4gICAgICB9XG4gICAgICBzdGFjayA9IHdoaWxlUnVsZS5zdGFjay5wb3AoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBzdGFjaywgbGluZVBvcywgYW5jaG9yUG9zaXRpb24sIGlzRmlyc3RMaW5lIH07XG59XG5mdW5jdGlvbiBtYXRjaFJ1bGVPckluamVjdGlvbnMoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pIHtcbiAgY29uc3QgbWF0Y2hSZXN1bHQgPSBtYXRjaFJ1bGUoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pO1xuICBjb25zdCBpbmplY3Rpb25zID0gZ3JhbW1hci5nZXRJbmplY3Rpb25zKCk7XG4gIGlmIChpbmplY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBtYXRjaFJlc3VsdDtcbiAgfVxuICBjb25zdCBpbmplY3Rpb25SZXN1bHQgPSBtYXRjaEluamVjdGlvbnMoaW5qZWN0aW9ucywgZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pO1xuICBpZiAoIWluamVjdGlvblJlc3VsdCkge1xuICAgIHJldHVybiBtYXRjaFJlc3VsdDtcbiAgfVxuICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgcmV0dXJuIGluamVjdGlvblJlc3VsdDtcbiAgfVxuICBjb25zdCBtYXRjaFJlc3VsdFNjb3JlID0gbWF0Y2hSZXN1bHQuY2FwdHVyZUluZGljZXNbMF0uc3RhcnQ7XG4gIGNvbnN0IGluamVjdGlvblJlc3VsdFNjb3JlID0gaW5qZWN0aW9uUmVzdWx0LmNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0O1xuICBpZiAoaW5qZWN0aW9uUmVzdWx0U2NvcmUgPCBtYXRjaFJlc3VsdFNjb3JlIHx8IGluamVjdGlvblJlc3VsdC5wcmlvcml0eU1hdGNoICYmIGluamVjdGlvblJlc3VsdFNjb3JlID09PSBtYXRjaFJlc3VsdFNjb3JlKSB7XG4gICAgcmV0dXJuIGluamVjdGlvblJlc3VsdDtcbiAgfVxuICByZXR1cm4gbWF0Y2hSZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXRjaFJ1bGUoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pIHtcbiAgY29uc3QgcnVsZSA9IHN0YWNrLmdldFJ1bGUoZ3JhbW1hcik7XG4gIGNvbnN0IHsgcnVsZVNjYW5uZXIsIGZpbmRPcHRpb25zIH0gPSBwcmVwYXJlUnVsZVNlYXJjaChydWxlLCBncmFtbWFyLCBzdGFjay5lbmRSdWxlLCBpc0ZpcnN0TGluZSwgbGluZVBvcyA9PT0gYW5jaG9yUG9zaXRpb24pO1xuICBjb25zdCByID0gcnVsZVNjYW5uZXIuZmluZE5leHRNYXRjaFN5bmMobGluZVRleHQsIGxpbmVQb3MsIGZpbmRPcHRpb25zKTtcbiAgaWYgKHIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FwdHVyZUluZGljZXM6IHIuY2FwdHVyZUluZGljZXMsXG4gICAgICBtYXRjaGVkUnVsZUlkOiByLnJ1bGVJZFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYXRjaEluamVjdGlvbnMoaW5qZWN0aW9ucywgZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pIHtcbiAgbGV0IGJlc3RNYXRjaFJhdGluZyA9IE51bWJlci5NQVhfVkFMVUU7XG4gIGxldCBiZXN0TWF0Y2hDYXB0dXJlSW5kaWNlcyA9IG51bGw7XG4gIGxldCBiZXN0TWF0Y2hSdWxlSWQ7XG4gIGxldCBiZXN0TWF0Y2hSZXN1bHRQcmlvcml0eSA9IDA7XG4gIGNvbnN0IHNjb3BlcyA9IHN0YWNrLmNvbnRlbnROYW1lU2NvcGVzTGlzdC5nZXRTY29wZU5hbWVzKCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpbmplY3Rpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgaW5qZWN0aW9uID0gaW5qZWN0aW9uc1tpXTtcbiAgICBpZiAoIWluamVjdGlvbi5tYXRjaGVyKHNjb3BlcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0gZ3JhbW1hci5nZXRSdWxlKGluamVjdGlvbi5ydWxlSWQpO1xuICAgIGNvbnN0IHsgcnVsZVNjYW5uZXIsIGZpbmRPcHRpb25zIH0gPSBwcmVwYXJlUnVsZVNlYXJjaChydWxlLCBncmFtbWFyLCBudWxsLCBpc0ZpcnN0TGluZSwgbGluZVBvcyA9PT0gYW5jaG9yUG9zaXRpb24pO1xuICAgIGNvbnN0IG1hdGNoUmVzdWx0ID0gcnVsZVNjYW5uZXIuZmluZE5leHRNYXRjaFN5bmMobGluZVRleHQsIGxpbmVQb3MsIGZpbmRPcHRpb25zKTtcbiAgICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgICBtYXRjaGVkIGluamVjdGlvbjogJHtpbmplY3Rpb24uZGVidWdTZWxlY3Rvcn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKHJ1bGVTY2FubmVyLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaFJhdGluZyA9IG1hdGNoUmVzdWx0LmNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0O1xuICAgIGlmIChtYXRjaFJhdGluZyA+PSBiZXN0TWF0Y2hSYXRpbmcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBiZXN0TWF0Y2hSYXRpbmcgPSBtYXRjaFJhdGluZztcbiAgICBiZXN0TWF0Y2hDYXB0dXJlSW5kaWNlcyA9IG1hdGNoUmVzdWx0LmNhcHR1cmVJbmRpY2VzO1xuICAgIGJlc3RNYXRjaFJ1bGVJZCA9IG1hdGNoUmVzdWx0LnJ1bGVJZDtcbiAgICBiZXN0TWF0Y2hSZXN1bHRQcmlvcml0eSA9IGluamVjdGlvbi5wcmlvcml0eTtcbiAgICBpZiAoYmVzdE1hdGNoUmF0aW5nID09PSBsaW5lUG9zKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGJlc3RNYXRjaENhcHR1cmVJbmRpY2VzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaW9yaXR5TWF0Y2g6IGJlc3RNYXRjaFJlc3VsdFByaW9yaXR5ID09PSAtMSxcbiAgICAgIGNhcHR1cmVJbmRpY2VzOiBiZXN0TWF0Y2hDYXB0dXJlSW5kaWNlcyxcbiAgICAgIG1hdGNoZWRSdWxlSWQ6IGJlc3RNYXRjaFJ1bGVJZFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwcmVwYXJlUnVsZVNlYXJjaChydWxlLCBncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgaWYgKFVzZU9uaWd1cnVtYUZpbmRPcHRpb25zKSB7XG4gICAgY29uc3QgcnVsZVNjYW5uZXIyID0gcnVsZS5jb21waWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKTtcbiAgICBjb25zdCBmaW5kT3B0aW9ucyA9IGdldEZpbmRPcHRpb25zKGFsbG93QSwgYWxsb3dHKTtcbiAgICByZXR1cm4geyBydWxlU2Nhbm5lcjogcnVsZVNjYW5uZXIyLCBmaW5kT3B0aW9ucyB9O1xuICB9XG4gIGNvbnN0IHJ1bGVTY2FubmVyID0gcnVsZS5jb21waWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKTtcbiAgcmV0dXJuIHsgcnVsZVNjYW5uZXIsIGZpbmRPcHRpb25zOiAwIC8qIE5vbmUgKi8gfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVSdWxlV2hpbGVTZWFyY2gocnVsZSwgZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gIGlmIChVc2VPbmlndXJ1bWFGaW5kT3B0aW9ucykge1xuICAgIGNvbnN0IHJ1bGVTY2FubmVyMiA9IHJ1bGUuY29tcGlsZVdoaWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKTtcbiAgICBjb25zdCBmaW5kT3B0aW9ucyA9IGdldEZpbmRPcHRpb25zKGFsbG93QSwgYWxsb3dHKTtcbiAgICByZXR1cm4geyBydWxlU2Nhbm5lcjogcnVsZVNjYW5uZXIyLCBmaW5kT3B0aW9ucyB9O1xuICB9XG4gIGNvbnN0IHJ1bGVTY2FubmVyID0gcnVsZS5jb21waWxlV2hpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpO1xuICByZXR1cm4geyBydWxlU2Nhbm5lciwgZmluZE9wdGlvbnM6IDAgLyogTm9uZSAqLyB9O1xufVxuZnVuY3Rpb24gZ2V0RmluZE9wdGlvbnMoYWxsb3dBLCBhbGxvd0cpIHtcbiAgbGV0IG9wdGlvbnMgPSAwIC8qIE5vbmUgKi87XG4gIGlmICghYWxsb3dBKSB7XG4gICAgb3B0aW9ucyB8PSAxIC8qIE5vdEJlZ2luU3RyaW5nICovO1xuICB9XG4gIGlmICghYWxsb3dHKSB7XG4gICAgb3B0aW9ucyB8PSA0IC8qIE5vdEJlZ2luUG9zaXRpb24gKi87XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBoYW5kbGVDYXB0dXJlcyhncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIHN0YWNrLCBsaW5lVG9rZW5zLCBjYXB0dXJlcywgY2FwdHVyZUluZGljZXMpIHtcbiAgaWYgKGNhcHR1cmVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsaW5lVGV4dENvbnRlbnQgPSBsaW5lVGV4dC5jb250ZW50O1xuICBjb25zdCBsZW4gPSBNYXRoLm1pbihjYXB0dXJlcy5sZW5ndGgsIGNhcHR1cmVJbmRpY2VzLmxlbmd0aCk7XG4gIGNvbnN0IGxvY2FsU3RhY2sgPSBbXTtcbiAgY29uc3QgbWF4RW5kID0gY2FwdHVyZUluZGljZXNbMF0uZW5kO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2FwdHVyZVJ1bGUgPSBjYXB0dXJlc1tpXTtcbiAgICBpZiAoY2FwdHVyZVJ1bGUgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjYXB0dXJlSW5kZXggPSBjYXB0dXJlSW5kaWNlc1tpXTtcbiAgICBpZiAoY2FwdHVyZUluZGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjYXB0dXJlSW5kZXguc3RhcnQgPiBtYXhFbmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB3aGlsZSAobG9jYWxTdGFjay5sZW5ndGggPiAwICYmIGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5lbmRQb3MgPD0gY2FwdHVyZUluZGV4LnN0YXJ0KSB7XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2VGcm9tU2NvcGVzKGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5zY29wZXMsIGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5lbmRQb3MpO1xuICAgICAgbG9jYWxTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgbGluZVRva2Vucy5wcm9kdWNlRnJvbVNjb3Blcyhsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uc2NvcGVzLCBjYXB0dXJlSW5kZXguc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRleC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChjYXB0dXJlUnVsZS5yZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkKSB7XG4gICAgICBjb25zdCBzY29wZU5hbWUgPSBjYXB0dXJlUnVsZS5nZXROYW1lKGxpbmVUZXh0Q29udGVudCwgY2FwdHVyZUluZGljZXMpO1xuICAgICAgY29uc3QgbmFtZVNjb3Blc0xpc3QgPSBzdGFjay5jb250ZW50TmFtZVNjb3Blc0xpc3QucHVzaEF0dHJpYnV0ZWQoc2NvcGVOYW1lLCBncmFtbWFyKTtcbiAgICAgIGNvbnN0IGNvbnRlbnROYW1lID0gY2FwdHVyZVJ1bGUuZ2V0Q29udGVudE5hbWUobGluZVRleHRDb250ZW50LCBjYXB0dXJlSW5kaWNlcyk7XG4gICAgICBjb25zdCBjb250ZW50TmFtZVNjb3Blc0xpc3QgPSBuYW1lU2NvcGVzTGlzdC5wdXNoQXR0cmlidXRlZChjb250ZW50TmFtZSwgZ3JhbW1hcik7XG4gICAgICBjb25zdCBzdGFja0Nsb25lID0gc3RhY2sucHVzaChjYXB0dXJlUnVsZS5yZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkLCBjYXB0dXJlSW5kZXguc3RhcnQsIC0xLCBmYWxzZSwgbnVsbCwgbmFtZVNjb3Blc0xpc3QsIGNvbnRlbnROYW1lU2NvcGVzTGlzdCk7XG4gICAgICBjb25zdCBvbmlnU3ViU3RyID0gZ3JhbW1hci5jcmVhdGVPbmlnU3RyaW5nKGxpbmVUZXh0Q29udGVudC5zdWJzdHJpbmcoMCwgY2FwdHVyZUluZGV4LmVuZCkpO1xuICAgICAgX3Rva2VuaXplU3RyaW5nKFxuICAgICAgICBncmFtbWFyLFxuICAgICAgICBvbmlnU3ViU3RyLFxuICAgICAgICBpc0ZpcnN0TGluZSAmJiBjYXB0dXJlSW5kZXguc3RhcnQgPT09IDAsXG4gICAgICAgIGNhcHR1cmVJbmRleC5zdGFydCxcbiAgICAgICAgc3RhY2tDbG9uZSxcbiAgICAgICAgbGluZVRva2VucyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIC8qIG5vIHRpbWUgbGltaXQgKi9cbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGRpc3Bvc2VPbmlnU3RyaW5nKG9uaWdTdWJTdHIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNhcHR1cmVSdWxlU2NvcGVOYW1lID0gY2FwdHVyZVJ1bGUuZ2V0TmFtZShsaW5lVGV4dENvbnRlbnQsIGNhcHR1cmVJbmRpY2VzKTtcbiAgICBpZiAoY2FwdHVyZVJ1bGVTY29wZU5hbWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGJhc2UgPSBsb2NhbFN0YWNrLmxlbmd0aCA+IDAgPyBsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uc2NvcGVzIDogc3RhY2suY29udGVudE5hbWVTY29wZXNMaXN0O1xuICAgICAgY29uc3QgY2FwdHVyZVJ1bGVTY29wZXNMaXN0ID0gYmFzZS5wdXNoQXR0cmlidXRlZChjYXB0dXJlUnVsZVNjb3BlTmFtZSwgZ3JhbW1hcik7XG4gICAgICBsb2NhbFN0YWNrLnB1c2gobmV3IExvY2FsU3RhY2tFbGVtZW50KGNhcHR1cmVSdWxlU2NvcGVzTGlzdCwgY2FwdHVyZUluZGV4LmVuZCkpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAobG9jYWxTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgbGluZVRva2Vucy5wcm9kdWNlRnJvbVNjb3Blcyhsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uc2NvcGVzLCBsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uZW5kUG9zKTtcbiAgICBsb2NhbFN0YWNrLnBvcCgpO1xuICB9XG59XG52YXIgTG9jYWxTdGFja0VsZW1lbnQgPSBjbGFzcyB7XG4gIHNjb3BlcztcbiAgZW5kUG9zO1xuICBjb25zdHJ1Y3RvcihzY29wZXMsIGVuZFBvcykge1xuICAgIHRoaXMuc2NvcGVzID0gc2NvcGVzO1xuICAgIHRoaXMuZW5kUG9zID0gZW5kUG9zO1xuICB9XG59O1xuXG4vLyBzcmMvZ3JhbW1hci9ncmFtbWFyLnRzXG5mdW5jdGlvbiBjcmVhdGVHcmFtbWFyKHNjb3BlTmFtZSwgZ3JhbW1hciwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcywgdG9rZW5UeXBlcywgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLCBncmFtbWFyUmVwb3NpdG9yeSwgb25pZ0xpYikge1xuICByZXR1cm4gbmV3IEdyYW1tYXIoXG4gICAgc2NvcGVOYW1lLFxuICAgIGdyYW1tYXIsXG4gICAgaW5pdGlhbExhbmd1YWdlLFxuICAgIGVtYmVkZGVkTGFuZ3VhZ2VzLFxuICAgIHRva2VuVHlwZXMsXG4gICAgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLFxuICAgIGdyYW1tYXJSZXBvc2l0b3J5LFxuICAgIG9uaWdMaWJcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbGxlY3RJbmplY3Rpb25zKHJlc3VsdCwgc2VsZWN0b3IsIHJ1bGUsIHJ1bGVGYWN0b3J5SGVscGVyLCBncmFtbWFyKSB7XG4gIGNvbnN0IG1hdGNoZXJzID0gY3JlYXRlTWF0Y2hlcnMoc2VsZWN0b3IsIG5hbWVNYXRjaGVyKTtcbiAgY29uc3QgcnVsZUlkID0gUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQocnVsZSwgcnVsZUZhY3RvcnlIZWxwZXIsIGdyYW1tYXIucmVwb3NpdG9yeSk7XG4gIGZvciAoY29uc3QgbWF0Y2hlciBvZiBtYXRjaGVycykge1xuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIGRlYnVnU2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgbWF0Y2hlcjogbWF0Y2hlci5tYXRjaGVyLFxuICAgICAgcnVsZUlkLFxuICAgICAgZ3JhbW1hcixcbiAgICAgIHByaW9yaXR5OiBtYXRjaGVyLnByaW9yaXR5XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5hbWVNYXRjaGVyKGlkZW50aWZlcnMsIHNjb3Blcykge1xuICBpZiAoc2NvcGVzLmxlbmd0aCA8IGlkZW50aWZlcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICByZXR1cm4gaWRlbnRpZmVycy5ldmVyeSgoaWRlbnRpZmllcikgPT4ge1xuICAgIGZvciAobGV0IGkgPSBsYXN0SW5kZXg7IGkgPCBzY29wZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzY29wZXNBcmVNYXRjaGluZyhzY29wZXNbaV0sIGlkZW50aWZpZXIpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IGkgKyAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNjb3Blc0FyZU1hdGNoaW5nKHRoaXNTY29wZU5hbWUsIHNjb3BlTmFtZSkge1xuICBpZiAoIXRoaXNTY29wZU5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXNTY29wZU5hbWUgPT09IHNjb3BlTmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGxlbiA9IHNjb3BlTmFtZS5sZW5ndGg7XG4gIHJldHVybiB0aGlzU2NvcGVOYW1lLmxlbmd0aCA+IGxlbiAmJiB0aGlzU2NvcGVOYW1lLnN1YnN0cigwLCBsZW4pID09PSBzY29wZU5hbWUgJiYgdGhpc1Njb3BlTmFtZVtsZW5dID09PSBcIi5cIjtcbn1cbnZhciBHcmFtbWFyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfcm9vdFNjb3BlTmFtZSwgZ3JhbW1hciwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcywgdG9rZW5UeXBlcywgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLCBncmFtbWFyUmVwb3NpdG9yeSwgX29uaWdMaWIpIHtcbiAgICB0aGlzLl9yb290U2NvcGVOYW1lID0gX3Jvb3RTY29wZU5hbWU7XG4gICAgdGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgPSBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnM7XG4gICAgdGhpcy5fb25pZ0xpYiA9IF9vbmlnTGliO1xuICAgIHRoaXMuX2Jhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIgPSBuZXcgQmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlcihcbiAgICAgIGluaXRpYWxMYW5ndWFnZSxcbiAgICAgIGVtYmVkZGVkTGFuZ3VhZ2VzXG4gICAgKTtcbiAgICB0aGlzLl9yb290SWQgPSAtMTtcbiAgICB0aGlzLl9sYXN0UnVsZUlkID0gMDtcbiAgICB0aGlzLl9ydWxlSWQyZGVzYyA9IFtudWxsXTtcbiAgICB0aGlzLl9pbmNsdWRlZEdyYW1tYXJzID0ge307XG4gICAgdGhpcy5fZ3JhbW1hclJlcG9zaXRvcnkgPSBncmFtbWFyUmVwb3NpdG9yeTtcbiAgICB0aGlzLl9ncmFtbWFyID0gaW5pdEdyYW1tYXIoZ3JhbW1hciwgbnVsbCk7XG4gICAgdGhpcy5faW5qZWN0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5fdG9rZW5UeXBlTWF0Y2hlcnMgPSBbXTtcbiAgICBpZiAodG9rZW5UeXBlcykge1xuICAgICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBPYmplY3Qua2V5cyh0b2tlblR5cGVzKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVycyA9IGNyZWF0ZU1hdGNoZXJzKHNlbGVjdG9yLCBuYW1lTWF0Y2hlcik7XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2hlciBvZiBtYXRjaGVycykge1xuICAgICAgICAgIHRoaXMuX3Rva2VuVHlwZU1hdGNoZXJzLnB1c2goe1xuICAgICAgICAgICAgbWF0Y2hlcjogbWF0Y2hlci5tYXRjaGVyLFxuICAgICAgICAgICAgdHlwZTogdG9rZW5UeXBlc1tzZWxlY3Rvcl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcm9vdElkO1xuICBfbGFzdFJ1bGVJZDtcbiAgX3J1bGVJZDJkZXNjO1xuICBfaW5jbHVkZWRHcmFtbWFycztcbiAgX2dyYW1tYXJSZXBvc2l0b3J5O1xuICBfZ3JhbW1hcjtcbiAgX2luamVjdGlvbnM7XG4gIF9iYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyO1xuICBfdG9rZW5UeXBlTWF0Y2hlcnM7XG4gIGdldCB0aGVtZVByb3ZpZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9ncmFtbWFyUmVwb3NpdG9yeTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLl9ydWxlSWQyZGVzYykge1xuICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgcnVsZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZU9uaWdTY2FubmVyKHNvdXJjZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25pZ0xpYi5jcmVhdGVPbmlnU2Nhbm5lcihzb3VyY2VzKTtcbiAgfVxuICBjcmVhdGVPbmlnU3RyaW5nKHNvdXJjZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25pZ0xpYi5jcmVhdGVPbmlnU3RyaW5nKHNvdXJjZXMpO1xuICB9XG4gIGdldE1ldGFkYXRhRm9yU2NvcGUoc2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlci5nZXRCYXNpY1Njb3BlQXR0cmlidXRlcyhzY29wZSk7XG4gIH1cbiAgX2NvbGxlY3RJbmplY3Rpb25zKCkge1xuICAgIGNvbnN0IGdyYW1tYXJSZXBvc2l0b3J5ID0ge1xuICAgICAgbG9va3VwOiAoc2NvcGVOYW1lMikgPT4ge1xuICAgICAgICBpZiAoc2NvcGVOYW1lMiA9PT0gdGhpcy5fcm9vdFNjb3BlTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ncmFtbWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEV4dGVybmFsR3JhbW1hcihzY29wZU5hbWUyKTtcbiAgICAgIH0sXG4gICAgICBpbmplY3Rpb25zOiAoc2NvcGVOYW1lMikgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhbW1hclJlcG9zaXRvcnkuaW5qZWN0aW9ucyhzY29wZU5hbWUyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHNjb3BlTmFtZSA9IHRoaXMuX3Jvb3RTY29wZU5hbWU7XG4gICAgY29uc3QgZ3JhbW1hciA9IGdyYW1tYXJSZXBvc2l0b3J5Lmxvb2t1cChzY29wZU5hbWUpO1xuICAgIGlmIChncmFtbWFyKSB7XG4gICAgICBjb25zdCByYXdJbmplY3Rpb25zID0gZ3JhbW1hci5pbmplY3Rpb25zO1xuICAgICAgaWYgKHJhd0luamVjdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgZXhwcmVzc2lvbiBpbiByYXdJbmplY3Rpb25zKSB7XG4gICAgICAgICAgY29sbGVjdEluamVjdGlvbnMoXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgcmF3SW5qZWN0aW9uc1tleHByZXNzaW9uXSxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBncmFtbWFyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaW5qZWN0aW9uU2NvcGVOYW1lcyA9IHRoaXMuX2dyYW1tYXJSZXBvc2l0b3J5LmluamVjdGlvbnMoc2NvcGVOYW1lKTtcbiAgICAgIGlmIChpbmplY3Rpb25TY29wZU5hbWVzKSB7XG4gICAgICAgIGluamVjdGlvblNjb3BlTmFtZXMuZm9yRWFjaCgoaW5qZWN0aW9uU2NvcGVOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5qZWN0aW9uR3JhbW1hciA9IHRoaXMuZ2V0RXh0ZXJuYWxHcmFtbWFyKGluamVjdGlvblNjb3BlTmFtZSk7XG4gICAgICAgICAgaWYgKGluamVjdGlvbkdyYW1tYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaW5qZWN0aW9uR3JhbW1hci5pbmplY3Rpb25TZWxlY3RvcjtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICBjb2xsZWN0SW5qZWN0aW9ucyhcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgaW5qZWN0aW9uR3JhbW1hcixcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGluamVjdGlvbkdyYW1tYXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc29ydCgoaTEsIGkyKSA9PiBpMS5wcmlvcml0eSAtIGkyLnByaW9yaXR5KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldEluamVjdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMuX2luamVjdGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2luamVjdGlvbnMgPSB0aGlzLl9jb2xsZWN0SW5qZWN0aW9ucygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW5qZWN0aW9ucztcbiAgfVxuICByZWdpc3RlclJ1bGUoZmFjdG9yeSkge1xuICAgIGNvbnN0IGlkID0gKyt0aGlzLl9sYXN0UnVsZUlkO1xuICAgIGNvbnN0IHJlc3VsdCA9IGZhY3RvcnkocnVsZUlkRnJvbU51bWJlcihpZCkpO1xuICAgIHRoaXMuX3J1bGVJZDJkZXNjW2lkXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFJ1bGUocnVsZUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bGVJZDJkZXNjW3J1bGVJZFRvTnVtYmVyKHJ1bGVJZCldO1xuICB9XG4gIGdldEV4dGVybmFsR3JhbW1hcihzY29wZU5hbWUsIHJlcG9zaXRvcnkpIHtcbiAgICBpZiAodGhpcy5faW5jbHVkZWRHcmFtbWFyc1tzY29wZU5hbWVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5jbHVkZWRHcmFtbWFyc1tzY29wZU5hbWVdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZ3JhbW1hclJlcG9zaXRvcnkpIHtcbiAgICAgIGNvbnN0IHJhd0luY2x1ZGVkR3JhbW1hciA9IHRoaXMuX2dyYW1tYXJSZXBvc2l0b3J5Lmxvb2t1cChzY29wZU5hbWUpO1xuICAgICAgaWYgKHJhd0luY2x1ZGVkR3JhbW1hcikge1xuICAgICAgICB0aGlzLl9pbmNsdWRlZEdyYW1tYXJzW3Njb3BlTmFtZV0gPSBpbml0R3JhbW1hcihcbiAgICAgICAgICByYXdJbmNsdWRlZEdyYW1tYXIsXG4gICAgICAgICAgcmVwb3NpdG9yeSAmJiByZXBvc2l0b3J5LiRiYXNlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmNsdWRlZEdyYW1tYXJzW3Njb3BlTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgdG9rZW5pemVMaW5lKGxpbmVUZXh0LCBwcmV2U3RhdGUsIHRpbWVMaW1pdCA9IDApIHtcbiAgICBjb25zdCByID0gdGhpcy5fdG9rZW5pemUobGluZVRleHQsIHByZXZTdGF0ZSwgZmFsc2UsIHRpbWVMaW1pdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2Vuczogci5saW5lVG9rZW5zLmdldFJlc3VsdChyLnJ1bGVTdGFjaywgci5saW5lTGVuZ3RoKSxcbiAgICAgIHJ1bGVTdGFjazogci5ydWxlU3RhY2ssXG4gICAgICBzdG9wcGVkRWFybHk6IHIuc3RvcHBlZEVhcmx5XG4gICAgfTtcbiAgfVxuICB0b2tlbml6ZUxpbmUyKGxpbmVUZXh0LCBwcmV2U3RhdGUsIHRpbWVMaW1pdCA9IDApIHtcbiAgICBjb25zdCByID0gdGhpcy5fdG9rZW5pemUobGluZVRleHQsIHByZXZTdGF0ZSwgdHJ1ZSwgdGltZUxpbWl0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiByLmxpbmVUb2tlbnMuZ2V0QmluYXJ5UmVzdWx0KHIucnVsZVN0YWNrLCByLmxpbmVMZW5ndGgpLFxuICAgICAgcnVsZVN0YWNrOiByLnJ1bGVTdGFjayxcbiAgICAgIHN0b3BwZWRFYXJseTogci5zdG9wcGVkRWFybHlcbiAgICB9O1xuICB9XG4gIF90b2tlbml6ZShsaW5lVGV4dCwgcHJldlN0YXRlLCBlbWl0QmluYXJ5VG9rZW5zLCB0aW1lTGltaXQpIHtcbiAgICBpZiAodGhpcy5fcm9vdElkID09PSAtMSkge1xuICAgICAgdGhpcy5fcm9vdElkID0gUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQoXG4gICAgICAgIHRoaXMuX2dyYW1tYXIucmVwb3NpdG9yeS4kc2VsZixcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5fZ3JhbW1hci5yZXBvc2l0b3J5XG4gICAgICApO1xuICAgICAgdGhpcy5nZXRJbmplY3Rpb25zKCk7XG4gICAgfVxuICAgIGxldCBpc0ZpcnN0TGluZTtcbiAgICBpZiAoIXByZXZTdGF0ZSB8fCBwcmV2U3RhdGUgPT09IFN0YXRlU3RhY2tJbXBsLk5VTEwpIHtcbiAgICAgIGlzRmlyc3RMaW5lID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJhd0RlZmF1bHRNZXRhZGF0YSA9IHRoaXMuX2Jhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIuZ2V0RGVmYXVsdEF0dHJpYnV0ZXMoKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHRoaXMudGhlbWVQcm92aWRlci5nZXREZWZhdWx0cygpO1xuICAgICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhID0gRW5jb2RlZFRva2VuTWV0YWRhdGEuc2V0KFxuICAgICAgICAwLFxuICAgICAgICByYXdEZWZhdWx0TWV0YWRhdGEubGFuZ3VhZ2VJZCxcbiAgICAgICAgcmF3RGVmYXVsdE1ldGFkYXRhLnRva2VuVHlwZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZGVmYXVsdFN0eWxlLmZvbnRTdHlsZSxcbiAgICAgICAgZGVmYXVsdFN0eWxlLmZvcmVncm91bmRJZCxcbiAgICAgICAgZGVmYXVsdFN0eWxlLmJhY2tncm91bmRJZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJvb3RTY29wZU5hbWUgPSB0aGlzLmdldFJ1bGUodGhpcy5fcm9vdElkKS5nZXROYW1lKFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgbGV0IHNjb3BlTGlzdDtcbiAgICAgIGlmIChyb290U2NvcGVOYW1lKSB7XG4gICAgICAgIHNjb3BlTGlzdCA9IEF0dHJpYnV0ZWRTY29wZVN0YWNrLmNyZWF0ZVJvb3RBbmRMb29rVXBTY29wZU5hbWUoXG4gICAgICAgICAgcm9vdFNjb3BlTmFtZSxcbiAgICAgICAgICBkZWZhdWx0TWV0YWRhdGEsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGVMaXN0ID0gQXR0cmlidXRlZFNjb3BlU3RhY2suY3JlYXRlUm9vdChcbiAgICAgICAgICBcInVua25vd25cIixcbiAgICAgICAgICBkZWZhdWx0TWV0YWRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByZXZTdGF0ZSA9IG5ldyBTdGF0ZVN0YWNrSW1wbChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGhpcy5fcm9vdElkLFxuICAgICAgICAtMSxcbiAgICAgICAgLTEsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBudWxsLFxuICAgICAgICBzY29wZUxpc3QsXG4gICAgICAgIHNjb3BlTGlzdFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNGaXJzdExpbmUgPSBmYWxzZTtcbiAgICAgIHByZXZTdGF0ZS5yZXNldCgpO1xuICAgIH1cbiAgICBsaW5lVGV4dCA9IGxpbmVUZXh0ICsgXCJcXG5cIjtcbiAgICBjb25zdCBvbmlnTGluZVRleHQgPSB0aGlzLmNyZWF0ZU9uaWdTdHJpbmcobGluZVRleHQpO1xuICAgIGNvbnN0IGxpbmVMZW5ndGggPSBvbmlnTGluZVRleHQuY29udGVudC5sZW5ndGg7XG4gICAgY29uc3QgbGluZVRva2VucyA9IG5ldyBMaW5lVG9rZW5zKFxuICAgICAgZW1pdEJpbmFyeVRva2VucyxcbiAgICAgIGxpbmVUZXh0LFxuICAgICAgdGhpcy5fdG9rZW5UeXBlTWF0Y2hlcnMsXG4gICAgICB0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9yc1xuICAgICk7XG4gICAgY29uc3QgciA9IF90b2tlbml6ZVN0cmluZyhcbiAgICAgIHRoaXMsXG4gICAgICBvbmlnTGluZVRleHQsXG4gICAgICBpc0ZpcnN0TGluZSxcbiAgICAgIDAsXG4gICAgICBwcmV2U3RhdGUsXG4gICAgICBsaW5lVG9rZW5zLFxuICAgICAgdHJ1ZSxcbiAgICAgIHRpbWVMaW1pdFxuICAgICk7XG4gICAgZGlzcG9zZU9uaWdTdHJpbmcob25pZ0xpbmVUZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZUxlbmd0aCxcbiAgICAgIGxpbmVUb2tlbnMsXG4gICAgICBydWxlU3RhY2s6IHIuc3RhY2ssXG4gICAgICBzdG9wcGVkRWFybHk6IHIuc3RvcHBlZEVhcmx5XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGluaXRHcmFtbWFyKGdyYW1tYXIsIGJhc2UpIHtcbiAgZ3JhbW1hciA9IGNsb25lKGdyYW1tYXIpO1xuICBncmFtbWFyLnJlcG9zaXRvcnkgPSBncmFtbWFyLnJlcG9zaXRvcnkgfHwge307XG4gIGdyYW1tYXIucmVwb3NpdG9yeS4kc2VsZiA9IHtcbiAgICAkdnNjb2RlVGV4dG1hdGVMb2NhdGlvbjogZ3JhbW1hci4kdnNjb2RlVGV4dG1hdGVMb2NhdGlvbixcbiAgICBwYXR0ZXJuczogZ3JhbW1hci5wYXR0ZXJucyxcbiAgICBuYW1lOiBncmFtbWFyLnNjb3BlTmFtZVxuICB9O1xuICBncmFtbWFyLnJlcG9zaXRvcnkuJGJhc2UgPSBiYXNlIHx8IGdyYW1tYXIucmVwb3NpdG9yeS4kc2VsZjtcbiAgcmV0dXJuIGdyYW1tYXI7XG59XG52YXIgQXR0cmlidXRlZFNjb3BlU3RhY2sgPSBjbGFzcyBfQXR0cmlidXRlZFNjb3BlU3RhY2sge1xuICAvKipcbiAgICogSW52YXJpYW50OlxuICAgKiBgYGBcbiAgICogaWYgKHBhcmVudCAmJiAhc2NvcGVQYXRoLmV4dGVuZHMocGFyZW50LnNjb3BlUGF0aCkpIHtcbiAgICogXHR0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgc2NvcGVQYXRoLCB0b2tlbkF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnNjb3BlUGF0aCA9IHNjb3BlUGF0aDtcbiAgICB0aGlzLnRva2VuQXR0cmlidXRlcyA9IHRva2VuQXR0cmlidXRlcztcbiAgfVxuICBzdGF0aWMgZnJvbUV4dGVuc2lvbihuYW1lc1Njb3BlTGlzdCwgY29udGVudE5hbWVTY29wZXNMaXN0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSBuYW1lc1Njb3BlTGlzdDtcbiAgICBsZXQgc2NvcGVOYW1lcyA9IG5hbWVzU2NvcGVMaXN0Py5zY29wZVBhdGggPz8gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIGNvbnRlbnROYW1lU2NvcGVzTGlzdCkge1xuICAgICAgc2NvcGVOYW1lcyA9IFNjb3BlU3RhY2sucHVzaChzY29wZU5hbWVzLCBmcmFtZS5zY29wZU5hbWVzKTtcbiAgICAgIGN1cnJlbnQgPSBuZXcgX0F0dHJpYnV0ZWRTY29wZVN0YWNrKGN1cnJlbnQsIHNjb3BlTmFtZXMsIGZyYW1lLmVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlUm9vdChzY29wZU5hbWUsIHRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiBuZXcgX0F0dHJpYnV0ZWRTY29wZVN0YWNrKG51bGwsIG5ldyBTY29wZVN0YWNrKG51bGwsIHNjb3BlTmFtZSksIHRva2VuQXR0cmlidXRlcyk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVJvb3RBbmRMb29rVXBTY29wZU5hbWUoc2NvcGVOYW1lLCB0b2tlbkF0dHJpYnV0ZXMsIGdyYW1tYXIpIHtcbiAgICBjb25zdCByYXdSb290TWV0YWRhdGEgPSBncmFtbWFyLmdldE1ldGFkYXRhRm9yU2NvcGUoc2NvcGVOYW1lKTtcbiAgICBjb25zdCBzY29wZVBhdGggPSBuZXcgU2NvcGVTdGFjayhudWxsLCBzY29wZU5hbWUpO1xuICAgIGNvbnN0IHJvb3RTdHlsZSA9IGdyYW1tYXIudGhlbWVQcm92aWRlci50aGVtZU1hdGNoKHNjb3BlUGF0aCk7XG4gICAgY29uc3QgcmVzb2x2ZWRUb2tlbkF0dHJpYnV0ZXMgPSBfQXR0cmlidXRlZFNjb3BlU3RhY2subWVyZ2VBdHRyaWJ1dGVzKFxuICAgICAgdG9rZW5BdHRyaWJ1dGVzLFxuICAgICAgcmF3Um9vdE1ldGFkYXRhLFxuICAgICAgcm9vdFN0eWxlXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IF9BdHRyaWJ1dGVkU2NvcGVTdGFjayhudWxsLCBzY29wZVBhdGgsIHJlc29sdmVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgfVxuICBnZXQgc2NvcGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlUGF0aC5zY29wZU5hbWU7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2NvcGVOYW1lcygpLmpvaW4oXCIgXCIpO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBfQXR0cmlidXRlZFNjb3BlU3RhY2suZXF1YWxzKHRoaXMsIG90aGVyKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICBkbyB7XG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoYS5zY29wZU5hbWUgIT09IGIuc2NvcGVOYW1lIHx8IGEudG9rZW5BdHRyaWJ1dGVzICE9PSBiLnRva2VuQXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBhID0gYS5wYXJlbnQ7XG4gICAgICBiID0gYi5wYXJlbnQ7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXR0cmlidXRlcyhleGlzdGluZ1Rva2VuQXR0cmlidXRlcywgYmFzaWNTY29wZUF0dHJpYnV0ZXMsIHN0eWxlQXR0cmlidXRlcykge1xuICAgIGxldCBmb250U3R5bGUgPSAtMSAvKiBOb3RTZXQgKi87XG4gICAgbGV0IGZvcmVncm91bmQgPSAwO1xuICAgIGxldCBiYWNrZ3JvdW5kID0gMDtcbiAgICBpZiAoc3R5bGVBdHRyaWJ1dGVzICE9PSBudWxsKSB7XG4gICAgICBmb250U3R5bGUgPSBzdHlsZUF0dHJpYnV0ZXMuZm9udFN0eWxlO1xuICAgICAgZm9yZWdyb3VuZCA9IHN0eWxlQXR0cmlidXRlcy5mb3JlZ3JvdW5kSWQ7XG4gICAgICBiYWNrZ3JvdW5kID0gc3R5bGVBdHRyaWJ1dGVzLmJhY2tncm91bmRJZDtcbiAgICB9XG4gICAgcmV0dXJuIEVuY29kZWRUb2tlbk1ldGFkYXRhLnNldChcbiAgICAgIGV4aXN0aW5nVG9rZW5BdHRyaWJ1dGVzLFxuICAgICAgYmFzaWNTY29wZUF0dHJpYnV0ZXMubGFuZ3VhZ2VJZCxcbiAgICAgIGJhc2ljU2NvcGVBdHRyaWJ1dGVzLnRva2VuVHlwZSxcbiAgICAgIG51bGwsXG4gICAgICBmb250U3R5bGUsXG4gICAgICBmb3JlZ3JvdW5kLFxuICAgICAgYmFja2dyb3VuZFxuICAgICk7XG4gIH1cbiAgcHVzaEF0dHJpYnV0ZWQoc2NvcGVQYXRoLCBncmFtbWFyKSB7XG4gICAgaWYgKHNjb3BlUGF0aCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChzY29wZVBhdGguaW5kZXhPZihcIiBcIikgPT09IC0xKSB7XG4gICAgICByZXR1cm4gX0F0dHJpYnV0ZWRTY29wZVN0YWNrLl9wdXNoQXR0cmlidXRlZCh0aGlzLCBzY29wZVBhdGgsIGdyYW1tYXIpO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBzY29wZVBhdGguc3BsaXQoLyAvZyk7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgIHJlc3VsdCA9IF9BdHRyaWJ1dGVkU2NvcGVTdGFjay5fcHVzaEF0dHJpYnV0ZWQocmVzdWx0LCBzY29wZSwgZ3JhbW1hcik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIF9wdXNoQXR0cmlidXRlZCh0YXJnZXQsIHNjb3BlTmFtZSwgZ3JhbW1hcikge1xuICAgIGNvbnN0IHJhd01ldGFkYXRhID0gZ3JhbW1hci5nZXRNZXRhZGF0YUZvclNjb3BlKHNjb3BlTmFtZSk7XG4gICAgY29uc3QgbmV3UGF0aCA9IHRhcmdldC5zY29wZVBhdGgucHVzaChzY29wZU5hbWUpO1xuICAgIGNvbnN0IHNjb3BlVGhlbWVNYXRjaFJlc3VsdCA9IGdyYW1tYXIudGhlbWVQcm92aWRlci50aGVtZU1hdGNoKG5ld1BhdGgpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gX0F0dHJpYnV0ZWRTY29wZVN0YWNrLm1lcmdlQXR0cmlidXRlcyhcbiAgICAgIHRhcmdldC50b2tlbkF0dHJpYnV0ZXMsXG4gICAgICByYXdNZXRhZGF0YSxcbiAgICAgIHNjb3BlVGhlbWVNYXRjaFJlc3VsdFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBfQXR0cmlidXRlZFNjb3BlU3RhY2sodGFyZ2V0LCBuZXdQYXRoLCBtZXRhZGF0YSk7XG4gIH1cbiAgZ2V0U2NvcGVOYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVBhdGguZ2V0U2VnbWVudHMoKTtcbiAgfVxuICBnZXRFeHRlbnNpb25JZkRlZmluZWQoYmFzZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICB3aGlsZSAoc2VsZiAmJiBzZWxmICE9PSBiYXNlKSB7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIGVuY29kZWRUb2tlbkF0dHJpYnV0ZXM6IHNlbGYudG9rZW5BdHRyaWJ1dGVzLFxuICAgICAgICBzY29wZU5hbWVzOiBzZWxmLnNjb3BlUGF0aC5nZXRFeHRlbnNpb25JZkRlZmluZWQoc2VsZi5wYXJlbnQ/LnNjb3BlUGF0aCA/PyBudWxsKVxuICAgICAgfSk7XG4gICAgICBzZWxmID0gc2VsZi5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBzZWxmID09PSBiYXNlID8gcmVzdWx0LnJldmVyc2UoKSA6IHZvaWQgMDtcbiAgfVxufTtcbnZhciBTdGF0ZVN0YWNrSW1wbCA9IGNsYXNzIF9TdGF0ZVN0YWNrSW1wbCB7XG4gIC8qKlxuICAgKiBJbnZhcmlhbnQ6XG4gICAqIGBgYFxuICAgKiBpZiAoY29udGVudE5hbWVTY29wZXNMaXN0ICE9PSBuYW1lU2NvcGVzTGlzdCAmJiBjb250ZW50TmFtZVNjb3Blc0xpc3Q/LnBhcmVudCAhPT0gbmFtZVNjb3Blc0xpc3QpIHtcbiAgICogXHR0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICogfVxuICAgKiBpZiAodGhpcy5wYXJlbnQgJiYgIW5hbWVTY29wZXNMaXN0LmV4dGVuZHModGhpcy5wYXJlbnQuY29udGVudE5hbWVTY29wZXNMaXN0KSkge1xuICAgKiBcdHRocm93IG5ldyBFcnJvcigpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyZW50LCBydWxlSWQsIGVudGVyUG9zLCBhbmNob3JQb3MsIGJlZ2luUnVsZUNhcHR1cmVkRU9MLCBlbmRSdWxlLCBuYW1lU2NvcGVzTGlzdCwgY29udGVudE5hbWVTY29wZXNMaXN0KSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5ydWxlSWQgPSBydWxlSWQ7XG4gICAgdGhpcy5iZWdpblJ1bGVDYXB0dXJlZEVPTCA9IGJlZ2luUnVsZUNhcHR1cmVkRU9MO1xuICAgIHRoaXMuZW5kUnVsZSA9IGVuZFJ1bGU7XG4gICAgdGhpcy5uYW1lU2NvcGVzTGlzdCA9IG5hbWVTY29wZXNMaXN0O1xuICAgIHRoaXMuY29udGVudE5hbWVTY29wZXNMaXN0ID0gY29udGVudE5hbWVTY29wZXNMaXN0O1xuICAgIHRoaXMuZGVwdGggPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmRlcHRoICsgMSA6IDE7XG4gICAgdGhpcy5fZW50ZXJQb3MgPSBlbnRlclBvcztcbiAgICB0aGlzLl9hbmNob3JQb3MgPSBhbmNob3JQb3M7XG4gIH1cbiAgX3N0YWNrRWxlbWVudEJyYW5kID0gdm9pZCAwO1xuICAvLyBUT0RPIHJlbW92ZSBtZVxuICBzdGF0aWMgTlVMTCA9IG5ldyBfU3RhdGVTdGFja0ltcGwoXG4gICAgbnVsbCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICBmYWxzZSxcbiAgICBudWxsLFxuICAgIG51bGwsXG4gICAgbnVsbFxuICApO1xuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9uIHRoZSBjdXJyZW50IGxpbmUgd2hlcmUgdGhpcyBzdGF0ZSB3YXMgcHVzaGVkLlxuICAgKiBUaGlzIGlzIHJlbGV2YW50IG9ubHkgd2hpbGUgdG9rZW5pemluZyBhIGxpbmUsIHRvIGRldGVjdCBlbmRsZXNzIGxvb3BzLlxuICAgKiBJdHMgdmFsdWUgaXMgbWVhbmluZ2xlc3MgYWNyb3NzIGxpbmVzLlxuICAgKi9cbiAgX2VudGVyUG9zO1xuICAvKipcbiAgICogVGhlIGNhcHR1cmVkIGFuY2hvciBwb3NpdGlvbiB3aGVuIHRoaXMgc3RhY2sgZWxlbWVudCB3YXMgcHVzaGVkLlxuICAgKiBUaGlzIGlzIHJlbGV2YW50IG9ubHkgd2hpbGUgdG9rZW5pemluZyBhIGxpbmUsIHRvIHJlc3RvcmUgdGhlIGFuY2hvciBwb3NpdGlvbiB3aGVuIHBvcHBpbmcuXG4gICAqIEl0cyB2YWx1ZSBpcyBtZWFuaW5nbGVzcyBhY3Jvc3MgbGluZXMuXG4gICAqL1xuICBfYW5jaG9yUG9zO1xuICAvKipcbiAgICogVGhlIGRlcHRoIG9mIHRoZSBzdGFjay5cbiAgICovXG4gIGRlcHRoO1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF9TdGF0ZVN0YWNrSW1wbC5fZXF1YWxzKHRoaXMsIG90aGVyKTtcbiAgfVxuICBzdGF0aWMgX2VxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3N0cnVjdHVyYWxFcXVhbHMoYSwgYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIEF0dHJpYnV0ZWRTY29wZVN0YWNrLmVxdWFscyhhLmNvbnRlbnROYW1lU2NvcGVzTGlzdCwgYi5jb250ZW50TmFtZVNjb3Blc0xpc3QpO1xuICB9XG4gIC8qKlxuICAgKiBBIHN0cnVjdHVyYWwgZXF1YWxzIGNoZWNrLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBgc2NvcGVzYC5cbiAgICovXG4gIHN0YXRpYyBfc3RydWN0dXJhbEVxdWFscyhhLCBiKSB7XG4gICAgZG8ge1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGEuZGVwdGggIT09IGIuZGVwdGggfHwgYS5ydWxlSWQgIT09IGIucnVsZUlkIHx8IGEuZW5kUnVsZSAhPT0gYi5lbmRSdWxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGEgPSBhLnBhcmVudDtcbiAgICAgIGIgPSBiLnBhcmVudDtcbiAgICB9IHdoaWxlICh0cnVlKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgX3Jlc2V0KGVsKSB7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBlbC5fZW50ZXJQb3MgPSAtMTtcbiAgICAgIGVsLl9hbmNob3JQb3MgPSAtMTtcbiAgICAgIGVsID0gZWwucGFyZW50O1xuICAgIH1cbiAgfVxuICByZXNldCgpIHtcbiAgICBfU3RhdGVTdGFja0ltcGwuX3Jlc2V0KHRoaXMpO1xuICB9XG4gIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIH1cbiAgc2FmZVBvcCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHVzaChydWxlSWQsIGVudGVyUG9zLCBhbmNob3JQb3MsIGJlZ2luUnVsZUNhcHR1cmVkRU9MLCBlbmRSdWxlLCBuYW1lU2NvcGVzTGlzdCwgY29udGVudE5hbWVTY29wZXNMaXN0KSB7XG4gICAgcmV0dXJuIG5ldyBfU3RhdGVTdGFja0ltcGwoXG4gICAgICB0aGlzLFxuICAgICAgcnVsZUlkLFxuICAgICAgZW50ZXJQb3MsXG4gICAgICBhbmNob3JQb3MsXG4gICAgICBiZWdpblJ1bGVDYXB0dXJlZEVPTCxcbiAgICAgIGVuZFJ1bGUsXG4gICAgICBuYW1lU2NvcGVzTGlzdCxcbiAgICAgIGNvbnRlbnROYW1lU2NvcGVzTGlzdFxuICAgICk7XG4gIH1cbiAgZ2V0RW50ZXJQb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyUG9zO1xuICB9XG4gIGdldEFuY2hvclBvcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5jaG9yUG9zO1xuICB9XG4gIGdldFJ1bGUoZ3JhbW1hcikge1xuICAgIHJldHVybiBncmFtbWFyLmdldFJ1bGUodGhpcy5ydWxlSWQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICB0aGlzLl93cml0ZVN0cmluZyhyLCAwKTtcbiAgICByZXR1cm4gXCJbXCIgKyByLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gIH1cbiAgX3dyaXRlU3RyaW5nKHJlcywgb3V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIG91dEluZGV4ID0gdGhpcy5wYXJlbnQuX3dyaXRlU3RyaW5nKHJlcywgb3V0SW5kZXgpO1xuICAgIH1cbiAgICByZXNbb3V0SW5kZXgrK10gPSBgKCR7dGhpcy5ydWxlSWR9LCAke3RoaXMubmFtZVNjb3Blc0xpc3Q/LnRvU3RyaW5nKCl9LCAke3RoaXMuY29udGVudE5hbWVTY29wZXNMaXN0Py50b1N0cmluZygpfSlgO1xuICAgIHJldHVybiBvdXRJbmRleDtcbiAgfVxuICB3aXRoQ29udGVudE5hbWVTY29wZXNMaXN0KGNvbnRlbnROYW1lU2NvcGVTdGFjaykge1xuICAgIGlmICh0aGlzLmNvbnRlbnROYW1lU2NvcGVzTGlzdCA9PT0gY29udGVudE5hbWVTY29wZVN0YWNrKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LnB1c2goXG4gICAgICB0aGlzLnJ1bGVJZCxcbiAgICAgIHRoaXMuX2VudGVyUG9zLFxuICAgICAgdGhpcy5fYW5jaG9yUG9zLFxuICAgICAgdGhpcy5iZWdpblJ1bGVDYXB0dXJlZEVPTCxcbiAgICAgIHRoaXMuZW5kUnVsZSxcbiAgICAgIHRoaXMubmFtZVNjb3Blc0xpc3QsXG4gICAgICBjb250ZW50TmFtZVNjb3BlU3RhY2tcbiAgICApO1xuICB9XG4gIHdpdGhFbmRSdWxlKGVuZFJ1bGUpIHtcbiAgICBpZiAodGhpcy5lbmRSdWxlID09PSBlbmRSdWxlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfU3RhdGVTdGFja0ltcGwoXG4gICAgICB0aGlzLnBhcmVudCxcbiAgICAgIHRoaXMucnVsZUlkLFxuICAgICAgdGhpcy5fZW50ZXJQb3MsXG4gICAgICB0aGlzLl9hbmNob3JQb3MsXG4gICAgICB0aGlzLmJlZ2luUnVsZUNhcHR1cmVkRU9MLFxuICAgICAgZW5kUnVsZSxcbiAgICAgIHRoaXMubmFtZVNjb3Blc0xpc3QsXG4gICAgICB0aGlzLmNvbnRlbnROYW1lU2NvcGVzTGlzdFxuICAgICk7XG4gIH1cbiAgLy8gVXNlZCB0byB3YXJuIG9mIGVuZGxlc3MgbG9vcHNcbiAgaGFzU2FtZVJ1bGVBcyhvdGhlcikge1xuICAgIGxldCBlbCA9IHRoaXM7XG4gICAgd2hpbGUgKGVsICYmIGVsLl9lbnRlclBvcyA9PT0gb3RoZXIuX2VudGVyUG9zKSB7XG4gICAgICBpZiAoZWwucnVsZUlkID09PSBvdGhlci5ydWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRvU3RhdGVTdGFja0ZyYW1lKCkge1xuICAgIHJldHVybiB7XG4gICAgICBydWxlSWQ6IHJ1bGVJZFRvTnVtYmVyKHRoaXMucnVsZUlkKSxcbiAgICAgIGJlZ2luUnVsZUNhcHR1cmVkRU9MOiB0aGlzLmJlZ2luUnVsZUNhcHR1cmVkRU9MLFxuICAgICAgZW5kUnVsZTogdGhpcy5lbmRSdWxlLFxuICAgICAgbmFtZVNjb3Blc0xpc3Q6IHRoaXMubmFtZVNjb3Blc0xpc3Q/LmdldEV4dGVuc2lvbklmRGVmaW5lZCh0aGlzLnBhcmVudD8ubmFtZVNjb3Blc0xpc3QgPz8gbnVsbCkgPz8gW10sXG4gICAgICBjb250ZW50TmFtZVNjb3Blc0xpc3Q6IHRoaXMuY29udGVudE5hbWVTY29wZXNMaXN0Py5nZXRFeHRlbnNpb25JZkRlZmluZWQodGhpcy5uYW1lU2NvcGVzTGlzdCkgPz8gW11cbiAgICB9O1xuICB9XG4gIHN0YXRpYyBwdXNoRnJhbWUoc2VsZiwgZnJhbWUpIHtcbiAgICBjb25zdCBuYW1lc1Njb3BlTGlzdCA9IEF0dHJpYnV0ZWRTY29wZVN0YWNrLmZyb21FeHRlbnNpb24oc2VsZj8ubmFtZVNjb3Blc0xpc3QgPz8gbnVsbCwgZnJhbWUubmFtZVNjb3Blc0xpc3QpO1xuICAgIHJldHVybiBuZXcgX1N0YXRlU3RhY2tJbXBsKFxuICAgICAgc2VsZixcbiAgICAgIHJ1bGVJZEZyb21OdW1iZXIoZnJhbWUucnVsZUlkKSxcbiAgICAgIGZyYW1lLmVudGVyUG9zID8/IC0xLFxuICAgICAgZnJhbWUuYW5jaG9yUG9zID8/IC0xLFxuICAgICAgZnJhbWUuYmVnaW5SdWxlQ2FwdHVyZWRFT0wsXG4gICAgICBmcmFtZS5lbmRSdWxlLFxuICAgICAgbmFtZXNTY29wZUxpc3QsXG4gICAgICBBdHRyaWJ1dGVkU2NvcGVTdGFjay5mcm9tRXh0ZW5zaW9uKG5hbWVzU2NvcGVMaXN0LCBmcmFtZS5jb250ZW50TmFtZVNjb3Blc0xpc3QpXG4gICAgKTtcbiAgfVxufTtcbnZhciBCYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgPSBjbGFzcyB7XG4gIGJhbGFuY2VkQnJhY2tldFNjb3BlcztcbiAgdW5iYWxhbmNlZEJyYWNrZXRTY29wZXM7XG4gIGFsbG93QW55ID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKGJhbGFuY2VkQnJhY2tldFNjb3BlcywgdW5iYWxhbmNlZEJyYWNrZXRTY29wZXMpIHtcbiAgICB0aGlzLmJhbGFuY2VkQnJhY2tldFNjb3BlcyA9IGJhbGFuY2VkQnJhY2tldFNjb3Blcy5mbGF0TWFwKFxuICAgICAgKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICB0aGlzLmFsbG93QW55ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1hdGNoZXJzKHNlbGVjdG9yLCBuYW1lTWF0Y2hlcikubWFwKChtKSA9PiBtLm1hdGNoZXIpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy51bmJhbGFuY2VkQnJhY2tldFNjb3BlcyA9IHVuYmFsYW5jZWRCcmFja2V0U2NvcGVzLmZsYXRNYXAoXG4gICAgICAoc2VsZWN0b3IpID0+IGNyZWF0ZU1hdGNoZXJzKHNlbGVjdG9yLCBuYW1lTWF0Y2hlcikubWFwKChtKSA9PiBtLm1hdGNoZXIpXG4gICAgKTtcbiAgfVxuICBnZXQgbWF0Y2hlc0Fsd2F5cygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd0FueSAmJiB0aGlzLnVuYmFsYW5jZWRCcmFja2V0U2NvcGVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBnZXQgbWF0Y2hlc05ldmVyKCkge1xuICAgIHJldHVybiB0aGlzLmJhbGFuY2VkQnJhY2tldFNjb3Blcy5sZW5ndGggPT09IDAgJiYgIXRoaXMuYWxsb3dBbnk7XG4gIH1cbiAgbWF0Y2goc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBleGNsdWRlciBvZiB0aGlzLnVuYmFsYW5jZWRCcmFja2V0U2NvcGVzKSB7XG4gICAgICBpZiAoZXhjbHVkZXIoc2NvcGVzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5jbHVkZXIgb2YgdGhpcy5iYWxhbmNlZEJyYWNrZXRTY29wZXMpIHtcbiAgICAgIGlmIChpbmNsdWRlcihzY29wZXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGxvd0FueTtcbiAgfVxufTtcbnZhciBMaW5lVG9rZW5zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbWl0QmluYXJ5VG9rZW5zLCBsaW5lVGV4dCwgdG9rZW5UeXBlT3ZlcnJpZGVzLCBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMpIHtcbiAgICB0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyA9IGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycztcbiAgICB0aGlzLl9lbWl0QmluYXJ5VG9rZW5zID0gZW1pdEJpbmFyeVRva2VucztcbiAgICB0aGlzLl90b2tlblR5cGVPdmVycmlkZXMgPSB0b2tlblR5cGVPdmVycmlkZXM7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICB0aGlzLl9saW5lVGV4dCA9IGxpbmVUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saW5lVGV4dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3Rva2VucyA9IFtdO1xuICAgIHRoaXMuX2JpbmFyeVRva2VucyA9IFtdO1xuICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gMDtcbiAgfVxuICBfZW1pdEJpbmFyeVRva2VucztcbiAgLyoqXG4gICAqIGRlZmluZWQgb25seSBpZiBgZmFsc2VgLlxuICAgKi9cbiAgX2xpbmVUZXh0O1xuICAvKipcbiAgICogdXNlZCBvbmx5IGlmIGBfZW1pdEJpbmFyeVRva2Vuc2AgaXMgZmFsc2UuXG4gICAqL1xuICBfdG9rZW5zO1xuICAvKipcbiAgICogdXNlZCBvbmx5IGlmIGBfZW1pdEJpbmFyeVRva2Vuc2AgaXMgdHJ1ZS5cbiAgICovXG4gIF9iaW5hcnlUb2tlbnM7XG4gIF9sYXN0VG9rZW5FbmRJbmRleDtcbiAgX3Rva2VuVHlwZU92ZXJyaWRlcztcbiAgcHJvZHVjZShzdGFjaywgZW5kSW5kZXgpIHtcbiAgICB0aGlzLnByb2R1Y2VGcm9tU2NvcGVzKHN0YWNrLmNvbnRlbnROYW1lU2NvcGVzTGlzdCwgZW5kSW5kZXgpO1xuICB9XG4gIHByb2R1Y2VGcm9tU2NvcGVzKHNjb3Blc0xpc3QsIGVuZEluZGV4KSB7XG4gICAgaWYgKHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID49IGVuZEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbWl0QmluYXJ5VG9rZW5zKSB7XG4gICAgICBsZXQgbWV0YWRhdGEgPSBzY29wZXNMaXN0Py50b2tlbkF0dHJpYnV0ZXMgPz8gMDtcbiAgICAgIGxldCBjb250YWluc0JhbGFuY2VkQnJhY2tldHMgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycz8ubWF0Y2hlc0Fsd2F5cykge1xuICAgICAgICBjb250YWluc0JhbGFuY2VkQnJhY2tldHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Rva2VuVHlwZU92ZXJyaWRlcy5sZW5ndGggPiAwIHx8IHRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzICYmICF0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycy5tYXRjaGVzQWx3YXlzICYmICF0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycy5tYXRjaGVzTmV2ZXIpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVzMiA9IHNjb3Blc0xpc3Q/LmdldFNjb3BlTmFtZXMoKSA/PyBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlblR5cGUgb2YgdGhpcy5fdG9rZW5UeXBlT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgaWYgKHRva2VuVHlwZS5tYXRjaGVyKHNjb3BlczIpKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IEVuY29kZWRUb2tlbk1ldGFkYXRhLnNldChcbiAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIHRvT3B0aW9uYWxUb2tlblR5cGUodG9rZW5UeXBlLnR5cGUpLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAtMSAvKiBOb3RTZXQgKi8sXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycykge1xuICAgICAgICAgIGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyA9IHRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLm1hdGNoKHNjb3BlczIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzKSB7XG4gICAgICAgIG1ldGFkYXRhID0gRW5jb2RlZFRva2VuTWV0YWRhdGEuc2V0KFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgOCAvKiBOb3RTZXQgKi8sXG4gICAgICAgICAgY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzLFxuICAgICAgICAgIC0xIC8qIE5vdFNldCAqLyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoID4gMCAmJiB0aGlzLl9iaW5hcnlUb2tlbnNbdGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aCAtIDFdID09PSBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9iaW5hcnlUb2tlbnMucHVzaCh0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCk7XG4gICAgICB0aGlzLl9iaW5hcnlUb2tlbnMucHVzaChtZXRhZGF0YSk7XG4gICAgICB0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBzY29wZXNMaXN0Py5nZXRTY29wZU5hbWVzKCkgPz8gW107XG4gICAgdGhpcy5fdG9rZW5zLnB1c2goe1xuICAgICAgc3RhcnRJbmRleDogdGhpcy5fbGFzdFRva2VuRW5kSW5kZXgsXG4gICAgICBlbmRJbmRleCxcbiAgICAgIC8vIHZhbHVlOiBsaW5lVGV4dC5zdWJzdHJpbmcobGFzdFRva2VuRW5kSW5kZXgsIGVuZEluZGV4KSxcbiAgICAgIHNjb3Blc1xuICAgIH0pO1xuICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gZW5kSW5kZXg7XG4gIH1cbiAgZ2V0UmVzdWx0KHN0YWNrLCBsaW5lTGVuZ3RoKSB7XG4gICAgaWYgKHRoaXMuX3Rva2Vucy5sZW5ndGggPiAwICYmIHRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlbnMubGVuZ3RoIC0gMV0uc3RhcnRJbmRleCA9PT0gbGluZUxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuX3Rva2Vucy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Rva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gLTE7XG4gICAgICB0aGlzLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXS5zdGFydEluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Rva2VucztcbiAgfVxuICBnZXRCaW5hcnlSZXN1bHQoc3RhY2ssIGxpbmVMZW5ndGgpIHtcbiAgICBpZiAodGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aCA+IDAgJiYgdGhpcy5fYmluYXJ5VG9rZW5zW3RoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGggLSAyXSA9PT0gbGluZUxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuX2JpbmFyeVRva2Vucy5wb3AoKTtcbiAgICAgIHRoaXMuX2JpbmFyeVRva2Vucy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gLTE7XG4gICAgICB0aGlzLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgdGhpcy5fYmluYXJ5VG9rZW5zW3RoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGggLSAyXSA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSB0aGlzLl9iaW5hcnlUb2tlbnNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWdpc3RyeS50c1xudmFyIFN5bmNSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodGhlbWUsIF9vbmlnTGliKSB7XG4gICAgdGhpcy5fb25pZ0xpYiA9IF9vbmlnTGliO1xuICAgIHRoaXMuX3RoZW1lID0gdGhlbWU7XG4gIH1cbiAgX2dyYW1tYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3Jhd0dyYW1tYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX2luamVjdGlvbkdyYW1tYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3RoZW1lO1xuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3QgZ3JhbW1hciBvZiB0aGlzLl9ncmFtbWFycy52YWx1ZXMoKSkge1xuICAgICAgZ3JhbW1hci5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG4gIHNldFRoZW1lKHRoZW1lKSB7XG4gICAgdGhpcy5fdGhlbWUgPSB0aGVtZTtcbiAgfVxuICBnZXRDb2xvck1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbWUuZ2V0Q29sb3JNYXAoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGBncmFtbWFyYCB0byByZWdpc3RyeSBhbmQgcmV0dXJuIGEgbGlzdCBvZiByZWZlcmVuY2VkIHNjb3BlIG5hbWVzXG4gICAqL1xuICBhZGRHcmFtbWFyKGdyYW1tYXIsIGluamVjdGlvblNjb3BlTmFtZXMpIHtcbiAgICB0aGlzLl9yYXdHcmFtbWFycy5zZXQoZ3JhbW1hci5zY29wZU5hbWUsIGdyYW1tYXIpO1xuICAgIGlmIChpbmplY3Rpb25TY29wZU5hbWVzKSB7XG4gICAgICB0aGlzLl9pbmplY3Rpb25HcmFtbWFycy5zZXQoZ3JhbW1hci5zY29wZU5hbWUsIGluamVjdGlvblNjb3BlTmFtZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTG9va3VwIGEgcmF3IGdyYW1tYXIuXG4gICAqL1xuICBsb29rdXAoc2NvcGVOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhd0dyYW1tYXJzLmdldChzY29wZU5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmplY3Rpb25zIGZvciB0aGUgZ2l2ZW4gZ3JhbW1hclxuICAgKi9cbiAgaW5qZWN0aW9ucyh0YXJnZXRTY29wZSkge1xuICAgIHJldHVybiB0aGlzLl9pbmplY3Rpb25HcmFtbWFycy5nZXQodGFyZ2V0U2NvcGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdGhlbWUgc2V0dGluZ3NcbiAgICovXG4gIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLl90aGVtZS5nZXREZWZhdWx0cygpO1xuICB9XG4gIC8qKlxuICAgKiBNYXRjaCBhIHNjb3BlIGluIHRoZSB0aGVtZS5cbiAgICovXG4gIHRoZW1lTWF0Y2goc2NvcGVQYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW1lLm1hdGNoKHNjb3BlUGF0aCk7XG4gIH1cbiAgLyoqXG4gICAqIExvb2t1cCBhIGdyYW1tYXIuXG4gICAqL1xuICBncmFtbWFyRm9yU2NvcGVOYW1lKHNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcywgdG9rZW5UeXBlcywgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzKSB7XG4gICAgaWYgKCF0aGlzLl9ncmFtbWFycy5oYXMoc2NvcGVOYW1lKSkge1xuICAgICAgbGV0IHJhd0dyYW1tYXIgPSB0aGlzLl9yYXdHcmFtbWFycy5nZXQoc2NvcGVOYW1lKTtcbiAgICAgIGlmICghcmF3R3JhbW1hcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2dyYW1tYXJzLnNldChzY29wZU5hbWUsIGNyZWF0ZUdyYW1tYXIoXG4gICAgICAgIHNjb3BlTmFtZSxcbiAgICAgICAgcmF3R3JhbW1hcixcbiAgICAgICAgaW5pdGlhbExhbmd1YWdlLFxuICAgICAgICBlbWJlZGRlZExhbmd1YWdlcyxcbiAgICAgICAgdG9rZW5UeXBlcyxcbiAgICAgICAgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLl9vbmlnTGliXG4gICAgICApKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dyYW1tYXJzLmdldChzY29wZU5hbWUpO1xuICB9XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBSZWdpc3RyeSA9IGNsYXNzIHtcbiAgX29wdGlvbnM7XG4gIF9zeW5jUmVnaXN0cnk7XG4gIF9lbnN1cmVHcmFtbWFyQ2FjaGU7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkgPSBuZXcgU3luY1JlZ2lzdHJ5KFxuICAgICAgVGhlbWUuY3JlYXRlRnJvbVJhd1RoZW1lKG9wdGlvbnMudGhlbWUsIG9wdGlvbnMuY29sb3JNYXApLFxuICAgICAgb3B0aW9ucy5vbmlnTGliXG4gICAgKTtcbiAgICB0aGlzLl9lbnN1cmVHcmFtbWFyQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc3luY1JlZ2lzdHJ5LmRpc3Bvc2UoKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlIHRoZSB0aGVtZS4gT25jZSBjYWxsZWQsIG5vIHByZXZpb3VzIGBydWxlU3RhY2tgIHNob3VsZCBiZSB1c2VkIGFueW1vcmUuXG4gICAqL1xuICBzZXRUaGVtZSh0aGVtZSwgY29sb3JNYXApIHtcbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkuc2V0VGhlbWUoVGhlbWUuY3JlYXRlRnJvbVJhd1RoZW1lKHRoZW1lLCBjb2xvck1hcCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9va3VwIGFycmF5IGZvciBjb2xvciBpZHMuXG4gICAqL1xuICBnZXRDb2xvck1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY1JlZ2lzdHJ5LmdldENvbG9yTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgdGhlIGdyYW1tYXIgZm9yIGBzY29wZU5hbWVgIGFuZCBhbGwgcmVmZXJlbmNlZCBpbmNsdWRlZCBncmFtbWFycyBhc3luY2hyb25vdXNseS5cbiAgICogUGxlYXNlIGRvIG5vdCB1c2UgbGFuZ3VhZ2UgaWQgMC5cbiAgICovXG4gIGxvYWRHcmFtbWFyV2l0aEVtYmVkZGVkTGFuZ3VhZ2VzKGluaXRpYWxTY29wZU5hbWUsIGluaXRpYWxMYW5ndWFnZSwgZW1iZWRkZWRMYW5ndWFnZXMpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkR3JhbW1hcldpdGhDb25maWd1cmF0aW9uKGluaXRpYWxTY29wZU5hbWUsIGluaXRpYWxMYW5ndWFnZSwgeyBlbWJlZGRlZExhbmd1YWdlcyB9KTtcbiAgfVxuICAvKipcbiAgICogTG9hZCB0aGUgZ3JhbW1hciBmb3IgYHNjb3BlTmFtZWAgYW5kIGFsbCByZWZlcmVuY2VkIGluY2x1ZGVkIGdyYW1tYXJzIGFzeW5jaHJvbm91c2x5LlxuICAgKiBQbGVhc2UgZG8gbm90IHVzZSBsYW5ndWFnZSBpZCAwLlxuICAgKi9cbiAgbG9hZEdyYW1tYXJXaXRoQ29uZmlndXJhdGlvbihpbml0aWFsU2NvcGVOYW1lLCBpbml0aWFsTGFuZ3VhZ2UsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZEdyYW1tYXIoXG4gICAgICBpbml0aWFsU2NvcGVOYW1lLFxuICAgICAgaW5pdGlhbExhbmd1YWdlLFxuICAgICAgY29uZmlndXJhdGlvbi5lbWJlZGRlZExhbmd1YWdlcyxcbiAgICAgIGNvbmZpZ3VyYXRpb24udG9rZW5UeXBlcyxcbiAgICAgIG5ldyBCYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMoXG4gICAgICAgIGNvbmZpZ3VyYXRpb24uYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIHx8IFtdLFxuICAgICAgICBjb25maWd1cmF0aW9uLnVuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIHx8IFtdXG4gICAgICApXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogTG9hZCB0aGUgZ3JhbW1hciBmb3IgYHNjb3BlTmFtZWAgYW5kIGFsbCByZWZlcmVuY2VkIGluY2x1ZGVkIGdyYW1tYXJzIGFzeW5jaHJvbm91c2x5LlxuICAgKi9cbiAgbG9hZEdyYW1tYXIoaW5pdGlhbFNjb3BlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkR3JhbW1hcihpbml0aWFsU2NvcGVOYW1lLCAwLCBudWxsLCBudWxsLCBudWxsKTtcbiAgfVxuICBfbG9hZEdyYW1tYXIoaW5pdGlhbFNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcywgdG9rZW5UeXBlcywgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jeVByb2Nlc3NvciA9IG5ldyBTY29wZURlcGVuZGVuY3lQcm9jZXNzb3IodGhpcy5fc3luY1JlZ2lzdHJ5LCBpbml0aWFsU2NvcGVOYW1lKTtcbiAgICB3aGlsZSAoZGVwZW5kZW5jeVByb2Nlc3Nvci5RLmxlbmd0aCA+IDApIHtcbiAgICAgIGRlcGVuZGVuY3lQcm9jZXNzb3IuUS5tYXAoKHJlcXVlc3QpID0+IHRoaXMuX2xvYWRTaW5nbGVHcmFtbWFyKHJlcXVlc3Quc2NvcGVOYW1lKSk7XG4gICAgICBkZXBlbmRlbmN5UHJvY2Vzc29yLnByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ3JhbW1hckZvclNjb3BlTmFtZShcbiAgICAgIGluaXRpYWxTY29wZU5hbWUsXG4gICAgICBpbml0aWFsTGFuZ3VhZ2UsXG4gICAgICBlbWJlZGRlZExhbmd1YWdlcyxcbiAgICAgIHRva2VuVHlwZXMsXG4gICAgICBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnNcbiAgICApO1xuICB9XG4gIF9sb2FkU2luZ2xlR3JhbW1hcihzY29wZU5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2Vuc3VyZUdyYW1tYXJDYWNoZS5oYXMoc2NvcGVOYW1lKSkge1xuICAgICAgdGhpcy5fZG9Mb2FkU2luZ2xlR3JhbW1hcihzY29wZU5hbWUpO1xuICAgICAgdGhpcy5fZW5zdXJlR3JhbW1hckNhY2hlLnNldChzY29wZU5hbWUsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfZG9Mb2FkU2luZ2xlR3JhbW1hcihzY29wZU5hbWUpIHtcbiAgICBjb25zdCBncmFtbWFyID0gdGhpcy5fb3B0aW9ucy5sb2FkR3JhbW1hcihzY29wZU5hbWUpO1xuICAgIGlmIChncmFtbWFyKSB7XG4gICAgICBjb25zdCBpbmplY3Rpb25zID0gdHlwZW9mIHRoaXMuX29wdGlvbnMuZ2V0SW5qZWN0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fb3B0aW9ucy5nZXRJbmplY3Rpb25zKHNjb3BlTmFtZSkgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9zeW5jUmVnaXN0cnkuYWRkR3JhbW1hcihncmFtbWFyLCBpbmplY3Rpb25zKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByYXdHcmFtbWFyLlxuICAgKi9cbiAgYWRkR3JhbW1hcihyYXdHcmFtbWFyLCBpbmplY3Rpb25zID0gW10sIGluaXRpYWxMYW5ndWFnZSA9IDAsIGVtYmVkZGVkTGFuZ3VhZ2VzID0gbnVsbCkge1xuICAgIHRoaXMuX3N5bmNSZWdpc3RyeS5hZGRHcmFtbWFyKHJhd0dyYW1tYXIsIGluamVjdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLl9ncmFtbWFyRm9yU2NvcGVOYW1lKHJhd0dyYW1tYXIuc2NvcGVOYW1lLCBpbml0aWFsTGFuZ3VhZ2UsIGVtYmVkZGVkTGFuZ3VhZ2VzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBncmFtbWFyIGZvciBgc2NvcGVOYW1lYC4gVGhlIGdyYW1tYXIgbXVzdCBmaXJzdCBiZSBjcmVhdGVkIHZpYSBgbG9hZEdyYW1tYXJgIG9yIGBhZGRHcmFtbWFyYC5cbiAgICovXG4gIF9ncmFtbWFyRm9yU2NvcGVOYW1lKHNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlID0gMCwgZW1iZWRkZWRMYW5ndWFnZXMgPSBudWxsLCB0b2tlblR5cGVzID0gbnVsbCwgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9zeW5jUmVnaXN0cnkuZ3JhbW1hckZvclNjb3BlTmFtZShcbiAgICAgIHNjb3BlTmFtZSxcbiAgICAgIGluaXRpYWxMYW5ndWFnZSxcbiAgICAgIGVtYmVkZGVkTGFuZ3VhZ2VzLFxuICAgICAgdG9rZW5UeXBlcyxcbiAgICAgIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9yc1xuICAgICk7XG4gIH1cbn07XG52YXIgSU5JVElBTCA9IFN0YXRlU3RhY2tJbXBsLk5VTEw7XG5leHBvcnQge1xuICBFbmNvZGVkVG9rZW5NZXRhZGF0YSxcbiAgRmluZE9wdGlvbixcbiAgRm9udFN0eWxlLFxuICBJTklUSUFMLFxuICBSZWdpc3RyeSxcbiAgVGhlbWUsXG4gIGRpc3Bvc2VPbmlnU3RyaW5nXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@shikijs+vscode-textmate@10.0.1/node_modules/@shikijs/vscode-textmate/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/animejs@4.1.4/node_modules/animejs/lib/anime.esm.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/animejs@4.1.4/node_modules/animejs/lib/anime.esm.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animatable: () => (/* binding */ Animatable),\n/* harmony export */   Draggable: () => (/* binding */ Draggable),\n/* harmony export */   JSAnimation: () => (/* binding */ JSAnimation),\n/* harmony export */   Scope: () => (/* binding */ Scope),\n/* harmony export */   ScrollObserver: () => (/* binding */ ScrollObserver),\n/* harmony export */   Spring: () => (/* binding */ Spring),\n/* harmony export */   TextSplitter: () => (/* binding */ TextSplitter),\n/* harmony export */   Timeline: () => (/* binding */ Timeline),\n/* harmony export */   Timer: () => (/* binding */ Timer),\n/* harmony export */   WAAPIAnimation: () => (/* binding */ WAAPIAnimation),\n/* harmony export */   animate: () => (/* binding */ animate),\n/* harmony export */   createAnimatable: () => (/* binding */ createAnimatable),\n/* harmony export */   createDraggable: () => (/* binding */ createDraggable),\n/* harmony export */   createScope: () => (/* binding */ createScope),\n/* harmony export */   createSpring: () => (/* binding */ createSpring),\n/* harmony export */   createTimeline: () => (/* binding */ createTimeline),\n/* harmony export */   createTimer: () => (/* binding */ createTimer),\n/* harmony export */   eases: () => (/* binding */ eases),\n/* harmony export */   engine: () => (/* binding */ engine),\n/* harmony export */   onScroll: () => (/* binding */ onScroll),\n/* harmony export */   scrollContainers: () => (/* binding */ scrollContainers),\n/* harmony export */   stagger: () => (/* binding */ stagger),\n/* harmony export */   svg: () => (/* binding */ svg),\n/* harmony export */   text: () => (/* binding */ text),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   waapi: () => (/* binding */ waapi)\n/* harmony export */ });\n/**\n * anime.js - ESM\n * @version v4.1.4\n * @author Julian Garnier\n * @license MIT\n * @copyright (c) 2025 Julian Garnier\n * @see https://animejs.com\n */\n\n// Global types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} DefaultsParams\n * @property {Number|String} [id]\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n * @property {Number} [playbackRate]\n * @property {Number} [frameRate]\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number|FunctionValue} [duration]\n * @property {Number|FunctionValue} [delay]\n * @property {Number} [loopDelay]\n * @property {EasingParam} [ease]\n * @property {'none'|'replace'|'blend'|compositionTypes} [composition]\n * @property {(v: any) => any} [modifier]\n * @property {(tickable: Tickable) => void} [onBegin]\n * @property {(tickable: Tickable) => void} [onBeforeUpdate]\n * @property {(tickable: Tickable) => void} [onUpdate]\n * @property {(tickable: Tickable) => void} [onLoop]\n * @property {(tickable: Tickable) => void} [onPause]\n * @property {(tickable: Tickable) => void} [onComplete]\n * @property {(renderable: Renderable) => void} [onRender]\n */\n\n/** @typedef {JSAnimation|Timeline} Renderable */\n/** @typedef {Timer|Renderable} Tickable */\n/** @typedef {Timer&JSAnimation&Timeline} CallbackArgument */\n/** @typedef {Animatable|Tickable|WAAPIAnimation|Draggable|ScrollObserver|TextSplitter|Scope} Revertible */\n\n// Stagger types ///////////////////////////////////////////////////////////////\n\n/**\n * @template T\n * @callback StaggerFunction\n * @param {Target} [target]\n * @param {Number} [index]\n * @param {Number} [length]\n * @param {Timeline} [tl]\n * @return {T}\n */\n\n/**\n * @typedef  {Object} StaggerParams\n * @property {Number|String} [start]\n * @property {Number|'first'|'center'|'last'|'random'} [from]\n * @property {Boolean} [reversed]\n * @property {Array.<Number>} [grid]\n * @property {('x'|'y')} [axis]\n * @property {String|((target: Target, i: Number, length: Number) => Number)} [use]\n * @property {Number} [total]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n */\n\n// Eases types /////////////////////////////////////////////////////////////////\n\n/**\n * @callback EasingFunction\n * @param {Number} time\n * @return {Number}\n */\n\n/**\n * @typedef {('linear'|'linear(x1, x2 25%, x3)'|'in'|'out'|'inOut'|'inQuad'|'outQuad'|'inOutQuad'|'inCubic'|'outCubic'|'inOutCubic'|'inQuart'|'outQuart'|'inOutQuart'|'inQuint'|'outQuint'|'inOutQuint'|'inSine'|'outSine'|'inOutSine'|'inCirc'|'outCirc'|'inOutCirc'|'inExpo'|'outExpo'|'inOutExpo'|'inBounce'|'outBounce'|'inOutBounce'|'inBack'|'outBack'|'inOutBack'|'inElastic'|'outElastic'|'inOutElastic'|'irregular'|'cubicBezier'|'steps'|'in(p = 1.675)'|'out(p = 1.675)'|'inOut(p = 1.675)'|'inBack(overshoot = 1.70158)'|'outBack(overshoot = 1.70158)'|'inOutBack(overshoot = 1.70158)'|'inElastic(amplitude = 1, period = .3)'|'outElastic(amplitude = 1, period = .3)'|'inOutElastic(amplitude = 1, period = .3)'|'irregular(length = 10, randomness = 1)'|'cubicBezier(x1, y1, x2, y2)'|'steps(steps = 10)')} EaseStringParamNames\n */\n\n// A hack to get both ease names suggestions AND allow any strings\n// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421\n/** @typedef {(String & {})|EaseStringParamNames|EasingFunction|Spring} EasingParam */\n\n/** @typedef {HTMLElement|SVGElement} DOMTarget */\n/** @typedef {Record<String, any>} JSTarget */\n/** @typedef {DOMTarget|JSTarget} Target */\n/** @typedef {Target|NodeList|String} TargetSelector */\n/** @typedef {DOMTarget|NodeList|String} DOMTargetSelector */\n/** @typedef {Array.<DOMTargetSelector>|DOMTargetSelector} DOMTargetsParam */\n/** @typedef {Array.<DOMTarget>} DOMTargetsArray */\n/** @typedef {Array.<JSTarget>|JSTarget} JSTargetsParam */\n/** @typedef {Array.<JSTarget>} JSTargetsArray */\n/** @typedef {Array.<TargetSelector>|TargetSelector} TargetsParam */\n/** @typedef {Array.<Target>} TargetsArray */\n\n// Spring types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} SpringParams\n * @property {Number} [mass=1] - Mass, default 1\n * @property {Number} [stiffness=100] - Stiffness, default 100\n * @property {Number} [damping=10] - Damping, default 10\n * @property {Number} [velocity=0] - Initial velocity, default 0\n */\n\n // Callback types //////////////////////////////////////////////////////////////\n\n/**\n * @template T\n * @callback Callback\n * @param {T} self - Returns itself\n * @param {PointerEvent} [e]\n * @return {*}\n */\n\n/**\n * @template {object} T\n * @typedef {Object} TickableCallbacks\n * @property {Callback<T>} [onBegin]\n * @property {Callback<T>} [onBeforeUpdate]\n * @property {Callback<T>} [onUpdate]\n * @property {Callback<T>} [onLoop]\n * @property {Callback<T>} [onPause]\n * @property {Callback<T>} [onComplete]\n */\n\n/**\n * @template {object} T\n * @typedef {Object} RenderableCallbacks\n * @property {Callback<T>} [onRender]\n */\n\n// Timer types /////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} TimerOptions\n * @property {Number|String} [id]\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {Number} [loopDelay]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|Number} [loop]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [frameRate]\n * @property {Number} [playbackRate]\n */\n\n/**\n\n/**\n * @typedef {TimerOptions & TickableCallbacks<Timer>} TimerParams\n */\n\n// Tween types /////////////////////////////////////////////////////////////////\n\n/**\n * @callback FunctionValue\n * @param {Target} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {Number|String|TweenObjectValue|Array.<Number|String|TweenObjectValue>}\n */\n\n/**\n * @callback TweenModifier\n * @param {Number} value - The animated value\n * @return {Number|String}\n */\n\n/** @typedef {[Number, Number, Number, Number]} ColorArray */\n\n/**\n * @typedef {Object} Tween\n * @property {Number} id\n * @property {JSAnimation} parent\n * @property {String} property\n * @property {Target} target\n * @property {String|Number} _value\n * @property {Function|null} _func\n * @property {EasingFunction} _ease\n * @property {Array.<Number>} _fromNumbers\n * @property {Array.<Number>} _toNumbers\n * @property {Array.<String>} _strings\n * @property {Number} _fromNumber\n * @property {Number} _toNumber\n * @property {Array.<Number>} _numbers\n * @property {Number} _number\n * @property {String} _unit\n * @property {TweenModifier} _modifier\n * @property {Number} _currentTime\n * @property {Number} _delay\n * @property {Number} _updateDuration\n * @property {Number} _startTime\n * @property {Number} _changeDuration\n * @property {Number} _absoluteStartTime\n * @property {tweenTypes} _tweenType\n * @property {valueTypes} _valueType\n * @property {Number} _composition\n * @property {Number} _isOverlapped\n * @property {Number} _isOverridden\n * @property {Number} _renderTransforms\n * @property {Tween} _prevRep\n * @property {Tween} _nextRep\n * @property {Tween} _prevAdd\n * @property {Tween} _nextAdd\n * @property {Tween} _prev\n * @property {Tween} _next\n */\n\n/**\n * @typedef TweenDecomposedValue\n * @property {Number} t - Type\n * @property {Number} n - Single number value\n * @property {String} u - Value unit\n * @property {String} o - Value operator\n * @property {Array.<Number>} d - Array of Numbers (in case of complex value type)\n * @property {Array.<String>} s - Strings (in case of complex value type)\n */\n\n/** @typedef {{_head: null|Tween, _tail: null|Tween}} TweenPropertySiblings */\n/** @typedef {Record<String, TweenPropertySiblings>} TweenLookups */\n/** @typedef {WeakMap.<Target, TweenLookups>} TweenReplaceLookups */\n/** @typedef {Map.<Target, TweenLookups>} TweenAdditiveLookups */\n\n// JSAnimation types ///////////////////////////////////////////////////////////\n\n/**\n * @typedef {Number|String|FunctionValue} TweenParamValue\n */\n\n/**\n * @typedef {TweenParamValue|[TweenParamValue, TweenParamValue]} TweenPropValue\n */\n\n/**\n * @typedef {(String & {})|'none'|'replace'|'blend'|compositionTypes} TweenComposition\n */\n\n/**\n * @typedef {Object} TweenParamsOptions\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */\n\n/**\n * @typedef {Object} TweenValues\n * @property {TweenParamValue} [from]\n * @property {TweenPropValue} [to]\n * @property {TweenPropValue} [fromTo]\n */\n\n/**\n * @typedef {TweenParamsOptions & TweenValues} TweenKeyValue\n */\n\n/**\n * @typedef {Array.<TweenKeyValue|TweenPropValue>} ArraySyntaxValue\n */\n\n/**\n * @typedef {TweenParamValue|ArraySyntaxValue|TweenKeyValue} TweenOptions\n */\n\n/**\n * @typedef {Partial<{to: TweenParamValue|Array.<TweenParamValue>; from: TweenParamValue|Array.<TweenParamValue>; fromTo: TweenParamValue|Array.<TweenParamValue>;}>} TweenObjectValue\n */\n\n/**\n * @typedef {Object} PercentageKeyframeOptions\n * @property {EasingParam} [ease]\n */\n\n/**\n * @typedef {Record<String, TweenParamValue>} PercentageKeyframeParams\n */\n\n/**\n * @typedef {Record<String, PercentageKeyframeParams & PercentageKeyframeOptions>} PercentageKeyframes\n */\n\n/**\n * @typedef {Array<Record<String, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>} DurationKeyframes\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n */\n\n// TODO: Currently setting TweenModifier to the intersected Record<> makes the FunctionValue type target param any if only one parameter is set\n/**\n * @typedef {Record<String, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | DurationKeyframes | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>} AnimationParams\n */\n\n// Timeline types //////////////////////////////////////////////////////////////\n\n/**\n * Accepts:<br>\n * - `Number` - Absolute position in milliseconds (e.g., `500` places element at exactly 500ms)<br>\n * - `'+=Number'` - Addition: Position element X ms after the last element (e.g., `'+=100'`)<br>\n * - `'-=Number'` - Subtraction: Position element X ms before the last element's end (e.g., `'-=100'`)<br>\n * - `'*=Number'` - Multiplier: Position element at a fraction of the total duration (e.g., `'*=.5'` for halfway)<br>\n * - `'<'` - Previous end: Position element at the end position of the previous element<br>\n * - `'<<'` - Previous start: Position element at the start position of the previous element<br>\n * - `'<<+=Number'` - Combined: Position element relative to previous element's start (e.g., `'<<+=250'`)<br>\n * - `'label'` - Label: Position element at a named label position (e.g., `'My Label'`)\n *\n * @typedef {Number|`+=${Number}`|`-=${Number}`|`*=${Number}`|'<'|'<<'|`<<+=${Number}`|`<<-=${Number}`|String} TimelinePosition\n */\n\n/**\n * Accepts:<br>\n * - `Number` - Absolute position in milliseconds (e.g., `500` places animation at exactly 500ms)<br>\n * - `'+=Number'` - Addition: Position animation X ms after the last animation (e.g., `'+=100'`)<br>\n * - `'-=Number'` - Subtraction: Position animation X ms before the last animation's end (e.g., `'-=100'`)<br>\n * - `'*=Number'` - Multiplier: Position animation at a fraction of the total duration (e.g., `'*=.5'` for halfway)<br>\n * - `'<'` - Previous end: Position animation at the end position of the previous animation<br>\n * - `'<<'` - Previous start: Position animation at the start position of the previous animation<br>\n * - `'<<+=Number'` - Combined: Position animation relative to previous animation's start (e.g., `'<<+=250'`)<br>\n * - `'label'` - Label: Position animation at a named label position (e.g., `'My Label'`)<br>\n * - `stagger(String|Nummber)` - Stagger multi-elements animation positions (e.g., 10, 20, 30...)\n *\n * @typedef {TimelinePosition | StaggerFunction<Number|String>} TimelineAnimationPosition\n */\n\n/**\n * @typedef {Object} TimelineOptions\n * @property {DefaultsParams} [defaults]\n * @property {EasingParam} [playbackEase]\n */\n\n/**\n * @typedef {TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} TimelineParams\n */\n\n// WAAPIAnimation types ////////////////////////////////////////////////////////\n\n/**\n * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue\n */\n\n/**\n * @callback WAAPIFunctionValue\n * @param {DOMTarget} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {WAAPITweenValue}\n */\n\n/**\n * @typedef {WAAPITweenValue|WAAPIFunctionValue|Array<String|Number|WAAPIFunctionValue>} WAAPIKeyframeValue\n */\n\n/**\n * @typedef {(animation: WAAPIAnimation) => void} WAAPICallback\n */\n\n/**\n * @typedef {Object} WAAPITweenOptions\n * @property {WAAPIKeyframeValue} [to]\n * @property {WAAPIKeyframeValue} [from]\n * @property {Number|WAAPIFunctionValue} [duration]\n * @property {Number|WAAPIFunctionValue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n */\n\n/**\n * @typedef {Object} WAAPIAnimationOptions\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [Reversed]\n * @property {Boolean} [Alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [playbackRate]\n * @property {Number|WAAPIFunctionValue} [duration]\n * @property {Number|WAAPIFunctionValue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n * @property {WAAPICallback} [onComplete]\n */\n\n/**\n * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | WAAPICallback | EasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams\n */\n\n// Animatable types ////////////////////////////////////////////////////////////\n\n/**\n * @callback AnimatablePropertySetter\n * @param  {Number|Array.<Number>} to\n * @param  {Number} [duration]\n * @param  {EasingParam} [ease]\n * @return {AnimatableObject}\n */\n\n/**\n * @callback AnimatablePropertyGetter\n * @return {Number|Array.<Number>}\n */\n\n/**\n * @typedef {AnimatablePropertySetter & AnimatablePropertyGetter} AnimatableProperty\n */\n\n/**\n * @typedef {Animatable & Record<String, AnimatableProperty>} AnimatableObject\n */\n\n/**\n * @typedef {Object} AnimatablePropertyParamsOptions\n * @property {String} [unit]\n * @property {TweenParamValue} [duration]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */\n\n/**\n * @typedef {Record<String, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions} AnimatableParams\n */\n\n// Scope types /////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} ReactRef\n * @property {HTMLElement|SVGElement|null} [current]\n */\n\n/**\n * @typedef {Object} AngularRef\n * @property {HTMLElement|SVGElement} [nativeElement]\n */\n\n/**\n * @typedef {Object} ScopeParams\n * @property {DOMTargetSelector|ReactRef|AngularRef} [root]\n * @property {DefaultsParams} [defaults]\n * @property {Record<String, String>} [mediaQueries]\n */\n\n/**\n * @template T\n * @callback ScopedCallback\n * @param {Scope} scope\n * @return {T}\n */\n\n/**\n * @callback ScopeCleanupCallback\n * @param {Scope} [scope]\n */\n\n/**\n * @callback ScopeConstructorCallback\n * @param {Scope} [scope]\n * @return {ScopeCleanupCallback|void}\n */\n\n/**\n * @callback ScopeMethod\n * @param {...*} args\n * @return {ScopeCleanupCallback|void}\n */\n\n// Scroll types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {String|Number} ScrollThresholdValue\n */\n\n/**\n * @typedef {Object} ScrollThresholdParam\n * @property {ScrollThresholdValue} [target]\n * @property {ScrollThresholdValue} [container]\n */\n\n/**\n * @callback ScrollObserverAxisCallback\n * @param {ScrollObserver} self\n * @return {'x'|'y'}\n */\n\n/**\n * @callback ScrollThresholdCallback\n * @param {ScrollObserver} self\n * @return {ScrollThresholdValue|ScrollThresholdParam}\n */\n\n/**\n * @typedef {Object} ScrollObserverParams\n * @property {Number|String} [id]\n * @property {Boolean|Number|String|EasingParam} [sync]\n * @property {TargetsParam} [container]\n * @property {TargetsParam} [target]\n * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]\n * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]\n * @property {Boolean} [debug]\n * @property {Callback<ScrollObserver>} [onEnter]\n * @property {Callback<ScrollObserver>} [onLeave]\n * @property {Callback<ScrollObserver>} [onEnterForward]\n * @property {Callback<ScrollObserver>} [onLeaveForward]\n * @property {Callback<ScrollObserver>} [onEnterBackward]\n * @property {Callback<ScrollObserver>} [onLeaveBackward]\n * @property {Callback<ScrollObserver>} [onUpdate]\n * @property {Callback<ScrollObserver>} [onSyncComplete]\n */\n\n// Draggable types /////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} DraggableAxisParam\n * @property {String} [mapTo]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n */\n\n/**\n * @typedef {Object} DraggableCursorParams\n * @property {String} [onHover]\n * @property {String} [onGrab]\n */\n\n/**\n * @typedef {Object} DraggableParams\n * @property {DOMTargetSelector} [trigger]\n * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]\n * @property {Boolean|DraggableAxisParam} [x]\n * @property {Boolean|DraggableAxisParam} [y]\n * @property {TweenModifier} [modifier]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]\n * @property {Number|((draggable: Draggable) => Number)} [containerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]\n * @property {Number|((draggable: Draggable) => Number)} [minVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]\n * @property {Number} [releaseMass]\n * @property {Number} [releaseStiffness]\n * @property {Number} [releaseDamping]\n * @property {Boolean} [releaseDamping]\n * @property {EasingParam} [releaseEase]\n * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]\n * @property {Callback<Draggable>} [onGrab]\n * @property {Callback<Draggable>} [onDrag]\n * @property {Callback<Draggable>} [onRelease]\n * @property {Callback<Draggable>} [onUpdate]\n * @property {Callback<Draggable>} [onSettle]\n * @property {Callback<Draggable>} [onSnap]\n * @property {Callback<Draggable>} [onResize]\n * @property {Callback<Draggable>} [onAfterResize]\n */\n\n// Text types //////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} splitTemplateParams\n * @property {false|String} [class]\n * @property {Boolean|'hidden'|'clip'|'visible'|'scroll'|'auto'} [wrap]\n * @property {Boolean|'top'|'right'|'bottom'|'left'|'center'} [clone]\n */\n\n/**\n * @typedef {Boolean|String} SplitValue\n */\n\n/**\n * @callback SplitFunctionValue\n * @param {Node|HTMLElement} [value]\n * @return String\n */\n\n/**\n * @typedef {Object} TextSplitterParams\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [lines]\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [words]\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [chars]\n * @property {Boolean} [accessible]\n * @property {Boolean} [includeSpaces]\n * @property {Boolean} [debug]\n */\n\n// SVG types ///////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {SVGGeometryElement & {\n *   setAttribute(name: 'draw', value: `${number} ${number}`): void;\n *   draw: `${number} ${number}`;\n * }} DrawableSVGGeometry\n */\n\n\n// Environments\n\n// TODO: Do we need to check if we're running inside a worker ?\nconst isBrowser = typeof window !== 'undefined';\n\n/** @type {Window & {AnimeJS: Array}|null} */\nconst win = isBrowser ? /** @type {Window & {AnimeJS: Array}} */(/** @type {unknown} */(window)) : null;\n\n/** @type {Document|null} */\nconst doc = isBrowser ? document : null;\n\n// Enums\n\n/** @enum {Number} */\nconst tweenTypes = {\n  OBJECT: 0,\n  ATTRIBUTE: 1,\n  CSS: 2,\n  TRANSFORM: 3,\n  CSS_VAR: 4,\n};\n\n/** @enum {Number} */\nconst valueTypes = {\n  NUMBER: 0,\n  UNIT: 1,\n  COLOR: 2,\n  COMPLEX: 3,\n};\n\n/** @enum {Number} */\nconst tickModes = {\n  NONE: 0,\n  AUTO: 1,\n  FORCE: 2,\n};\n\n/** @enum {Number} */\nconst compositionTypes = {\n  replace: 0,\n  none: 1,\n  blend: 2,\n};\n\n// Cache symbols\n\nconst isRegisteredTargetSymbol = Symbol();\nconst isDomSymbol = Symbol();\nconst isSvgSymbol = Symbol();\nconst transformsSymbol = Symbol();\nconst morphPointsSymbol = Symbol();\nconst proxyTargetSymbol = Symbol();\n\n// Numbers\n\nconst minValue = 1e-11;\nconst maxValue = 1e12;\nconst K = 1e3;\nconst maxFps = 120;\n\n// Strings\n\nconst emptyString = '';\nconst shortTransforms = /*#__PURE__*/ (() => {\n  const map = new Map();\n  map.set('x', 'translateX');\n  map.set('y', 'translateY');\n  map.set('z', 'translateZ');\n  return map;\n})();\n\nconst validTransforms = [\n  'translateX',\n  'translateY',\n  'translateZ',\n  'rotate',\n  'rotateX',\n  'rotateY',\n  'rotateZ',\n  'scale',\n  'scaleX',\n  'scaleY',\n  'scaleZ',\n  'skew',\n  'skewX',\n  'skewY',\n  'perspective',\n  'matrix',\n  'matrix3d',\n];\n\nconst transformsFragmentStrings = /*#__PURE__*/ validTransforms.reduce((a, v) => ({...a, [v]: v + '('}), {});\n\n// Functions\n\n/** @return {void} */\nconst noop = () => {};\n\n// Regex\n\nconst hexTestRgx = /(^#([\\da-f]{3}){1,2}$)|(^#([\\da-f]{4}){1,2}$)/i;\nconst rgbExecRgx = /rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i;\nconst rgbaExecRgx = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\nconst hslExecRgx = /hsl\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*\\)/i;\nconst hslaExecRgx = /hsla\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\n// export const digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?/g;\nconst digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:e[-+]?\\d)?/gi;\n// export const unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)+([a-z]+|%)$/i;\nconst unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:e[-+]?\\d+)?)([a-z]+|%)$/i;\nconst lowerCaseRgx = /([a-z])([A-Z])/g;\nconst transformsExecRgx = /(\\w+)(\\([^)]+\\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()\nconst relativeValuesExecRgx = /(\\*=|\\+=|-=)/;\n\n\n\n\n/** @type {DefaultsParams} */\nconst defaults = {\n  id: null,\n  keyframes: null,\n  playbackEase: null,\n  playbackRate: 1,\n  frameRate: maxFps,\n  loop: 0,\n  reversed: false,\n  alternate: false,\n  autoplay: true,\n  duration: K,\n  delay: 0,\n  loopDelay: 0,\n  ease: 'out(2)',\n  composition: compositionTypes.replace,\n  modifier: v => v,\n  onBegin: noop,\n  onBeforeUpdate: noop,\n  onUpdate: noop,\n  onLoop: noop,\n  onPause: noop,\n  onComplete: noop,\n  onRender: noop,\n};\n\nconst scope = {\n  /** @type {Scope} */\n  current: null,\n  /** @type {Document|DOMTarget} */\n  root: doc,\n};\n\nconst globals = {\n  /** @type {DefaultsParams} */\n  defaults,\n  /** @type {Number} */\n  precision: 4,\n  /** @type {Number} equals 1 in ms mode, 0.001 in s mode */\n  timeScale: 1,\n  /** @type {Number} */\n  tickThreshold: 200,\n};\n\nconst globalVersions = { version: '4.1.4', engine: null };\n\nif (isBrowser) {\n  if (!win.AnimeJS) win.AnimeJS = [];\n  win.AnimeJS.push(globalVersions);\n}\n\n// Strings\n\n/**\n * @param  {String} str\n * @return {String}\n */\nconst toLowerCase = str => str.replace(lowerCaseRgx, '$1-$2').toLowerCase();\n\n/**\n * Prioritize this method instead of regex when possible\n * @param  {String} str\n * @param  {String} sub\n * @return {Boolean}\n */\nconst stringStartsWith = (str, sub) => str.indexOf(sub) === 0;\n\n// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.\nconst now = Date.now;\n\n// Types checkers\n\nconst isArr = Array.isArray;\n/**@param {any} a @return {a is Record<String, any>} */\nconst isObj = a => a && a.constructor === Object;\n/**@param {any} a @return {a is Number} */\nconst isNum = a => typeof a === 'number' && !isNaN(a);\n/**@param {any} a @return {a is String} */\nconst isStr = a => typeof a === 'string';\n/**@param {any} a @return {a is Function} */\nconst isFnc = a => typeof a === 'function';\n/**@param {any} a @return {a is undefined} */\nconst isUnd = a => typeof a === 'undefined';\n/**@param {any} a @return {a is null | undefined} */\nconst isNil = a => isUnd(a) || a === null;\n/**@param {any} a @return {a is SVGElement} */\nconst isSvg = a => isBrowser && a instanceof SVGElement;\n/**@param {any} a @return {Boolean} */\nconst isHex = a => hexTestRgx.test(a);\n/**@param {any} a @return {Boolean} */\nconst isRgb = a => stringStartsWith(a, 'rgb');\n/**@param {any} a @return {Boolean} */\nconst isHsl = a => stringStartsWith(a, 'hsl');\n/**@param {any} a @return {Boolean} */\nconst isCol = a => isHex(a) || isRgb(a) || isHsl(a);\n/**@param {any} a @return {Boolean} */\nconst isKey = a => !globals.defaults.hasOwnProperty(a);\n\n// Number\n\n/**\n * @param  {Number|String} str\n * @return {Number}\n */\nconst parseNumber = str => isStr(str) ?\n  parseFloat(/** @type {String} */(str)) :\n  /** @type {Number} */(str);\n\n// Math\n\nconst pow = Math.pow;\nconst sqrt = Math.sqrt;\nconst sin = Math.sin;\nconst cos = Math.cos;\nconst abs = Math.abs;\nconst exp = Math.exp;\nconst ceil = Math.ceil;\nconst floor = Math.floor;\nconst asin = Math.asin;\nconst max = Math.max;\nconst atan2 = Math.atan2;\nconst PI = Math.PI;\nconst _round = Math.round;\n\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */\nconst clamp = (v, min, max) => v < min ? min : v > max ? max : v;\n\nconst powCache = {};\n\n/**\n * @param  {Number} v\n * @param  {Number} decimalLength\n * @return {Number}\n */\nconst round = (v, decimalLength) => {\n  if (decimalLength < 0) return v;\n  if (!decimalLength) return _round(v);\n  let p = powCache[decimalLength];\n  if (!p) p = powCache[decimalLength] = 10 ** decimalLength;\n  return _round(v * p) / p;\n};\n\n/**\n * @param  {Number} v\n * @param  {Number|Array<Number>} increment\n * @return {Number}\n */\nconst snap = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => (abs(cv - v) < abs(closest - v) ? cv : closest)) : increment ? _round(v / increment) * increment : v;\n\n/**\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} progress\n * @return {Number}\n */\nconst interpolate = (start, end, progress) => start + (end - start) * progress;\n\n/**\n * @param  {Number} min\n * @param  {Number} max\n * @param  {Number} [decimalLength]\n * @return {Number}\n */\nconst random = (min, max, decimalLength) => { const m = 10 ** (decimalLength || 0); return floor((Math.random() * (max - min + (1 / m)) + min) * m) / m };\n\n/**\n * Adapted from https://bost.ocks.org/mike/shuffle/\n * @param  {Array} items\n * @return {Array}\n */\nconst shuffle = items => {\n  let m = items.length, t, i;\n  while (m) { i = random(0, --m); t = items[m]; items[m] = items[i]; items[i] = t; }\n  return items;\n};\n\n/**\n * @param  {Number} v\n * @return {Number}\n */\nconst clampInfinity = v => v === Infinity ? maxValue : v === -Infinity ? -maxValue : v;\n\n/**\n * @param  {Number} v\n * @return {Number}\n */\nconst normalizeTime = v => v <= minValue ? minValue : clampInfinity(round(v, 11));\n\n// Arrays\n\n/**\n * @template T\n * @param {T[]} a\n * @return {T[]}\n */\nconst cloneArray = a => isArr(a) ? [ ...a ] : a;\n\n// Objects\n\n/**\n * @template T\n * @template U\n * @param {T} o1\n * @param {U} o2\n * @return {T & U}\n */\nconst mergeObjects = (o1, o2) => {\n  const merged = /** @type {T & U} */({ ...o1 });\n  for (let p in o2) {\n    const o1p = /** @type {T & U} */(o1)[p];\n    merged[p] = isUnd(o1p) ? /** @type {T & U} */(o2)[p] : o1p;\n  }  return merged;\n};\n\n// Linked lists\n\n/**\n * @param {Object} parent\n * @param {Function} callback\n * @param {Boolean} [reverse]\n * @param {String} [prevProp]\n * @param {String} [nextProp]\n * @return {void}\n */\nconst forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {\n  let next = parent._head;\n  let adjustedNextProp = nextProp;\n  if (reverse) {\n    next = parent._tail;\n    adjustedNextProp = prevProp;\n  }\n  while (next) {\n    const currentNext = next[adjustedNextProp];\n    callback(next);\n    next = currentNext;\n  }\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {String} [prevProp]\n * @param  {String} [nextProp]\n * @return {void}\n */\nconst removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {\n  const prev = child[prevProp];\n  const next = child[nextProp];\n  prev ? prev[nextProp] = next : parent._head = next;\n  next ? next[prevProp] = prev : parent._tail = prev;\n  child[prevProp] = null;\n  child[nextProp] = null;\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {Function} [sortMethod]\n * @param  {String} prevProp\n * @param  {String} nextProp\n * @return {void}\n */\nconst addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {\n  let prev = parent._tail;\n  while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];\n  const next = prev ? prev[nextProp] : parent._head;\n  prev ? prev[nextProp] = child : parent._head = child;\n  next ? next[prevProp] = child : parent._tail = child;\n  child[prevProp] = prev;\n  child[nextProp] = next;\n};\n\n/**\n * @param  {(...args: any[]) => Tickable | ((...args: any[]) => void)} constructor\n * @return {(...args: any[]) => Tickable | ((...args: any[]) => void)}\n */\nconst createRefreshable = constructor => {\n  /** @type {Tickable} */\n  let tracked;\n  return (...args) => {\n    let currentIteration, currentIterationProgress, reversed, alternate;\n    if (tracked) {\n      currentIteration = tracked.currentIteration;\n      currentIterationProgress = tracked.iterationProgress;\n      reversed = tracked.reversed;\n      alternate = tracked._alternate;\n      tracked.revert();\n    }\n    const cleanup = constructor(...args);\n    if (cleanup && !isFnc(cleanup) && cleanup.revert) tracked = cleanup;\n    if (!isUnd(currentIterationProgress)) {\n      /** @type {Tickable} */(tracked).currentIteration = currentIteration;\n      /** @type {Tickable} */(tracked).iterationProgress = (alternate ? !(currentIteration % 2) ? reversed : !reversed : reversed) ? 1 - currentIterationProgress : currentIterationProgress;\n    }\n    return cleanup || noop;\n  }\n};\n\n/*\n * Base class to control framerate and playback rate.\n * Inherited by Engine, Timer, Animation and Timeline.\n */\nclass Clock {\n\n  /** @param {Number} [initTime] */\n  constructor(initTime = 0) {\n    /** @type {Number} */\n    this.deltaTime = 0;\n    /** @type {Number} */\n    this._currentTime = initTime;\n    /** @type {Number} */\n    this._elapsedTime = initTime;\n    /** @type {Number} */\n    this._startTime = initTime;\n    /** @type {Number} */\n    this._lastTime = initTime;\n    /** @type {Number} */\n    this._scheduledTime = 0;\n    /** @type {Number} */\n    this._frameDuration = round(K / maxFps, 0);\n    /** @type {Number} */\n    this._fps = maxFps;\n    /** @type {Number} */\n    this._speed = 1;\n    /** @type {Boolean} */\n    this._hasChildren = false;\n    /** @type {Tickable|Tween} */\n    this._head = null;\n    /** @type {Tickable|Tween} */\n    this._tail = null;\n  }\n\n  get fps() {\n    return this._fps;\n  }\n\n  set fps(frameRate) {\n    const previousFrameDuration = this._frameDuration;\n    const fr = +frameRate;\n    const fps = fr < minValue ? minValue : fr;\n    const frameDuration = round(K / fps, 0);\n    this._fps = fps;\n    this._frameDuration = frameDuration;\n    this._scheduledTime += frameDuration - previousFrameDuration;\n  }\n\n  get speed() {\n    return this._speed;\n  }\n\n  set speed(playbackRate) {\n    const pbr = +playbackRate;\n    this._speed = pbr < minValue ? minValue : pbr;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {tickModes}\n   */\n  requestTick(time) {\n    const scheduledTime = this._scheduledTime;\n    const elapsedTime = this._elapsedTime;\n    this._elapsedTime += (time - elapsedTime);\n    // If the elapsed time is lower than the scheduled time\n    // this means not enough time has passed to hit one frameDuration\n    // so skip that frame\n    if (elapsedTime < scheduledTime) return tickModes.NONE;\n    const frameDuration = this._frameDuration;\n    const frameDelta = elapsedTime - scheduledTime;\n    // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.\n    // Skips ahead if the actual elapsed time is higher.\n    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;\n    return tickModes.AUTO;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {Number}\n   */\n  computeDeltaTime(time) {\n    const delta = time - this._lastTime;\n    this.deltaTime = delta;\n    this._lastTime = time;\n    return delta;\n  }\n\n}\n\n\n\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {tickModes} tickMode\n * @return {Number}\n */\nconst render = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n\n  const parent = tickable.parent;\n  const duration = tickable.duration;\n  const completed = tickable.completed;\n  const iterationDuration = tickable.iterationDuration;\n  const iterationCount = tickable.iterationCount;\n  const _currentIteration = tickable._currentIteration;\n  const _loopDelay = tickable._loopDelay;\n  const _reversed = tickable._reversed;\n  const _alternate = tickable._alternate;\n  const _hasChildren = tickable._hasChildren;\n  const tickableDelay = tickable._delay;\n  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime\n\n  const tickableEndTime = tickableDelay + iterationDuration;\n  const tickableAbsoluteTime = time - tickableDelay;\n  const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);\n  const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);\n  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;\n  const isCurrentTimeAboveZero = tickableCurrentTime > 0;\n  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;\n  const isSetter = duration <= minValue;\n  const forcedTick = tickMode === tickModes.FORCE;\n\n  let isOdd = 0;\n  let iterationElapsedTime = tickableAbsoluteTime;\n  // Render checks\n  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer\n  let hasRendered = 0;\n\n  // Execute the \"expensive\" iterations calculations only when necessary\n  if (iterationCount > 1) {\n    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers\n    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));\n    tickable._currentIteration = clamp(currentIteration, 0, iterationCount);\n    // Prevent the iteration count to go above the max iterations when reaching the end of the animation\n    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;\n    isOdd = tickable._currentIteration % 2;\n    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;\n  }\n\n  // Checks if exactly one of _reversed and (_alternate && isOdd) is true\n  const isReversed = _reversed ^ (_alternate && isOdd);\n  const _ease = /** @type {Renderable} */(tickable)._ease;\n  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;\n  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;\n  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;\n\n  tickable._currentTime = tickableAbsoluteTime;\n  tickable._iterationTime = iterationTime;\n  tickable.backwards = isRunningBackwards;\n\n  if (isCurrentTimeAboveZero && !tickable.began) {\n    tickable.began = true;\n    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n      tickable.onBegin(/** @type {CallbackArgument} */(tickable));\n    }\n  } else if (tickableAbsoluteTime <= 0) {\n    tickable.began = false;\n  }\n\n  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function\n  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values\n  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {\n    tickable.onLoop(/** @type {CallbackArgument} */(tickable));\n  }\n\n  if (\n    forcedTick ||\n    tickMode === tickModes.AUTO && (\n      time >= tickableDelay && time <= tickableEndTime || // Normal render\n      time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state\n      time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state\n    ) ||\n    iterationTime >= tickableEndTime && tickablePrevTime !== duration ||\n    iterationTime <= tickableDelay && tickablePrevTime > 0 ||\n    time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation\n    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped\n  ) {\n\n    if (isCurrentTimeAboveZero) {\n      // Trigger onUpdate callback before rendering\n      tickable.computeDeltaTime(tickablePrevTime);\n      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n    // Start tweens rendering\n    if (!_hasChildren) {\n\n      // Time has jumped more than globals.tickThreshold so consider this tick manual\n      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;\n      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;\n\n      // Only Animation can have tweens, Timer returns undefined\n      let tween = /** @type {Tween} */(/** @type {JSAnimation} */(tickable)._head);\n      let tweenTarget;\n      let tweenStyle;\n      let tweenTargetTransforms;\n      let tweenTargetTransformsProperties;\n      let tweenTransformsNeedUpdate = 0;\n\n      while (tween) {\n\n        const tweenComposition = tween._composition;\n        const tweenCurrentTime = tween._currentTime;\n        const tweenChangeDuration = tween._changeDuration;\n        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;\n        const tweenNextRep = tween._nextRep;\n        const tweenPrevRep = tween._prevRep;\n        const tweenHasComposition = tweenComposition !== compositionTypes.none;\n\n        if ((forcedRender || (\n            (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&\n            (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)\n          )) && (!tweenHasComposition || (\n            !tween._isOverridden &&\n            (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&\n            (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&\n            (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))\n          ))\n        ) {\n\n          const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);\n          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);\n          const tweenModifier = tween._modifier;\n          const tweenValueType = tween._valueType;\n          const tweenType = tween._tweenType;\n          const tweenIsObject = tweenType === tweenTypes.OBJECT;\n          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;\n          // Only round the in-between frames values if the final value is a string\n          const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;\n\n          // Recompose tween value\n          /** @type {String|Number} */\n          let value;\n          /** @type {Number} */\n          let number;\n\n          if (tweenIsNumber) {\n            value = number = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision )));\n          } else if (tweenValueType === valueTypes.UNIT) {\n            // Rounding the values speed up string composition\n            number = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision)));\n            value = `${number}${tween._unit}`;\n          } else if (tweenValueType === valueTypes.COLOR) {\n            const fn = tween._fromNumbers;\n            const tn = tween._toNumbers;\n            const r = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[0], tn[0], tweenProgress))), 0, 255), 0);\n            const g = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[1], tn[1], tweenProgress))), 0, 255), 0);\n            const b = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[2], tn[2], tweenProgress))), 0, 255), 0);\n            const a = clamp(/** @type {Number} */(tweenModifier(round(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);\n            value = `rgba(${r},${g},${b},${a})`;\n            if (tweenHasComposition) {\n              const ns = tween._numbers;\n              ns[0] = r;\n              ns[1] = g;\n              ns[2] = b;\n              ns[3] = a;\n            }\n          } else if (tweenValueType === valueTypes.COMPLEX) {\n            value = tween._strings[0];\n            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {\n              const n = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));\n              const s = tween._strings[j + 1];\n              value += `${s ? n + s : n}`;\n              if (tweenHasComposition) {\n                tween._numbers[j] = n;\n              }\n            }\n          }\n\n          // For additive tweens and Animatables\n          if (tweenHasComposition) {\n            tween._number = number;\n          }\n\n          if (!internalRender && tweenComposition !== compositionTypes.blend) {\n\n            const tweenProperty = tween.property;\n            tweenTarget = tween.target;\n\n            if (tweenIsObject) {\n              tweenTarget[tweenProperty] = value;\n            } else if (tweenType === tweenTypes.ATTRIBUTE) {\n              /** @type {DOMTarget} */(tweenTarget).setAttribute(tweenProperty, /** @type {String} */(value));\n            } else {\n              tweenStyle = /** @type {DOMTarget} */(tweenTarget).style;\n              if (tweenType === tweenTypes.TRANSFORM) {\n                if (tweenTarget !== tweenTargetTransforms) {\n                  tweenTargetTransforms = tweenTarget;\n                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.\n                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];\n                }\n                tweenTargetTransformsProperties[tweenProperty] = value;\n                tweenTransformsNeedUpdate = 1;\n              } else if (tweenType === tweenTypes.CSS) {\n                tweenStyle[tweenProperty] = value;\n              } else if (tweenType === tweenTypes.CSS_VAR) {\n                tweenStyle.setProperty(tweenProperty,/** @type {String} */(value));\n              }\n            }\n\n            if (isCurrentTimeAboveZero) hasRendered = 1;\n\n          } else {\n            // Used for composing timeline tweens without having to do a real render\n            tween._value = value;\n          }\n\n        }\n\n        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax\n        // to reduce memory usage on string composition\n        if (tweenTransformsNeedUpdate && tween._renderTransforms) {\n          let str = emptyString;\n          for (let key in tweenTargetTransformsProperties) {\n            str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;\n          }\n          tweenStyle.transform = str;\n          tweenTransformsNeedUpdate = 0;\n        }\n\n        tween = tween._next;\n      }\n\n      if (!muteCallbacks && hasRendered) {\n        /** @type {JSAnimation} */(tickable).onRender(/** @type {JSAnimation} */(tickable));\n      }\n    }\n\n    if (!muteCallbacks && isCurrentTimeAboveZero) {\n      tickable.onUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n  }\n\n  // End tweens rendering\n\n  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards\n  if (parent && isSetter) {\n    if (!muteCallbacks && (\n      (parent.began && !isRunningBackwards && tickableAbsoluteTime >= duration && !completed) ||\n      (isRunningBackwards && tickableAbsoluteTime <= minValue && completed)\n    )) {\n      tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n      tickable.completed = !isRunningBackwards;\n    }\n  // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops\n  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {\n    if (iterationCount === Infinity) {\n      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer\n      tickable._startTime += tickable.duration;\n    } else if (tickable._currentIteration >= iterationCount - 1) {\n      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick\n      tickable.paused = true;\n      if (!completed && !_hasChildren) {\n        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function\n        tickable.completed = true;\n        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n          tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n          tickable._resolve(/** @type {CallbackArgument} */(tickable));\n        }\n      }\n    }\n  // Otherwise set the completed flag to false\n  } else {\n    tickable.completed = false;\n  }\n\n  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?\n  return hasRendered;\n};\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {Number} tickMode\n * @return {void}\n */\nconst tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n  const _currentIteration = tickable._currentIteration;\n  render(tickable, time, muteCallbacks, internalRender, tickMode);\n  if (tickable._hasChildren) {\n    const tl = /** @type {Timeline} */(tickable);\n    const tlIsRunningBackwards = tl.backwards;\n    const tlChildrenTime = internalRender ? time : tl._iterationTime;\n    const tlCildrenTickTime = now();\n\n    let tlChildrenHasRendered = 0;\n    let tlChildrenHaveCompleted = true;\n\n    // If the timeline has looped forward, we need to manually triggers children skipped callbacks\n    if (!internalRender && tl._currentIteration !== _currentIteration) {\n      const tlIterationDuration = tl.iterationDuration;\n      forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n        if (!tlIsRunningBackwards) {\n          // Force an internal render to trigger the callbacks if the child has not completed on loop\n          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {\n            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);\n          }\n          // Reset their began and completed flags to allow retrigering callbacks on the next iteration\n          child.began = false;\n          child.completed = false;\n        } else {\n          const childDuration = child.duration;\n          const childStartTime = child._offset + child._delay;\n          const childEndTime = childStartTime + childDuration;\n          // Triggers the onComplete callback on reverse for children on the edges of the timeline\n          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {\n            child.onComplete(child);\n          }\n        }\n      });\n      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */(tl));\n    }\n\n    forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n      const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds\n      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;\n      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);\n      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;\n    }, tlIsRunningBackwards);\n\n    // Renders on timeline are triggered by its children so it needs to be set after rendering the children\n    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */(tl));\n\n    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end\n    if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {\n      // Make sure the paused flag is false in case it has been skipped in the render function\n      tl.paused = true;\n      if (!tl.completed) {\n        tl.completed = true;\n        if (!muteCallbacks) {\n          tl.onComplete(/** @type {CallbackArgument} */(tl));\n          tl._resolve(/** @type {CallbackArgument} */(tl));\n        }\n      }\n    }\n  }\n};\n\n\n\n\nconst additive = {\n  animation: null,\n  update: noop,\n};\n\n/**\n * @typedef AdditiveAnimation\n * @property {Number} duration\n * @property {Number} _offset\n * @property {Number} _delay\n * @property {Tween} _head\n * @property {Tween} _tail\n */\n\n/**\n * @param  {TweenAdditiveLookups} lookups\n * @return {AdditiveAnimation}\n */\nconst addAdditiveAnimation = lookups => {\n  let animation = additive.animation;\n  if (!animation) {\n    animation = {\n      duration: minValue,\n      computeDeltaTime: noop,\n      _offset: 0,\n      _delay: 0,\n      _head: null,\n      _tail: null,\n    };\n    additive.animation = animation;\n    additive.update = () => {\n      lookups.forEach(propertyAnimation => {\n        for (let propertyName in propertyAnimation) {\n          const tweens = propertyAnimation[propertyName];\n          const lookupTween = tweens._head;\n          if (lookupTween) {\n            const valueType = lookupTween._valueType;\n            const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;\n            let additiveValue = lookupTween._fromNumber;\n            let tween = tweens._tail;\n            while (tween && tween !== lookupTween) {\n              if (additiveValues) {\n                for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];\n              } else {\n                additiveValue += tween._number;\n              }\n              tween = tween._prevAdd;\n            }\n            lookupTween._toNumber = additiveValue;\n            lookupTween._toNumbers = additiveValues;\n          }\n        }\n      });\n      // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop\n      render(animation, 1, 1, 0, tickModes.FORCE);\n    };\n  }\n  return animation;\n};\n\nconst engineTickMethod = /*#__PURE__*/ (() => isBrowser ? requestAnimationFrame : setImmediate)();\nconst engineCancelMethod = /*#__PURE__*/ (() => isBrowser ? cancelAnimationFrame : clearImmediate)();\n\nclass Engine extends Clock {\n\n  /** @param {Number} [initTime] */\n  constructor(initTime) {\n    super(initTime);\n    this.useDefaultMainLoop = true;\n    this.pauseOnDocumentHidden = true;\n    /** @type {DefaultsParams} */\n    this.defaults = defaults;\n    // this.paused = isBrowser && doc.hidden ? true  : false;\n    this.paused = true;\n    /** @type {Number|NodeJS.Immediate} */\n    this.reqId = 0;\n  }\n\n  update() {\n    const time = this._currentTime = now();\n    if (this.requestTick(time)) {\n      this.computeDeltaTime(time);\n      const engineSpeed = this._speed;\n      const engineFps = this._fps;\n      let activeTickable = /** @type {Tickable} */(this._head);\n      while (activeTickable) {\n        const nextTickable = activeTickable._next;\n        if (!activeTickable.paused) {\n          tick(\n            activeTickable,\n            (time - activeTickable._startTime) * activeTickable._speed * engineSpeed,\n            0, // !muteCallbacks\n            0, // !internalRender\n            activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO\n          );\n        } else {\n          removeChild(this, activeTickable);\n          this._hasChildren = !!this._tail;\n          activeTickable._running = false;\n          if (activeTickable.completed && !activeTickable._cancelled) {\n            activeTickable.cancel();\n          }\n        }\n        activeTickable = nextTickable;\n      }\n      additive.update();\n    }\n  }\n\n  wake() {\n    if (this.useDefaultMainLoop && !this.reqId) {\n      // Imediatly request a tick to update engine._elapsedTime and get accurate offsetPosition calculation in timer.js\n      this.requestTick(now());\n      this.reqId = engineTickMethod(tickEngine);\n    }\n    return this;\n  }\n\n  pause() {\n    if (!this.reqId) return;\n    this.paused = true;\n    return killEngine();\n  }\n\n  resume() {\n    if (!this.paused) return;\n    this.paused = false;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.resetTime());\n    return this.wake();\n  }\n\n  // Getter and setter for speed\n  get speed() {\n    return this._speed * (globals.timeScale === 1 ? 1 : K);\n  }\n\n  set speed(playbackRate) {\n    this._speed = playbackRate * globals.timeScale;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.speed = child._speed);\n  }\n\n  // Getter and setter for timeUnit\n  get timeUnit() {\n    return globals.timeScale === 1 ? 'ms' : 's';\n  };\n\n  set timeUnit(unit) {\n    const secondsScale = 0.001;\n    const isSecond = unit === 's';\n    const newScale = isSecond ? secondsScale : 1;\n    if (globals.timeScale !== newScale) {\n      globals.timeScale = newScale;\n      globals.tickThreshold = 200 * newScale;\n      const scaleFactor = isSecond ? secondsScale : K;\n      /** @type {Number} */\n      (this.defaults.duration) *= scaleFactor;\n      this._speed *= scaleFactor;\n    }\n  }\n\n  // Getter and setter for precision\n  get precision() {\n    return globals.precision;\n  }\n\n  set precision(precision) {\n    globals.precision = precision;\n  }\n\n}\nconst engine = /*#__PURE__*/(() => {\n  const engine = new Engine(now());\n  if (isBrowser) {\n    globalVersions.engine = engine;\n    doc.addEventListener('visibilitychange', () => {\n      if (!engine.pauseOnDocumentHidden) return;\n      doc.hidden ? engine.pause() : engine.resume();\n    });\n  }\n  return engine;\n})();\n\n\nconst tickEngine = () => {\n  if (engine._head) {\n    engine.reqId = engineTickMethod(tickEngine);\n    engine.update();\n  } else {\n    engine.reqId = 0;\n  }\n};\n\nconst killEngine = () => {\n  engineCancelMethod(/** @type {NodeJS.Immediate & Number} */(engine.reqId));\n  engine.reqId = 0;\n  return engine;\n};\n\n\n\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst parseInlineTransforms = (target, propName, animationInlineStyles) => {\n  const inlineTransforms = target.style.transform;\n  let inlinedStylesPropertyValue;\n  if (inlineTransforms) {\n    const cachedTransforms = target[transformsSymbol];\n    let t; while (t = transformsExecRgx.exec(inlineTransforms)) {\n      const inlinePropertyName = t[1];\n      // const inlinePropertyValue = t[2];\n      const inlinePropertyValue = t[2].slice(1, -1);\n      cachedTransforms[inlinePropertyName] = inlinePropertyValue;\n      if (inlinePropertyName === propName) {\n        inlinedStylesPropertyValue = inlinePropertyValue;\n        // Store the new parsed inline styles if animationInlineStyles is provided\n        if (animationInlineStyles) {\n          animationInlineStyles[propName] = inlinePropertyValue;\n        }\n      }\n    }\n  }\n  return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue :\n    stringStartsWith(propName, 'scale') ? '1' :\n    stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew') ? '0deg' : '0px';\n};\n\n\n\n\n/**\n * @param  {DOMTargetsParam|TargetsParam} v\n * @return {NodeList|HTMLCollection}\n */\nfunction getNodeList(v) {\n  const n = isStr(v) ? scope.root.querySelectorAll(v) : v;\n  if (n instanceof NodeList || n instanceof HTMLCollection) return n;\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction parseTargets(targets) {\n  if (isNil(targets)) return /** @type {TargetsArray} */([]);\n  if (!isBrowser) return /** @type {JSTargetsArray} */(isArr(targets) && targets.flat(Infinity) || [targets]);\n  if (isArr(targets)) {\n    const flattened = targets.flat(Infinity);\n    /** @type {TargetsArray} */\n    const parsed = [];\n    for (let i = 0, l = flattened.length; i < l; i++) {\n      const item = flattened[i];\n      if (!isNil(item)) {\n        const nodeList = getNodeList(item);\n        if (nodeList) {\n          for (let j = 0, jl = nodeList.length; j < jl; j++) {\n            const subItem = nodeList[j];\n            if (!isNil(subItem)) {\n              let isDuplicate = false;\n              for (let k = 0, kl = parsed.length; k < kl; k++) {\n                if (parsed[k] === subItem) {\n                  isDuplicate = true;\n                  break;\n                }\n              }\n              if (!isDuplicate) {\n                parsed.push(subItem);\n              }\n            }\n          }\n        } else {\n          let isDuplicate = false;\n          for (let j = 0, jl = parsed.length; j < jl; j++) {\n            if (parsed[j] === item) {\n              isDuplicate = true;\n              break;\n            }\n          }\n          if (!isDuplicate) {\n            parsed.push(item);\n          }\n        }\n      }\n    }\n    return parsed;\n  }\n  const nodeList = getNodeList(targets);\n  if (nodeList) return /** @type {DOMTargetsArray} */(Array.from(nodeList));\n  return /** @type {TargetsArray} */([targets]);\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction registerTargets(targets) {\n  const parsedTargetsArray = parseTargets(targets);\n  const parsedTargetsLength = parsedTargetsArray.length;\n  if (parsedTargetsLength) {\n    for (let i = 0; i < parsedTargetsLength; i++) {\n      const target = parsedTargetsArray[i];\n      if (!target[isRegisteredTargetSymbol]) {\n        target[isRegisteredTargetSymbol] = true;\n        const isSvgType = isSvg(target);\n        const isDom = /** @type {DOMTarget} */(target).nodeType || isSvgType;\n        if (isDom) {\n          target[isDomSymbol] = true;\n          target[isSvgSymbol] = isSvgType;\n          target[transformsSymbol] = {};\n        }\n      }\n    }\n  }\n  return parsedTargetsArray;\n}\n\n\n\n\n/**\n * @param  {TargetsParam} path\n * @return {SVGGeometryElement|undefined}\n */\nconst getPath = path => {\n  const parsedTargets = parseTargets(path);\n  const $parsedSvg = /** @type {SVGGeometryElement} */(parsedTargets[0]);\n  if (!$parsedSvg || !isSvg($parsedSvg)) return;\n  return $parsedSvg;\n};\n\n/**\n * @param  {TargetsParam} path2\n * @param  {Number} [precision]\n * @return {FunctionValue}\n */\nconst morphTo = (path2, precision = .33) => ($path1) => {\n  const $path2 = /** @type {SVGGeometryElement} */(getPath(path2));\n  if (!$path2) return;\n  const isPath = $path1.tagName === 'path';\n  const separator = isPath ? ' ' : ',';\n  const previousPoints = $path1[morphPointsSymbol];\n  if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);\n\n  let v1 = '', v2 = '';\n\n  if (!precision) {\n    v1 = $path1.getAttribute(isPath ? 'd' : 'points');\n    v2 = $path2.getAttribute(isPath ? 'd' : 'points');\n  } else {\n    const length1 = /** @type {SVGGeometryElement} */($path1).getTotalLength();\n    const length2 = $path2.getTotalLength();\n    const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));\n    for (let i = 0; i < maxPoints; i++) {\n      const t = i / (maxPoints - 1);\n      const pointOnPath1 = /** @type {SVGGeometryElement} */($path1).getPointAtLength(length1 * t);\n      const pointOnPath2 = $path2.getPointAtLength(length2 * t);\n      const prefix = isPath ? (i === 0 ? 'M' : 'L') : '';\n      v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';\n      v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';\n    }\n  }\n\n  $path1[morphPointsSymbol] = v2;\n\n  return [v1, v2];\n};\n\n/**\n * @param {SVGGeometryElement} [$el]\n * @return {Number}\n */\nconst getScaleFactor = $el => {\n  let scaleFactor = 1;\n  if ($el && $el.getCTM) {\n    const ctm = $el.getCTM();\n    if (ctm) {\n      const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);\n      const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);\n      scaleFactor = (scaleX + scaleY) / 2;\n    }\n  }\n  return scaleFactor;\n};\n\n/**\n * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.\n * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable\n * @param {number} start - Starting position (0-1)\n * @param {number} end - Ending position (0-1)\n * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality\n */\nconst createDrawableProxy = ($el, start, end) => {\n  const pathLength = K;\n  const computedStyles = getComputedStyle($el);\n  const strokeLineCap = computedStyles.strokeLinecap;\n  // @ts-ignore\n  const $scalled = computedStyles.vectorEffect === 'non-scaling-stroke' ? $el : null;\n  let currentCap = strokeLineCap;\n\n  const proxy = new Proxy($el, {\n    get(target, property) {\n      const value = target[property];\n      if (property === proxyTargetSymbol) return target;\n      if (property === 'setAttribute') {\n        return (...args) => {\n          if (args[0] === 'draw') {\n            const value = args[1];\n            const values = value.split(' ');\n            const v1 = +values[0];\n            const v2 = +values[1];\n            // TOTO: Benchmark if performing two slices is more performant than one split\n            // const spaceIndex = value.indexOf(' ');\n            // const v1 = round(+value.slice(0, spaceIndex), precision);\n            // const v2 = round(+value.slice(spaceIndex + 1), precision);\n            const scaleFactor = getScaleFactor($scalled);\n            const os = v1 * -pathLength * scaleFactor;\n            const d1 = (v2 * pathLength * scaleFactor) + os;\n            const d2 = (pathLength * scaleFactor +\n                      ((v1 === 0 && v2 === 1) || (v1 === 1 && v2 === 0) ? 0 : 10 * scaleFactor) - d1);\n            if (strokeLineCap !== 'butt') {\n              const newCap = v1 === v2 ? 'butt' : strokeLineCap;\n              if (currentCap !== newCap) {\n                target.style.strokeLinecap = `${newCap}`;\n                currentCap = newCap;\n              }\n            }\n            target.setAttribute('stroke-dashoffset', `${os}`);\n            target.setAttribute('stroke-dasharray', `${d1} ${d2}`);\n          }\n          return Reflect.apply(value, target, args);\n        };\n      }\n\n      if (isFnc(value)) {\n        return (...args) => Reflect.apply(value, target, args);\n      } else {\n        return value;\n      }\n    }\n  });\n\n  if ($el.getAttribute('pathLength') !== `${pathLength}`) {\n    $el.setAttribute('pathLength', `${pathLength}`);\n    proxy.setAttribute('draw', `${start} ${end}`);\n  }\n\n  return /** @type {DrawableSVGGeometry} */(proxy);\n};\n\n/**\n * Creates drawable proxies for multiple SVG elements.\n * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors\n * @param {number} [start=0] - Starting position (0-1)\n * @param {number} [end=0] - Ending position (0-1)\n * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality\n */\nconst createDrawable = (selector, start = 0, end = 0) => {\n  const els = parseTargets(selector);\n  return els.map($el => createDrawableProxy(\n    /** @type {SVGGeometryElement} */($el),\n    start,\n    end\n  ));\n};\n\n// Motion path animation\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {Number} progress\n * @param {Number}lookup\n * @return {DOMPoint}\n */\nconst getPathPoint = ($path, progress, lookup = 0) => {\n  return $path.getPointAtLength(progress + lookup >= 1 ? progress + lookup : 0);\n};\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {String} pathProperty\n * @return {FunctionValue}\n */\nconst getPathProgess = ($path, pathProperty) => {\n  return $el => {\n    const totalLength = +($path.getTotalLength());\n    const inSvg = $el[isSvgSymbol];\n    const ctm = $path.getCTM();\n    /** @type {TweenObjectValue} */\n    return {\n      from: 0,\n      to: totalLength,\n      /** @type {TweenModifier} */\n      modifier: progress => {\n        if (pathProperty === 'a') {\n          const p0 = getPathPoint($path, progress, -1);\n          const p1 = getPathPoint($path, progress, 1);\n          return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;\n        } else {\n          const p = getPathPoint($path, progress, 0);\n          return pathProperty === 'x' ?\n            inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e :\n            inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {TargetsParam} path\n */\nconst createMotionPath = path => {\n  const $path = getPath(path);\n  if (!$path) return;\n  return {\n    translateX: getPathProgess($path, 'x'),\n    translateY: getPathProgess($path, 'y'),\n    rotate: getPathProgess($path, 'a'),\n  }\n};\n\n// Check for valid SVG attribute\n\nconst cssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];\n\n/**\n * @param  {Target} el\n * @param  {String} propertyName\n * @return {Boolean}\n */\nconst isValidSVGAttribute = (el, propertyName) => {\n  // Return early and use CSS opacity animation instead (already better default values (opacity: 1 instead of 0)) and rotate should be considered a transform\n  if (cssReservedProperties.includes(propertyName)) return false;\n  if (el.getAttribute(propertyName) || propertyName in el) {\n    if (propertyName === 'scale') { // Scale\n      const elParentNode = /** @type {SVGGeometryElement} */(/** @type {DOMTarget} */(el).parentNode);\n      // Only consider scale as a valid SVG attribute on filter element\n      return elParentNode && elParentNode.tagName === 'filter';\n    }\n    return true;\n  }\n};\n\nconst svg = {\n  morphTo,\n  createMotionPath,\n  createDrawable,\n};\n\n\n\n\n/**\n * RGB / RGBA Color value string -> RGBA values array\n * @param  {String} rgbValue\n * @return {ColorArray}\n */\nconst rgbToRgba = rgbValue => {\n  const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);\n  const a = !isUnd(rgba[4]) ? +rgba[4] : 1;\n  return [\n    +rgba[1],\n    +rgba[2],\n    +rgba[3],\n    a\n  ]\n};\n\n/**\n * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array\n * @param  {String} hexValue\n * @return {ColorArray}\n */\nconst hexToRgba = hexValue => {\n  const hexLength = hexValue.length;\n  const isShort = hexLength === 4 || hexLength === 5;\n  return [\n    +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),\n    +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),\n    +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),\n    ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)\n  ]\n};\n\n/**\n * @param  {Number} p\n * @param  {Number} q\n * @param  {Number} t\n * @return {Number}\n */\nconst hue2rgb = (p, q, t) => {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  return t < 1 / 6 ? p + (q - p) * 6 * t :\n         t < 1 / 2 ? q :\n         t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :\n         p;\n};\n\n/**\n * HSL / HSLA Color value string -> RGBA values array\n * @param  {String} hslValue\n * @return {ColorArray}\n */\nconst hslToRgba = hslValue => {\n  const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);\n  const h = +hsla[1] / 360;\n  const s = +hsla[2] / 100;\n  const l = +hsla[3] / 100;\n  const a = !isUnd(hsla[4]) ? +hsla[4] : 1;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = l;\n  } else {\n    const q = l < .5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);\n    g = round(hue2rgb(p, q, h) * 255, 0);\n    b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);\n  }\n  return [r, g, b, a];\n};\n\n/**\n * All in one color converter that converts a color string value into an array of RGBA values\n * @param  {String} colorString\n * @return {ColorArray}\n */\nconst convertColorStringValuesToRgbaArray = colorString => {\n  return isRgb(colorString) ? rgbToRgba(colorString) :\n         isHex(colorString) ? hexToRgba(colorString) :\n         isHsl(colorString) ? hslToRgba(colorString) :\n         [0, 0, 0, 1];\n};\n\n\n\n\n/**\n * @template T, D\n * @param {T|undefined} targetValue\n * @param {D} defaultValue\n * @return {T|D}\n */\nconst setValue = (targetValue, defaultValue) => {\n  return isUnd(targetValue) ? defaultValue : targetValue;\n};\n\n/**\n * @param  {TweenPropValue} value\n * @param  {Target} target\n * @param  {Number} index\n * @param  {Number} total\n * @param  {Object} [store]\n * @return {any}\n */\nconst getFunctionValue = (value, target, index, total, store) => {\n  if (isFnc(value)) {\n    const func = () => {\n      const computed = /** @type {Function} */(value)(target, index, total);\n      // Fallback to 0 if the function returns undefined / NaN / null / false / 0\n      return !isNaN(+computed) ? +computed : computed || 0;\n    };\n    if (store) {\n      store.func = func;\n    }\n    return func();\n  } else {\n    return value;\n  }\n};\n\n/**\n * @param  {Target} target\n * @param  {String} prop\n * @return {tweenTypes}\n */\nconst getTweenType = (target, prop) => {\n  return !target[isDomSymbol] ? tweenTypes.OBJECT :\n    // Handle SVG attributes\n    target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE :\n    // Handle CSS Transform properties differently than CSS to allow individual animations\n    validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM :\n    // CSS variables\n    stringStartsWith(prop, '--') ? tweenTypes.CSS_VAR :\n    // All other CSS properties\n    prop in /** @type {DOMTarget} */(target).style ? tweenTypes.CSS :\n    // Handle other DOM Attributes\n    prop in target ? tweenTypes.OBJECT :\n    tweenTypes.ATTRIBUTE;\n};\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst getCSSValue = (target, propName, animationInlineStyles) => {\n  const inlineStyles = target.style[propName];\n  if (inlineStyles && animationInlineStyles) {\n    animationInlineStyles[propName] = inlineStyles;\n  }\n  const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);\n  return value === 'auto' ? '0' : value;\n};\n\n/**\n * @param {Target} target\n * @param {String} propName\n * @param {tweenTypes} [tweenType]\n * @param {Object|void} [animationInlineStyles]\n * @return {String|Number}\n */\nconst getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {\n  const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);\n  return type === tweenTypes.OBJECT ? target[propName] || 0 :\n         type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */(target).getAttribute(propName) :\n         type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */(target), propName, animationInlineStyles) :\n         type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles).trimStart() :\n         getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles);\n};\n\n/**\n * @param  {Number} x\n * @param  {Number} y\n * @param  {String} operator\n * @return {Number}\n */\nconst getRelativeValue = (x, y, operator) => {\n  return operator === '-' ? x - y :\n         operator === '+' ? x + y :\n         x * y;\n};\n\n/** @return {TweenDecomposedValue} */\nconst createDecomposedValueTargetObject = () => {\n  return {\n    /** @type {valueTypes} */\n    t: valueTypes.NUMBER,\n    n: 0,\n    u: null,\n    o: null,\n    d: null,\n    s: null,\n  }\n};\n\n/**\n * @param  {String|Number} rawValue\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeRawValue = (rawValue, targetObject) => {\n  /** @type {valueTypes} */\n  targetObject.t = valueTypes.NUMBER;\n  targetObject.n = 0;\n  targetObject.u = null;\n  targetObject.o = null;\n  targetObject.d = null;\n  targetObject.s = null;\n  if (!rawValue) return targetObject;\n  const num = +rawValue;\n  if (!isNaN(num)) {\n    // It's a number\n    targetObject.n = num;\n    return targetObject;\n  } else {\n    // let str = /** @type {String} */(rawValue).trim();\n    let str = /** @type {String} */(rawValue);\n    // Parsing operators (+=, -=, *=) manually is much faster than using regex here\n    if (str[1] === '=') {\n      targetObject.o = str[0];\n      str = str.slice(2);\n    }\n    // Skip exec regex if the value type is complex or color to avoid long regex backtracking\n    const unitMatch = str.includes(' ') ? false : unitsExecRgx.exec(str);\n    if (unitMatch) {\n      // Has a number and a unit\n      targetObject.t = valueTypes.UNIT;\n      targetObject.n = +unitMatch[1];\n      targetObject.u = unitMatch[2];\n      return targetObject;\n    } else if (targetObject.o) {\n      // Has an operator (+=, -=, *=)\n      targetObject.n = +str;\n      return targetObject;\n    } else if (isCol(str)) {\n      // Is a color\n      targetObject.t = valueTypes.COLOR;\n      targetObject.d = convertColorStringValuesToRgbaArray(str);\n      return targetObject;\n    } else {\n      // Is a more complex string (generally svg coords, calc() or filters CSS values)\n      const matchedNumbers = str.match(digitWithExponentRgx);\n      targetObject.t = valueTypes.COMPLEX;\n      targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];\n      targetObject.s = str.split(digitWithExponentRgx) || [];\n      return targetObject;\n    }\n  }\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeTweenValue = (tween, targetObject) => {\n  targetObject.t = tween._valueType;\n  targetObject.n = tween._toNumber;\n  targetObject.u = tween._unit;\n  targetObject.o = null;\n  targetObject.d = cloneArray(tween._toNumbers);\n  targetObject.s = cloneArray(tween._strings);\n  return targetObject;\n};\n\nconst decomposedOriginalValue = createDecomposedValueTargetObject();\n\n\n\n\nconst lookups = {\n  /** @type {TweenReplaceLookups} */\n  _rep: new WeakMap(),\n  /** @type {TweenAdditiveLookups} */\n  _add: new Map(),\n};\n\n/**\n * @param  {Target} target\n * @param  {String} property\n * @param  {String} lookup\n * @return {TweenPropertySiblings}\n */\nconst getTweenSiblings = (target, property, lookup = '_rep') => {\n  const lookupMap = lookups[lookup];\n  let targetLookup = lookupMap.get(target);\n  if (!targetLookup) {\n    targetLookup = {};\n    lookupMap.set(target, targetLookup);\n  }\n  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {\n    _head: null,\n    _tail: null,\n  }\n};\n\n/**\n * @param  {Tween} p\n * @param  {Tween} c\n * @return {Number|Boolean}\n */\nconst addTweenSortMethod = (p, c) => {\n  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;\n};\n\n/**\n * @param {Tween} tween\n */\nconst overrideTween = tween => {\n  tween._isOverlapped = 1;\n  tween._isOverridden = 1;\n  tween._changeDuration = minValue;\n  tween._currentTime = minValue;\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenPropertySiblings} siblings\n * @return {Tween}\n */\nconst composeTween = (tween, siblings) => {\n\n  const tweenCompositionType = tween._composition;\n\n  // Handle replaced tweens\n\n  if (tweenCompositionType === compositionTypes.replace) {\n\n    const tweenAbsStartTime = tween._absoluteStartTime;\n\n    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');\n\n    const prevSibling = tween._prevRep;\n\n    // Update the previous siblings for composition replace tweens\n\n    if (prevSibling) {\n\n      const prevParent = prevSibling.parent;\n      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;\n\n      // Handle looped animations tween\n\n      if (\n        // Check if the previous tween is from a different animation\n        tween.parent.id !== prevParent.id &&\n        // Check if the animation has loops\n        prevParent.iterationCount> 1 &&\n        // Check if _absoluteChangeEndTime of last loop overlaps the current tween\n        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime\n      ) {\n\n        // TODO: Find a way to only override the iterations overlapping with the tween\n        overrideTween(prevSibling);\n\n        let prevPrevSibling = prevSibling._prevRep;\n\n        // If the tween was part of a set of keyframes, override its siblings\n        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {\n          overrideTween(prevPrevSibling);\n          prevPrevSibling = prevPrevSibling._prevRep;\n        }\n\n      }\n\n      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;\n\n      if (prevAbsEndTime > absoluteUpdateStartTime) {\n\n        const prevChangeStartTime = prevSibling._startTime;\n        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);\n        // Rounding is necessary here to minimize floating point errors when working in seconds\n        const updatedPrevChangeDuration = round(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);\n\n        prevSibling._changeDuration = updatedPrevChangeDuration;\n        prevSibling._currentTime = updatedPrevChangeDuration;\n        prevSibling._isOverlapped = 1;\n\n        // Override the previous tween if its new _changeDuration is lower than minValue\n        // TODO: See if it's even neceseeary to test against minValue, checking for 0 might be enough\n        if (updatedPrevChangeDuration < minValue) {\n          overrideTween(prevSibling);\n        }\n      }\n\n      // Pause (and cancel) the parent if it only contains overlapped tweens\n\n      let pausePrevParentAnimation = true;\n\n      forEachChildren(prevParent, (/** @type Tween */t) => {\n        if (!t._isOverlapped) pausePrevParentAnimation = false;\n      });\n\n      if (pausePrevParentAnimation) {\n        const prevParentTL = prevParent.parent;\n        if (prevParentTL) {\n          let pausePrevParentTL = true;\n          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {\n            if (a !== prevParent) {\n              forEachChildren(a, (/** @type Tween */t) => {\n                if (!t._isOverlapped) pausePrevParentTL = false;\n              });\n            }\n          });\n          if (pausePrevParentTL) {\n            prevParentTL.cancel();\n          }\n        } else {\n          prevParent.cancel();\n          // Previously, calling .cancel() on a timeline child would affect the render order of other children\n          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop\n          // This is no longer needed since timeline tween composition is now handled separately\n          // Keeping this here for reference\n          // prevParent.completed = true;\n          // prevParent.pause();\n        }\n      }\n\n    }\n\n    // let nextSibling = tween._nextRep;\n\n    // // All the next siblings are automatically overridden\n\n    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     console.log(tween.id, nextSibling.id);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n  // Handle additive tweens composition\n\n  } else if (tweenCompositionType === compositionTypes.blend) {\n\n    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');\n    const additiveAnimation = addAdditiveAnimation(lookups._add);\n\n    let lookupTween = additiveTweenSiblings._head;\n\n    if (!lookupTween) {\n      lookupTween = { ...tween };\n      lookupTween._composition = compositionTypes.replace;\n      lookupTween._updateDuration = minValue;\n      lookupTween._startTime = 0;\n      lookupTween._numbers = cloneArray(tween._fromNumbers);\n      lookupTween._number = 0;\n      lookupTween._next = null;\n      lookupTween._prev = null;\n      addChild(additiveTweenSiblings, lookupTween);\n      addChild(additiveAnimation, lookupTween);\n    }\n\n    // Convert the values of TO to FROM and set TO to 0\n\n    const toNumber = tween._toNumber;\n    tween._fromNumber = lookupTween._fromNumber - toNumber;\n    tween._toNumber = 0;\n    tween._numbers = cloneArray(tween._fromNumbers);\n    tween._number = 0;\n    lookupTween._fromNumber = toNumber;\n\n    if (tween._toNumbers) {\n      const toNumbers = cloneArray(tween._toNumbers);\n      if (toNumbers) {\n        toNumbers.forEach((value, i) => {\n          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;\n          tween._toNumbers[i] = 0;\n        });\n      }\n      lookupTween._fromNumbers = toNumbers;\n    }\n\n    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');\n\n  }\n\n  return tween;\n\n};\n\n/**\n * @param  {Tween} tween\n * @return {Tween}\n */\nconst removeTweenSliblings = tween => {\n  const tweenComposition = tween._composition;\n  if (tweenComposition !== compositionTypes.none) {\n    const tweenTarget = tween.target;\n    const tweenProperty = tween.property;\n    const replaceTweensLookup = lookups._rep;\n    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);\n    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];\n    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');\n    if (tweenComposition === compositionTypes.blend) {\n      const addTweensLookup = lookups._add;\n      const addTargetProps = addTweensLookup.get(tweenTarget);\n      if (!addTargetProps) return;\n      const additiveTweenSiblings = addTargetProps[tweenProperty];\n      const additiveAnimation = additive.animation;\n      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');\n      // If only one tween is left in the additive lookup, it's the tween lookup\n      const lookupTween = additiveTweenSiblings._head;\n      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {\n        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');\n        removeChild(additiveAnimation, lookupTween);\n        let shouldClean = true;\n        for (let prop in addTargetProps) {\n          if (addTargetProps[prop]._head) {\n            shouldClean = false;\n            break;\n          }\n        }\n        if (shouldClean) {\n          addTweensLookup.delete(tweenTarget);\n        }\n      }\n    }\n  }\n  return tween;\n};\n\n\n\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst resetTimerProperties = timer => {\n  timer.paused = true;\n  timer.began = false;\n  timer.completed = false;\n  return timer;\n};\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst reviveTimer = timer => {\n  if (!timer._cancelled) return timer;\n  if (timer._hasChildren) {\n    forEachChildren(timer, reviveTimer);\n  } else {\n    forEachChildren(timer, (/** @type {Tween} tween*/tween) => {\n      if (tween._composition !== compositionTypes.none) {\n        composeTween(tween, getTweenSiblings(tween.target, tween.property));\n      }\n    });\n  }\n  timer._cancelled = 0;\n  return timer;\n};\n\nlet timerId = 0;\n\n/**\n * Base class used to create Timers, Animations and Timelines\n */\nclass Timer extends Clock {\n  /**\n   * @param {TimerParams} [parameters]\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   */\n  constructor(parameters = {}, parent = null, parentPosition = 0) {\n\n    super(0);\n\n    const {\n      id,\n      delay,\n      duration,\n      reversed,\n      alternate,\n      loop,\n      loopDelay,\n      autoplay,\n      frameRate,\n      playbackRate,\n      onComplete,\n      onLoop,\n      onPause,\n      onBegin,\n      onBeforeUpdate,\n      onUpdate,\n    } = parameters;\n\n    if (scope.current) scope.current.register(this);\n\n    const timerInitTime = parent ? 0 : engine._elapsedTime;\n    const timerDefaults = parent ? parent.defaults : globals.defaults;\n    const timerDelay = /** @type {Number} */(isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay);\n    const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;\n    const timerLoop = setValue(loop, timerDefaults.loop);\n    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);\n    const timerIterationCount = timerLoop === true ||\n                                timerLoop === Infinity ||\n                                /** @type {Number} */(timerLoop) < 0 ? Infinity :\n                                /** @type {Number} */(timerLoop) + 1;\n\n\n    let offsetPosition = 0;\n\n    if (parent) {\n      offsetPosition = parentPosition;\n    } else {\n      // Make sure to tick the engine once if not currently running to get up to date engine._elapsedTime\n      // to avoid big gaps with the following offsetPosition calculation\n      if (!engine.reqId) engine.requestTick(now());\n      // Make sure to scale the offset position with globals.timeScale to properly handle seconds unit\n      offsetPosition = (engine._elapsedTime - engine._startTime) * globals.timeScale;\n    }\n\n    // Timer's parameters\n    this.id = !isUnd(id) ? id : ++timerId;\n    /** @type {Timeline} */\n    this.parent = parent;\n    // Total duration of the timer\n    this.duration = clampInfinity(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || minValue;\n    /** @type {Boolean} */\n    this.backwards = false;\n    /** @type {Boolean} */\n    this.paused = true;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Callback<this>} */\n    this.onBegin = onBegin || timerDefaults.onBegin;\n    /** @type {Callback<this>} */\n    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;\n    /** @type {Callback<this>} */\n    this.onUpdate = onUpdate || timerDefaults.onUpdate;\n    /** @type {Callback<this>} */\n    this.onLoop = onLoop || timerDefaults.onLoop;\n    /** @type {Callback<this>} */\n    this.onPause = onPause || timerDefaults.onPause;\n    /** @type {Callback<this>} */\n    this.onComplete = onComplete || timerDefaults.onComplete;\n    /** @type {Number} */\n    this.iterationDuration = timerDuration; // Duration of one loop\n    /** @type {Number} */\n    this.iterationCount = timerIterationCount; // Number of loops\n    /** @type {Boolean|ScrollObserver} */\n    this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);\n    /** @type {Number} */\n    this._offset = offsetPosition;\n    /** @type {Number} */\n    this._delay = timerDelay;\n    /** @type {Number} */\n    this._loopDelay = timerLoopDelay;\n    /** @type {Number} */\n    this._iterationTime = 0;\n    /** @type {Number} */\n    this._currentIteration = 0; // Current loop index\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Boolean} */\n    this._running = false;\n    /** @type {Number} */\n    this._reversed = +setValue(reversed, timerDefaults.reversed);\n    /** @type {Number} */\n    this._reverse = this._reversed;\n    /** @type {Number} */\n    this._cancelled = 0;\n    /** @type {Boolean} */\n    this._alternate = setValue(alternate, timerDefaults.alternate);\n    /** @type {Renderable} */\n    this._prev = null;\n    /** @type {Renderable} */\n    this._next = null;\n\n    // Clock's parameters\n    /** @type {Number} */\n    this._elapsedTime = timerInitTime;\n    /** @type {Number} */\n    this._startTime = timerInitTime;\n    /** @type {Number} */\n    this._lastTime = timerInitTime;\n    /** @type {Number} */\n    this._fps = setValue(frameRate, timerDefaults.frameRate);\n    /** @type {Number} */\n    this._speed = setValue(playbackRate, timerDefaults.playbackRate);\n  }\n\n  get cancelled() {\n    return !!this._cancelled;\n  }\n\n  /** @param {Boolean} cancelled  */\n  set cancelled(cancelled) {\n    cancelled ? this.cancel() : this.reset(1).play();\n  }\n\n  get currentTime() {\n    return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);\n  }\n\n  /** @param {Number} time  */\n  set currentTime(time) {\n    const paused = this.paused;\n    // Pausing the timer is necessary to avoid time jumps on a running instance\n    this.pause().seek(+time);\n    if (!paused) this.resume();\n  }\n\n  get iterationCurrentTime() {\n    return round(this._iterationTime, globals.precision);\n  }\n\n  /** @param {Number} time  */\n  set iterationCurrentTime(time) {\n    this.currentTime = (this.iterationDuration * this._currentIteration) + time;\n  }\n\n  get progress() {\n    return clamp(round(this._currentTime / this.duration, 10), 0, 1);\n  }\n\n  /** @param {Number} progress  */\n  set progress(progress) {\n    this.currentTime = this.duration * progress;\n  }\n\n  get iterationProgress() {\n    return clamp(round(this._iterationTime / this.iterationDuration, 10), 0, 1);\n  }\n\n  /** @param {Number} progress  */\n  set iterationProgress(progress) {\n    const iterationDuration = this.iterationDuration;\n    this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);\n  }\n\n  get currentIteration() {\n    return this._currentIteration;\n  }\n\n  /** @param {Number} iterationCount  */\n  set currentIteration(iterationCount) {\n    this.currentTime = (this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1));\n  }\n\n  get reversed() {\n    return !!this._reversed;\n  }\n\n  /** @param {Boolean} reverse  */\n  set reversed(reverse) {\n    reverse ? this.reverse() : this.play();\n  }\n\n  get speed() {\n    return super.speed;\n  }\n\n  /** @param {Number} playbackRate  */\n  set speed(playbackRate) {\n    super.speed = playbackRate;\n    this.resetTime();\n  }\n\n  /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */\n  reset(internalRender = 0) {\n    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings\n    reviveTimer(this);\n    if (this._reversed && !this._reverse) this.reversed = false;\n    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden\n    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order\n    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?\n    this._iterationTime = this.iterationDuration;\n    // Set tickMode to tickModes.FORCE to force rendering\n    tick(this, 0, 1, internalRender, tickModes.FORCE);\n    // Reset timer properties after revive / render to make sure the props are not updated again\n    resetTimerProperties(this);\n    // Also reset children properties\n    if (this._hasChildren) {\n      forEachChildren(this, resetTimerProperties);\n    }\n    return this;\n  }\n\n  /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */\n  init(internalRender = 0) {\n    this.fps = this._fps;\n    this.speed = this._speed;\n    // Manually calling .init() on timelines should render all children intial state\n    // Forces all children to render once then render to 0 when reseted\n    if (!internalRender && this._hasChildren) {\n      tick(this, this.duration, 1, internalRender, tickModes.FORCE);\n    }\n    this.reset(internalRender);\n    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link\n    const autoplay = this._autoplay;\n    if (autoplay === true) {\n      this.resume();\n    } else if (autoplay && !isUnd(/** @type {ScrollObserver} */(autoplay).linked)) {\n      /** @type {ScrollObserver} */(autoplay).link(this);\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  resetTime() {\n    const timeScale = 1 / (this._speed * engine._speed);\n    // TODO: See if we can safely use engine._elapsedTime here\n    // if (!engine.reqId) engine.requestTick(now())\n    // this._startTime = engine._elapsedTime - (this._currentTime + this._delay) * timeScale;\n    this._startTime = now() - (this._currentTime + this._delay) * timeScale;\n    return this;\n  }\n\n  /** @return {this} */\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    this.onPause(this);\n    return this;\n  }\n\n  /** @return {this} */\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // We can safely imediatly render a timer that has no duration and no children\n    if (this.duration <= minValue && !this._hasChildren) {\n      tick(this, minValue, 0, 0, tickModes.FORCE);\n    } else {\n      if (!this._running) {\n        addChild(engine, this);\n        engine._hasChildren = true;\n        this._running = true;\n      }\n      this.resetTime();\n      // Forces the timer to advance by at least one frame when the next tick occurs\n      this._startTime -= 12;\n      engine.wake();\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  restart() {\n    return this.reset(0).resume();\n  }\n\n  /**\n   * @param  {Number} time\n   * @param  {Boolean|Number} [muteCallbacks]\n   * @param  {Boolean|Number} [internalRender]\n   * @return {this}\n   */\n  seek(time, muteCallbacks = 0, internalRender = 0) {\n    // Recompose the tween siblings in case the timer has been cancelled\n    reviveTimer(this);\n    // If you seek a completed animation, otherwise the next play will starts at 0\n    this.completed = false;\n    const isPaused = this.paused;\n    this.paused = true;\n    // timer, time, muteCallbacks, internalRender, tickMode\n    tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);\n    return isPaused ? this : this.resume();\n  }\n\n  /** @return {this} */\n  alternate() {\n    const reversed = this._reversed;\n    const count = this.iterationCount;\n    const duration = this.iterationDuration;\n    // Calculate the maximum iterations possible given the iteration duration\n    const iterations = count === Infinity ? floor(maxValue / duration) : count;\n    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);\n    if (count === Infinity) {\n      // Handle infinite loops to loop on themself\n      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;\n    } else {\n      this.seek((duration * iterations) - this._currentTime);\n    }\n    this.resetTime();\n    return this;\n  }\n\n  /** @return {this} */\n  play() {\n    if (this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  /** @return {this} */\n  reverse() {\n    if (!this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  // TODO: Move all the animation / tweens / children related code to Animation / Timeline\n\n  /** @return {this} */\n  cancel() {\n    if (this._hasChildren) {\n      forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);\n    } else {\n      forEachChildren(this, removeTweenSliblings);\n    }\n    this._cancelled = 1;\n    // Pausing the timer removes it from the engine\n    return this.pause();\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    const normlizedDuration = normalizeTime(newDuration);\n    if (currentDuration === normlizedDuration) return this;\n    const timeScale = newDuration / currentDuration;\n    const isSetter = newDuration <= minValue;\n    this.duration = isSetter ? minValue : normlizedDuration;\n    this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);\n    this._offset *= timeScale;\n    this._delay *= timeScale;\n    this._loopDelay *= timeScale;\n    return this;\n  }\n\n /**\n   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary\n   * @return {this}\n   */\n  revert() {\n    tick(this, 0, 1, 0, tickModes.AUTO);\n    const ap = /** @type {ScrollObserver} */(this._autoplay);\n    if (ap && ap.linked && ap.linked === this) ap.revert();\n    return this.cancel();\n  }\n\n /**\n   * Imediatly completes the timer, cancels it and triggers the onComplete callback\n   * @return {this}\n   */\n  complete() {\n    return this.seek(this.duration).cancel();\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      // this.then = null prevents infinite recursion if returned by an async function\n      // https://github.com/juliangarnierorg/anime-beta/issues/26\n      this.then = null;\n      callback(this);\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      // Make sure to resolve imediatly if the timer has already completed\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n\n}\n\n/**\n * @param {TimerParams} [parameters]\n * @return {Timer}\n */\nconst createTimer = parameters => new Timer(parameters, null, 0).init();\n\n\n\n\n/** @type {EasingFunction} */\nconst none = t => t;\n\n// Cubic Bezier solver adapted from https://github.com/gre/bezier-ease  Gatan Renaudeau\n\n/**\n * @param  {Number} aT\n * @param  {Number} aA1\n * @param  {Number} aA2\n * @return {Number}\n */\nconst calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + (3 * aA1)) * aT;\n\n/**\n * @param  {Number} aX\n * @param  {Number} mX1\n * @param  {Number} mX2\n * @return {Number}\n */\nconst binarySubdivide = (aX, mX1, mX2) => {\n  let aA = 0, aB = 1, currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (abs(currentX) > .0000001 && ++i < 100);\n  return currentT;\n};\n\n/**\n * @param  {Number} [mX1] The x coordinate of the first point\n * @param  {Number} [mY1] The y coordinate of the first point\n * @param  {Number} [mX2] The x coordinate of the second point\n * @param  {Number} [mY2] The y coordinate of the second point\n * @return {EasingFunction}\n */\n\nconst cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0) => (mX1 === mY1 && mX2 === mY2) ? none :\n  t => t === 0 || t === 1 ? t :\n  calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);\n\n/**\n * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\n * Only covers 'end' and 'start' jumpterms\n * @param  {Number} steps\n * @param  {Boolean} [fromStart]\n * @return {EasingFunction}\n */\nconst steps = (steps = 10, fromStart) => {\n  const roundMethod = fromStart ? ceil : floor;\n  return t => roundMethod(clamp(t, 0, 1) * steps) * (1 / steps);\n};\n\n/**\n * Without parameters, the linear function creates a non-eased transition.\n * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.\n * @param  {...(String|Number)} args - Points\n * @return {EasingFunction}\n */\nconst linear = (...args) => {\n  const argsLength = args.length;\n  if (!argsLength) return none;\n  const totalPoints = argsLength - 1;\n  const firstArg = args[0];\n  const lastArg = args[totalPoints];\n  const xPoints = [0];\n  const yPoints = [parseNumber(firstArg)];\n  for (let i = 1; i < totalPoints; i++) {\n    const arg = args[i];\n    const splitValue = isStr(arg) ?\n    /** @type {String} */(arg).trim().split(' ') :\n    [arg];\n    const value = splitValue[0];\n    const percent = splitValue[1];\n    xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);\n    yPoints.push(parseNumber(value));\n  }\n  yPoints.push(parseNumber(lastArg));\n  xPoints.push(1);\n  return function easeLinear(t) {\n    for (let i = 1, l = xPoints.length; i < l; i++) {\n      const currentX = xPoints[i];\n      if (t <= currentX) {\n        const prevX = xPoints[i - 1];\n        const prevY = yPoints[i - 1];\n        return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);\n      }\n    }\n    return yPoints[yPoints.length - 1];\n  }\n};\n\n/**\n * Generate random steps\n * @param  {Number} [length] - The number of steps\n * @param  {Number} [randomness] - How strong the randomness is\n * @return {EasingFunction}\n */\nconst irregular = (length = 10, randomness = 1) => {\n  const values = [0];\n  const total = length - 1;\n  for (let i = 1; i < total; i++) {\n    const previousValue = values[i - 1];\n    const spacing = i / total;\n    const segmentEnd = (i + 1) / total;\n    const randomVariation = spacing + (segmentEnd - spacing) * Math.random();\n    // Mix the even spacing and random variation based on the randomness parameter\n    const randomValue = spacing * (1 - randomness) + randomVariation * randomness;\n    values.push(clamp(randomValue, previousValue, 1));\n  }\n  values.push(1);\n  return linear(...values);\n};\n\n// Easing functions adapted from http://www.robertpenner.com/ease  Robert Penner\n\n/**\n * @callback PowerEasing\n * @param {Number|String} [power=1.675]\n * @return {EasingFunction}\n */\n\n/**\n * @callback BackEasing\n * @param {Number|String} [overshoot=1.70158]\n * @return {EasingFunction}\n */\n\n/**\n * @callback ElasticEasing\n * @param {Number|String} [amplitude=1]\n * @param {Number|String} [period=.3]\n * @return {EasingFunction}\n */\n\n/**\n * @callback EaseFactory\n * @param {Number|String} [paramA]\n * @param {Number|String} [paramB]\n * @return {EasingFunction|Number}\n */\n\n/** @typedef {PowerEasing|BackEasing|ElasticEasing} EasesFactory */\n\nconst halfPI = PI / 2;\nconst doublePI = PI * 2;\n/** @type {PowerEasing} */\nconst easeInPower = (p = 1.68) => t => pow(t, +p);\n\n/** @type {Record<String, EasesFactory|EasingFunction>} */\nconst easeInFunctions = {\n  [emptyString]: easeInPower,\n  Quad: easeInPower(2),\n  Cubic: easeInPower(3),\n  Quart: easeInPower(4),\n  Quint: easeInPower(5),\n  /** @type {EasingFunction} */\n  Sine: t => 1 - cos(t * halfPI),\n  /** @type {EasingFunction} */\n  Circ: t => 1 - sqrt(1 - t * t),\n  /** @type {EasingFunction} */\n  Expo: t => t ? pow(2, 10 * t - 10) : 0,\n  /** @type {EasingFunction} */\n  Bounce: t => {\n    let pow2, b = 4;\n    while (t < ((pow2 = pow(2, --b)) - 1) / 11);\n    return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);\n  },\n  /** @type {BackEasing} */\n  Back: (overshoot = 1.70158) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,\n  /** @type {ElasticEasing} */\n  Elastic: (amplitude = 1, period = .3) => {\n    const a = clamp(+amplitude, 1, 10);\n    const p = clamp(+period, minValue, 2);\n    const s = (p / doublePI) * asin(1 / a);\n    const e = doublePI / p;\n    return t => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin(((1 - t) - s) * e);\n  }\n};\n\n/**\n * @callback EaseType\n * @param {EasingFunction} Ease\n * @return {EasingFunction}\n */\n\n/** @type {Record<String, EaseType>} */\nconst easeTypes = {\n  in: easeIn => t => easeIn(t),\n  out: easeIn => t => 1 - easeIn(1 - t),\n  inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,\n  outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2,\n};\n\n/**\n * @param  {String} string\n * @param  {Record<String, EasesFactory|EasingFunction>} easesFunctions\n * @param  {Object} easesLookups\n * @return {EasingFunction}\n */\nconst parseEaseString = (string, easesFunctions, easesLookups) => {\n  if (easesLookups[string]) return easesLookups[string];\n  if (string.indexOf('(') <= -1) {\n    const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');\n    const parsedFn = /** @type {EasingFunction} */(hasParams ? /** @type {EasesFactory} */(easesFunctions[string])() : easesFunctions[string]);\n    return parsedFn ? easesLookups[string] = parsedFn : none;\n  } else {\n    const split = string.slice(0, -1).split('(');\n    const parsedFn = /** @type {EasesFactory} */(easesFunctions[split[0]]);\n    return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : none;\n  }\n};\n\n/**\n * @typedef  {Object} EasesFunctions\n * @property {typeof linear} linear\n * @property {typeof irregular} irregular\n * @property {typeof steps} steps\n * @property {typeof cubicBezier} cubicBezier\n * @property {PowerEasing} in\n * @property {PowerEasing} out\n * @property {PowerEasing} inOut\n * @property {PowerEasing} outIn\n * @property {EasingFunction} inQuad\n * @property {EasingFunction} outQuad\n * @property {EasingFunction} inOutQuad\n * @property {EasingFunction} outInQuad\n * @property {EasingFunction} inCubic\n * @property {EasingFunction} outCubic\n * @property {EasingFunction} inOutCubic\n * @property {EasingFunction} outInCubic\n * @property {EasingFunction} inQuart\n * @property {EasingFunction} outQuart\n * @property {EasingFunction} inOutQuart\n * @property {EasingFunction} outInQuart\n * @property {EasingFunction} inQuint\n * @property {EasingFunction} outQuint\n * @property {EasingFunction} inOutQuint\n * @property {EasingFunction} outInQuint\n * @property {EasingFunction} inSine\n * @property {EasingFunction} outSine\n * @property {EasingFunction} inOutSine\n * @property {EasingFunction} outInSine\n * @property {EasingFunction} inCirc\n * @property {EasingFunction} outCirc\n * @property {EasingFunction} inOutCirc\n * @property {EasingFunction} outInCirc\n * @property {EasingFunction} inExpo\n * @property {EasingFunction} outExpo\n * @property {EasingFunction} inOutExpo\n * @property {EasingFunction} outInExpo\n * @property {EasingFunction} inBounce\n * @property {EasingFunction} outBounce\n * @property {EasingFunction} inOutBounce\n * @property {EasingFunction} outInBounce\n * @property {BackEasing} inBack\n * @property {BackEasing} outBack\n * @property {BackEasing} inOutBack\n * @property {BackEasing} outInBack\n * @property {ElasticEasing} inElastic\n * @property {ElasticEasing} outElastic\n * @property {ElasticEasing} inOutElastic\n * @property {ElasticEasing} outInElastic\n */\n\nconst eases = (/*#__PURE__*/ (() => {\n  const list = { linear, irregular, steps, cubicBezier };\n  for (let type in easeTypes) {\n    for (let name in easeInFunctions) {\n      const easeIn = easeInFunctions[name];\n      const easeType = easeTypes[type];\n      list[type + name] = /** @type {EasesFactory|EasingFunction} */(\n        name === emptyString || name === 'Back' || name === 'Elastic' ?\n        (a, b) => easeType(/** @type {EasesFactory} */(easeIn)(a, b)) :\n        easeType(/** @type {EasingFunction} */(easeIn))\n      );\n    }\n  }\n  return /** @type {EasesFunctions} */(list);\n})());\n\n/** @type {Record<String, EasingFunction>} */\nconst JSEasesLookups = { linear: none };\n\n/**\n * @param  {EasingParam} ease\n * @return {EasingFunction}\n */\nconst parseEasings = ease => isFnc(ease) ? ease :\n  isStr(ease) ? parseEaseString(/** @type {String} */(ease), eases, JSEasesLookups) :\n  none;\n\n\n\n\nconst propertyNamesCache = {};\n\n/**\n * @param  {String} propertyName\n * @param  {Target} target\n * @param  {tweenTypes} tweenType\n * @return {String}\n */\nconst sanitizePropertyName = (propertyName, target, tweenType) => {\n  if (tweenType === tweenTypes.TRANSFORM) {\n    const t = shortTransforms.get(propertyName);\n    return t ? t : propertyName;\n  } else if (\n    tweenType === tweenTypes.CSS ||\n    // Handle special cases where properties like \"strokeDashoffset\" needs to be set as \"stroke-dashoffset\"\n    // but properties like \"baseFrequency\" should stay in lowerCamelCase\n    (tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */(target).style))\n  ) {\n    const cachedPropertyName = propertyNamesCache[propertyName];\n    if (cachedPropertyName) {\n      return cachedPropertyName;\n    } else {\n      const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;\n      propertyNamesCache[propertyName] = lowerCaseName;\n      return lowerCaseName;\n    }\n  } else {\n    return propertyName;\n  }\n};\n\n\n\n\nconst angleUnitsMap = { 'deg': 1, 'rad': 180 / PI, 'turn': 360 };\nconst convertedValuesCache = {};\n\n/**\n * @param  {DOMTarget} el\n * @param  {TweenDecomposedValue} decomposedValue\n * @param  {String} unit\n * @param  {Boolean} [force]\n * @return {TweenDecomposedValue}\n */\nconst convertValueUnit = (el, decomposedValue, unit, force = false) => {\n  const currentUnit = decomposedValue.u;\n  const currentNumber = decomposedValue.n;\n  if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) { // TODO: Check if checking against the same unit string is necessary\n    return decomposedValue;\n  }\n  const cachedKey = currentNumber + currentUnit + unit;\n  const cached = convertedValuesCache[cachedKey];\n  if (!isUnd(cached) && !force) {\n    decomposedValue.n = cached;\n  } else {\n    let convertedValue;\n    if (currentUnit in angleUnitsMap) {\n      convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];\n    } else {\n      const baseline = 100;\n      const tempEl = /** @type {DOMTarget} */(el.cloneNode());\n      const parentNode = el.parentNode;\n      const parentEl = (parentNode && (parentNode !== doc)) ? parentNode : doc.body;\n      parentEl.appendChild(tempEl);\n      const elStyle = tempEl.style;\n      elStyle.width = baseline + currentUnit;\n      const currentUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;\n      elStyle.width = baseline + unit;\n      const newUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;\n      const factor = currentUnitWidth / newUnitWidth;\n      parentEl.removeChild(tempEl);\n      convertedValue = factor * currentNumber;\n    }\n    decomposedValue.n = convertedValue;\n    convertedValuesCache[cachedKey] = convertedValue;\n  }\n  decomposedValue.t === valueTypes.UNIT;\n  decomposedValue.u = unit;\n  return decomposedValue;\n};\n\n\n\n\n/**\n * @template {Renderable} T\n * @param {T} renderable\n * @return {T}\n */\nconst cleanInlineStyles = renderable => {\n  // Allow cleanInlineStyles() to be called on timelines\n  if (renderable._hasChildren) {\n    forEachChildren(renderable, cleanInlineStyles, true);\n  } else {\n    const animation = /** @type {JSAnimation} */(renderable);\n    animation.pause();\n    forEachChildren(animation, (/** @type {Tween} */tween) => {\n      const tweenProperty = tween.property;\n      const tweenTarget = tween.target;\n      if (tweenTarget[isDomSymbol]) {\n        const targetStyle = /** @type {DOMTarget} */(tweenTarget).style;\n        const originalInlinedValue = animation._inlineStyles[tweenProperty];\n        if (tween._tweenType === tweenTypes.TRANSFORM) {\n          const cachedTransforms = tweenTarget[transformsSymbol];\n          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n            delete cachedTransforms[tweenProperty];\n          } else {\n            cachedTransforms[tweenProperty] = originalInlinedValue;\n          }\n          if (tween._renderTransforms) {\n            if (!Object.keys(cachedTransforms).length) {\n              targetStyle.removeProperty('transform');\n            } else {\n              let str = emptyString;\n              for (let key in cachedTransforms) {\n                str += transformsFragmentStrings[key] + cachedTransforms[key] + ') ';\n              }\n              targetStyle.transform = str;\n            }\n          }\n        } else {\n          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n            targetStyle.removeProperty(tweenProperty);\n          } else {\n            targetStyle[tweenProperty] = originalInlinedValue;\n          }\n        }\n        if (animation._tail === tween) {\n          animation.targets.forEach(t => {\n            if (t.getAttribute && t.getAttribute('style') === emptyString) {\n              t.removeAttribute('style');\n            }          });\n        }\n      }\n    });\n  }\n  return renderable;\n};\n\n// Defines decomposed values target objects only once and mutate their properties later to avoid GC\n// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object\nconst fromTargetObject = createDecomposedValueTargetObject();\nconst toTargetObject = createDecomposedValueTargetObject();\nconst toFunctionStore = { func: null };\nconst keyframesTargetArray = [null];\nconst fastSetValuesArray = [null, null];\n/** @type {TweenKeyValue} */\nconst keyObjectTarget = { to: null };\n\nlet tweenId = 0;\nlet keyframes;\n/** @type {TweenParamsOptions & TweenValues} */\nlet key;\n\n/**\n * @param {DurationKeyframes | PercentageKeyframes} keyframes\n * @param {AnimationParams} parameters\n * @return {AnimationParams}\n */\nconst generateKeyframes = (keyframes, parameters) => {\n  /** @type {AnimationParams} */\n  const properties = {};\n  if (isArr(keyframes)) {\n    const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);\n    for (let i = 0, l = propertyNames.length; i < l; i++) {\n      const propName = propertyNames[i];\n      const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {\n        /** @type {TweenKeyValue} */\n        const newKey = {};\n        for (let p in key) {\n          const keyValue = /** @type {TweenPropValue} */(key[p]);\n          if (isKey(p)) {\n            if (p === propName) {\n              newKey.to = keyValue;\n            }\n          } else {\n            newKey[p] = keyValue;\n          }\n        }\n        return newKey;\n      });\n      properties[propName] = /** @type {ArraySyntaxValue} */(propArray);\n    }\n\n  } else {\n    const totalDuration = /** @type {Number} */(setValue(parameters.duration, globals.defaults.duration));\n    const keys = Object.keys(keyframes)\n    .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })\n    .sort((a, b) => a.o - b.o);\n    keys.forEach(key => {\n      const offset = key.o;\n      const prop = key.p;\n      for (let name in prop) {\n        if (isKey(name)) {\n          let propArray = /** @type {Array} */(properties[name]);\n          if (!propArray) propArray = properties[name] = [];\n          const duration = offset * totalDuration;\n          let length = propArray.length;\n          let prevKey = propArray[length - 1];\n          const keyObj = { to: prop[name] };\n          let durProgress = 0;\n          for (let i = 0; i < length; i++) {\n            durProgress += propArray[i].duration;\n          }\n          if (length === 1) {\n            keyObj.from = prevKey.to;\n          }\n          if (prop.ease) {\n            keyObj.ease = prop.ease;\n          }\n          keyObj.duration = duration - (length ? durProgress : 0);\n          propArray.push(keyObj);\n        }\n      }\n      return key;\n    });\n\n    for (let name in properties) {\n      const propArray = /** @type {Array} */(properties[name]);\n      let prevEase;\n      // let durProgress = 0\n      for (let i = 0, l = propArray.length; i < l; i++) {\n        const prop = propArray[i];\n        // Emulate WAPPI easing parameter position\n        const currentEase = prop.ease;\n        prop.ease = prevEase ? prevEase : undefined;\n        prevEase = currentEase;\n        // durProgress += prop.duration;\n        // if (i === l - 1 && durProgress !== totalDuration) {\n        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })\n        // }\n      }\n      if (!propArray[0].duration) {\n        propArray.shift();\n      }\n    }\n\n  }\n\n  return properties;\n};\n\nclass JSAnimation extends Timer {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimationParams} parameters\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   * @param {Boolean} [fastSet=false]\n   * @param {Number} [index=0]\n   * @param {Number} [length=0]\n   */\n  constructor(\n    targets,\n    parameters,\n    parent,\n    parentPosition,\n    fastSet = false,\n    index = 0,\n    length = 0\n  ) {\n\n    super(/** @type {TimerParams&AnimationParams} */(parameters), parent, parentPosition);\n\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    // If the parameters object contains a \"keyframes\" property, convert all the keyframes values to regular properties\n\n    const kfParams = /** @type {AnimationParams} */(parameters).keyframes;\n    const params = /** @type {AnimationParams} */(kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);\n\n    const {\n      delay,\n      duration,\n      ease,\n      playbackEase,\n      modifier,\n      composition,\n      onRender,\n    } = params;\n\n    const animDefaults = parent ? parent.defaults : globals.defaults;\n    const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);\n    const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);\n    const tEasing = hasSpring ? /** @type {Spring} */(ease).ease : setValue(ease, animEase ? 'linear' : animDefaults.ease);\n    const tDuration = hasSpring ? /** @type {Spring} */(ease).duration : setValue(duration, animDefaults.duration);\n    const tDelay = setValue(delay, animDefaults.delay);\n    const tModifier = modifier || animDefaults.modifier;\n    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation\n    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;\n    // TODO: Do not create an empty object until we know the animation will generate inline styles\n    const animInlineStyles = {};\n    // const absoluteOffsetTime = this._offset;\n    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);\n\n    let iterationDuration = NaN;\n    let iterationDelay = NaN;\n    let animationAnimationLength = 0;\n    let shouldTriggerRender = 0;\n\n    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {\n\n      const target = parsedTargets[targetIndex];\n      const ti = index || targetIndex;\n      const tl = length || targetsLength;\n\n      let lastTransformGroupIndex = NaN;\n      let lastTransformGroupLength = NaN;\n\n      for (let p in params) {\n\n        if (isKey(p)) {\n\n          const tweenType = getTweenType(target, p);\n\n          const propName = sanitizePropertyName(p, target, tweenType);\n\n          let propValue = params[p];\n\n          const isPropValueArray = isArr(propValue);\n\n          if (fastSet && !isPropValueArray) {\n            fastSetValuesArray[0] = propValue;\n            fastSetValuesArray[1] = propValue;\n            propValue = fastSetValuesArray;\n          }\n\n          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })\n          // Normalize property values to valid keyframe syntax:\n          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]\n          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];\n          if (isPropValueArray) {\n            const arrayLength = /** @type {Array} */(propValue).length;\n            const isNotObjectValue = !isObj(propValue[0]);\n            // Convert [x, y] to [{to: [x, y]}]\n            if (arrayLength === 2 && isNotObjectValue) {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));\n              keyframesTargetArray[0] = keyObjectTarget;\n              keyframes = keyframesTargetArray;\n            // Convert [x, y, z] to [[x, y], z]\n            } else if (arrayLength > 2 && isNotObjectValue) {\n              keyframes = [];\n              /** @type {Array.<Number>} */(propValue).forEach((v, i) => {\n                if (!i) {\n                  fastSetValuesArray[0] = v;\n                } else if (i === 1) {\n                  fastSetValuesArray[1] = v;\n                  keyframes.push(fastSetValuesArray);\n                } else {\n                  keyframes.push(v);\n                }\n              });\n            } else {\n              keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);\n            }\n          } else {\n            keyframesTargetArray[0] = propValue;\n            keyframes = keyframesTargetArray;\n          }\n\n          let siblings = null;\n          let prevTween = null;\n          let firstTweenChangeStartTime = NaN;\n          let lastTweenChangeEndTime = 0;\n          let tweenIndex = 0;\n\n          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {\n\n            const keyframe = keyframes[tweenIndex];\n\n            if (isObj(keyframe)) {\n              key = keyframe;\n            } else {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);\n              key = keyObjectTarget;\n            }\n\n            toFunctionStore.func = null;\n\n            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);\n\n            let tweenToValue;\n            // Allows function based values to return an object syntax value ({to: v})\n            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {\n              key = computedToValue;\n              tweenToValue = computedToValue.to;\n            } else {\n              tweenToValue = computedToValue;\n            }\n            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);\n            const keyEasing = key.ease;\n            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);\n            // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time\n            const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing || tEasing;\n            // Calculate default individual keyframe duration by dividing the tl of keyframes\n            const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).duration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);\n            // Default delay value should only be applied to the first tween\n            const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);\n            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);\n            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];\n            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper\n            const tweenModifier = key.modifier || tModifier;\n            const hasFromvalue = !isUnd(tweenFromValue);\n            const hasToValue = !isUnd(tweenToValue);\n            const isFromToArray = isArr(tweenToValue);\n            const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);\n            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const absoluteStartTime = round(absoluteOffsetTime + tweenStartTime, 12);\n\n            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false\n            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;\n\n            let prevSibling = prevTween;\n\n            if (tweenComposition !== compositionTypes.none) {\n              if (!siblings) siblings = getTweenSiblings(target, propName);\n              let nextSibling = siblings._head;\n              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time\n              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {\n                prevSibling = nextSibling;\n                nextSibling = nextSibling._nextRep;\n                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time\n                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {\n                  while (nextSibling) {\n                    overrideTween(nextSibling);\n                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden\n                    nextSibling = nextSibling._nextRep;\n                  }\n                }\n              }\n            }\n\n            // Decompose values\n            if (isFromToValue) {\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);\n              if (fromTargetObject.t === valueTypes.NUMBER) {\n                if (prevSibling) {\n                  if (prevSibling._valueType === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = prevSibling._unit;\n                  }\n                } else {\n                  decomposeRawValue(\n                    getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),\n                    decomposedOriginalValue\n                  );\n                  if (decomposedOriginalValue.t === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = decomposedOriginalValue.u;\n                  }\n                }\n              }\n            } else {\n              if (hasToValue) {\n                decomposeRawValue(tweenToValue, toTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, toTargetObject);\n                } else {\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);\n                }\n              }\n              if (hasFromvalue) {\n                decomposeRawValue(tweenFromValue, fromTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, fromTargetObject);\n                } else {\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), fromTargetObject);\n                }\n              }\n            }\n\n            // Apply operators\n            if (fromTargetObject.o) {\n              fromTargetObject.n = getRelativeValue(\n                !prevSibling ? decomposeRawValue(\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),\n                  decomposedOriginalValue\n                ).n : prevSibling._toNumber,\n                fromTargetObject.n,\n                fromTargetObject.o\n              );\n            }\n\n            if (toTargetObject.o) {\n              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);\n            }\n\n            // Values omogenisation in cases of type difference between \"from\" and \"to\"\n            if (fromTargetObject.t !== toTargetObject.t) {\n              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {\n                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;\n                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;\n                notComplexValue.t = valueTypes.COMPLEX;\n                notComplexValue.s = cloneArray(complexValue.s);\n                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);\n              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {\n                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;\n                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;\n                notUnitValue.t = valueTypes.UNIT;\n                notUnitValue.u = unitValue.u;\n              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {\n                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;\n                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;\n                notColorValue.t = valueTypes.COLOR;\n                notColorValue.s = colorValue.s;\n                notColorValue.d = [0, 0, 0, 1];\n              }\n            }\n\n            // Unit conversion\n            if (fromTargetObject.u !== toTargetObject.u) {\n              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;\n              valueToConvert = convertValueUnit(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);\n              // TODO:\n              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);\n            }\n\n            // Fill in non existing complex values\n            if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {\n              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;\n              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;\n              // TODO: Check if n should be used instead of 0 for default complex values\n              shortestValue.d = longestValue.d.map((_, i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);\n              shortestValue.s = cloneArray(longestValue.s);\n            }\n\n            // Tween factory\n\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const tweenUpdateDuration = round(+tweenDuration || minValue, 12);\n\n            /** @type {Tween} */\n            const tween = {\n              parent: this,\n              id: tweenId++,\n              property: propName,\n              target: target,\n              _value: null,\n              _func: toFunctionStore.func,\n              _ease: parseEasings(tweenEasing),\n              _fromNumbers: cloneArray(fromTargetObject.d),\n              _toNumbers: cloneArray(toTargetObject.d),\n              _strings: cloneArray(toTargetObject.s),\n              _fromNumber: fromTargetObject.n,\n              _toNumber: toTargetObject.n,\n              _numbers: cloneArray(fromTargetObject.d), // For additive tween and animatables\n              _number: fromTargetObject.n, // For additive tween and animatables\n              _unit: toTargetObject.u,\n              _modifier: tweenModifier,\n              _currentTime: 0,\n              _startTime: tweenStartTime,\n              _delay: +tweenDelay,\n              _updateDuration: tweenUpdateDuration,\n              _changeDuration: tweenUpdateDuration,\n              _absoluteStartTime: absoluteStartTime,\n              // NOTE: Investigate bit packing to stores ENUM / BOOL\n              _tweenType: tweenType,\n              _valueType: toTargetObject.t,\n              _composition: tweenComposition,\n              _isOverlapped: 0,\n              _isOverridden: 0,\n              _renderTransforms: 0,\n              _prevRep: null, // For replaced tween\n              _nextRep: null, // For replaced tween\n              _prevAdd: null, // For additive tween\n              _nextAdd: null, // For additive tween\n              _prev: null,\n              _next: null,\n            };\n\n            if (tweenComposition !== compositionTypes.none) {\n              composeTween(tween, siblings);\n            }\n\n            if (isNaN(firstTweenChangeStartTime)) {\n              firstTweenChangeStartTime = tween._startTime;\n            }\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);\n            prevTween = tween;\n            animationAnimationLength++;\n\n            addChild(this, tween);\n\n          }\n\n          // Update animation timings with the added tweens properties\n\n          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {\n            iterationDelay = firstTweenChangeStartTime;\n          }\n\n          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {\n            iterationDuration = lastTweenChangeEndTime;\n          }\n\n          // TODO: Find a way to inline tween._renderTransforms = 1 here\n          if (tweenType === tweenTypes.TRANSFORM) {\n            lastTransformGroupIndex = animationAnimationLength - tweenIndex;\n            lastTransformGroupLength = animationAnimationLength;\n          }\n\n        }\n\n      }\n\n      // Set _renderTransforms to last transform property to correctly render the transforms list\n      if (!isNaN(lastTransformGroupIndex)) {\n        let i = 0;\n        forEachChildren(this, (/** @type {Tween} */tween) => {\n          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {\n            tween._renderTransforms = 1;\n            if (tween._composition === compositionTypes.blend) {\n              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {\n                if (additiveTween.id === tween.id) {\n                  additiveTween._renderTransforms = 1;\n                }\n              });\n            }\n          }\n          i++;\n        });\n      }\n\n    }\n\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n\n    if (iterationDelay) {\n      forEachChildren(this, (/** @type {Tween} */tween) => {\n        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too\n        if (!(tween._startTime - tween._delay)) {\n          tween._delay -= iterationDelay;\n        }\n        tween._startTime -= iterationDelay;\n      });\n      iterationDuration -= iterationDelay;\n    } else {\n      iterationDelay = 0;\n    }\n\n    // Prevents iterationDuration to be NaN if no valid animatable props have been provided\n    // Prevents _iterationCount to be NaN if no valid animatable props have been provided\n    if (!iterationDuration) {\n      iterationDuration = minValue;\n      this.iterationCount = 0;\n    }\n    /** @type {TargetsArray} */\n    this.targets = parsedTargets;\n    /** @type {Number} */\n    this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;\n    /** @type {Callback<this>} */\n    this.onRender = onRender || animDefaults.onRender;\n    /** @type {EasingFunction} */\n    this._ease = animEase;\n    /** @type {Number} */\n    this._delay = iterationDelay;\n    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.\n    // this._delay = parent ? 0 : iterationDelay;\n    // this._offset += parent ? iterationDelay : 0;\n    /** @type {Number} */\n    this.iterationDuration = iterationDuration;\n    /** @type {{}} */\n    this._inlineStyles = animInlineStyles;\n\n    if (!this._autoplay && shouldTriggerRender) this.onRender(this);\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      // Rounding is necessary here to minimize floating point errors\n      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);\n      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);\n      tween._currentTime *= timeScale;\n      tween._startTime *= timeScale;\n      tween._absoluteStartTime *= timeScale;\n    });\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      const tweenFunc = tween._func;\n      if (tweenFunc) {\n        const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);\n        decomposeRawValue(ogValue, decomposedOriginalValue);\n        decomposeRawValue(tweenFunc(), toTargetObject);\n        tween._fromNumbers = cloneArray(decomposedOriginalValue.d);\n        tween._fromNumber = decomposedOriginalValue.n;\n        tween._toNumbers = cloneArray(toTargetObject.d);\n        tween._strings = cloneArray(toTargetObject.s);\n        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025\n        tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Cancel the animation and revert all the values affected by this animation to their original state\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();\n\n\n\n\n/**\n * Converts an easing function into a valid CSS linear() timing function string\n * @param {EasingFunction} fn\n * @param {number} [samples=100]\n * @returns {string} CSS linear() timing function\n */\nconst easingToLinear = (fn, samples = 100) => {\n  const points = [];\n  for (let i = 0; i <= samples; i++) points.push(fn(i / samples));\n  return `linear(${points.join(', ')})`;\n};\n\nconst WAAPIEasesLookups = {\n  in: 'ease-in',\n  out: 'ease-out',\n  inOut: 'ease-in-out',\n};\n\nconst WAAPIeases = /*#__PURE__*/(() => {\n  const list = {};\n  for (let type in easeTypes) list[type] = (/** @type {String|Number} */p) => easeTypes[type](easeInPower(p));\n  return /** @type {Record<String, EasingFunction>} */(list);\n})();\n\n/**\n * @param  {EasingParam} ease\n * @return {String}\n */\nconst parseWAAPIEasing = (ease) => {\n  let parsedEase = WAAPIEasesLookups[ease];\n  if (parsedEase) return parsedEase;\n  parsedEase = 'linear';\n  if (isStr(ease)) {\n    if (\n      stringStartsWith(ease, 'linear') ||\n      stringStartsWith(ease, 'cubic-') ||\n      stringStartsWith(ease, 'steps') ||\n      stringStartsWith(ease, 'ease')\n    ) {\n      parsedEase = ease;\n    } else if (stringStartsWith(ease, 'cubicB')) {\n      parsedEase = toLowerCase(ease);\n    } else {\n      const parsed = parseEaseString(ease, WAAPIeases, WAAPIEasesLookups);\n      if (isFnc(parsed)) parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);\n    }\n    WAAPIEasesLookups[ease] = parsedEase;\n  } else if (isFnc(ease)) {\n    const easing = easingToLinear(ease);\n    if (easing) parsedEase = easing;\n  } else if (/** @type {Spring} */(ease).ease) {\n    parsedEase = easingToLinear(/** @type {Spring} */(ease).ease);\n  }\n  return parsedEase;\n};\n\nconst transformsShorthands = ['x', 'y', 'z'];\nconst commonDefaultPXProperties = [\n  'perspective',\n  'width',\n  'height',\n  'margin',\n  'padding',\n  'top',\n  'right',\n  'bottom',\n  'left',\n  'borderWidth',\n  'fontSize',\n  'borderRadius',\n  ...transformsShorthands\n];\n\nconst validIndividualTransforms = /*#__PURE__*/ (() => [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))])();\n\nlet transformsPropertiesRegistered = null;\n\nconst WAAPIAnimationsLookups = {\n  _head: null,\n  _tail: null,\n};\n\n/**\n * @param {DOMTarget} $el\n * @param {String} [property]\n * @param {WAAPIAnimation} [parent]\n */\nconst removeWAAPIAnimation = ($el, property, parent) => {\n  let nextLookup = WAAPIAnimationsLookups._head;\n  while (nextLookup) {\n    const next = nextLookup._next;\n    const matchTarget = nextLookup.$el === $el;\n    const matchProperty = !property || nextLookup.property === property;\n    const matchParent = !parent || nextLookup.parent === parent;\n    if (matchTarget && matchProperty && matchParent) {\n      const anim = nextLookup.animation;\n      try { anim.commitStyles(); } catch {}      anim.cancel();\n      removeChild(WAAPIAnimationsLookups, nextLookup);\n      const lookupParent = nextLookup.parent;\n      if (lookupParent) {\n        lookupParent._completed++;\n        if (lookupParent.animations.length === lookupParent._completed) {\n          lookupParent.completed = true;\n          if (!lookupParent.muteCallbacks) {\n            lookupParent.paused = true;\n            lookupParent.onComplete(lookupParent);\n            lookupParent._resolve(lookupParent);\n          }\n        }\n      }\n    }\n    nextLookup = next;\n  }\n};\n\n/**\n * @param {WAAPIAnimation} parent\n * @param {DOMTarget} $el\n * @param {String} property\n * @param {PropertyIndexedKeyframes} keyframes\n * @param {KeyframeAnimationOptions} params\n * @retun {Animation}\n */\nconst addWAAPIAnimation = (parent, $el, property, keyframes, params) => {\n  const animation = $el.animate(keyframes, params);\n  const animTotalDuration = params.delay + (+params.duration * params.iterations);\n  animation.playbackRate = parent._speed;\n  if (parent.paused) animation.pause();\n  if (parent.duration < animTotalDuration) {\n    parent.duration = animTotalDuration;\n    parent.controlAnimation = animation;\n  }\n  parent.animations.push(animation);\n  removeWAAPIAnimation($el, property);\n  addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });\n  const handleRemove = () => { removeWAAPIAnimation($el, property, parent); };\n  animation.onremove = handleRemove;\n  animation.onfinish = handleRemove;\n  return animation;\n};\n\n/**\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} value\n * @param  {DOMTarget} $el\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {String}\n */\nconst normalizeTweenValue = (propName, value, $el, i, targetsLength) => {\n  let v = getFunctionValue(/** @type {any} */(value), $el, i, targetsLength);\n  if (!isNum(v)) return v;\n  if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate')) return `${v}px`;\n  if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew')) return `${v}deg`;\n  return `${v}`;\n};\n\n/**\n * @param  {DOMTarget} $el\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} from\n * @param  {WAAPIKeyframeValue} to\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {WAAPITweenValue}\n */\nconst parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {\n  /** @type {WAAPITweenValue} */\n  let tweenValue = '0';\n  const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];\n  if (!isUnd(from)) {\n    const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);\n    tweenValue = [computedFrom, computedTo];\n  } else {\n    tweenValue = isArr(to) ? to.map((/** @type {any} */v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;\n  }\n  return tweenValue;\n};\n\nclass WAAPIAnimation {\n/**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n */\n  constructor(targets, params) {\n\n    if (scope.current) scope.current.register(this);\n\n    // Skip the registration and fallback to no animation in case CSS.registerProperty is not supported\n    if (isNil(transformsPropertiesRegistered)) {\n      if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'))) {\n        transformsPropertiesRegistered = false;\n      } else {\n        validTransforms.forEach(t => {\n          const isSkew = stringStartsWith(t, 'skew');\n          const isScale = stringStartsWith(t, 'scale');\n          const isRotate = stringStartsWith(t, 'rotate');\n          const isTranslate = stringStartsWith(t, 'translate');\n          const isAngle = isRotate || isSkew;\n          const syntax = isAngle ? '<angle>' : isScale ? \"<number>\" : isTranslate ? \"<length-percentage>\" : \"*\";\n          try {\n            CSS.registerProperty({\n              name: '--' + t,\n              syntax,\n              inherits: false,\n              initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0',\n            });\n          } catch {}        });\n        transformsPropertiesRegistered = true;\n      }\n    }\n\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n\n    const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));\n    const spring = /** @type {Spring} */(ease).ease && ease;\n    const autoplay = setValue(params.autoplay, globals.defaults.autoplay);\n    const scroll = autoplay && /** @type {ScrollObserver} */(autoplay).link ? autoplay : false;\n    const alternate = params.alternate && /** @type {Boolean} */(params.alternate) === true;\n    const reversed = params.reversed && /** @type {Boolean} */(params.reversed) === true;\n    const loop = setValue(params.loop, globals.defaults.loop);\n    const iterations = /** @type {Number} */((loop === true || loop === Infinity) ? Infinity : isNum(loop) ? loop + 1 : 1);\n    /** @type {PlaybackDirection} */\n    const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';\n    /** @type {FillMode} */\n    const fill = 'forwards';\n    /** @type {String} */\n    const easing = parseWAAPIEasing(ease);\n    const timeScale = (globals.timeScale === 1 ? 1 : K);\n\n    /** @type {DOMTargetsArray}] */\n    this.targets = parsedTargets;\n    /** @type {Array<globalThis.Animation>}] */\n    this.animations = [];\n    /** @type {globalThis.Animation}] */\n    this.controlAnimation = null;\n    /** @type {Callback<this>} */\n    this.onComplete = params.onComplete || noop;\n    /** @type {Number} */\n    this.duration = 0;\n    /** @type {Boolean} */\n    this.muteCallbacks = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.paused = !autoplay || scroll !== false;\n    /** @type {Boolean} */\n    this.reversed = reversed;\n    /** @type {Boolean|ScrollObserver} */\n    this.autoplay = autoplay;\n    /** @type {Number} */\n    this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Number} */\n    this._completed = 0;\n    /** @type {Array<Object>}] */\n    this._inlineStyles = parsedTargets.map($el => $el.getAttribute('style'));\n\n    parsedTargets.forEach(($el, i) => {\n\n      const cachedTransforms = $el[transformsSymbol];\n\n      const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));\n\n      /** @type {Number} */\n      const duration = (spring ? /** @type {Spring} */(spring).duration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;\n      /** @type {Number} */\n      const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;\n      /** @type {CompositeOperation} */\n      const composite = /** @type {CompositeOperation} */(setValue(params.composition, 'replace'));\n\n      for (let name in params) {\n        if (!isKey(name)) continue;\n        /** @type {PropertyIndexedKeyframes} */\n        const keyframes = {};\n        /** @type {KeyframeAnimationOptions} */\n        const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };\n        const propertyValue = params[name];\n        const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;\n        let parsedPropertyValue;\n        if (isObj(propertyValue)) {\n          const tweenOptions = /** @type {WAAPITweenOptions} */(propertyValue);\n          const tweenOptionsEase = setValue(tweenOptions.ease, ease);\n          const tweenOptionsSpring = /** @type {Spring} */(tweenOptionsEase).ease && tweenOptionsEase;\n          const to = /** @type {WAAPITweenOptions} */(tweenOptions).to;\n          const from = /** @type {WAAPITweenOptions} */(tweenOptions).from;\n          /** @type {Number} */\n          tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */(tweenOptionsSpring).duration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;\n          /** @type {Number} */\n          tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;\n          /** @type {CompositeOperation} */\n          tweenParams.composite = /** @type {CompositeOperation} */(setValue(tweenOptions.composition, composite));\n          /** @type {String} */\n          tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);\n          parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n          if (!isUnd(from)) {\n            if (!individualTransformProperty) {\n              $el.style[name] = keyframes[name][0];\n            } else {\n              const key = `--${individualTransformProperty}`;\n              $el.style.setProperty(key, keyframes[key][0]);\n            }\n          }\n        } else {\n          parsedPropertyValue = isArr(propertyValue) ?\n                                propertyValue.map((/** @type {any} */v) => normalizeTweenValue(name, v, $el, i, targetsLength)) :\n                                normalizeTweenValue(name, /** @type {any} */(propertyValue), $el, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parsedPropertyValue;\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n        }\n      }\n      if (hasIndividualTransforms) {\n        let transforms = emptyString;\n        for (let t in cachedTransforms) {\n          transforms += `${transformsFragmentStrings[t]}var(--${t})) `;\n        }\n        $el.style.transform = transforms;\n      }\n    });\n\n    if (scroll) {\n      /** @type {ScrollObserver} */(this.autoplay).link(this);\n    }\n  }\n\n  /**\n   * @callback forEachCallback\n   * @param {globalThis.Animation} animation\n   */\n\n  /**\n   * @param  {forEachCallback|String} callback\n   * @return {this}\n   */\n  forEach(callback) {\n    const cb = isStr(callback) ? (/** @type {globalThis.Animation} */a) => a[callback]() : callback;\n    this.animations.forEach(cb);\n    return this;\n  }\n\n  get speed() {\n    return this._speed;\n  }\n\n  /** @param {Number} speed */\n  set speed(speed) {\n    this._speed = +speed;\n    this.forEach(anim => anim.playbackRate = speed);\n  }\n\n  get currentTime() {\n    const controlAnimation = this.controlAnimation;\n    const timeScale = globals.timeScale;\n    return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;\n  }\n\n  /** @param {Number} time */\n  set currentTime(time) {\n    const t = time * (globals.timeScale === 1 ? 1 : K);\n    this.forEach(anim => {\n      // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.\n      // The \"paused\" play state supersedes the \"finished\" play state; if the animation is both paused and finished, the \"paused\" state is the one that will be reported.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event\n      if (t >= this.duration) anim.play();\n      anim.currentTime = t;\n    });\n  }\n\n  get progress() {\n    return this.currentTime / this.duration;\n  }\n\n  /** @param {Number} progress */\n  set progress(progress) {\n    this.forEach(anim => anim.currentTime = progress * this.duration || 0);\n  }\n\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // TODO: Store the current time, and seek back to the last position\n    return this.forEach('play');\n  }\n\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    return this.forEach('pause');\n  }\n\n  alternate() {\n    this.reversed = !this.reversed;\n    this.forEach('reverse');\n    if (this.paused) this.forEach('pause');\n    return this;\n  }\n\n  play() {\n    if (this.reversed) this.alternate();\n    return this.resume();\n  }\n\n  reverse() {\n    if (!this.reversed) this.alternate();\n    return this.resume();\n  }\n\n /**\n  * @param {Number} time\n  * @param {Boolean} muteCallbacks\n  */\n  seek(time, muteCallbacks = false) {\n    if (muteCallbacks) this.muteCallbacks = true;\n    if (time < this.duration) this.completed = false;\n    this.currentTime = time;\n    this.muteCallbacks = false;\n    if (this.paused) this.pause();\n    return this;\n  }\n\n  restart() {\n    this.completed = false;\n    return this.seek(0, true).resume();\n  }\n\n  commitStyles() {\n    return this.forEach('commitStyles');\n  }\n\n  complete() {\n    return this.seek(this.duration);\n  }\n\n  cancel() {\n    this.forEach('cancel');\n    return this.pause();\n  }\n\n  revert() {\n    this.cancel();\n    this.targets.forEach(($el, i) => $el.setAttribute('style', this._inlineStyles[i]) );\n    return this;\n  }\n\n  /**\n   * @param  {WAAPICallback} [callback]\n   * @return {Promise}\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      this.then = null;\n      callback(this);\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n}\n\nconst waapi = {\n/**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n * @return {WAAPIAnimation}\n */\n  animate: (targets, params) => new WAAPIAnimation(targets, params),\n  convertEase: easingToLinear\n};\n\n\n\n\n/**\n * @param  {Callback<Timer>} [callback]\n * @return {Timer}\n */\nconst sync = (callback = noop) => {\n  return new Timer({ duration: 1 * globals.timeScale, onComplete: callback }, null, 0).resume();\n};\n\n/**\n * @overload\n * @param  {DOMTargetSelector} targetSelector\n * @param  {String}            propName\n * @return {String}\n *\n * @overload\n * @param  {JSTargetsParam} targetSelector\n * @param  {String}         propName\n * @return {Number|String}\n *\n * @overload\n * @param  {DOMTargetsParam} targetSelector\n * @param  {String}          propName\n * @param  {String}          unit\n * @return {String}\n *\n * @overload\n * @param  {TargetsParam} targetSelector\n * @param  {String}       propName\n * @param  {Boolean}      unit\n * @return {Number}\n *\n * @param  {TargetsParam}   targetSelector\n * @param  {String}         propName\n * @param  {String|Boolean} [unit]\n */\nfunction getTargetValue(targetSelector, propName, unit) {\n  const targets = registerTargets(targetSelector);\n  if (!targets.length) return;\n  const [ target ] = targets;\n  const tweenType = getTweenType(target, propName);\n  const normalizePropName = sanitizePropertyName(propName, target, tweenType);\n  let originalValue = getOriginalAnimatableValue(target, normalizePropName);\n  if (isUnd(unit)) {\n    return originalValue;\n  } else {\n    decomposeRawValue(originalValue, decomposedOriginalValue);\n    if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {\n      if (unit === false) {\n        return decomposedOriginalValue.n;\n      } else {\n        const convertedValue = convertValueUnit(/** @type {DOMTarget} */(target), decomposedOriginalValue, /** @type {String} */(unit), false);\n        return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;\n      }\n    }\n  }\n}\n\n/**\n * @param  {TargetsParam}    targets\n * @param  {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst setTargetValues = (targets, parameters) => {\n  if (isUnd(parameters)) return;\n  parameters.duration = minValue;\n  // Do not overrides currently active tweens by default\n  parameters.composition = setValue(parameters.composition, compositionTypes.none);\n  // Skip init() and force rendering by playing the animation\n  return new JSAnimation(targets, parameters, null, 0, true).resume();\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {JSAnimation}    animation\n * @param  {String}       [propertyName]\n * @return {Boolean}\n */\nconst removeTargetsFromAnimation = (targetsArray, animation, propertyName) => {\n  let tweensMatchesTargets = false;\n  forEachChildren(animation, (/**@type {Tween} */tween) => {\n    const tweenTarget = tween.target;\n    if (targetsArray.includes(tweenTarget)) {\n      const tweenName = tween.property;\n      const tweenType = tween._tweenType;\n      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);\n      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {\n        // Make sure to flag the previous CSS transform tween to renderTransform\n        if (tween.parent._tail === tween &&\n            tween._tweenType === tweenTypes.TRANSFORM &&\n            tween._prev &&\n            tween._prev._tweenType === tweenTypes.TRANSFORM\n        ) {\n          tween._prev._renderTransforms = 1;\n        }\n        // Removes the tween from the selected animation\n        removeChild(animation, tween);\n        // Detach the tween from its siblings to make sure blended tweens are correctlly removed\n        removeTweenSliblings(tween);\n        tweensMatchesTargets = true;\n      }\n    }\n  }, true);\n  return tweensMatchesTargets;\n};\n\n/**\n * @param  {TargetsParam} targets\n * @param  {Renderable|WAAPIAnimation} [renderable]\n * @param  {String}                    [propertyName]\n * @return {TargetsArray}\n */\nconst remove = (targets, renderable, propertyName) => {\n  const targetsArray = parseTargets(targets);\n  const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : engine);\n  const waapiAnimation = renderable && /** @type {WAAPIAnimation} */(renderable).controlAnimation && /** @type {WAAPIAnimation} */(renderable);\n  for (let i = 0, l = targetsArray.length; i < l; i++) {\n    const $el = /** @type {DOMTarget}  */(targetsArray[i]);\n    removeWAAPIAnimation($el, propertyName, waapiAnimation);\n  }\n  let removeMatches;\n  if (parent._hasChildren) {\n    let iterationDuration = 0;\n    forEachChildren(parent, (/** @type {Renderable} */child) => {\n      if (!child._hasChildren) {\n        removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);\n        // Remove the child from its parent if no tweens and no children left after the removal\n        if (removeMatches && !child._head) {\n          child.cancel();\n          removeChild(parent, child);\n        } else {\n          // Calculate the new iterationDuration value to handle onComplete with last child in render()\n          const childTLOffset = child._offset + child._delay;\n          const childDur = childTLOffset + child.duration;\n          if (childDur > iterationDuration) {\n            iterationDuration = childDur;\n          }\n        }\n      }\n      // Make sure to also remove engine's children targets\n      // NOTE: Avoid recursion?\n      if (child._head) {\n        remove(targets, child, propertyName);\n      } else {\n        child._hasChildren = false;\n      }\n    }, true);\n    // Update iterationDuration value to handle onComplete with last child in render()\n    if (!isUnd(/** @type {Renderable} */(parent).iterationDuration)) {\n      /** @type {Renderable} */(parent).iterationDuration = iterationDuration;\n    }\n  } else {\n    removeMatches = removeTargetsFromAnimation(\n      targetsArray,\n      /** @type {JSAnimation} */(parent),\n      propertyName\n    );\n  }\n\n  if (removeMatches && !parent._head) {\n    parent._hasChildren = false;\n    // Cancel the parent if there are no tweens and no children left after the removal\n    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself\n    if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();\n  }\n\n  return targetsArray;\n};\n\n/**\n * @param  {(...args: any[]) => Tickable} constructor\n * @return {(...args: any[]) => Tickable}\n */\nconst keepTime = createRefreshable;\n\n/**\n * @param  {String|Array} items\n * @return {any}\n */\nconst randomPick = items => items[random(0, items.length - 1)];\n\n/**\n * @param  {Number|String} v\n * @param  {Number} decimalLength\n * @return {String}\n */\nconst roundPad = (v, decimalLength) => (+v).toFixed(decimalLength);\n\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */\nconst padStart = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);\n\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */\nconst padEnd = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);\n\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */\nconst wrap = (v, min, max) => (((v - min) % (max - min) + (max - min)) % (max - min)) + min;\n\n/**\n * @param  {Number} value\n * @param  {Number} inLow\n * @param  {Number} inHigh\n * @param  {Number} outLow\n * @param  {Number} outHigh\n * @return {Number}\n */\nconst mapRange = (value, inLow, inHigh, outLow, outHigh) => outLow + ((value - inLow) / (inHigh - inLow)) * (outHigh - outLow);\n\n/**\n * @param  {Number} degrees\n * @return {Number}\n */\nconst degToRad = degrees => degrees * PI / 180;\n\n/**\n * @param  {Number} radians\n * @return {Number}\n */\nconst radToDeg = radians => radians * 180 / PI;\n\n/**\n * https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} amount\n * @param  {Renderable|Boolean} [renderable]\n * @return {Number}\n */\nconst lerp = (start, end, amount, renderable) => {\n  let dt = K / globals.defaults.frameRate;\n  if (renderable !== false) {\n    const ticker = /** @type Renderable */\n                   (renderable) ||\n                   (engine._hasChildren && engine);\n    if (ticker && ticker.deltaTime) {\n      dt = ticker.deltaTime;\n    }\n  }\n  const t = 1 - Math.exp(-amount * dt * .1);\n  return !amount ? start : amount === 1 ? end : (1 - t) * start + t * end;\n};\n\n// Chain-able utilities\n\n/**\n * @callback UtilityFunction\n * @param {...*} args\n * @return {Number|String}\n *\n * @param {UtilityFunction} fn\n * @param {Number} [last=0]\n * @return {function(...(Number|String)): function(Number|String): (Number|String)}\n */\nconst curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);\n\n/**\n * @param {Function} fn\n * @return {function(...(Number|String))}\n */\nconst chain = fn => {\n   return (...args) => {\n    const result = fn(...args);\n    return new Proxy(noop, {\n      apply: (_, __, [v]) => result(v),\n      get: (_, prop) => chain(/**@param {...Number|String} nextArgs */(...nextArgs) => {\n        const nextResult = utils[prop](...nextArgs);\n        return (/**@type {Number|String} */v) => nextResult(result(v));\n      })\n    });\n  }\n};\n\n/**\n * @param {UtilityFunction} fn\n * @param {Number} [right]\n * @return {function(...(Number|String)): UtilityFunction}\n */\nconst makeChainable = (fn, right = 0) => (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);\n\n/**\n * @callback ChainedUtilsResult\n * @param {Number} value\n * @return {Number}\n *\n * @typedef {Object} ChainableUtils\n * @property {ChainedClamp} clamp\n * @property {ChainedRound} round\n * @property {ChainedSnap} snap\n * @property {ChainedWrap} wrap\n * @property {ChainedInterpolate} interpolate\n * @property {ChainedMapRange} mapRange\n * @property {ChainedRoundPad} roundPad\n * @property {ChainedPadStart} padStart\n * @property {ChainedPadEnd} padEnd\n * @property {ChainedDegToRad} degToRad\n * @property {ChainedRadToDeg} radToDeg\n *\n * @typedef {ChainableUtils & ChainedUtilsResult} ChainableUtil\n *\n * @callback ChainedClamp\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedRound\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedSnap\n * @param {Number} increment\n * @return {ChainableUtil}\n *\n * @callback ChainedWrap\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedInterpolate\n * @param {Number} start\n * @param {Number} end\n * @return {ChainableUtil}\n *\n * @callback ChainedMapRange\n * @param {Number} inLow\n * @param {Number} inHigh\n * @param {Number} outLow\n * @param {Number} outHigh\n * @return {ChainableUtil}\n *\n * @callback ChainedRoundPad\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedPadStart\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedPadEnd\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedDegToRad\n * @return {ChainableUtil}\n *\n * @callback ChainedRadToDeg\n * @return {ChainableUtil}\n */\n\nconst utils = {\n  $: registerTargets,\n  get: getTargetValue,\n  set: setTargetValues,\n  remove,\n  cleanInlineStyles,\n  random,\n  randomPick,\n  shuffle,\n  lerp,\n  sync,\n  keepTime,\n  clamp: /** @type {typeof clamp & ChainedClamp} */(makeChainable(clamp)),\n  round: /** @type {typeof round & ChainedRound} */(makeChainable(round)),\n  snap: /** @type {typeof snap & ChainedSnap} */(makeChainable(snap)),\n  wrap: /** @type {typeof wrap & ChainedWrap} */(makeChainable(wrap)),\n  interpolate: /** @type {typeof interpolate & ChainedInterpolate} */(makeChainable(interpolate, 1)),\n  mapRange: /** @type {typeof mapRange & ChainedMapRange} */(makeChainable(mapRange)),\n  roundPad: /** @type {typeof roundPad & ChainedRoundPad} */(makeChainable(roundPad)),\n  padStart: /** @type {typeof padStart & ChainedPadStart} */(makeChainable(padStart)),\n  padEnd: /** @type {typeof padEnd & ChainedPadEnd} */(makeChainable(padEnd)),\n  degToRad: /** @type {typeof degToRad & ChainedDegToRad} */(makeChainable(degToRad)),\n  radToDeg: /** @type {typeof radToDeg & ChainedRadToDeg} */(makeChainable(radToDeg)),\n};\n\n\n\n\n/**\n * Timeline's children offsets positions parser\n * @param  {Timeline} timeline\n * @param  {String} timePosition\n * @return {Number}\n */\nconst getPrevChildOffset = (timeline, timePosition) => {\n  if (stringStartsWith(timePosition, '<')) {\n    const goToPrevAnimationOffset = timePosition[1] === '<';\n    const prevAnimation = /** @type {Tickable} */(timeline._tail);\n    const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;\n    return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;\n  }\n};\n\n/**\n * @param  {Timeline} timeline\n * @param  {TimelinePosition} [timePosition]\n * @return {Number}\n */\nconst parseTimelinePosition = (timeline, timePosition) => {\n  let tlDuration = timeline.iterationDuration;\n  if (tlDuration === minValue) tlDuration = 0;\n  if (isUnd(timePosition)) return tlDuration;\n  if (isNum(+timePosition)) return +timePosition;\n  const timePosStr = /** @type {String} */(timePosition);\n  const tlLabels = timeline ? timeline.labels : null;\n  const hasLabels = !isNil(tlLabels);\n  const prevOffset = getPrevChildOffset(timeline, timePosStr);\n  const hasSibling = !isUnd(prevOffset);\n  const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);\n  if (matchedRelativeOperator) {\n    const fullOperator = matchedRelativeOperator[0];\n    const split = timePosStr.split(fullOperator);\n    const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;\n    const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;\n    const parsedNumericalOffset = +split[1];\n    return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);\n  } else {\n    return hasSibling ? prevOffset :\n           hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] :\n           tlDuration : tlDuration;\n  }\n};\n\n/**\n * @param {Timeline} tl\n * @return {Number}\n */\nfunction getTimelineTotalDuration(tl) {\n  return clampInfinity(((tl.iterationDuration + tl._loopDelay) * tl.iterationCount) - tl._loopDelay) || minValue;\n}\n\n/**\n * @overload\n * @param  {TimerParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @return {Timeline}\n *\n * @overload\n * @param  {AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} targets\n * @param  {Number} [index]\n * @param  {Number} [length]\n * @return {Timeline}\n *\n * @param  {TimerParams|AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} [targets]\n * @param  {Number} [index]\n * @param  {Number} [length]\n */\nfunction addTlChild(childParams, tl, timePosition, targets, index, length) {\n  const isSetter = isNum(childParams.duration) && /** @type {Number} */(childParams.duration) <= minValue;\n  // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position\n  const adjustedPosition = isSetter ? timePosition - minValue : timePosition;\n  tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);\n  const tlChild = targets ?\n    new JSAnimation(targets,/** @type {AnimationParams} */(childParams), tl, adjustedPosition, false, index, length) :\n    new Timer(/** @type {TimerParams} */(childParams), tl, adjustedPosition);\n  tlChild.init(1);\n  // TODO: Might be better to insert at a position relative to startTime?\n  addChild(tl, tlChild);\n  forEachChildren(tl, (/** @type {Renderable} */child) => {\n    const childTLOffset = child._offset + child._delay;\n    const childDur = childTLOffset + child.duration;\n    if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;\n  });\n  tl.duration = getTimelineTotalDuration(tl);\n  return tl;\n}\n\nclass Timeline extends Timer {\n\n  /**\n   * @param {TimelineParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    super(/** @type {TimerParams&TimelineParams} */(parameters), null, 0);\n    /** @type {Number} */\n    this.duration = 0; // TL duration starts at 0 and grows when adding children\n    /** @type {Record<String, Number>} */\n    this.labels = {};\n    const defaultsParams = parameters.defaults;\n    const globalDefaults = globals.defaults;\n    /** @type {DefaultsParams} */\n    this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;\n    /** @type {Callback<this>} */\n    this.onRender = parameters.onRender || globalDefaults.onRender;\n    const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);\n    this._ease = tlPlaybackEase ? parseEasings(tlPlaybackEase) : null;\n    /** @type {Number} */\n    this.iterationDuration = 0;\n  }\n\n  /**\n   * @overload\n   * @param {TargetsParam} a1\n   * @param {AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   * @return {this}\n   *\n   * @overload\n   * @param {TimerParams} a1\n   * @param {TimelinePosition} [a2]\n   * @return {this}\n   *\n   * @param {TargetsParam|TimerParams} a1\n   * @param {TimelinePosition|AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   */\n  add(a1, a2, a3) {\n    const isAnim = isObj(a2);\n    const isTimer = isObj(a1);\n    if (isAnim || isTimer) {\n      this._hasChildren = true;\n      if (isAnim) {\n        const childParams = /** @type {AnimationParams} */(a2);\n        // Check for function for children stagger positions\n        if (isFnc(a3)) {\n          const staggeredPosition = a3;\n          const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */(a1));\n          // Store initial duration before adding new children that will change the duration\n          const tlDuration = this.duration;\n          // Store initial _iterationDuration before adding new children that will change the duration\n          const tlIterationDuration = this.iterationDuration;\n          // Store the original id in order to add specific indexes to the new animations ids\n          const id = childParams.id;\n          let i = 0;\n          /** @type {Number} */\n          const parsedLength = (parsedTargetsArray.length);\n          parsedTargetsArray.forEach((/** @type {Target} */target) => {\n            // Create a new parameter object for each staggered children\n            const staggeredChildParams = { ...childParams };\n            // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation\n            this.duration = tlDuration;\n            this.iterationDuration = tlIterationDuration;\n            if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;\n            addTlChild(\n              staggeredChildParams,\n              this,\n              parseTimelinePosition(this, staggeredPosition(target, i, parsedLength, this)),\n              target,\n              i,\n              parsedLength\n            );\n            i++;\n          });\n        } else {\n          addTlChild(\n            childParams,\n            this,\n            parseTimelinePosition(this, a3),\n            /** @type {TargetsParam} */(a1),\n          );\n        }\n      } else {\n        // It's a Timer\n        addTlChild(\n          /** @type TimerParams */(a1),\n          this,\n          parseTimelinePosition(this,a2),\n        );\n      }\n      return this.init(1); // 1 = internalRender\n    }\n  }\n\n  /**\n   * @overload\n   * @param {Tickable} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {WAAPIAnimation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   */\n  sync(synced, position) {\n    if (isUnd(synced) || synced && isUnd(synced.pause)) return this;\n    synced.pause();\n    const duration = +(/** @type {globalThis.Animation} */(synced).effect ? /** @type {globalThis.Animation} */(synced).effect.getTiming().duration : /** @type {Tickable} */(synced).duration);\n    return this.add(synced, { currentTime: [0, duration], duration, ease: 'linear' }, position);\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {AnimationParams} parameters\n   * @param  {TimelinePosition} [position]\n   * @return {this}\n   */\n  set(targets, parameters, position) {\n    if (isUnd(parameters)) return this;\n    parameters.duration = minValue;\n    parameters.composition = compositionTypes.replace;\n    return this.add(targets, parameters, position);\n  }\n\n  /**\n   * @param {Callback<Timer>} callback\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   */\n  call(callback, position) {\n    if (isUnd(callback) || callback && !isFnc(callback)) return this;\n    return this.add({ duration: 0, onComplete: () => callback(this) }, position);\n  }\n\n  /**\n   * @param {String} labelName\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   */\n  label(labelName, position) {\n    if (isUnd(labelName) || labelName && !isStr(labelName)) return this;\n    this.labels[labelName] = parseTimelinePosition(this, position);\n    return this;\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {String} [propertyName]\n   * @return {this}\n   */\n  remove(targets, propertyName) {\n    remove(targets, this, propertyName);\n    return this;\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    const labels = this.labels;\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.stretch(child.duration * timeScale));\n    for (let labelName in labels) labels[labelName] *= timeScale;\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {JSAnimation} */child) => {\n      if (child.refresh) child.refresh();\n    });\n    return this;\n  }\n\n  /**\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n}\n\n/**\n * @param {TimelineParams} [parameters]\n * @return {Timeline}\n */\nconst createTimeline = parameters => new Timeline(parameters).init();\n\n\n\n\nclass Animatable {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimatableParams} parameters\n   */\n  constructor(targets, parameters) {\n    if (scope.current) scope.current.register(this);\n    const beginHandler = () => {\n      if (this.callbacks.completed) this.callbacks.reset();\n      this.callbacks.play();\n    };\n    const pauseHandler = () => {\n      if (this.callbacks.completed) return;\n      let paused = true;\n      for (let name in this.animations) {\n        const anim = this.animations[name];\n        if (!anim.paused && paused) {\n          paused = false;\n          break;\n        }\n      }\n      if (paused) {\n        this.callbacks.complete();\n      }\n    };\n    /** @type {AnimationParams} */\n    const globalParams = {\n      onBegin: beginHandler,\n      onComplete: pauseHandler,\n      onPause: pauseHandler,\n    };\n    /** @type {AnimationParams} */\n    const callbacksAnimationParams = { v: 1, autoplay: false };\n    const properties = {};\n    this.targets = [];\n    this.animations = {};\n    /** @type {JSAnimation|null} */\n    this.callbacks = null;\n    if (isUnd(targets) || isUnd(parameters)) return;\n    for (let propName in parameters) {\n      const paramValue = parameters[propName];\n      if (isKey(propName)) {\n        properties[propName] = paramValue;\n      } else if (stringStartsWith(propName, 'on')) {\n        callbacksAnimationParams[propName] = paramValue;\n      } else {\n        globalParams[propName] = paramValue;\n      }\n    }\n    this.callbacks = new JSAnimation({ v: 0 }, callbacksAnimationParams);\n    for (let propName in properties) {\n      const propValue = properties[propName];\n      const isObjValue = isObj(propValue);\n      /** @type {TweenParamsOptions} */\n      let propParams = {};\n      let to = '+=0';\n      if (isObjValue) {\n        const unit = propValue.unit;\n        if (isStr(unit)) to += unit;\n      } else {\n        propParams.duration = propValue;\n      }\n      propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;\n      const animParams = mergeObjects(globalParams, propParams);\n      animParams.composition = compositionTypes.replace;\n      animParams.autoplay = false;\n      const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();\n      if (!this.targets.length) this.targets.push(...animation.targets);\n      /** @type {AnimatableProperty} */\n      this[propName] = (to, duration, ease) => {\n        const tween = /** @type {Tween} */(animation._head);\n        if (isUnd(to) && tween) {\n          const numbers = tween._numbers;\n          if (numbers && numbers.length) {\n            return numbers;\n          } else {\n            return tween._modifier(tween._number);\n          }\n        } else {\n          forEachChildren(animation, (/** @type {Tween} */tween) => {\n            if (isArr(to)) {\n              for (let i = 0, l = /** @type {Array} */(to).length; i < l; i++) {\n                if (!isUnd(tween._numbers[i])) {\n                  tween._fromNumbers[i] = /** @type {Number} */(tween._modifier(tween._numbers[i]));\n                  tween._toNumbers[i] = to[i];\n                }\n              }\n            } else {\n              tween._fromNumber = /** @type {Number} */(tween._modifier(tween._number));\n              tween._toNumber = /** @type {Number} */(to);\n            }\n            if (!isUnd(ease)) tween._ease = parseEasings(ease);\n            tween._currentTime = 0;\n          });\n          if (!isUnd(duration)) animation.stretch(duration);\n          animation.reset(1).resume();\n          return this;\n        }\n      };\n    }\n  }\n\n  revert() {\n    for (let propName in this.animations) {\n      this[propName] = noop;\n      this.animations[propName].revert();\n    }\n    this.animations = {};\n    this.targets.length = 0;\n    if (this.callbacks) this.callbacks.revert();\n    return this;\n  }\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimatableParams} parameters\n * @return {AnimatableObject}\n */\nconst createAnimatable = (targets, parameters) => /** @type {AnimatableObject} */ (new Animatable(targets, parameters));\n\n\n\n\n/*\n * Spring ease solver adapted from https://webkit.org/demos/spring/spring.js\n * Webkit Copyright  2016 Apple Inc\n */\n\nconst maxSpringParamValue = K * 10;\n\n/**\n * @typedef {Object} SpringParams\n * @property {Number} [mass=1] - Mass, default 1\n * @property {Number} [stiffness=100] - Stiffness, default 100\n * @property {Number} [damping=10] - Damping, default 10\n * @property {Number} [velocity=0] - Initial velocity, default 0\n */\nclass Spring {\n  /**\n   * @param {SpringParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    this.timeStep = .02; // Interval fed to the solver to calculate duration\n    this.restThreshold = .0005; // Values below this threshold are considered resting position\n    this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold\n    this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)\n    this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation\n    this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration\n    this.m = clamp(setValue(parameters.mass, 1), 0, maxSpringParamValue);\n    this.s = clamp(setValue(parameters.stiffness, 100), 1, maxSpringParamValue);\n    this.d = clamp(setValue(parameters.damping, 10), .1, maxSpringParamValue);\n    this.v = clamp(setValue(parameters.velocity, 0), -maxSpringParamValue, maxSpringParamValue);\n    this.w0 = 0;\n    this.zeta = 0;\n    this.wd = 0;\n    this.b = 0;\n    this.solverDuration = 0;\n    this.duration = 0;\n    this.compute();\n    /** @type {EasingFunction} */\n    this.ease = t => t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);\n  }\n\n  /** @type {EasingFunction} */\n  solve(time) {\n    const { zeta, w0, wd, b } = this;\n    let t = time;\n    if (zeta < 1) {\n      t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));\n    } else {\n      t = (1 + b * t) * exp(-t * w0);\n    }\n    return 1 - t;\n  }\n\n  compute() {\n    const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;\n    const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);\n    const zeta = this.zeta = d / (2 * sqrt(s * m));\n    const wd = this.wd = zeta < 1 ? w0 * sqrt(1 - zeta * zeta) : 0;\n    this.b = zeta < 1 ? (zeta * w0 + -v) / wd : -v + w0;\n    let solverTime = 0;\n    let restSteps = 0;\n    let iterations = 0;\n    while (restSteps < maxRestSteps && iterations < maxIterations) {\n      if (abs(1 - this.solve(solverTime)) < restThreshold) {\n        restSteps++;\n      } else {\n        restSteps = 0;\n      }\n      this.solverDuration = solverTime;\n      solverTime += timeStep;\n      iterations++;\n    }\n    this.duration = round(this.solverDuration * K, 0) * globals.timeScale;\n  }\n\n  get mass() {\n    return this.m;\n  }\n\n  set mass(v) {\n    this.m = clamp(setValue(v, 1), 0, maxSpringParamValue);\n    this.compute();\n  }\n\n  get stiffness() {\n    return this.s;\n  }\n\n  set stiffness(v) {\n    this.s = clamp(setValue(v, 100), 1, maxSpringParamValue);\n    this.compute();\n  }\n\n  get damping() {\n    return this.d;\n  }\n\n  set damping(v) {\n    this.d = clamp(setValue(v, 10), .1, maxSpringParamValue);\n    this.compute();\n  }\n\n  get velocity() {\n    return this.v;\n  }\n\n  set velocity(v) {\n    this.v = clamp(setValue(v, 0), -maxSpringParamValue, maxSpringParamValue);\n    this.compute();\n  }\n}\n\n/**\n * @param {SpringParams} [parameters]\n * @returns {Spring}\n */\nconst createSpring = (parameters) => new Spring(parameters);\n\n\n\n\n/**\n * @param {Event} e\n */\nconst preventDefault = e => {\n  if (e.cancelable) e.preventDefault();\n};\n\nclass DOMProxy {\n  /** @param {Object} el */\n  constructor(el) {\n    this.el = el;\n    this.zIndex = 0;\n    this.parentElement = null;\n    this.classList = {\n      add: noop,\n      remove: noop,\n    };\n  }\n\n  get x() { return this.el.x || 0 };\n  set x(v) { this.el.x = v; };\n\n  get y() { return this.el.y || 0 };\n  set y(v) { this.el.y = v; };\n\n  get width() { return this.el.width || 0 };\n  set width(v) { this.el.width = v; };\n\n  get height() { return this.el.height || 0 };\n  set height(v) { this.el.height = v; };\n\n  getBoundingClientRect() {\n    return {\n      top: this.y,\n      right: this.x,\n      bottom: this.y + this.height,\n      left: this.x + this.width,\n    }\n  }\n}\n\nclass Transforms {\n  /**\n   * @param {DOMTarget|DOMProxy} $el\n   */\n  constructor($el) {\n    this.$el = $el;\n    this.inlineTransforms = [];\n    this.point = new DOMPoint();\n    this.inversedMatrix = this.getMatrix().inverse();\n  }\n\n  /**\n   * @param {Number} x\n   * @param {Number} y\n   * @return {DOMPoint}\n   */\n  normalizePoint(x, y) {\n    this.point.x = x;\n    this.point.y = y;\n    return this.point.matrixTransform(this.inversedMatrix);\n  }\n\n  /**\n   * @callback TraverseParentsCallback\n   * @param {DOMTarget} $el\n   * @param {Number} i\n   */\n\n  /**\n   * @param {TraverseParentsCallback} cb\n   */\n  traverseUp(cb) {\n    let $el = /** @type {DOMTarget|Document} */(this.$el.parentElement), i = 0;\n    while ($el && $el !== doc) {\n      cb(/** @type {DOMTarget} */($el), i);\n      $el = /** @type {DOMTarget} */($el.parentElement);\n      i++;\n    }\n  }\n\n  getMatrix() {\n    const matrix = new DOMMatrix();\n    this.traverseUp($el => {\n      const transformValue = getComputedStyle($el).transform;\n      if (transformValue) {\n        const elMatrix = new DOMMatrix(transformValue);\n        matrix.preMultiplySelf(elMatrix);\n      }\n    });\n    return matrix;\n  }\n\n  remove() {\n    this.traverseUp(($el, i) => {\n      this.inlineTransforms[i] = $el.style.transform;\n      $el.style.transform = 'none';\n    });\n  }\n\n  revert() {\n    this.traverseUp(($el, i) => {\n      const ct = this.inlineTransforms[i];\n      if (ct === '') {\n        $el.style.removeProperty('transform');\n      } else {\n        $el.style.transform = ct;\n      }\n    });\n  }\n}\n\n/**\n * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams} T\n * @param {T | ((draggable: Draggable) => T)} value\n * @param {Draggable} draggable\n * @return {T}\n */\nconst parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */(value)(draggable) : value;\n\nlet zIndex = 0;\n\nclass Draggable {\n  /**\n   * @param {TargetsParam} target\n   * @param {DraggableParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    if (!target) return;\n    if (scope.current) scope.current.register(this);\n    const paramX = parameters.x;\n    const paramY = parameters.y;\n    const trigger = parameters.trigger;\n    const modifier = parameters.modifier;\n    const ease = parameters.releaseEase;\n    const customEase = ease && parseEasings(ease);\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);\n    const xProp = /** @type {String} */(isObj(paramX) && !isUnd(/** @type {Object} */(paramX).mapTo) ? /** @type {Object} */(paramX).mapTo : 'translateX');\n    const yProp = /** @type {String} */(isObj(paramY) && !isUnd(/** @type {Object} */(paramY).mapTo) ? /** @type {Object} */(paramY).mapTo : 'translateY');\n    const container = parseDraggableFunctionParameter(parameters.container, this);\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.$target = /** @type {HTMLElement} */(isObj(target) ? new DOMProxy(target) : parseTargets(target)[0]);\n    this.$trigger = /** @type {HTMLElement} */(parseTargets(trigger ? trigger : target)[0]);\n    this.fixed = getTargetValue(this.$target, 'position') === 'fixed';\n    // Refreshable parameters\n    this.isFinePointer = true;\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerPadding = [0, 0, 0, 0];\n    /** @type {Number} */\n    this.containerFriction = 0;\n    /** @type {Number} */\n    this.releaseContainerFriction = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapX = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapY = 0;\n    /** @type {Number} */\n    this.scrollSpeed = 0;\n    /** @type {Number} */\n    this.scrollThreshold = 0;\n    /** @type {Number} */\n    this.dragSpeed = 0;\n    /** @type {Number} */\n    this.maxVelocity = 0;\n    /** @type {Number} */\n    this.minVelocity = 0;\n    /** @type {Number} */\n    this.velocityMultiplier = 0;\n    /** @type {Boolean|DraggableCursorParams} */\n    this.cursor = false;\n    /** @type {Spring} */\n    this.releaseXSpring = hasSpring ? /** @type {Spring} */(ease) : createSpring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20),\n    });\n    /** @type {Spring} */\n    this.releaseYSpring = hasSpring ? /** @type {Spring} */(ease) : createSpring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20),\n    });\n    /** @type {EasingFunction} */\n    this.releaseEase = customEase || eases.outQuint;\n    /** @type {Boolean} */\n    this.hasReleaseSpring = hasSpring;\n    /** @type {Callback<this>} */\n    this.onGrab = parameters.onGrab || noop;\n    /** @type {Callback<this>} */\n    this.onDrag = parameters.onDrag || noop;\n    /** @type {Callback<this>} */\n    this.onRelease = parameters.onRelease || noop;\n    /** @type {Callback<this>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<this>} */\n    this.onSettle = parameters.onSettle || noop;\n    /** @type {Callback<this>} */\n    this.onSnap = parameters.onSnap || noop;\n    /** @type {Callback<this>} */\n    this.onResize = parameters.onResize || noop;\n    /** @type {Callback<this>} */\n    this.onAfterResize = parameters.onAfterResize || noop;\n    /** @type {[Number, Number]} */\n    this.disabled = [0, 0];\n    /** @type {AnimatableParams} */\n    const animatableParams = {};\n    if (modifier) animatableParams.modifier = modifier;\n    if (isUnd(paramX) || paramX === true) {\n      animatableParams[xProp] = 0;\n    } else if (isObj(paramX)) {\n      const paramXObject = /** @type {DraggableAxisParam} */(paramX);\n      const animatableXParams = {};\n      if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;\n      if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;\n      animatableParams[xProp] = animatableXParams;\n    } else if (paramX === false) {\n      animatableParams[xProp] = 0;\n      this.disabled[0] = 1;\n    }\n    if (isUnd(paramY) || paramY === true) {\n      animatableParams[yProp] = 0;\n    } else if (isObj(paramY)) {\n      const paramYObject = /** @type {DraggableAxisParam} */(paramY);\n      const animatableYParams = {};\n      if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;\n      if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;\n      animatableParams[yProp] = animatableYParams;\n    } else if (paramY === false) {\n      animatableParams[yProp] = 0;\n      this.disabled[1] = 1;\n    }\n    /** @type {AnimatableObject} */\n    this.animate = /** @type {AnimatableObject} */(new Animatable(this.$target, animatableParams));\n    // Internal props\n    this.xProp = xProp;\n    this.yProp = yProp;\n    this.destX = 0;\n    this.destY = 0;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.scroll = {x: 0, y: 0};\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y\n    /** @type {[Number, Number]} */\n    this.snapped = [0, 0]; // x, y\n    /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */\n    this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2\n    /** @type {[Number, Number]} */\n    this.scrollView = [0, 0]; // w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.dragArea = [0, 0, 0, 0]; // x, y, w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerBounds = [-maxValue, maxValue, maxValue, -maxValue]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.targetBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number]} */\n    this.window = [0, 0]; // w, h\n    /** @type {[Number, Number, Number]} */\n    this.velocityStack = [0, 0, 0];\n    /** @type {Number} */\n    this.velocityStackIndex = 0;\n    /** @type {Number} */\n    this.velocityTime = now();\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Number} */\n    this.angle = 0;\n    /** @type {JSAnimation} */\n    this.cursorStyles = null;\n    /** @type {JSAnimation} */\n    this.triggerStyles = null;\n    /** @type {JSAnimation} */\n    this.bodyStyles = null;\n    /** @type {JSAnimation} */\n    this.targetStyles = null;\n    /** @type {JSAnimation} */\n    this.touchActionStyles = null;\n    this.transforms = new Transforms(this.$target);\n    this.overshootCoords = { x: 0, y: 0 };\n    this.overshootTicker = new Timer({\n      autoplay: false,\n      onUpdate: () => {\n        this.updated = true;\n        this.manual = true;\n        // Use a duration of 1 to prevent the animatable from completing immediately to prevent issues with onSettle()\n        // https://github.com/juliangarnier/anime/issues/1045\n        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 1);\n        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 1);\n      },\n      onComplete: () => {\n        this.manual = false;\n        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 0);\n        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 0);\n      },\n    }, null, 0).init();\n    this.updateTicker = new Timer({ autoplay: false, onUpdate: () => this.update() }, null,0,).init();\n    this.contained = !isUnd(container);\n    this.manual = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.enabled = false;\n    this.initialized = false;\n    this.activeProp = this.disabled[1] ? xProp : yProp;\n    this.animate.callbacks.onRender = () => {\n      const hasUpdated = this.updated;\n      const hasMoved = this.grabbed && hasUpdated;\n      const hasReleased = !hasMoved && this.released;\n      const x = this.x;\n      const y = this.y;\n      const dx = x - this.coords[2];\n      const dy = y - this.coords[3];\n      this.deltaX = dx;\n      this.deltaY = dy;\n      this.coords[2] = x;\n      this.coords[3] = y;\n      // Check if dx or dy are not 0 to check if the draggable has actually moved\n      // https://github.com/juliangarnier/anime/issues/1032\n      if (hasUpdated && (dx || dy)) {\n        this.onUpdate(this);\n      }\n      if (!hasReleased) {\n        this.updated = false;\n      } else {\n        this.computeVelocity(dx, dy);\n        this.angle = atan2(dy, dx);\n      }\n    };\n    this.animate.callbacks.onComplete = () => {\n      if ((!this.grabbed && this.released)) {\n        // Set released to false before calling onSettle to avoid recursion\n        this.released = false;\n      }\n      if (!this.manual) {\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.velocity = 0;\n        this.velocityStack[0] = 0;\n        this.velocityStack[1] = 0;\n        this.velocityStack[2] = 0;\n        this.velocityStackIndex = 0;\n        this.onSettle(this);\n      }\n    };\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 150 * globals.timeScale,\n      onComplete: () => {\n        this.onResize(this);\n        this.refresh();\n        this.onAfterResize(this);\n      },\n    }).init();\n    this.parameters = parameters;\n    this.resizeObserver = new ResizeObserver(() => {\n      if (this.initialized) {\n        this.resizeTicker.restart();\n      } else {\n        this.initialized = true;\n      }\n    });\n    this.enable();\n    this.refresh();\n    this.resizeObserver.observe(this.$container);\n    if (!isObj(target)) this.resizeObserver.observe(this.$target);\n  }\n\n  /**\n   * @param  {Number} dx\n   * @param  {Number} dy\n   * @return {Number}\n   */\n  computeVelocity(dx, dy) {\n    const prevTime = this.velocityTime;\n    const curTime = now();\n    const elapsed = curTime - prevTime;\n    if (elapsed < 17) return this.velocity;\n    this.velocityTime = curTime;\n    const velocityStack = this.velocityStack;\n    const vMul = this.velocityMultiplier;\n    const minV = this.minVelocity;\n    const maxV = this.maxVelocity;\n    const vi = this.velocityStackIndex;\n    velocityStack[vi] = round(clamp((sqrt(dx * dx + dy * dy) / elapsed) * vMul, minV, maxV), 5);\n    const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);\n    this.velocity = velocity;\n    this.velocityStackIndex = (vi + 1) % 3;\n    return velocity;\n  }\n\n  /**\n   * @param {Number}  x\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setX(x, muteUpdateCallback = false) {\n    if (this.disabled[0]) return;\n    const v = round(x, 5);\n    this.overshootTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destX = v;\n    this.snapped[0] = snap(v, this.snapX);\n    this.animate[this.xProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n\n  /**\n   * @param {Number}  y\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setY(y, muteUpdateCallback = false) {\n    if (this.disabled[1]) return;\n    const v = round(y, 5);\n    this.overshootTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destY = v;\n    this.snapped[1] = snap(v, this.snapY);\n    this.animate[this.yProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n\n  get x() {\n    return round(/** @type {Number} */(this.animate[this.xProp]()), globals.precision);\n  }\n\n  set x(x) {\n    this.setX(x, false);\n  }\n\n  get y() {\n    return round(/** @type {Number} */(this.animate[this.yProp]()), globals.precision);\n  }\n\n  set y(y) {\n    this.setY(y, false);\n  }\n\n  get progressX() {\n    return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);\n  }\n\n  set progressX(x) {\n    this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);\n  }\n\n  get progressY() {\n    return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);\n  }\n\n  set progressY(y) {\n    this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);\n  }\n\n  updateScrollCoords() {\n    const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);\n    const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    const threshold = this.scrollThreshold;\n    this.scroll.x = sx;\n    this.scroll.y = sy;\n    this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;\n    this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;\n    this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;\n    this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;\n  }\n\n  updateBoundingValues() {\n    const $container = this.$container;\n    // Return early if no $container defined to prevents error when reading scrollWidth / scrollHeight\n    // https://github.com/juliangarnier/anime/issues/1064\n    if (!$container) return;\n    const cx = this.x;\n    const cy = this.y;\n    const cx2 = this.coords[2];\n    const cy2 =  this.coords[3];\n    // Prevents interfering with the scroll area in cases the target is outside of the container\n    // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates\n    this.coords[2] = 0;\n    this.coords[3] = 0;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.transforms.remove();\n    const iw = this.window[0] = win.innerWidth;\n    const ih = this.window[1] = win.innerHeight;\n    const uw = this.useWin;\n    const sw = $container.scrollWidth;\n    const sh = $container.scrollHeight;\n    const fx = this.fixed;\n    const transformContainerRect = $container.getBoundingClientRect();\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    this.dragArea[0] = uw ? 0 : transformContainerRect.left;\n    this.dragArea[1] = uw ? 0 : transformContainerRect.top;\n    this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;\n    this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;\n    this.updateScrollCoords();\n    const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();\n    this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);\n    this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);\n    const containerOverflow = getTargetValue($container, 'overflow');\n    const visibleOverflow = containerOverflow === 'visible';\n    const hiddenOverflow = containerOverflow === 'hidden';\n    this.canScroll = fx ? false :\n      this.contained &&\n      (($container === doc.body && visibleOverflow) || (!hiddenOverflow && !visibleOverflow)) &&\n      (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) &&\n      (!this.containerArray || (this.containerArray && !isArr(this.containerArray)));\n    if (this.contained) {\n      const sx = this.scroll.x;\n      const sy = this.scroll.y;\n      const canScroll = this.canScroll;\n      const targetRect = this.$target.getBoundingClientRect();\n      const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;\n      const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;\n      const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;\n      const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;\n      this.targetBounds[0] = round((targetRect.top + sy) - (uw ? 0 : top), 0);\n      this.targetBounds[1] = round((targetRect.right + sx) - (uw ? iw : right), 0);\n      this.targetBounds[2] = round((targetRect.bottom + sy) - (uw ? ih : bottom), 0);\n      this.targetBounds[3] = round((targetRect.left + sx) - (uw ? 0 : left), 0);\n      if (this.containerArray) {\n        this.containerBounds[0] = this.containerArray[0] + cpt;\n        this.containerBounds[1] = this.containerArray[1] - cpr;\n        this.containerBounds[2] = this.containerArray[2] - cpb;\n        this.containerBounds[3] = this.containerArray[3] + cpl;\n      } else {\n        this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);\n        this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);\n        this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);\n        this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);\n      }\n    }\n    this.transforms.revert();\n    // Restore coordinates\n    this.coords[2] = cx2;\n    this.coords[3] = cy2;\n    this.setX(cx, true);\n    this.setY(cy, true);\n  }\n\n  /**\n   * @param  {Array} bounds\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {Number}\n   */\n  isOutOfBounds(bounds, x, y) {\n    // Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB\n    if (!this.contained) return 0;\n    const [ bt, br, bb, bl ] = bounds;\n    const [ dx, dy ] = this.disabled;\n    const obx = !dx && x < bl || !dx && x > br;\n    const oby = !dy && y < bt || !dy && y > bb;\n    return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;\n  }\n\n  refresh() {\n    const params = this.parameters;\n    const paramX = params.x;\n    const paramY = params.y;\n    const container = parseDraggableFunctionParameter(params.container, this);\n    const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;\n    const containerPadding = /** @type {[Number, Number, Number, Number]} */(isArr(cp) ? cp : [cp, cp, cp, cp]);\n    const cx = this.x;\n    const cy = this.y;\n    const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);\n    const cursorStyles = { onHover: 'grab', onGrab: 'grabbing' };\n    if (parsedCursorStyles) {\n      const { onHover, onGrab } = /** @type {DraggableCursorParams} */(parsedCursorStyles);\n      if (onHover) cursorStyles.onHover = onHover;\n      if (onGrab) cursorStyles.onGrab = onGrab;\n    }\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.isFinePointer = matchMedia('(pointer:fine)').matches;\n    this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);\n    this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);\n    this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);\n    this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);\n    this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);\n    this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);\n    this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);\n    this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);\n    this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);\n    this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);\n    this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);\n    this.cursor = parsedCursorStyles === false ? false : cursorStyles;\n    this.updateBoundingValues();\n\n    // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);\n    // if (ob === 1 || ob === 3) this.progressX = px;\n    // if (ob === 2 || ob === 3) this.progressY = py;\n\n    // if (this.initialized && this.contained) {\n    //   if (this.progressX !== px) this.progressX = px;\n    //   if (this.progressY !== py) this.progressY = py;\n    // }\n\n    const [ bt, br, bb, bl ] = this.containerBounds;\n    this.setX(clamp(cx, bl, br), true);\n    this.setY(clamp(cy, bt, bb), true);\n  }\n\n  update() {\n    this.updateScrollCoords();\n    if (this.canScroll) {\n      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n      const [ sw, sh ] = this.scrollView;\n      const daw = this.dragArea[2];\n      const dah = this.dragArea[3];\n      const csx = this.scroll.x;\n      const csy = this.scroll.y;\n      const nsw = this.$container.scrollWidth;\n      const nsh = this.$container.scrollHeight;\n      const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;\n      const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;\n      const swd = sw - csw;\n      const shd = sh - csh;\n      // Handle cases where the scrollarea dimensions changes during drag\n      if (this.dragged && swd > 0) {\n        this.coords[0] -= swd;\n        this.scrollView[0] = csw;\n      }\n      if (this.dragged && shd > 0) {\n        this.coords[1] -= shd;\n        this.scrollView[1] = csh;\n      }\n      // Handle autoscroll when target is at the edges of the scroll bounds\n      const s = this.scrollSpeed * 10;\n      const threshold = this.scrollThreshold;\n      const [ x, y ] = this.coords;\n      const [ st, sr, sb, sl ] = this.scrollBounds;\n      const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);\n      const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);\n      const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);\n      const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);\n      if (t || b || l || r) {\n        const [nx, ny] = this.disabled;\n        let scrollX = csx;\n        let scrollY = csy;\n        if (!nx) {\n          scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);\n          this.coords[0] -= csx - scrollX;\n        }\n        if (!ny) {\n          scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);\n          this.coords[1] -= csy - scrollY;\n        }\n        // Note: Safari mobile requires to use different scroll methods depending if using the window or not\n        if (this.useWin) {\n          this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));\n        } else {\n          this.$scrollContainer.scrollTo(scrollX, scrollY);\n        }\n      }\n    }\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;\n    this.coords[0] += (px1 - px3) * this.dragSpeed;\n    this.coords[1] += (py1 - py3) * this.dragSpeed;\n    this.pointer[4] = px1;\n    this.pointer[5] = py1;\n    const [ cx, cy ] = this.coords;\n    const [ sx, sy ] = this.snapped;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);\n    this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);\n    this.computeVelocity(px1 - px3, py1 - py3);\n    this.angle = atan2(py1 - py2, px1 - px2);\n    const [ nsx, nsy ] = this.snapped;\n    if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {\n      this.onSnap(this);\n    }\n  }\n\n  stop() {\n    this.updateTicker.pause();\n    this.overshootTicker.pause();\n    // Pauses the in bounds onRelease animations\n    for (let prop in this.animate.animations) this.animate.animations[prop].pause();\n    remove(this, null, 'x');\n    remove(this, null, 'y');\n    remove(this, null, 'progressX');\n    remove(this, null, 'progressY');\n    remove(this.scroll); // Removes any active animations on the container scroll\n    remove(this.overshootCoords); // Removes active overshoot animations\n    return this;\n  }\n\n  /**\n   * @param {Number} [duration]\n   * @param {Number} [gap]\n   * @param {EasingParam} [ease]\n   * @return {this}\n   */\n  scrollInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.updateScrollCoords();\n    const x = this.destX;\n    const y = this.destY;\n    const scroll = this.scroll;\n    const scrollBounds = this.scrollBounds;\n    const canScroll = this.canScroll;\n    if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {\n      const [ st, sr, sb, sl ] = scrollBounds;\n      const t = round(clamp(y - st, -maxValue, 0), 0);\n      const r = round(clamp(x - sr, 0, maxValue), 0);\n      const b = round(clamp(y - sb, 0, maxValue), 0);\n      const l = round(clamp(x - sl, -maxValue, 0), 0);\n      new JSAnimation(scroll, {\n        x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),\n        y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),\n        duration: isUnd(duration) ? 350 * globals.timeScale : duration,\n        ease,\n        onUpdate: () => {\n          this.canScroll = false;\n          this.$scrollContainer.scrollTo(scroll.x, scroll.y);\n        }\n      }).init().then(() => {\n        this.canScroll = canScroll;\n      });\n    }\n    return this;\n  }\n\n  handleHover() {\n    if (this.isFinePointer && this.cursor && !this.cursorStyles) {\n      this.cursorStyles = setTargetValues(this.$trigger, {\n        cursor: /** @type {DraggableCursorParams} */(this.cursor).onHover\n      });\n    }\n  }\n\n  /**\n   * @param  {Number} [duration]\n   * @param  {Number} [gap]\n   * @param  {EasingParam} [ease]\n   * @return {this}\n   */\n  animateInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.stop();\n    this.updateBoundingValues();\n    const x = this.x;\n    const y = this.y;\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;\n    const br = this.scroll.x - this.targetBounds[1] - cpr - gap;\n    const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;\n    const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;\n    const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);\n    if (ob) {\n      const [ disabledX, disabledY ] = this.disabled;\n      const destX = clamp(snap(x, this.snapX), bl, br);\n      const destY = clamp(snap(y, this.snapY), bt, bb);\n      const dur = isUnd(duration) ? 350 * globals.timeScale : duration;\n      if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);\n      if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);\n    }\n    return this;\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleDown(e) {\n    const $eTarget = /** @type {HTMLElement} */(e.target);\n    if (this.grabbed || /** @type {HTMLInputElement} */($eTarget).type === 'range') return;\n\n    e.stopPropagation();\n\n    this.grabbed = true;\n    this.released = false;\n    this.stop();\n    this.updateBoundingValues();\n    const touches = /** @type {TouchEvent} */(e).changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;\n    const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    const cx = this.x;\n    const cy = this.y;\n    this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;\n    this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;\n    this.pointer[0] = x;\n    this.pointer[1] = y;\n    this.pointer[2] = x;\n    this.pointer[3] = y;\n    this.pointer[4] = x;\n    this.pointer[5] = y;\n    this.pointer[6] = x;\n    this.pointer[7] = y;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    const z = /** @type {Number} */(getTargetValue(this.$target, 'zIndex', false));\n    zIndex = (z > zIndex ? z : zIndex) + 1;\n    this.targetStyles = setTargetValues(this.$target, { zIndex });\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.isFinePointer && this.cursor) {\n      this.bodyStyles = setTargetValues(doc.body, {\n        cursor: /** @type {DraggableCursorParams} */(this.cursor).onGrab\n      });\n    }\n    this.scrollInView(100, 0, eases.out(3));\n    this.onGrab(this);\n\n    doc.addEventListener('touchmove', this);\n    doc.addEventListener('touchend', this);\n    doc.addEventListener('touchcancel', this);\n    doc.addEventListener('mousemove', this);\n    doc.addEventListener('mouseup', this);\n    doc.addEventListener('selectstart', this);\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleMove(e) {\n    if (!this.grabbed) return;\n    const touches = /** @type {TouchEvent} */(e).changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;\n    const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n    const movedX = x - this.pointer[6];\n    const movedY = y - this.pointer[7];\n\n    let $parent = /** @type {HTMLElement} */(e.target);\n    let isAtTop = false;\n    let isAtBottom = false;\n    let canTouchScroll = false;\n\n    while (touches && $parent && $parent !== this.$trigger) {\n      const overflowY = getTargetValue($parent, 'overflow-y');\n      if (overflowY !== 'hidden' && overflowY !== 'visible') {\n        const { scrollTop, scrollHeight, clientHeight } = $parent;\n        if (scrollHeight > clientHeight) {\n          canTouchScroll = true;\n          isAtTop = scrollTop <= 3;\n          isAtBottom = scrollTop >= (scrollHeight - clientHeight) - 3;\n          break;\n        }\n      }\n      $parent = /** @type {HTMLElement} */($parent.parentNode);\n    }\n\n    if (canTouchScroll && ((!isAtTop && !isAtBottom) || (isAtTop && movedY < 0) || (isAtBottom && movedY > 0))) {\n\n      this.pointer[0] = x;\n      this.pointer[1] = y;\n      this.pointer[2] = x;\n      this.pointer[3] = y;\n      this.pointer[4] = x;\n      this.pointer[5] = y;\n      this.pointer[6] = x;\n      this.pointer[7] = y;\n\n    } else {\n\n      preventDefault(e);\n\n      // Needed to prevents click on handleUp\n      if (!this.triggerStyles) this.triggerStyles = setTargetValues(this.$trigger, { pointerEvents: 'none' });\n      // Needed to prevent page scroll while dragging on touch devvice\n      this.$trigger.addEventListener('touchstart', preventDefault, { passive: false });\n      this.$trigger.addEventListener('touchmove', preventDefault, { passive: false });\n      this.$trigger.addEventListener('touchend', preventDefault);\n\n\n      if ((!this.disabled[0] && abs(movedX) > 3) || (!this.disabled[1] && abs(movedY) > 3)) {\n\n        this.updateTicker.resume();\n        this.pointer[2] = this.pointer[0];\n        this.pointer[3] = this.pointer[1];\n        this.pointer[0] = x;\n        this.pointer[1] = y;\n        this.dragged = true;\n        this.released = false;\n        this.onDrag(this);\n      }\n    }\n  }\n\n  handleUp() {\n\n    if (!this.grabbed) return;\n\n    this.updateTicker.pause();\n\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n\n    const [ disabledX, disabledY ] = this.disabled;\n    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const [ sx, sy ] = this.snapped;\n    const springX = this.releaseXSpring;\n    const springY = this.releaseYSpring;\n    const releaseEase = this.releaseEase;\n    const hasReleaseSpring = this.hasReleaseSpring;\n    const overshootCoords = this.overshootCoords;\n    const cx = this.x;\n    const cy = this.y;\n    const pv = this.computeVelocity(px1 - px3, py1 - py3);\n    const pa = this.angle = atan2(py1 - py2, px1 - px2);\n    const ds = pv * 150;\n    const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;\n    const nx = cx + (cos(pa) * ds);\n    const ny = cy + (sin(pa) * ds);\n    const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;\n    const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;\n    const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);\n    const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);\n    const ob = this.isOutOfBounds(this.containerBounds, nx, ny);\n\n    let durationX = 0;\n    let durationY = 0;\n    let easeX = releaseEase;\n    let easeY = releaseEase;\n    let longestReleaseDuration = 0;\n\n    overshootCoords.x = cx;\n    overshootCoords.y = cy;\n\n    if (!disabledX) {\n      const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;\n      const distanceX = round(cx - dx, 0);\n      springX.velocity = disabledY && hasReleaseSpring ? distanceX ? (ds * directionX) / abs(distanceX) : 0 : pv;\n      const { ease, duration, restDuration } = springX;\n      durationX = cx === dx ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);\n      if (hasReleaseSpring) easeX = ease;\n      if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;\n    }\n\n    if (!disabledY) {\n      const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;\n      const distanceY = round(cy - dy, 0);\n      springY.velocity = disabledX && hasReleaseSpring ? distanceY ? (ds * directionY) / abs(distanceY) : 0 : pv;\n      const { ease, duration, restDuration } = springY;\n      durationY = cy === dy ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);\n      if (hasReleaseSpring) easeY = ease;\n      if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;\n    }\n\n    if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {\n\n        const composition = compositionTypes.blend;\n\n        new JSAnimation(overshootCoords, {\n          x: { to: bx, duration: durationX * .65 },\n          y: { to: by, duration: durationY * .65 },\n          ease: releaseEase,\n          composition,\n        }).init();\n\n        new JSAnimation(overshootCoords, {\n          x: { to: dx, duration: durationX },\n          y: { to: dy, duration: durationY },\n          ease: releaseEase,\n          composition,\n        }).init();\n\n        this.overshootTicker.stretch(max(durationX, durationY)).restart();\n\n    } else {\n\n      if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);\n      if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);\n\n    }\n\n    this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);\n\n    let hasSnapped = false;\n\n    if (dx !== sx) {\n      this.snapped[0] = dx;\n      if (this.snapX) hasSnapped = true;\n    }\n\n    if (dy !== sy && this.snapY) {\n      this.snapped[1] = dy;\n      if (this.snapY) hasSnapped = true;\n    }\n\n    if (hasSnapped) this.onSnap(this);\n\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = true;\n    this.released = true;\n\n    // It's important to trigger the callback after the release animations to be able to cancel them\n    this.onRelease(this);\n\n    this.$trigger.removeEventListener('touchstart', preventDefault);\n    this.$trigger.removeEventListener('touchmove', preventDefault);\n    this.$trigger.removeEventListener('touchend', preventDefault);\n\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n  }\n\n  reset() {\n    this.stop();\n    this.resizeTicker.pause();\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.coords[0] = 0;\n    this.coords[1] = 0;\n    this.pointer[0] = 0;\n    this.pointer[1] = 0;\n    this.pointer[2] = 0;\n    this.pointer[3] = 0;\n    this.pointer[4] = 0;\n    this.pointer[5] = 0;\n    this.pointer[6] = 0;\n    this.pointer[7] = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    return this;\n  }\n\n  enable() {\n    if (!this.enabled) {\n      this.enabled = true;\n      this.$target.classList.remove('is-disabled');\n      this.touchActionStyles = setTargetValues(this.$trigger, {\n        touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'\n      });\n      this.$trigger.addEventListener('touchstart', this, { passive: true });\n      this.$trigger.addEventListener('mousedown', this, { passive: true });\n      this.$trigger.addEventListener('mouseenter', this);\n    }\n    return this;\n  }\n\n  disable() {\n    this.enabled = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.touchActionStyles.revert();\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    this.$target.classList.add('is-disabled');\n    this.$trigger.removeEventListener('touchstart', this);\n    this.$trigger.removeEventListener('mousedown', this);\n    this.$trigger.removeEventListener('mouseenter', this);\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n    return this;\n  }\n\n  revert() {\n    this.reset();\n    this.disable();\n    this.$target.classList.remove('is-disabled');\n    this.updateTicker.revert();\n    this.overshootTicker.revert();\n    this.resizeTicker.revert();\n    this.animate.revert();\n    this.resizeObserver.disconnect();\n    return this;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'mousedown':\n        this.handleDown(/** @type {MouseEvent} */(e));\n        break;\n      case 'touchstart':\n        this.handleDown(/** @type {TouchEvent} */(e));\n        break;\n      case 'mousemove':\n        this.handleMove(/** @type {MouseEvent} */(e));\n        break;\n      case 'touchmove':\n        this.handleMove(/** @type {TouchEvent} */(e));\n        break;\n      case 'mouseup':\n        this.handleUp();\n        break;\n      case 'touchend':\n        this.handleUp();\n        break;\n      case 'touchcancel':\n        this.handleUp();\n        break;\n      case 'mouseenter':\n        this.handleHover();\n        break;\n      case 'selectstart':\n        preventDefault(e);\n        break;\n    }\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @param {DraggableParams} [parameters]\n * @return {Draggable}\n */\nconst createDraggable = (target, parameters) => new Draggable(target, parameters);\n\n\n\n\nclass Scope {\n  /** @param {ScopeParams} [parameters] */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const rootParam = parameters.root;\n    /** @type {Document|DOMTarget} */\n    let root = doc;\n    if (rootParam) {\n      root = /** @type {ReactRef} */(rootParam).current ||\n             /** @type {AngularRef} */(rootParam).nativeElement ||\n             parseTargets(/** @type {DOMTargetSelector} */(rootParam))[0] ||\n             doc;\n    }\n    const scopeDefaults = parameters.defaults;\n    const globalDefault = globals.defaults;\n    const mediaQueries = parameters.mediaQueries;\n    /** @type {DefaultsParams} */\n    this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;\n    /** @type {Document|DOMTarget} */\n    this.root = root;\n    /** @type {Array<ScopeConstructorCallback>} */\n    this.constructors = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructors = [];\n    /** @type {Array<Revertible>} */\n    this.revertibles = [];\n    /** @type {Array<ScopeConstructorCallback | ((scope: this) => Tickable)>} */\n    this.constructorsOnce = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructorsOnce = [];\n    /** @type {Array<Revertible>} */\n    this.revertiblesOnce = [];\n    /** @type {Boolean} */\n    this.once = false;\n    /** @type {Number} */\n    this.onceIndex = 0;\n    /** @type {Record<String, ScopeMethod>} */\n    this.methods = {};\n    /** @type {Record<String, Boolean>} */\n    this.matches = {};\n    /** @type {Record<String, MediaQueryList>} */\n    this.mediaQueryLists = {};\n    /** @type {Record<String, any>} */\n    this.data = {};\n    if (mediaQueries) {\n      for (let mq in mediaQueries) {\n        const _mq = win.matchMedia(mediaQueries[mq]);\n        this.mediaQueryLists[mq] = _mq;\n        _mq.addEventListener('change', this);\n      }\n    }\n  }\n\n  /**\n   * @param {Revertible} revertible\n   */\n  register(revertible) {\n    const store = this.once ? this.revertiblesOnce : this.revertibles;\n    store.push(revertible);\n  }\n\n  /**\n   * @template T\n   * @param {ScopedCallback<T>} cb\n   * @return {T}\n   */\n  execute(cb) {\n    let activeScope = scope.current;\n    let activeRoot = scope.root;\n    let activeDefaults = globals.defaults;\n    scope.current = this;\n    scope.root = this.root;\n    globals.defaults = this.defaults;\n    const mqs = this.mediaQueryLists;\n    for (let mq in mqs) this.matches[mq] = mqs[mq].matches;\n    const returned = cb(this);\n    scope.current = activeScope;\n    scope.root = activeRoot;\n    globals.defaults = activeDefaults;\n    return returned;\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    this.onceIndex = 0;\n    this.execute(() => {\n      let i = this.revertibles.length;\n      let y = this.revertConstructors.length;\n      while (i--) this.revertibles[i].revert();\n      while (y--) this.revertConstructors[y](this);\n      this.revertibles.length = 0;\n      this.revertConstructors.length = 0;\n      this.constructors.forEach((/** @type {ScopeConstructorCallback} */constructor) => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    });\n    return this;\n  }\n\n  /**\n   * @overload\n   * @param {String} a1\n   * @param {ScopeMethod} a2\n   * @return {this}\n   *\n   * @overload\n   * @param {ScopeConstructorCallback} a1\n   * @return {this}\n   *\n   * @param {String|ScopeConstructorCallback} a1\n   * @param {ScopeMethod} [a2]\n   */\n  add(a1, a2) {\n    this.once = false;\n    if (isFnc(a1)) {\n      const constructor = /** @type {ScopeConstructorCallback} */(a1);\n      this.constructors.push(constructor);\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    } else {\n      this.methods[/** @type {String} */(a1)] = (/** @type {any} */...args) => this.execute(() => a2(...args));\n    }\n    return this;\n  }\n\n  /**\n   * @param {ScopeConstructorCallback} scopeConstructorCallback\n   * @return {this}\n   */\n  addOnce(scopeConstructorCallback) {\n    this.once = true;\n    if (isFnc(scopeConstructorCallback)) {\n      const currentIndex = this.onceIndex++;\n      const tracked = this.constructorsOnce[currentIndex];\n      if (tracked) return this;\n      const constructor = /** @type {ScopeConstructorCallback} */(scopeConstructorCallback);\n      this.constructorsOnce[currentIndex] = constructor;\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructorsOnce.push(revertConstructor);\n        }\n      });\n    }\n    return this;\n  }\n\n  /**\n   * @param  {(scope: this) => Tickable} cb\n   * @return {Tickable}\n   */\n  keepTime(cb) {\n    this.once = true;\n    const currentIndex = this.onceIndex++;\n    const tracked = /** @type {(scope: this) => Tickable} */(this.constructorsOnce[currentIndex]);\n    if (isFnc(tracked)) return tracked(this);\n    const constructor = /** @type {(scope: this) => Tickable} */(createRefreshable(cb));\n    this.constructorsOnce[currentIndex] = constructor;\n    let trackedTickable;\n    this.execute(() => {\n      trackedTickable = constructor(this);\n    });\n    return trackedTickable;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'change':\n        this.refresh();\n        break;\n    }\n  }\n\n  revert() {\n    const revertibles = this.revertibles;\n    const revertConstructors = this.revertConstructors;\n    const revertiblesOnce = this.revertiblesOnce;\n    const revertConstructorsOnce = this.revertConstructorsOnce;\n    const mqs = this.mediaQueryLists;\n    let i = revertibles.length;\n    let j = revertConstructors.length;\n    let k = revertiblesOnce.length;\n    let l = revertConstructorsOnce.length;\n    while (i--) revertibles[i].revert();\n    while (j--) revertConstructors[j](this);\n    while (k--) revertiblesOnce[k].revert();\n    while (l--) revertConstructorsOnce[l](this);\n    for (let mq in mqs) mqs[mq].removeEventListener('change', this);\n    revertibles.length = 0;\n    revertConstructors.length = 0;\n    this.constructors.length = 0;\n    revertiblesOnce.length = 0;\n    revertConstructorsOnce.length = 0;\n    this.constructorsOnce.length = 0;\n    this.onceIndex = 0;\n    this.matches = {};\n    this.methods = {};\n    this.mediaQueryLists = {};\n    this.data = {};\n  }\n}\n\n/**\n * @param {ScopeParams} [params]\n * @return {Scope}\n */\nconst createScope = params => new Scope(params);\n\n/**\n * @return {Number}\n */\nconst getMaxViewHeight = () => {\n  const $el = doc.createElement('div');\n  doc.body.appendChild($el);\n  $el.style.height = '100lvh';\n  const height = $el.offsetHeight;\n  doc.body.removeChild($el);\n  return height;\n};\n\n/**\n * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T\n * @param {T | ((observer: ScrollObserver) => T)} value\n * @param {ScrollObserver} scroller\n * @return {T}\n */\nconst parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */(value)(scroller) : value;\n\nconst scrollContainers = new Map();\n\nclass ScrollContainer {\n  /**\n   * @param {HTMLElement} $el\n   */\n  constructor($el) {\n    /** @type {HTMLElement} */\n    this.element = $el;\n    /** @type {Boolean} */\n    this.useWin = this.element === doc.body;\n    /** @type {Number} */\n    this.winWidth = 0;\n    /** @type {Number} */\n    this.winHeight = 0;\n    /** @type {Number} */\n    this.width = 0;\n    /** @type {Number} */\n    this.height = 0;\n    /** @type {Number} */\n    this.left = 0;\n    /** @type {Number} */\n    this.top = 0;\n    /** @type {Number} */\n    this.zIndex = 0;\n    /** @type {Number} */\n    this.scrollX = 0;\n    /** @type {Number} */\n    this.scrollY = 0;\n    /** @type {Number} */\n    this.prevScrollX = 0;\n    /** @type {Number} */\n    this.prevScrollY = 0;\n    /** @type {Number} */\n    this.scrollWidth = 0;\n    /** @type {Number} */\n    this.scrollHeight = 0;\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Boolean} */\n    this.backwardX = false;\n    /** @type {Boolean} */\n    this.backwardY = false;\n    /** @type {Timer} */\n    this.scrollTicker = new Timer({\n      autoplay: false,\n      onBegin: () => this.dataTimer.resume(),\n      onUpdate: () => {\n        const backwards = this.backwardX || this.backwardY;\n        forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);\n      },\n      onComplete: () => this.dataTimer.pause()\n    }).init();\n    /** @type {Timer} */\n    this.dataTimer = new Timer({\n      autoplay: false,\n      frameRate: 30,\n      onUpdate: self => {\n        const dt = self.deltaTime;\n        const px = this.prevScrollX;\n        const py = this.prevScrollY;\n        const nx = this.scrollX;\n        const ny = this.scrollY;\n        const dx = px - nx;\n        const dy = py - ny;\n        this.prevScrollX = nx;\n        this.prevScrollY = ny;\n        if (dx) this.backwardX = px > nx;\n        if (dy) this.backwardY = py > ny;\n        this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);\n      }\n    }).init();\n    /** @type {Timer} */\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 250 * globals.timeScale,\n      onComplete: () => {\n        this.updateWindowBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n      }\n    }).init();\n    /** @type {Timer} */\n    this.wakeTicker = new Timer({\n      autoplay: false,\n      duration: 500 * globals.timeScale,\n      onBegin: () => {\n        this.scrollTicker.resume();\n      },\n      onComplete: () => {\n        this.scrollTicker.pause();\n      }\n    }).init();\n    /** @type {ScrollObserver} */\n    this._head = null;\n    /** @type {ScrollObserver} */\n    this._tail = null;\n    this.updateScrollCoords();\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n    this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());\n    this.resizeObserver.observe(this.element);\n    (this.useWin ? win : this.element).addEventListener('scroll', this, false);\n  }\n\n  updateScrollCoords() {\n    const useWin = this.useWin;\n    const $el = this.element;\n    this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);\n    this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);\n  }\n\n  updateWindowBounds() {\n    this.winWidth = win.innerWidth;\n    this.winHeight = getMaxViewHeight();\n  }\n\n  updateBounds() {\n    const style = getComputedStyle(this.element);\n    const $el = this.element;\n    this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    this.updateWindowBounds();\n    let width, height;\n    if (this.useWin) {\n      width = this.winWidth;\n      height = this.winHeight;\n    } else {\n      const elRect = $el.getBoundingClientRect();\n      width = $el.clientWidth;\n      height = $el.clientHeight;\n      this.top = elRect.top;\n      this.left = elRect.left;\n    }\n    this.width = width;\n    this.height = height;\n  }\n\n  refreshScrollObservers() {\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      if (child._debug) {\n        child.removeDebug();\n      }\n    });\n    this.updateBounds();\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      child.refresh();\n      if (child._debug) {\n        child.debug();\n      }\n    });\n  }\n\n  refresh() {\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n  }\n\n  handleScroll() {\n    this.updateScrollCoords();\n    this.wakeTicker.restart();\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'scroll':\n        this.handleScroll();\n        break;\n    }\n  }\n\n  revert() {\n    this.scrollTicker.cancel();\n    this.dataTimer.cancel();\n    this.resizeTicker.cancel();\n    this.wakeTicker.cancel();\n    this.resizeObserver.disconnect();\n    (this.useWin ? win : this.element).removeEventListener('scroll', this);\n    scrollContainers.delete(this.element);\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @return {ScrollContainer}\n */\nconst registerAndGetScrollContainer = target => {\n  const $el = /** @type {HTMLElement} */(target ? parseTargets(target)[0] || doc.body : doc.body);\n  let scrollContainer = scrollContainers.get($el);\n  if (!scrollContainer) {\n    scrollContainer = new ScrollContainer($el);\n    scrollContainers.set($el, scrollContainer);\n  }\n  return scrollContainer;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number|string} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst convertValueToPx = ($el, v, size, under, over) => {\n  const clampMin = v === 'min';\n  const clampMax = v === 'max';\n  const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 :\n                v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' :\n                v === 'center' ? '50%' :\n                v;\n  const { n, u } = decomposeRawValue(value, decomposedOriginalValue);\n  let px = n;\n  if (u === '%') {\n    px = (n / 100) * size;\n  } else if (u) {\n    px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;\n  }\n  if (clampMax && under < 0) px += under;\n  if (clampMin && over > 0) px += over;\n  return px;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {ScrollThresholdValue} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst parseBoundValue = ($el, v, size, under, over) => {\n  /** @type {Number} */\n  let value;\n  if (isStr(v)) {\n    const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */(v));\n    if (matchedOperator) {\n      const splitter = matchedOperator[0];\n      const operator = splitter[0];\n      const splitted = /** @type {String} */(v).split(splitter);\n      const clampMin = splitted[0] === 'min';\n      const clampMax = splitted[0] === 'max';\n      const valueAPx = convertValueToPx($el, splitted[0], size, under, over);\n      const valueBPx = convertValueToPx($el, splitted[1], size, under, over);\n      if (clampMin) {\n        const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);\n        value = min < valueAPx ? valueAPx : min;\n      } else if (clampMax) {\n        const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);\n        value = max > valueAPx ? valueAPx : max;\n      } else {\n        value = getRelativeValue(valueAPx, valueBPx, operator);\n      }\n    } else {\n      value = convertValueToPx($el, v, size, under, over);\n    }\n  } else {\n    value = /** @type {Number} */(v);\n  }\n  return round(value, 0);\n};\n\n/**\n * @param {JSAnimation} linked\n * @return {HTMLElement}\n */\nconst getAnimationDomTarget = linked => {\n  let $linkedTarget;\n  const linkedTargets = linked.targets;\n  for (let i = 0, l = linkedTargets.length; i < l; i++) {\n    const target = linkedTargets[i];\n    if (target[isDomSymbol]) {\n      $linkedTarget = /** @type {HTMLElement} */(target);\n      break;\n    }\n  }\n  return $linkedTarget;\n};\n\nlet scrollerIndex = 0;\n\nconst debugColors$1 = ['#FF4B4B','#FF971B','#FFC730','#F9F640','#7AFF5A','#18FF74','#17E09B','#3CFFEC','#05DBE9','#33B3F1','#638CF9','#C563FE','#FF4FCF','#F93F8A'];\n\nclass ScrollObserver {\n  /**\n   * @param {ScrollObserverParams} parameters\n   */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const syncMode = setValue(parameters.sync, 'play pause');\n    const ease = syncMode ? parseEasings(/** @type {EasingParam} */(syncMode)) : null;\n    const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);\n    const isEase = syncMode && !(ease === none && !isLinear);\n    const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);\n    const isMethods = syncMode && (isStr(syncMode) && !isEase && !isSmooth);\n    const syncMethods = isMethods ? /** @type {String} */(syncMode).split(' ').map(\n      (/** @type {String} */m) => () => {\n        const linked = this.linked;\n        return linked && linked[m] ? linked[m]() : null;\n      }\n    ) : null;\n    const biDirSync = isMethods && syncMethods.length > 2;\n    /** @type {Number} */\n    this.index = scrollerIndex++;\n    /** @type {String|Number} */\n    this.id = !isUnd(parameters.id) ? parameters.id : this.index;\n    /** @type {ScrollContainer} */\n    this.container = registerAndGetScrollContainer(parameters.container);\n    /** @type {HTMLElement} */\n    this.target = null;\n    /** @type {Tickable|WAAPIAnimation} */\n    this.linked = null;\n    /** @type {Boolean} */\n    this.repeat = null;\n    /** @type {Boolean} */\n    this.horizontal = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.enter = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.leave = null;\n    /** @type {Boolean} */\n    this.sync = isEase || isSmooth || !!syncMethods;\n    /** @type {EasingFunction} */\n    this.syncEase = isEase ? ease : null;\n    /** @type {Number} */\n    this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */(syncMode) : null;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnter = parameters.onEnter || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeave = parameters.onLeave || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterForward = parameters.onEnterForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveForward = parameters.onLeaveForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterBackward = parameters.onEnterBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveBackward = parameters.onLeaveBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncComplete = parameters.onSyncComplete || noop;\n    /** @type {Boolean} */\n    this.reverted = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.isInView = false;\n    /** @type {Boolean} */\n    this.forceEnter = false;\n    /** @type {Boolean} */\n    this.hasEntered = false;\n    /** @type {Boolean} */\n    this.isReady = false;\n    // /** @type {Array.<Number>} */\n    // this.offsets = [];\n    /** @type {Number} */\n    this.offset = 0;\n    /** @type {Number} */\n    this.offsetStart = 0;\n    /** @type {Number} */\n    this.offsetEnd = 0;\n    /** @type {Number} */\n    this.distance = 0;\n    /** @type {Number} */\n    this.prevProgress = 0;\n    /** @type {Array} */\n    this.thresholds = ['start', 'end', 'end', 'start'];\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [0, 0, 0, 0];\n    /** @type {JSAnimation} */\n    this.debugStyles = null;\n    /** @type {HTMLElement} */\n    this.$debug = null;\n    /** @type {ScrollObserverParams} */\n    this._params = parameters;\n    /** @type {Boolean} */\n    this._debug = setValue(parameters.debug, false);\n    /** @type {ScrollObserver} */\n    this._next = null;\n    /** @type {ScrollObserver} */\n    this._prev = null;\n    addChild(this.container, this);\n    // Wait for the next frame to add to the container in order to handle calls to link()\n    sync(() => {\n      if (this.reverted) return;\n      if (!this.target) {\n        const target = /** @type {HTMLElement} */(parseTargets(parameters.target)[0]);\n        this.target = target || doc.body;\n        this.refresh();\n      }\n      if (this._debug) this.debug();\n    });\n  }\n\n  /**\n   * @param {Tickable|WAAPIAnimation} linked\n   */\n  link(linked) {\n    if (linked) {\n      // Make sure to pause the linked object in case it's added later\n      linked.pause();\n      this.linked = linked;\n      // Try to use a target of the linked object if no target parameters specified\n      if (!this._params.target) {\n        /** @type {HTMLElement} */\n        let $linkedTarget;\n        if (!isUnd(/** @type {JSAnimation} */(linked).targets)) {\n          $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(linked));\n        } else {\n          forEachChildren(/** @type {Timeline} */(linked), (/** @type {JSAnimation} */child) => {\n            if (child.targets && !$linkedTarget) {\n              $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(child));\n            }\n          });\n        }\n        // Fallback to body if no target found\n        this.target = $linkedTarget || doc.body;\n        this.refresh();\n      }\n    }\n    return this;\n  }\n\n  get velocity() {\n    return this.container.velocity;\n  }\n\n  get backward() {\n    return this.horizontal ? this.container.backwardX : this.container.backwardY;\n  }\n\n  get scroll() {\n    return this.horizontal ? this.container.scrollX : this.container.scrollY;\n  }\n\n  get progress() {\n    const p = (this.scroll - this.offsetStart) / this.distance;\n    return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);\n  }\n\n  refresh() {\n    // This flag is used to prevent running handleScroll() outside of this.refresh() with values not calculated\n    this.isReady = true;\n    this.reverted = false;\n    const params = this._params;\n    this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);\n    this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';\n    this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');\n    this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');\n    this.updateBounds();\n    this.handleScroll();\n    return this;\n  }\n\n  removeDebug() {\n    if (this.$debug) {\n      this.$debug.parentNode.removeChild(this.$debug);\n      this.$debug = null;\n    }\n    if (this.debugStyles) {\n      this.debugStyles.revert();\n      this.$debug = null;\n    }\n    return this;\n  }\n\n  debug() {\n    this.removeDebug();\n    const container = this.container;\n    const isHori = this.horizontal;\n    const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');\n    const $debug = doc.createElement('div');\n    const $thresholds = doc.createElement('div');\n    const $triggers = doc.createElement('div');\n    const color = debugColors$1[this.index % debugColors$1.length];\n    const useWin = container.useWin;\n    const containerWidth = useWin ? container.winWidth : container.width;\n    const containerHeight = useWin ? container.winHeight : container.height;\n    const scrollWidth = container.scrollWidth;\n    const scrollHeight = container.scrollHeight;\n    const size = this.container.width > 360 ? 320 : 260;\n    const offLeft = isHori ? 0 : 10;\n    const offTop = isHori ? 10 : 0;\n    const half = isHori ? 24 : size / 2;\n    const labelHeight = isHori ? half : 15;\n    const labelWidth = isHori ? 60 : half;\n    const labelSize = isHori ? labelWidth : labelHeight;\n    const repeat = isHori ? 'repeat-x' : 'repeat-y';\n    /**\n     * @param {Number} v\n     * @return {String}\n     */\n    const gradientOffset = v => isHori ? '0px '+(v)+'px' : (v)+'px'+' 2px';\n    /**\n     * @param {String} c\n     * @return {String}\n     */\n    const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;\n    /**\n     * @param {String} p\n     * @param {Number} l\n     * @param {Number} t\n     * @param {Number} w\n     * @param {Number} h\n     * @return {String}\n     */\n    const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;\n    $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${isHori ? 'column' : 'row'};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `;\n    $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;\n    if (!$existingDebug) {\n      $thresholds.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(half-10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(half-10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};\n      `;\n    }\n    $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;\n    if (!$existingDebug) {\n      $triggers.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};\n      `;\n    }\n    const labels = [' enter: ', ' leave: '];\n    this.coords.forEach((v, i) => {\n      const isView = i > 1;\n      const value = (isView ? 0 : this.offset) + v;\n      const isTail = i % 2;\n      const isFirst = value < labelSize;\n      const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;\n      const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;\n      const $label = doc.createElement('div');\n      const $text = doc.createElement('div');\n      const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';\n      const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;\n      // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;\n      $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;\n      $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}\n        display: flex;\n        flex-direction: ${isHori ? 'column' : 'row'};\n        justify-content: flex-${isView ? 'start' : 'end'};\n        align-items: flex-${isFlip ? 'end' : 'start'};\n        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};\n      `;\n      $text.style.cssText = `\n        overflow: hidden;\n        max-width: ${(size / 2) - 10}px;\n        height: ${labelHeight};\n        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${isTail ? color : 'rgba(0,0,0,.75)'};\n        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};\n        border: 2px solid ${isTail ? color : 'transparent'};\n        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;\n        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;\n      `;\n      $label.appendChild($text);\n      let position = value - flipOffset + (isHori ? 1 : 0);\n      $label.style[isHori ? 'left' : 'top'] = `${position}px`;\n      // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';\n      (isView ? $thresholds : $triggers).appendChild($label);\n    });\n\n    $debug.appendChild($thresholds);\n    $debug.appendChild($triggers);\n    container.element.appendChild($debug);\n\n    if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');\n    this.$debug = $debug;\n    const containerPosition = getTargetValue(container.element, 'position');\n    if (containerPosition === 'static') {\n      this.debugStyles = setTargetValues(container.element, { position: 'relative '});\n    }\n\n  }\n\n  updateBounds() {\n    if (this._debug) {\n      this.removeDebug();\n    }\n    let stickys;\n    const $target = this.target;\n    const container = this.container;\n    const isHori = this.horizontal;\n    const linked = this.linked;\n    let linkedTime;\n    let $el = $target;\n    // let offsetX = 0;\n    // let offsetY = 0;\n    // let $offsetParent = $el;\n    /** @type {Element} */\n    if (linked) {\n      linkedTime = linked.currentTime;\n      linked.seek(0, true);\n    }\n    /* Old implementation to get offset and targetSize before fixing https://github.com/juliangarnier/anime/issues/1021\n    // const isContainerStatic = getTargetValue(container.element, 'position') === 'static' ? setTargetValues(container.element, { position: 'relative '}) : false;\n    // while ($el && $el !== container.element && $el !== doc.body) {\n    //   const isSticky = getTargetValue($el, 'position') === 'sticky' ?\n    //                    setTargetValues($el, { position: 'static' }) :\n    //                    false;\n    //   if ($el === $offsetParent) {\n    //     offsetX += $el.offsetLeft || 0;\n    //     offsetY += $el.offsetTop || 0;\n    //     $offsetParent = $el.offsetParent;\n    //   }\n    //   $el = /** @type {HTMLElement} */($el.parentElement);\n    //   if (isSticky) {\n    //     if (!stickys) stickys = [];\n    //     stickys.push(isSticky);\n    //   }\n    // }\n    // if (isContainerStatic) isContainerStatic.revert();\n    // const offset = isHori ? offsetX : offsetY;\n    // const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;\n\n    while ($el && $el !== container.element && $el !== doc.body) {\n      const isSticky = getTargetValue($el, 'position') === 'sticky' ? setTargetValues($el, { position: 'static' }) : false;\n      $el = $el.parentElement;\n      if (isSticky) {\n        if (!stickys) stickys = [];\n        stickys.push(isSticky);\n      }\n    }\n    const rect = $target.getBoundingClientRect();\n    const offset = isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top;\n    const targetSize = isHori ? rect.width : rect.height;\n    const containerSize = isHori ? container.width : container.height;\n    const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;\n    const maxScroll = scrollSize - containerSize;\n    const enter = this.enter;\n    const leave = this.leave;\n\n    /** @type {ScrollThresholdValue} */\n    let enterTarget = 'start';\n    /** @type {ScrollThresholdValue} */\n    let leaveTarget = 'end';\n    /** @type {ScrollThresholdValue} */\n    let enterContainer = 'end';\n    /** @type {ScrollThresholdValue} */\n    let leaveContainer = 'start';\n\n    if (isStr(enter)) {\n      const splitted = /** @type {String} */(enter).split(' ');\n      enterContainer = splitted[0];\n      enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;\n    } else if (isObj(enter)) {\n      const e = /** @type {ScrollThresholdParam} */(enter);\n      if (!isUnd(e.container)) enterContainer = e.container;\n      if (!isUnd(e.target)) enterTarget = e.target;\n    } else if (isNum(enter)) {\n      enterContainer = /** @type {Number} */(enter);\n    }\n\n    if (isStr(leave)) {\n      const splitted = /** @type {String} */(leave).split(' ');\n      leaveContainer = splitted[0];\n      leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;\n    } else if (isObj(leave)) {\n      const t = /** @type {ScrollThresholdParam} */(leave);\n      if (!isUnd(t.container)) leaveContainer = t.container;\n      if (!isUnd(t.target)) leaveTarget = t.target;\n    } else if (isNum(leave)) {\n      leaveContainer = /** @type {Number} */(leave);\n    }\n\n    const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);\n    const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);\n    const under = (parsedEnterTarget + offset) - containerSize;\n    const over = (parsedLeaveTarget + offset) - maxScroll;\n    const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);\n    const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);\n    const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;\n    const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;\n    const scrollDelta = offsetEnd - offsetStart;\n    // this.offsets[0] = offsetX;\n    // this.offsets[1] = offsetY;\n    this.offset = offset;\n    this.offsetStart = offsetStart;\n    this.offsetEnd = offsetEnd;\n    this.distance = scrollDelta <= 0 ? 0 : scrollDelta;\n    this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];\n    this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];\n    if (stickys) {\n      stickys.forEach(sticky => sticky.revert());\n    }\n    if (linked) {\n      linked.seek(linkedTime, true);\n    }\n    if (this._debug) {\n      this.debug();\n    }\n  }\n\n  handleScroll() {\n    if (!this.isReady) return;\n    const linked = this.linked;\n    const sync = this.sync;\n    const syncEase = this.syncEase;\n    const syncSmooth = this.syncSmooth;\n    const shouldSeek = linked && (syncEase || syncSmooth);\n    const isHori = this.horizontal;\n    const container = this.container;\n    const scroll = this.scroll;\n    const isBefore = scroll <= this.offsetStart;\n    const isAfter = scroll >= this.offsetEnd;\n    const isInView = !isBefore && !isAfter;\n    const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;\n    const forceEnter = !this.hasEntered && isOnTheEdge;\n    const $debug = this._debug && this.$debug;\n    let hasUpdated = false;\n    let syncCompleted = false;\n    let p = this.progress;\n\n    if (isBefore && this.began) {\n      this.began = false;\n    }\n\n    if (p > 0 && !this.began) {\n      this.began = true;\n    }\n\n    if (shouldSeek) {\n      const lp = linked.progress;\n      if (syncSmooth && isNum(syncSmooth)) {\n        if (/** @type {Number} */(syncSmooth) < 1) {\n          const step = 0.0001;\n          const snap = lp < p && p === 1 ? step : lp > p && !p ? -step : 0;\n          p = round(lerp(lp, p, interpolate(.01, .2, /** @type {Number} */(syncSmooth)), false) + snap, 6);\n        }\n      } else if (syncEase) {\n        p = syncEase(p);\n      }\n      hasUpdated = p !== this.prevProgress;\n      syncCompleted = lp === 1;\n      if (hasUpdated && !syncCompleted && (syncSmooth && lp)) {\n        container.wakeTicker.restart();\n      }\n    }\n\n    if ($debug) {\n      const sticky = isHori ? container.scrollY : container.scrollX;\n      $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';\n    }\n\n    // Trigger enter callbacks if already in view or when entering the view\n    if ((isInView && !this.isInView) || (forceEnter && !this.forceEnter && !this.hasEntered)) {\n      if (isInView) this.isInView = true;\n      if (!this.forceEnter || !this.hasEntered) {\n        if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;\n        this.onSyncEnter(this);\n        this.onEnter(this);\n        if (this.backward) {\n          this.onSyncEnterBackward(this);\n          this.onEnterBackward(this);\n        } else {\n          this.onSyncEnterForward(this);\n          this.onEnterForward(this);\n        }\n        this.hasEntered = true;\n        if (forceEnter) this.forceEnter = true;\n      } else if (isInView) {\n        this.forceEnter = false;\n      }\n    }\n\n    if (isInView || !isInView && this.isInView) {\n      hasUpdated = true;\n    }\n\n    if (hasUpdated) {\n      if (shouldSeek) linked.seek(linked.duration * p);\n      this.onUpdate(this);\n    }\n\n    if (!isInView && this.isInView) {\n      this.isInView = false;\n      this.onSyncLeave(this);\n      this.onLeave(this);\n      if (this.backward) {\n        this.onSyncLeaveBackward(this);\n        this.onLeaveBackward(this);\n      } else {\n        this.onSyncLeaveForward(this);\n        this.onLeaveForward(this);\n      }\n      if (sync && !syncSmooth) {\n        syncCompleted = true;\n      }\n    }\n\n    if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {\n      if (sync) {\n        this.onSyncComplete(this);\n      }\n      this.completed = true;\n      if ((!this.repeat && !linked) || (!this.repeat && linked && linked.completed)) {\n        this.revert();\n      }\n    }\n\n    if (p < 1 && this.completed) {\n      this.completed = false;\n    }\n\n    this.prevProgress = p;\n  }\n\n  revert() {\n    if (this.reverted) return;\n    const container = this.container;\n    removeChild(container, this);\n    if (!container._head) {\n      container.revert();\n    }\n    if (this._debug) {\n      this.removeDebug();\n    }\n    this.reverted = true;\n    this.isReady = false;\n    return this;\n  }\n\n}\n\n/**\n * @param {ScrollObserverParams} [parameters={}]\n * @return {ScrollObserver}\n */\nconst onScroll = (parameters = {}) => new ScrollObserver(parameters);\n\n\n\n\nconst segmenter = (typeof Intl !== 'undefined') && Intl.Segmenter;\nconst valueRgx = /\\{value\\}/g;\nconst indexRgx = /\\{i\\}/g;\nconst whiteSpaceGroupRgx = /(\\s+)/;\nconst whiteSpaceRgx = /^\\s+$/;\nconst lineType = 'line';\nconst wordType = 'word';\nconst charType = 'char';\nconst dataLine = `data-line`;\n\n/**\n * @typedef {Object} Segment\n * @property {String} segment\n * @property {Boolean} [isWordLike]\n */\n\n/**\n * @typedef {Object} Segmenter\n * @property {function(String): Iterable<Segment>} segment\n */\n\n/** @type {Segmenter} */\nlet wordSegmenter = null;\n/** @type {Segmenter} */\nlet graphemeSegmenter = null;\nlet $splitTemplate = null;\n\n/**\n * @param  {Segment} seg\n * @return {Boolean}\n */\nconst isSegmentWordLike = seg => {\n  return seg.isWordLike ||\n         seg.segment === ' ' || // Consider spaces as words first, then handle them diffrently later\n         isNum(+seg.segment); // Safari doesn't considers numbers as words\n};\n\n/**\n * @param {HTMLElement} $el\n */\nconst setAriaHidden = $el => $el.setAttribute('aria-hidden', 'true');\n\n/**\n * @param {DOMTarget} $el\n * @param {String} type\n * @return {Array<HTMLElement>}\n */\nconst getAllTopLevelElements = ($el, type) => [.../** @type {*} */($el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`))];\n\nconst debugColors = { line: '#00D672', word: '#FF4B4B', char: '#5A87FF' };\n\n/**\n * @param {HTMLElement} $el\n */\nconst filterEmptyElements = $el => {\n  if (!$el.childElementCount && !$el.textContent.trim()) {\n    const $parent = $el.parentElement;\n    $el.remove();\n    if ($parent) filterEmptyElements($parent);\n  }\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number} lineIndex\n * @param {Set<HTMLElement>} bin\n * @returns {Set<HTMLElement>}\n */\nconst filterLineElements = ($el, lineIndex, bin) => {\n  const dataLineAttr = $el.getAttribute(dataLine);\n  if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === 'BR') bin.add($el);\n  let i = $el.childElementCount;\n  while (i--) filterLineElements(/** @type {HTMLElement} */($el.children[i]), lineIndex, bin);\n  return bin;\n};\n\n/**\n * @param  {'line'|'word'|'char'} type\n * @param  {splitTemplateParams} params\n * @return {String}\n */\nconst generateTemplate = (type, params = {}) => {\n  let template = ``;\n  const classString = isStr(params.class) ? ` class=\"${params.class}\"` : '';\n  const cloneType = setValue(params.clone, false);\n  const wrapType = setValue(params.wrap, false);\n  const overflow = wrapType ? wrapType === true ? 'clip' : wrapType : cloneType ? 'clip' : false;\n  if (wrapType) template += `<span${overflow ? ` style=\"overflow:${overflow};\"` : ''}>`;\n  template += `<span${classString}${cloneType ? ` style=\"position:relative;\"` : ''} data-${type}=\"{i}\">`;\n  if (cloneType) {\n    const left = cloneType === 'left' ? '-100%' : cloneType === 'right' ? '100%' : '0';\n    const top = cloneType === 'top' ? '-100%' : cloneType === 'bottom' ? '100%' : '0';\n    template += `<span>{value}</span>`;\n    template += `<span inert style=\"position:absolute;top:${top};left:${left};white-space:nowrap;\">{value}</span>`;\n  } else {\n    template += `{value}`;\n  }\n  template += `</span>`;\n  if (wrapType) template += `</span>`;\n  return template;\n};\n\n/**\n * @param  {String|SplitFunctionValue} htmlTemplate\n * @param  {Array<HTMLElement>} store\n * @param  {Node|HTMLElement} node\n * @param  {DocumentFragment} $parentFragment\n * @param  {'line'|'word'|'char'} type\n * @param  {Boolean} debug\n * @param  {Number} lineIndex\n * @param  {Number} [wordIndex]\n * @param  {Number} [charIndex]\n * @return {HTMLElement}\n */\nconst processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {\n  const isLine = type === lineType;\n  const isChar = type === charType;\n  const className = `_${type}_`;\n  const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;\n  const displayStyle = isLine ? 'block' : 'inline-block';\n  $splitTemplate.innerHTML = template\n    .replace(valueRgx, `<i class=\"${className}\"></i>`)\n    .replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);\n  const $content = $splitTemplate.content;\n  const $highestParent = /** @type {HTMLElement} */($content.firstElementChild);\n  const $split = /** @type {HTMLElement} */($content.querySelector(`[data-${type}]`)) || $highestParent;\n  const $replacables = /** @type {NodeListOf<HTMLElement>} */($content.querySelectorAll(`i.${className}`));\n  const replacablesLength = $replacables.length;\n  if (replacablesLength) {\n    $highestParent.style.display = displayStyle;\n    $split.style.display = displayStyle;\n    $split.setAttribute(dataLine, `${lineIndex}`);\n    if (!isLine) {\n      $split.setAttribute('data-word', `${wordIndex}`);\n      if (isChar) $split.setAttribute('data-char', `${charIndex}`);\n    }\n    let i = replacablesLength;\n    while (i--) {\n      const $replace = $replacables[i];\n      const $closestParent = $replace.parentElement;\n      $closestParent.style.display = displayStyle;\n      if (isLine) {\n        $closestParent.innerHTML = /** @type {HTMLElement} */(node).innerHTML;\n      } else {\n        $closestParent.replaceChild(node.cloneNode(true), $replace);\n      }\n    }\n    store.push($split);\n    $parentFragment.appendChild($content);\n  } else {\n    console.warn(`The expression \"{value}\" is missing from the provided template.`);\n  }\n  if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;\n  return $highestParent;\n};\n\n/**\n * A class that splits text into words and wraps them in span elements while preserving the original HTML structure.\n * @class\n */\nclass TextSplitter {\n  /**\n   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n   * @param  {TextSplitterParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    // Only init segmenters when needed\n    if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], { granularity: wordType }) : {\n      segment: (text) => {\n        const segments = [];\n        const words = text.split(whiteSpaceGroupRgx);\n        for (let i = 0, l = words.length; i < l; i++) {\n          const segment = words[i];\n          segments.push({\n            segment,\n            isWordLike: !whiteSpaceRgx.test(segment), // Consider non-whitespace as word-like\n          });\n        }\n        return segments;\n      }\n    };\n    if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], { granularity: 'grapheme' }) : {\n      segment: text => [...text].map(char => ({ segment: char }))\n    };\n    if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement('template');\n    if (scope.current) scope.current.register(this);\n    const { words, chars, lines, accessible, includeSpaces, debug } = parameters;\n    const $target = /** @type {HTMLElement} */((target = isArr(target) ? target[0] : target) && /** @type {Node} */(target).nodeType ? target : (getNodeList(target) || [])[0]);\n    const lineParams = lines === true ? {} : lines;\n    const wordParams = words === true || isUnd(words) ? {} : words;\n    const charParams = chars === true ? {} : chars;\n    this.debug = setValue(debug, false);\n    this.includeSpaces = setValue(includeSpaces, false);\n    this.accessible = setValue(accessible, true);\n    this.linesOnly = lineParams && (!wordParams && !charParams);\n    /** @type {String|false|SplitFunctionValue} */\n    this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, /** @type {splitTemplateParams} */(lineParams)) : lineParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, /** @type {splitTemplateParams} */(wordParams)) : wordParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.charTemplate = isObj(charParams) ? generateTemplate(charType, /** @type {splitTemplateParams} */(charParams)) : charParams;\n    this.$target = $target;\n    this.html = $target && $target.innerHTML;\n    this.lines = [];\n    this.words = [];\n    this.chars = [];\n    this.effects = [];\n    this.effectsCleanups = [];\n    this.cache = null;\n    this.ready = false;\n    this.width = 0;\n    this.resizeTimeout = null;\n    const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();\n    // Make sure this is declared before calling handleSplit() in case revert() is called inside an effect callback\n    this.resizeObserver = new ResizeObserver(() => {\n      // Use a setTimeout instead of a Timer for better tree shaking\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = setTimeout(() => {\n        const currentWidth = /** @type {HTMLElement} */($target).offsetWidth;\n        if (currentWidth === this.width) return;\n        this.width = currentWidth;\n        handleSplit();\n      }, 150);\n    });\n    // Only declare the font ready promise when splitting by lines and not alreay split\n    if (this.lineTemplate && !this.ready) {\n      doc.fonts.ready.then(handleSplit);\n    } else {\n      handleSplit();\n    }\n    $target ? this.resizeObserver.observe($target) : console.warn('No Text Splitter target found.');\n  }\n\n  /**\n   * @param  {(...args: any[]) => Tickable | (() => void)} effect\n   * @return this\n   */\n  addEffect(effect) {\n    if (!isFnc(effect)) return console.warn('Effect must return a function.');\n    const refreshableEffect = createRefreshable(effect);\n    this.effects.push(refreshableEffect);\n    if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);\n    return this;\n  }\n\n  revert() {\n    clearTimeout(this.resizeTimeout);\n    this.lines.length = this.words.length = this.chars.length = 0;\n    this.resizeObserver.disconnect();\n    // Make sure to revert the effects after disconnecting the resizeObserver to avoid triggering it in the process\n    this.effectsCleanups.forEach(cleanup => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());\n    this.$target.innerHTML = this.html;\n    return this;\n  }\n\n  /**\n   * Recursively processes a node and its children\n   * @param {Node} node\n   */\n  splitNode(node) {\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const includeSpaces = this.includeSpaces;\n    const debug = this.debug;\n    const nodeType = node.nodeType;\n    if (nodeType === 3) {\n      const nodeText = node.nodeValue;\n      // If the nodeText is only whitespace, leave it as is\n      if (nodeText.trim()) {\n        const tempWords = [];\n        const words = this.words;\n        const chars = this.chars;\n        const wordSegments = wordSegmenter.segment(nodeText);\n        const $wordsFragment = doc.createDocumentFragment();\n        let prevSeg = null;\n        for (const wordSegment of wordSegments) {\n          const segment = wordSegment.segment;\n          const isWordLike = isSegmentWordLike(wordSegment);\n          // Determine if this segment should be a new word, first segment always becomes a new word\n          if (!prevSeg || (isWordLike && (prevSeg && (isSegmentWordLike(prevSeg))))) {\n            tempWords.push(segment);\n          } else {\n            // Only concatenate if both current and previous are non-word-like and don't contain spaces\n            const lastWordIndex = tempWords.length - 1;\n            const lastWord = tempWords[lastWordIndex];\n            if (!lastWord.includes(' ') && !segment.includes(' ')) {\n              tempWords[lastWordIndex] += segment;\n            } else {\n              tempWords.push(segment);\n            }\n          }\n          prevSeg = wordSegment;\n        }\n\n        for (let i = 0, l = tempWords.length; i < l; i++) {\n          const word = tempWords[i];\n          if (!word.trim()) {\n            // Preserve whitespace only if includeSpaces is false and if the current space is not the first node\n            if (i && includeSpaces) continue;\n            $wordsFragment.appendChild(doc.createTextNode(word));\n          } else {\n            const nextWord = tempWords[i + 1];\n            const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();\n            const wordToProcess = word;\n            const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;\n            const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + '\\xa0' : word);\n            if (charTemplate) {\n              const charSegmentsArray = [...charSegments];\n              for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {\n                const charSegment = charSegmentsArray[j];\n                const isLastChar = j === jl - 1;\n                // If this is the last character and includeSpaces is true with a following space, append the space\n                const charText = isLastChar && hasWordFollowingSpace ? charSegment.segment + '\\xa0' : charSegment.segment;\n                const $charNode = doc.createTextNode(charText);\n                processHTMLTemplate(charTemplate, chars, $charNode, /** @type {DocumentFragment} */($charsFragment), charType, debug, -1, words.length, chars.length);\n              }\n            }\n            if (wordTemplate) {\n              processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);\n              // Chars elements must be re-parsed in the split() method if both words and chars are parsed\n            } else if (charTemplate) {\n              $wordsFragment.appendChild($charsFragment);\n            } else {\n              $wordsFragment.appendChild(doc.createTextNode(word));\n            }\n            // Skip the next iteration if we included a space\n            if (hasWordFollowingSpace) i++;\n          }\n        }\n        node.parentNode.replaceChild($wordsFragment, node);\n      }\n    } else if (nodeType === 1) {\n      // Converting to an array is necessary to work around childNodes pottential mutation\n      const childNodes = /** @type {Array<Node>} */([.../** @type {*} */(node.childNodes)]);\n      for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);\n    }\n  }\n\n  /**\n   * @param {Boolean} clearCache\n   * @return {this}\n   */\n  split(clearCache = false) {\n    const $el = this.$target;\n    const isCached = !!this.cache && !clearCache;\n    const lineTemplate = this.lineTemplate;\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const fontsReady = doc.fonts.status !== 'loading';\n    const canSplitLines = lineTemplate && fontsReady;\n    this.ready = !lineTemplate || fontsReady;\n    if (canSplitLines || clearCache) {\n      // No need to revert effects animations here since it's already taken care by the refreshable\n      this.effectsCleanups.forEach(cleanup => isFnc(cleanup) && cleanup(this));\n    }\n    if (!isCached) {\n      if (clearCache) {\n        $el.innerHTML = this.html;\n        this.words.length = this.chars.length = 0;\n      }\n      this.splitNode($el);\n      this.cache = $el.innerHTML;\n    }\n    if (canSplitLines) {\n      if (isCached) $el.innerHTML = this.cache;\n      this.lines.length = 0;\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n    }\n    // Always reparse characters after a line reset or if both words and chars are activated\n    if (charTemplate && (canSplitLines || wordTemplate)) {\n      this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Words are used when lines only and prioritized over chars\n    const elementsArray = this.words.length ? this.words : this.chars;\n    let y, linesCount = 0;\n    for (let i = 0, l = elementsArray.length; i < l; i++) {\n      const $el = elementsArray[i];\n      const { top, height } = $el.getBoundingClientRect();\n      if (y && top - y > height * .5) linesCount++;\n      $el.setAttribute(dataLine, `${linesCount}`);\n      const nested = $el.querySelectorAll(`[${dataLine}]`);\n      let c = nested.length;\n      while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);\n      y = top;\n    }\n    if (canSplitLines) {\n      const linesFragment = doc.createDocumentFragment();\n      const parents = new Set();\n      const clones = [];\n      for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {\n        const $clone = /** @type {HTMLElement} */($el.cloneNode(true));\n        filterLineElements($clone, lineIndex, new Set()).forEach($el => {\n          const $parent = $el.parentElement;\n          if ($parent) parents.add($parent);\n          $el.remove();\n        });\n        clones.push($clone);\n      }\n      parents.forEach(filterEmptyElements);\n      for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) {\n        processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);\n      }\n      $el.innerHTML = '';\n      $el.appendChild(linesFragment);\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n      if (charTemplate) this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Remove the word wrappers and clear the words array if lines split only\n    if (this.linesOnly) {\n      const words = this.words;\n      let w = words.length;\n      while (w--) {\n        const $word = words[w];\n        $word.replaceWith($word.textContent);\n      }\n      words.length = 0;\n    }\n    if (this.accessible && (canSplitLines || !isCached)) {\n      const $accessible = doc.createElement('span');\n      // Make the accessible element visually-hidden (https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html)\n      $accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;\n      // $accessible.setAttribute('tabindex', '-1');\n      $accessible.innerHTML = this.html;\n      $el.insertBefore($accessible, $el.firstChild);\n      this.lines.forEach(setAriaHidden);\n      this.words.forEach(setAriaHidden);\n      this.chars.forEach(setAriaHidden);\n    }\n    this.width = /** @type {HTMLElement} */($el).offsetWidth;\n    if (canSplitLines || clearCache) {\n      this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));\n    }\n    return this;\n  }\n\n  refresh() {\n    this.split(true);\n  }\n}\n\n/**\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst split = (target, parameters) => new TextSplitter(target, parameters);\n\nconst text = {\n  split,\n};\n\n\n\n\n/**\n * @overload\n * @param {Number} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<Number>}\n */\n/**\n * @overload\n * @param {String} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<String>}\n */\n/**\n * @overload\n * @param {[Number, Number]} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<Number>}\n */\n/**\n * @overload\n * @param {[String, String]} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<String>}\n */\n/**\n * @param {Number|String|[Number, Number]|[String, String]} val The staggered value or range\n * @param {StaggerParams} [params] The stagger parameters\n * @return {StaggerFunction<Number|String>}\n */\nconst stagger = (val, params = {}) => {\n  let values = [];\n  let maxValue = 0;\n  const from = params.from;\n  const reversed = params.reversed;\n  const ease = params.ease;\n  const hasEasing = !isUnd(ease);\n  const hasSpring = hasEasing && !isUnd(/** @type {Spring} */(ease).ease);\n  const staggerEase = hasSpring ? /** @type {Spring} */(ease).ease : hasEasing ? parseEasings(ease) : null;\n  const grid = params.grid;\n  const axis = params.axis;\n  const customTotal = params.total;\n  const fromFirst = isUnd(from) || from === 0 || from === 'first';\n  const fromCenter = from === 'center';\n  const fromLast = from === 'last';\n  const fromRandom = from === 'random';\n  const isRange = isArr(val);\n  const useProp = params.use;\n  const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);\n  const val2 = isRange ? parseNumber(val[1]) : 0;\n  const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);\n  const start = params.start || 0 + (isRange ? val1 : 0);\n  let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;\n  return (target, i, t, tl) => {\n    const [ registeredTarget ] = registerTargets(target);\n    const total = isUnd(customTotal) ? t : customTotal;\n    const customIndex = !isUnd(useProp) ? isFnc(useProp) ? useProp(registeredTarget, i, total) : getOriginalAnimatableValue(registeredTarget, useProp) : false;\n    const staggerIndex = isNum(customIndex) || isStr(customIndex) && isNum(+customIndex) ? +customIndex : i;\n    if (fromCenter) fromIndex = (total - 1) / 2;\n    if (fromLast) fromIndex = total - 1;\n    if (!values.length) {\n      for (let index = 0; index < total; index++) {\n        if (!grid) {\n          values.push(abs(fromIndex - index));\n        } else {\n          const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n          const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n          const toX = index % grid[0];\n          const toY = floor(index / grid[0]);\n          const distanceX = fromX - toX;\n          const distanceY = fromY - toY;\n          let value = sqrt(distanceX * distanceX + distanceY * distanceY);\n          if (axis === 'x') value = -distanceX;\n          if (axis === 'y') value = -distanceY;\n          values.push(value);\n        }\n        maxValue = max(...values);\n      }\n      if (staggerEase) values = values.map(val => staggerEase(val / maxValue) * maxValue);\n      if (reversed) values = values.map(val => axis ? (val < 0) ? val * -1 : -val : abs(maxValue - val));\n      if (fromRandom) values = shuffle(values);\n    }\n    const spacing = isRange ? (val2 - val1) / maxValue : val1;\n    const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */(start);\n    /** @type {String|Number} */\n    let output = offset + ((spacing * round(values[staggerIndex], 2)) || 0);\n    if (params.modifier) output = params.modifier(output);\n    if (unitMatch) output = `${output}${unitMatch[2]}`;\n    return output;\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9hbmltZWpzQDQuMS40L25vZGVfbW9kdWxlcy9hbmltZWpzL2xpYi9hbmltZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QixjQUFjLHVDQUF1QztBQUNyRCxjQUFjLGFBQWE7QUFDM0IsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsUUFBUTtBQUN0QixjQUFjLGFBQWE7QUFDM0IsY0FBYywyQ0FBMkM7QUFDekQsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyxrQ0FBa0M7QUFDaEQ7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyw0QkFBNEI7QUFDMUMsY0FBYyxnRkFBZ0Y7O0FBRTlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxlQUFlO0FBQzdCLGNBQWMseUNBQXlDO0FBQ3ZELGNBQWMsU0FBUztBQUN2QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFdBQVc7QUFDekIsY0FBYyxn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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUErQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJEQUEyRCxlQUFlO0FBQzFFLDBEQUEwRCxlQUFlO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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WTtBQUNaO0FBQ0E7QUFDQSxXQUFXLGlEQUFpRDtBQUM1RCxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNELDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUgsUUFBUTtBQUMzSCxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBLCtCQUErQixPQUFPLEVBQUUsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7O0FBRTZTIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL2FuaW1lanNANC4xLjQvbm9kZV9tb2R1bGVzL2FuaW1lanMvbGliL2FuaW1lLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGFuaW1lLmpzIC0gRVNNXG4gKiBAdmVyc2lvbiB2NC4xLjRcbiAqIEBhdXRob3IgSnVsaWFuIEdhcm5pZXJcbiAqIEBsaWNlbnNlIE1JVFxuICogQGNvcHlyaWdodCAoYykgMjAyNSBKdWxpYW4gR2FybmllclxuICogQHNlZSBodHRwczovL2FuaW1lanMuY29tXG4gKi9cblxuLy8gR2xvYmFsIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0c1BhcmFtc1xuICogQHByb3BlcnR5IHtOdW1iZXJ8U3RyaW5nfSBbaWRdXG4gKiBAcHJvcGVydHkge1BlcmNlbnRhZ2VLZXlmcmFtZXN8RHVyYXRpb25LZXlmcmFtZXN9IFtrZXlmcmFtZXNdXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbcGxheWJhY2tFYXNlXVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwbGF5YmFja1JhdGVdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2ZyYW1lUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEJvb2xlYW59IFtsb29wXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbcmV2ZXJzZWRdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFthbHRlcm5hdGVdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58U2Nyb2xsT2JzZXJ2ZXJ9IFthdXRvcGxheV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9uVmFsdWV9IFtkdXJhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9uVmFsdWV9IFtkZWxheV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbG9vcERlbGF5XVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gKiBAcHJvcGVydHkgeydub25lJ3wncmVwbGFjZSd8J2JsZW5kJ3xjb21wb3NpdGlvblR5cGVzfSBbY29tcG9zaXRpb25dXG4gKiBAcHJvcGVydHkgeyh2OiBhbnkpID0+IGFueX0gW21vZGlmaWVyXVxuICogQHByb3BlcnR5IHsodGlja2FibGU6IFRpY2thYmxlKSA9PiB2b2lkfSBbb25CZWdpbl1cbiAqIEBwcm9wZXJ0eSB7KHRpY2thYmxlOiBUaWNrYWJsZSkgPT4gdm9pZH0gW29uQmVmb3JlVXBkYXRlXVxuICogQHByb3BlcnR5IHsodGlja2FibGU6IFRpY2thYmxlKSA9PiB2b2lkfSBbb25VcGRhdGVdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvbkxvb3BdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvblBhdXNlXVxuICogQHByb3BlcnR5IHsodGlja2FibGU6IFRpY2thYmxlKSA9PiB2b2lkfSBbb25Db21wbGV0ZV1cbiAqIEBwcm9wZXJ0eSB7KHJlbmRlcmFibGU6IFJlbmRlcmFibGUpID0+IHZvaWR9IFtvblJlbmRlcl1cbiAqL1xuXG4vKiogQHR5cGVkZWYge0pTQW5pbWF0aW9ufFRpbWVsaW5lfSBSZW5kZXJhYmxlICovXG4vKiogQHR5cGVkZWYge1RpbWVyfFJlbmRlcmFibGV9IFRpY2thYmxlICovXG4vKiogQHR5cGVkZWYge1RpbWVyJkpTQW5pbWF0aW9uJlRpbWVsaW5lfSBDYWxsYmFja0FyZ3VtZW50ICovXG4vKiogQHR5cGVkZWYge0FuaW1hdGFibGV8VGlja2FibGV8V0FBUElBbmltYXRpb258RHJhZ2dhYmxlfFNjcm9sbE9ic2VydmVyfFRleHRTcGxpdHRlcnxTY29wZX0gUmV2ZXJ0aWJsZSAqL1xuXG4vLyBTdGFnZ2VyIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAY2FsbGJhY2sgU3RhZ2dlckZ1bmN0aW9uXG4gKiBAcGFyYW0ge1RhcmdldH0gW3RhcmdldF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdXG4gKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aF1cbiAqIEBwYXJhbSB7VGltZWxpbmV9IFt0bF1cbiAqIEByZXR1cm4ge1R9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiAge09iamVjdH0gU3RhZ2dlclBhcmFtc1xuICogQHByb3BlcnR5IHtOdW1iZXJ8U3RyaW5nfSBbc3RhcnRdXG4gKiBAcHJvcGVydHkge051bWJlcnwnZmlyc3QnfCdjZW50ZXInfCdsYXN0J3wncmFuZG9tJ30gW2Zyb21dXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXZlcnNlZF1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj59IFtncmlkXVxuICogQHByb3BlcnR5IHsoJ3gnfCd5Jyl9IFtheGlzXVxuICogQHByb3BlcnR5IHtTdHJpbmd8KCh0YXJnZXQ6IFRhcmdldCwgaTogTnVtYmVyLCBsZW5ndGg6IE51bWJlcikgPT4gTnVtYmVyKX0gW3VzZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdG90YWxdXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gW21vZGlmaWVyXVxuICovXG5cbi8vIEVhc2VzIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQGNhbGxiYWNrIEVhc2luZ0Z1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeygnbGluZWFyJ3wnbGluZWFyKHgxLCB4MiAyNSUsIHgzKSd8J2luJ3wnb3V0J3wnaW5PdXQnfCdpblF1YWQnfCdvdXRRdWFkJ3wnaW5PdXRRdWFkJ3wnaW5DdWJpYyd8J291dEN1YmljJ3wnaW5PdXRDdWJpYyd8J2luUXVhcnQnfCdvdXRRdWFydCd8J2luT3V0UXVhcnQnfCdpblF1aW50J3wnb3V0UXVpbnQnfCdpbk91dFF1aW50J3wnaW5TaW5lJ3wnb3V0U2luZSd8J2luT3V0U2luZSd8J2luQ2lyYyd8J291dENpcmMnfCdpbk91dENpcmMnfCdpbkV4cG8nfCdvdXRFeHBvJ3wnaW5PdXRFeHBvJ3wnaW5Cb3VuY2UnfCdvdXRCb3VuY2UnfCdpbk91dEJvdW5jZSd8J2luQmFjayd8J291dEJhY2snfCdpbk91dEJhY2snfCdpbkVsYXN0aWMnfCdvdXRFbGFzdGljJ3wnaW5PdXRFbGFzdGljJ3wnaXJyZWd1bGFyJ3wnY3ViaWNCZXppZXInfCdzdGVwcyd8J2luKHAgPSAxLjY3NSknfCdvdXQocCA9IDEuNjc1KSd8J2luT3V0KHAgPSAxLjY3NSknfCdpbkJhY2sob3ZlcnNob290ID0gMS43MDE1OCknfCdvdXRCYWNrKG92ZXJzaG9vdCA9IDEuNzAxNTgpJ3wnaW5PdXRCYWNrKG92ZXJzaG9vdCA9IDEuNzAxNTgpJ3wnaW5FbGFzdGljKGFtcGxpdHVkZSA9IDEsIHBlcmlvZCA9IC4zKSd8J291dEVsYXN0aWMoYW1wbGl0dWRlID0gMSwgcGVyaW9kID0gLjMpJ3wnaW5PdXRFbGFzdGljKGFtcGxpdHVkZSA9IDEsIHBlcmlvZCA9IC4zKSd8J2lycmVndWxhcihsZW5ndGggPSAxMCwgcmFuZG9tbmVzcyA9IDEpJ3wnY3ViaWNCZXppZXIoeDEsIHkxLCB4MiwgeTIpJ3wnc3RlcHMoc3RlcHMgPSAxMCknKX0gRWFzZVN0cmluZ1BhcmFtTmFtZXNcbiAqL1xuXG4vLyBBIGhhY2sgdG8gZ2V0IGJvdGggZWFzZSBuYW1lcyBzdWdnZXN0aW9ucyBBTkQgYWxsb3cgYW55IHN0cmluZ3Ncbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjk3MjkjaXNzdWVjb21tZW50LTQ2MDM0NjQyMVxuLyoqIEB0eXBlZGVmIHsoU3RyaW5nICYge30pfEVhc2VTdHJpbmdQYXJhbU5hbWVzfEVhc2luZ0Z1bmN0aW9ufFNwcmluZ30gRWFzaW5nUGFyYW0gKi9cblxuLyoqIEB0eXBlZGVmIHtIVE1MRWxlbWVudHxTVkdFbGVtZW50fSBET01UYXJnZXQgKi9cbi8qKiBAdHlwZWRlZiB7UmVjb3JkPFN0cmluZywgYW55Pn0gSlNUYXJnZXQgKi9cbi8qKiBAdHlwZWRlZiB7RE9NVGFyZ2V0fEpTVGFyZ2V0fSBUYXJnZXQgKi9cbi8qKiBAdHlwZWRlZiB7VGFyZ2V0fE5vZGVMaXN0fFN0cmluZ30gVGFyZ2V0U2VsZWN0b3IgKi9cbi8qKiBAdHlwZWRlZiB7RE9NVGFyZ2V0fE5vZGVMaXN0fFN0cmluZ30gRE9NVGFyZ2V0U2VsZWN0b3IgKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPERPTVRhcmdldFNlbGVjdG9yPnxET01UYXJnZXRTZWxlY3Rvcn0gRE9NVGFyZ2V0c1BhcmFtICovXG4vKiogQHR5cGVkZWYge0FycmF5LjxET01UYXJnZXQ+fSBET01UYXJnZXRzQXJyYXkgKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPEpTVGFyZ2V0PnxKU1RhcmdldH0gSlNUYXJnZXRzUGFyYW0gKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPEpTVGFyZ2V0Pn0gSlNUYXJnZXRzQXJyYXkgKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPFRhcmdldFNlbGVjdG9yPnxUYXJnZXRTZWxlY3Rvcn0gVGFyZ2V0c1BhcmFtICovXG4vKiogQHR5cGVkZWYge0FycmF5LjxUYXJnZXQ+fSBUYXJnZXRzQXJyYXkgKi9cblxuLy8gU3ByaW5nIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcHJpbmdQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFzcz0xXSAtIE1hc3MsIGRlZmF1bHQgMVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdGlmZm5lc3M9MTAwXSAtIFN0aWZmbmVzcywgZGVmYXVsdCAxMDBcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGFtcGluZz0xMF0gLSBEYW1waW5nLCBkZWZhdWx0IDEwXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3ZlbG9jaXR5PTBdIC0gSW5pdGlhbCB2ZWxvY2l0eSwgZGVmYXVsdCAwXG4gKi9cblxuIC8vIENhbGxiYWNrIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBjYWxsYmFjayBDYWxsYmFja1xuICogQHBhcmFtIHtUfSBzZWxmIC0gUmV0dXJucyBpdHNlbGZcbiAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBbZV1cbiAqIEByZXR1cm4geyp9XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge29iamVjdH0gVFxuICogQHR5cGVkZWYge09iamVjdH0gVGlja2FibGVDYWxsYmFja3NcbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8VD59IFtvbkJlZ2luXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uQmVmb3JlVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uTG9vcF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8VD59IFtvblBhdXNlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uQ29tcGxldGVdXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge29iamVjdH0gVFxuICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyYWJsZUNhbGxiYWNrc1xuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uUmVuZGVyXVxuICovXG5cbi8vIFRpbWVyIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtpZF1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZHVyYXRpb25dXG4gKiBAcHJvcGVydHkge1R3ZWVuUGFyYW1WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsb29wRGVsYXldXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXZlcnNlZF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FsdGVybmF0ZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxOdW1iZXJ9IFtsb29wXVxuICogQHByb3BlcnR5IHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSBbYXV0b3BsYXldXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2ZyYW1lUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGxheWJhY2tSYXRlXVxuICovXG5cbi8qKlxuXG4vKipcbiAqIEB0eXBlZGVmIHtUaW1lck9wdGlvbnMgJiBUaWNrYWJsZUNhbGxiYWNrczxUaW1lcj59IFRpbWVyUGFyYW1zXG4gKi9cblxuLy8gVHdlZW4gdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRnVuY3Rpb25WYWx1ZVxuICogQHBhcmFtIHtUYXJnZXR9IHRhcmdldCAtIFRoZSBhbmltYXRlZCB0YXJnZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSB0YXJnZXQgaW5kZXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBUaGUgdG90YWwgbnVtYmVyIG9mIGFuaW1hdGVkIHRhcmdldHNcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd8VHdlZW5PYmplY3RWYWx1ZXxBcnJheS48TnVtYmVyfFN0cmluZ3xUd2Vlbk9iamVjdFZhbHVlPn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBUd2Vlbk1vZGlmaWVyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYW5pbWF0ZWQgdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyXX0gQ29sb3JBcnJheSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFR3ZWVuXG4gKiBAcHJvcGVydHkge051bWJlcn0gaWRcbiAqIEBwcm9wZXJ0eSB7SlNBbmltYXRpb259IHBhcmVudFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcHJvcGVydHkge1RhcmdldH0gdGFyZ2V0XG4gKiBAcHJvcGVydHkge1N0cmluZ3xOdW1iZXJ9IF92YWx1ZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxudWxsfSBfZnVuY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gX2Vhc2VcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj59IF9mcm9tTnVtYmVyc1xuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gX3RvTnVtYmVyc1xuICogQHByb3BlcnR5IHtBcnJheS48U3RyaW5nPn0gX3N0cmluZ3NcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfZnJvbU51bWJlclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF90b051bWJlclxuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gX251bWJlcnNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfbnVtYmVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gX3VuaXRcbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gX21vZGlmaWVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2N1cnJlbnRUaW1lXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2RlbGF5XG4gKiBAcHJvcGVydHkge051bWJlcn0gX3VwZGF0ZUR1cmF0aW9uXG4gKiBAcHJvcGVydHkge051bWJlcn0gX3N0YXJ0VGltZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9jaGFuZ2VEdXJhdGlvblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9hYnNvbHV0ZVN0YXJ0VGltZVxuICogQHByb3BlcnR5IHt0d2VlblR5cGVzfSBfdHdlZW5UeXBlXG4gKiBAcHJvcGVydHkge3ZhbHVlVHlwZXN9IF92YWx1ZVR5cGVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfY29tcG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfaXNPdmVybGFwcGVkXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2lzT3ZlcnJpZGRlblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9yZW5kZXJUcmFuc2Zvcm1zXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfcHJldlJlcFxuICogQHByb3BlcnR5IHtUd2Vlbn0gX25leHRSZXBcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9wcmV2QWRkXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfbmV4dEFkZFxuICogQHByb3BlcnR5IHtUd2Vlbn0gX3ByZXZcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9uZXh0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBUd2VlbkRlY29tcG9zZWRWYWx1ZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHQgLSBUeXBlXG4gKiBAcHJvcGVydHkge051bWJlcn0gbiAtIFNpbmdsZSBudW1iZXIgdmFsdWVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB1IC0gVmFsdWUgdW5pdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IG8gLSBWYWx1ZSBvcGVyYXRvclxuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gZCAtIEFycmF5IG9mIE51bWJlcnMgKGluIGNhc2Ugb2YgY29tcGxleCB2YWx1ZSB0eXBlKVxuICogQHByb3BlcnR5IHtBcnJheS48U3RyaW5nPn0gcyAtIFN0cmluZ3MgKGluIGNhc2Ugb2YgY29tcGxleCB2YWx1ZSB0eXBlKVxuICovXG5cbi8qKiBAdHlwZWRlZiB7e19oZWFkOiBudWxsfFR3ZWVuLCBfdGFpbDogbnVsbHxUd2Vlbn19IFR3ZWVuUHJvcGVydHlTaWJsaW5ncyAqL1xuLyoqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBUd2VlblByb3BlcnR5U2libGluZ3M+fSBUd2Vlbkxvb2t1cHMgKi9cbi8qKiBAdHlwZWRlZiB7V2Vha01hcC48VGFyZ2V0LCBUd2Vlbkxvb2t1cHM+fSBUd2VlblJlcGxhY2VMb29rdXBzICovXG4vKiogQHR5cGVkZWYge01hcC48VGFyZ2V0LCBUd2Vlbkxvb2t1cHM+fSBUd2VlbkFkZGl0aXZlTG9va3VwcyAqL1xuXG4vLyBKU0FuaW1hdGlvbiB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtOdW1iZXJ8U3RyaW5nfEZ1bmN0aW9uVmFsdWV9IFR3ZWVuUGFyYW1WYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1R3ZWVuUGFyYW1WYWx1ZXxbVHdlZW5QYXJhbVZhbHVlLCBUd2VlblBhcmFtVmFsdWVdfSBUd2VlblByb3BWYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhTdHJpbmcgJiB7fSl8J25vbmUnfCdyZXBsYWNlJ3wnYmxlbmQnfGNvbXBvc2l0aW9uVHlwZXN9IFR3ZWVuQ29tcG9zaXRpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFR3ZWVuUGFyYW1zT3B0aW9uc1xuICogQHByb3BlcnR5IHtUd2VlblBhcmFtVmFsdWV9IFtkdXJhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZGVsYXldXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gW21vZGlmaWVyXVxuICogQHByb3BlcnR5IHtUd2VlbkNvbXBvc2l0aW9ufSBbY29tcG9zaXRpb25dXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUd2VlblZhbHVlc1xuICogQHByb3BlcnR5IHtUd2VlblBhcmFtVmFsdWV9IFtmcm9tXVxuICogQHByb3BlcnR5IHtUd2VlblByb3BWYWx1ZX0gW3RvXVxuICogQHByb3BlcnR5IHtUd2VlblByb3BWYWx1ZX0gW2Zyb21Ub11cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtUd2VlblBhcmFtc09wdGlvbnMgJiBUd2VlblZhbHVlc30gVHdlZW5LZXlWYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0FycmF5LjxUd2VlbktleVZhbHVlfFR3ZWVuUHJvcFZhbHVlPn0gQXJyYXlTeW50YXhWYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1R3ZWVuUGFyYW1WYWx1ZXxBcnJheVN5bnRheFZhbHVlfFR3ZWVuS2V5VmFsdWV9IFR3ZWVuT3B0aW9uc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1BhcnRpYWw8e3RvOiBUd2VlblBhcmFtVmFsdWV8QXJyYXkuPFR3ZWVuUGFyYW1WYWx1ZT47IGZyb206IFR3ZWVuUGFyYW1WYWx1ZXxBcnJheS48VHdlZW5QYXJhbVZhbHVlPjsgZnJvbVRvOiBUd2VlblBhcmFtVmFsdWV8QXJyYXkuPFR3ZWVuUGFyYW1WYWx1ZT47fT59IFR3ZWVuT2JqZWN0VmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBlcmNlbnRhZ2VLZXlmcmFtZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFR3ZWVuUGFyYW1WYWx1ZT59IFBlcmNlbnRhZ2VLZXlmcmFtZVBhcmFtc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFBlcmNlbnRhZ2VLZXlmcmFtZVBhcmFtcyAmIFBlcmNlbnRhZ2VLZXlmcmFtZU9wdGlvbnM+fSBQZXJjZW50YWdlS2V5ZnJhbWVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXk8UmVjb3JkPFN0cmluZywgVHdlZW5PcHRpb25zIHwgVHdlZW5Nb2RpZmllciB8IGJvb2xlYW4+ICYgVHdlZW5QYXJhbXNPcHRpb25zPn0gRHVyYXRpb25LZXlmcmFtZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7UGVyY2VudGFnZUtleWZyYW1lc3xEdXJhdGlvbktleWZyYW1lc30gW2tleWZyYW1lc11cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtwbGF5YmFja0Vhc2VdXG4gKi9cblxuLy8gVE9ETzogQ3VycmVudGx5IHNldHRpbmcgVHdlZW5Nb2RpZmllciB0byB0aGUgaW50ZXJzZWN0ZWQgUmVjb3JkPD4gbWFrZXMgdGhlIEZ1bmN0aW9uVmFsdWUgdHlwZSB0YXJnZXQgcGFyYW0gYW55IGlmIG9ubHkgb25lIHBhcmFtZXRlciBpcyBzZXRcbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFR3ZWVuT3B0aW9ucyB8IENhbGxiYWNrPEpTQW5pbWF0aW9uPiB8IFR3ZWVuTW9kaWZpZXIgfCBib29sZWFuIHwgUGVyY2VudGFnZUtleWZyYW1lcyB8IER1cmF0aW9uS2V5ZnJhbWVzIHwgU2Nyb2xsT2JzZXJ2ZXI+ICYgVGltZXJPcHRpb25zICYgQW5pbWF0aW9uT3B0aW9ucyAmIFR3ZWVuUGFyYW1zT3B0aW9ucyAmIFRpY2thYmxlQ2FsbGJhY2tzPEpTQW5pbWF0aW9uPiAmIFJlbmRlcmFibGVDYWxsYmFja3M8SlNBbmltYXRpb24+fSBBbmltYXRpb25QYXJhbXNcbiAqL1xuXG4vLyBUaW1lbGluZSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEFjY2VwdHM6PGJyPlxuICogLSBgTnVtYmVyYCAtIEFic29sdXRlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAoZS5nLiwgYDUwMGAgcGxhY2VzIGVsZW1lbnQgYXQgZXhhY3RseSA1MDBtcyk8YnI+XG4gKiAtIGAnKz1OdW1iZXInYCAtIEFkZGl0aW9uOiBQb3NpdGlvbiBlbGVtZW50IFggbXMgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudCAoZS5nLiwgYCcrPTEwMCdgKTxicj5cbiAqIC0gYCctPU51bWJlcidgIC0gU3VidHJhY3Rpb246IFBvc2l0aW9uIGVsZW1lbnQgWCBtcyBiZWZvcmUgdGhlIGxhc3QgZWxlbWVudCdzIGVuZCAoZS5nLiwgYCctPTEwMCdgKTxicj5cbiAqIC0gYCcqPU51bWJlcidgIC0gTXVsdGlwbGllcjogUG9zaXRpb24gZWxlbWVudCBhdCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCBkdXJhdGlvbiAoZS5nLiwgYCcqPS41J2AgZm9yIGhhbGZ3YXkpPGJyPlxuICogLSBgJzwnYCAtIFByZXZpb3VzIGVuZDogUG9zaXRpb24gZWxlbWVudCBhdCB0aGUgZW5kIHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyBlbGVtZW50PGJyPlxuICogLSBgJzw8J2AgLSBQcmV2aW91cyBzdGFydDogUG9zaXRpb24gZWxlbWVudCBhdCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIGVsZW1lbnQ8YnI+XG4gKiAtIGAnPDwrPU51bWJlcidgIC0gQ29tYmluZWQ6IFBvc2l0aW9uIGVsZW1lbnQgcmVsYXRpdmUgdG8gcHJldmlvdXMgZWxlbWVudCdzIHN0YXJ0IChlLmcuLCBgJzw8Kz0yNTAnYCk8YnI+XG4gKiAtIGAnbGFiZWwnYCAtIExhYmVsOiBQb3NpdGlvbiBlbGVtZW50IGF0IGEgbmFtZWQgbGFiZWwgcG9zaXRpb24gKGUuZy4sIGAnTXkgTGFiZWwnYClcbiAqXG4gKiBAdHlwZWRlZiB7TnVtYmVyfGArPSR7TnVtYmVyfWB8YC09JHtOdW1iZXJ9YHxgKj0ke051bWJlcn1gfCc8J3wnPDwnfGA8PCs9JHtOdW1iZXJ9YHxgPDwtPSR7TnVtYmVyfWB8U3RyaW5nfSBUaW1lbGluZVBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBBY2NlcHRzOjxicj5cbiAqIC0gYE51bWJlcmAgLSBBYnNvbHV0ZSBwb3NpdGlvbiBpbiBtaWxsaXNlY29uZHMgKGUuZy4sIGA1MDBgIHBsYWNlcyBhbmltYXRpb24gYXQgZXhhY3RseSA1MDBtcyk8YnI+XG4gKiAtIGAnKz1OdW1iZXInYCAtIEFkZGl0aW9uOiBQb3NpdGlvbiBhbmltYXRpb24gWCBtcyBhZnRlciB0aGUgbGFzdCBhbmltYXRpb24gKGUuZy4sIGAnKz0xMDAnYCk8YnI+XG4gKiAtIGAnLT1OdW1iZXInYCAtIFN1YnRyYWN0aW9uOiBQb3NpdGlvbiBhbmltYXRpb24gWCBtcyBiZWZvcmUgdGhlIGxhc3QgYW5pbWF0aW9uJ3MgZW5kIChlLmcuLCBgJy09MTAwJ2ApPGJyPlxuICogLSBgJyo9TnVtYmVyJ2AgLSBNdWx0aXBsaWVyOiBQb3NpdGlvbiBhbmltYXRpb24gYXQgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgZHVyYXRpb24gKGUuZy4sIGAnKj0uNSdgIGZvciBoYWxmd2F5KTxicj5cbiAqIC0gYCc8J2AgLSBQcmV2aW91cyBlbmQ6IFBvc2l0aW9uIGFuaW1hdGlvbiBhdCB0aGUgZW5kIHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyBhbmltYXRpb248YnI+XG4gKiAtIGAnPDwnYCAtIFByZXZpb3VzIHN0YXJ0OiBQb3NpdGlvbiBhbmltYXRpb24gYXQgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyBhbmltYXRpb248YnI+XG4gKiAtIGAnPDwrPU51bWJlcidgIC0gQ29tYmluZWQ6IFBvc2l0aW9uIGFuaW1hdGlvbiByZWxhdGl2ZSB0byBwcmV2aW91cyBhbmltYXRpb24ncyBzdGFydCAoZS5nLiwgYCc8PCs9MjUwJ2ApPGJyPlxuICogLSBgJ2xhYmVsJ2AgLSBMYWJlbDogUG9zaXRpb24gYW5pbWF0aW9uIGF0IGEgbmFtZWQgbGFiZWwgcG9zaXRpb24gKGUuZy4sIGAnTXkgTGFiZWwnYCk8YnI+XG4gKiAtIGBzdGFnZ2VyKFN0cmluZ3xOdW1tYmVyKWAgLSBTdGFnZ2VyIG11bHRpLWVsZW1lbnRzIGFuaW1hdGlvbiBwb3NpdGlvbnMgKGUuZy4sIDEwLCAyMCwgMzAuLi4pXG4gKlxuICogQHR5cGVkZWYge1RpbWVsaW5lUG9zaXRpb24gfCBTdGFnZ2VyRnVuY3Rpb248TnVtYmVyfFN0cmluZz59IFRpbWVsaW5lQW5pbWF0aW9uUG9zaXRpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbWVsaW5lT3B0aW9uc1xuICogQHByb3BlcnR5IHtEZWZhdWx0c1BhcmFtc30gW2RlZmF1bHRzXVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW3BsYXliYWNrRWFzZV1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtUaW1lck9wdGlvbnMgJiBUaW1lbGluZU9wdGlvbnMgJiBUaWNrYWJsZUNhbGxiYWNrczxUaW1lbGluZT4gJiBSZW5kZXJhYmxlQ2FsbGJhY2tzPFRpbWVsaW5lPn0gVGltZWxpbmVQYXJhbXNcbiAqL1xuXG4vLyBXQUFQSUFuaW1hdGlvbiB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtTdHJpbmd8TnVtYmVyfEFycmF5PFN0cmluZz58QXJyYXk8TnVtYmVyPn0gV0FBUElUd2VlblZhbHVlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV0FBUElGdW5jdGlvblZhbHVlXG4gKiBAcGFyYW0ge0RPTVRhcmdldH0gdGFyZ2V0IC0gVGhlIGFuaW1hdGVkIHRhcmdldFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIHRhcmdldCBpbmRleFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSB0b3RhbCBudW1iZXIgb2YgYW5pbWF0ZWQgdGFyZ2V0c1xuICogQHJldHVybiB7V0FBUElUd2VlblZhbHVlfVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1dBQVBJVHdlZW5WYWx1ZXxXQUFQSUZ1bmN0aW9uVmFsdWV8QXJyYXk8U3RyaW5nfE51bWJlcnxXQUFQSUZ1bmN0aW9uVmFsdWU+fSBXQUFQSUtleWZyYW1lVmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYW5pbWF0aW9uOiBXQUFQSUFuaW1hdGlvbikgPT4gdm9pZH0gV0FBUElDYWxsYmFja1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV0FBUElUd2Vlbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7V0FBUElLZXlmcmFtZVZhbHVlfSBbdG9dXG4gKiBAcHJvcGVydHkge1dBQVBJS2V5ZnJhbWVWYWx1ZX0gW2Zyb21dXG4gKiBAcHJvcGVydHkge051bWJlcnxXQUFQSUZ1bmN0aW9uVmFsdWV9IFtkdXJhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfFdBQVBJRnVuY3Rpb25WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gKiBAcHJvcGVydHkge0NvbXBvc2l0ZU9wZXJhdGlvbn0gW2NvbXBvc2l0aW9uXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV0FBUElBbmltYXRpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge051bWJlcnxCb29sZWFufSBbbG9vcF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW1JldmVyc2VkXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbQWx0ZXJuYXRlXVxuICogQHByb3BlcnR5IHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSBbYXV0b3BsYXldXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3BsYXliYWNrUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfFdBQVBJRnVuY3Rpb25WYWx1ZX0gW2R1cmF0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8V0FBUElGdW5jdGlvblZhbHVlfSBbZGVsYXldXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7Q29tcG9zaXRlT3BlcmF0aW9ufSBbY29tcG9zaXRpb25dXG4gKiBAcHJvcGVydHkge1dBQVBJQ2FsbGJhY2t9IFtvbkNvbXBsZXRlXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFdBQVBJS2V5ZnJhbWVWYWx1ZSB8IFdBQVBJQW5pbWF0aW9uT3B0aW9ucyB8IEJvb2xlYW4gfCBTY3JvbGxPYnNlcnZlciB8IFdBQVBJQ2FsbGJhY2sgfCBFYXNpbmdQYXJhbSB8IFdBQVBJVHdlZW5PcHRpb25zPiAmIFdBQVBJQW5pbWF0aW9uT3B0aW9uc30gV0FBUElBbmltYXRpb25QYXJhbXNcbiAqL1xuXG4vLyBBbmltYXRhYmxlIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBbmltYXRhYmxlUHJvcGVydHlTZXR0ZXJcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheS48TnVtYmVyPn0gdG9cbiAqIEBwYXJhbSAge051bWJlcn0gW2R1cmF0aW9uXVxuICogQHBhcmFtICB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICogQHJldHVybiB7QW5pbWF0YWJsZU9iamVjdH1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBbmltYXRhYmxlUHJvcGVydHlHZXR0ZXJcbiAqIEByZXR1cm4ge051bWJlcnxBcnJheS48TnVtYmVyPn1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtBbmltYXRhYmxlUHJvcGVydHlTZXR0ZXIgJiBBbmltYXRhYmxlUHJvcGVydHlHZXR0ZXJ9IEFuaW1hdGFibGVQcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0FuaW1hdGFibGUgJiBSZWNvcmQ8U3RyaW5nLCBBbmltYXRhYmxlUHJvcGVydHk+fSBBbmltYXRhYmxlT2JqZWN0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmltYXRhYmxlUHJvcGVydHlQYXJhbXNPcHRpb25zXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW3VuaXRdXG4gKiBAcHJvcGVydHkge1R3ZWVuUGFyYW1WYWx1ZX0gW2R1cmF0aW9uXVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gKiBAcHJvcGVydHkge1R3ZWVuTW9kaWZpZXJ9IFttb2RpZmllcl1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Db21wb3NpdGlvbn0gW2NvbXBvc2l0aW9uXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFR3ZWVuUGFyYW1WYWx1ZSB8IEVhc2luZ1BhcmFtIHwgVHdlZW5Nb2RpZmllciB8IFR3ZWVuQ29tcG9zaXRpb24gfCBBbmltYXRhYmxlUHJvcGVydHlQYXJhbXNPcHRpb25zPiAmIEFuaW1hdGFibGVQcm9wZXJ0eVBhcmFtc09wdGlvbnN9IEFuaW1hdGFibGVQYXJhbXNcbiAqL1xuXG4vLyBTY29wZSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWN0UmVmXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR8bnVsbH0gW2N1cnJlbnRdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmd1bGFyUmVmXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IFtuYXRpdmVFbGVtZW50XVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2NvcGVQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7RE9NVGFyZ2V0U2VsZWN0b3J8UmVhY3RSZWZ8QW5ndWxhclJlZn0gW3Jvb3RdXG4gKiBAcHJvcGVydHkge0RlZmF1bHRzUGFyYW1zfSBbZGVmYXVsdHNdXG4gKiBAcHJvcGVydHkge1JlY29yZDxTdHJpbmcsIFN0cmluZz59IFttZWRpYVF1ZXJpZXNdXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQGNhbGxiYWNrIFNjb3BlZENhbGxiYWNrXG4gKiBAcGFyYW0ge1Njb3BlfSBzY29wZVxuICogQHJldHVybiB7VH1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZUNsZWFudXBDYWxsYmFja1xuICogQHBhcmFtIHtTY29wZX0gW3Njb3BlXVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNjb3BlQ29uc3RydWN0b3JDYWxsYmFja1xuICogQHBhcmFtIHtTY29wZX0gW3Njb3BlXVxuICogQHJldHVybiB7U2NvcGVDbGVhbnVwQ2FsbGJhY2t8dm9pZH1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZU1ldGhvZFxuICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gKiBAcmV0dXJuIHtTY29wZUNsZWFudXBDYWxsYmFja3x2b2lkfVxuICovXG5cbi8vIFNjcm9sbCB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ3xOdW1iZXJ9IFNjcm9sbFRocmVzaG9sZFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTY3JvbGxUaHJlc2hvbGRQYXJhbVxuICogQHByb3BlcnR5IHtTY3JvbGxUaHJlc2hvbGRWYWx1ZX0gW3RhcmdldF1cbiAqIEBwcm9wZXJ0eSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9IFtjb250YWluZXJdXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2Nyb2xsT2JzZXJ2ZXJBeGlzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7U2Nyb2xsT2JzZXJ2ZXJ9IHNlbGZcbiAqIEByZXR1cm4geyd4J3wneSd9XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2tcbiAqIEBwYXJhbSB7U2Nyb2xsT2JzZXJ2ZXJ9IHNlbGZcbiAqIEByZXR1cm4ge1Njcm9sbFRocmVzaG9sZFZhbHVlfFNjcm9sbFRocmVzaG9sZFBhcmFtfVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2Nyb2xsT2JzZXJ2ZXJQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfFN0cmluZ30gW2lkXVxuICogQHByb3BlcnR5IHtCb29sZWFufE51bWJlcnxTdHJpbmd8RWFzaW5nUGFyYW19IFtzeW5jXVxuICogQHByb3BlcnR5IHtUYXJnZXRzUGFyYW19IFtjb250YWluZXJdXG4gKiBAcHJvcGVydHkge1RhcmdldHNQYXJhbX0gW3RhcmdldF1cbiAqIEBwcm9wZXJ0eSB7J3gnfCd5J3xTY3JvbGxPYnNlcnZlckF4aXNDYWxsYmFja3woKG9ic2VydmVyOiBTY3JvbGxPYnNlcnZlcikgPT4gJ3gnfCd5J3xTY3JvbGxPYnNlcnZlckF4aXNDYWxsYmFjayl9IFtheGlzXVxuICogQHByb3BlcnR5IHtTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRQYXJhbXxTY3JvbGxUaHJlc2hvbGRDYWxsYmFja3woKG9ic2VydmVyOiBTY3JvbGxPYnNlcnZlcikgPT4gU2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2spfSBbZW50ZXJdXG4gKiBAcHJvcGVydHkge1Njcm9sbFRocmVzaG9sZFZhbHVlfFNjcm9sbFRocmVzaG9sZFBhcmFtfFNjcm9sbFRocmVzaG9sZENhbGxiYWNrfCgob2JzZXJ2ZXI6IFNjcm9sbE9ic2VydmVyKSA9PiBTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRQYXJhbXxTY3JvbGxUaHJlc2hvbGRDYWxsYmFjayl9IFtsZWF2ZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnwoKG9ic2VydmVyOiBTY3JvbGxPYnNlcnZlcikgPT4gQm9vbGVhbil9IFtyZXBlYXRdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkZWJ1Z11cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25FbnRlcl1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25MZWF2ZV1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25FbnRlckZvcndhcmRdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uTGVhdmVGb3J3YXJkXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59IFtvbkVudGVyQmFja3dhcmRdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uTGVhdmVCYWNrd2FyZF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25VcGRhdGVdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uU3luY0NvbXBsZXRlXVxuICovXG5cbi8vIERyYWdnYWJsZSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRHJhZ2dhYmxlQXhpc1BhcmFtXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW21hcFRvXVxuICogQHByb3BlcnR5IHtUd2Vlbk1vZGlmaWVyfSBbbW9kaWZpZXJdXG4gKiBAcHJvcGVydHkge1R3ZWVuQ29tcG9zaXRpb259IFtjb21wb3NpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEFycmF5PE51bWJlcj58KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyfEFycmF5PE51bWJlcj4pfSBbc25hcF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERyYWdnYWJsZUN1cnNvclBhcmFtc1xuICogQHByb3BlcnR5IHtTdHJpbmd9IFtvbkhvdmVyXVxuICogQHByb3BlcnR5IHtTdHJpbmd9IFtvbkdyYWJdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEcmFnZ2FibGVQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7RE9NVGFyZ2V0U2VsZWN0b3J9IFt0cmlnZ2VyXVxuICogQHByb3BlcnR5IHtET01UYXJnZXRTZWxlY3RvcnxBcnJheTxOdW1iZXI+fCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IERPTVRhcmdldFNlbGVjdG9yfEFycmF5PE51bWJlcj4pfSBbY29udGFpbmVyXVxuICogQHByb3BlcnR5IHtCb29sZWFufERyYWdnYWJsZUF4aXNQYXJhbX0gW3hdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58RHJhZ2dhYmxlQXhpc1BhcmFtfSBbeV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gW21vZGlmaWVyXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8QXJyYXk8TnVtYmVyPnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXJ8QXJyYXk8TnVtYmVyPil9IFtzbmFwXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8QXJyYXk8TnVtYmVyPnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXJ8QXJyYXk8TnVtYmVyPil9IFtjb250YWluZXJQYWRkaW5nXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW2NvbnRhaW5lckZyaWN0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW3JlbGVhc2VDb250YWluZXJGcmljdGlvbl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcil9IFtkcmFnU3BlZWRdXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbc2Nyb2xsU3BlZWRdXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbc2Nyb2xsVGhyZXNob2xkXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW21pblZlbG9jaXR5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW21heFZlbG9jaXR5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW3ZlbG9jaXR5TXVsdGlwbGllcl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmVsZWFzZU1hc3NdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3JlbGVhc2VTdGlmZm5lc3NdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3JlbGVhc2VEYW1waW5nXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVsZWFzZURhbXBpbmddXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbcmVsZWFzZUVhc2VdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58RHJhZ2dhYmxlQ3Vyc29yUGFyYW1zfCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IEJvb2xlYW58RHJhZ2dhYmxlQ3Vyc29yUGFyYW1zKX0gW2N1cnNvcl1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uR3JhYl1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uRHJhZ11cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uUmVsZWFzZV1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25TZXR0bGVdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPERyYWdnYWJsZT59IFtvblNuYXBdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPERyYWdnYWJsZT59IFtvblJlc2l6ZV1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uQWZ0ZXJSZXNpemVdXG4gKi9cblxuLy8gVGV4dCB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBzcGxpdFRlbXBsYXRlUGFyYW1zXG4gKiBAcHJvcGVydHkge2ZhbHNlfFN0cmluZ30gW2NsYXNzXVxuICogQHByb3BlcnR5IHtCb29sZWFufCdoaWRkZW4nfCdjbGlwJ3wndmlzaWJsZSd8J3Njcm9sbCd8J2F1dG8nfSBbd3JhcF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnwndG9wJ3wncmlnaHQnfCdib3R0b20nfCdsZWZ0J3wnY2VudGVyJ30gW2Nsb25lXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0Jvb2xlYW58U3RyaW5nfSBTcGxpdFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU3BsaXRGdW5jdGlvblZhbHVlXG4gKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IFt2YWx1ZV1cbiAqIEByZXR1cm4gU3RyaW5nXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0U3BsaXR0ZXJQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7U3BsaXRWYWx1ZXxzcGxpdFRlbXBsYXRlUGFyYW1zfFNwbGl0RnVuY3Rpb25WYWx1ZX0gW2xpbmVzXVxuICogQHByb3BlcnR5IHtTcGxpdFZhbHVlfHNwbGl0VGVtcGxhdGVQYXJhbXN8U3BsaXRGdW5jdGlvblZhbHVlfSBbd29yZHNdXG4gKiBAcHJvcGVydHkge1NwbGl0VmFsdWV8c3BsaXRUZW1wbGF0ZVBhcmFtc3xTcGxpdEZ1bmN0aW9uVmFsdWV9IFtjaGFyc11cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FjY2Vzc2libGVdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbmNsdWRlU3BhY2VzXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbZGVidWddXG4gKi9cblxuLy8gU1ZHIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAdHlwZWRlZiB7U1ZHR2VvbWV0cnlFbGVtZW50ICYge1xuICogICBzZXRBdHRyaWJ1dGUobmFtZTogJ2RyYXcnLCB2YWx1ZTogYCR7bnVtYmVyfSAke251bWJlcn1gKTogdm9pZDtcbiAqICAgZHJhdzogYCR7bnVtYmVyfSAke251bWJlcn1gO1xuICogfX0gRHJhd2FibGVTVkdHZW9tZXRyeVxuICovXG5cblxuLy8gRW52aXJvbm1lbnRzXG5cbi8vIFRPRE86IERvIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UncmUgcnVubmluZyBpbnNpZGUgYSB3b3JrZXIgP1xuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKiBAdHlwZSB7V2luZG93ICYge0FuaW1lSlM6IEFycmF5fXxudWxsfSAqL1xuY29uc3Qgd2luID0gaXNCcm93c2VyID8gLyoqIEB0eXBlIHtXaW5kb3cgJiB7QW5pbWVKUzogQXJyYXl9fSAqLygvKiogQHR5cGUge3Vua25vd259ICovKHdpbmRvdykpIDogbnVsbDtcblxuLyoqIEB0eXBlIHtEb2N1bWVudHxudWxsfSAqL1xuY29uc3QgZG9jID0gaXNCcm93c2VyID8gZG9jdW1lbnQgOiBudWxsO1xuXG4vLyBFbnVtc1xuXG4vKiogQGVudW0ge051bWJlcn0gKi9cbmNvbnN0IHR3ZWVuVHlwZXMgPSB7XG4gIE9CSkVDVDogMCxcbiAgQVRUUklCVVRFOiAxLFxuICBDU1M6IDIsXG4gIFRSQU5TRk9STTogMyxcbiAgQ1NTX1ZBUjogNCxcbn07XG5cbi8qKiBAZW51bSB7TnVtYmVyfSAqL1xuY29uc3QgdmFsdWVUeXBlcyA9IHtcbiAgTlVNQkVSOiAwLFxuICBVTklUOiAxLFxuICBDT0xPUjogMixcbiAgQ09NUExFWDogMyxcbn07XG5cbi8qKiBAZW51bSB7TnVtYmVyfSAqL1xuY29uc3QgdGlja01vZGVzID0ge1xuICBOT05FOiAwLFxuICBBVVRPOiAxLFxuICBGT1JDRTogMixcbn07XG5cbi8qKiBAZW51bSB7TnVtYmVyfSAqL1xuY29uc3QgY29tcG9zaXRpb25UeXBlcyA9IHtcbiAgcmVwbGFjZTogMCxcbiAgbm9uZTogMSxcbiAgYmxlbmQ6IDIsXG59O1xuXG4vLyBDYWNoZSBzeW1ib2xzXG5cbmNvbnN0IGlzUmVnaXN0ZXJlZFRhcmdldFN5bWJvbCA9IFN5bWJvbCgpO1xuY29uc3QgaXNEb21TeW1ib2wgPSBTeW1ib2woKTtcbmNvbnN0IGlzU3ZnU3ltYm9sID0gU3ltYm9sKCk7XG5jb25zdCB0cmFuc2Zvcm1zU3ltYm9sID0gU3ltYm9sKCk7XG5jb25zdCBtb3JwaFBvaW50c1N5bWJvbCA9IFN5bWJvbCgpO1xuY29uc3QgcHJveHlUYXJnZXRTeW1ib2wgPSBTeW1ib2woKTtcblxuLy8gTnVtYmVyc1xuXG5jb25zdCBtaW5WYWx1ZSA9IDFlLTExO1xuY29uc3QgbWF4VmFsdWUgPSAxZTEyO1xuY29uc3QgSyA9IDFlMztcbmNvbnN0IG1heEZwcyA9IDEyMDtcblxuLy8gU3RyaW5nc1xuXG5jb25zdCBlbXB0eVN0cmluZyA9ICcnO1xuY29uc3Qgc2hvcnRUcmFuc2Zvcm1zID0gLyojX19QVVJFX18qLyAoKCkgPT4ge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIG1hcC5zZXQoJ3gnLCAndHJhbnNsYXRlWCcpO1xuICBtYXAuc2V0KCd5JywgJ3RyYW5zbGF0ZVknKTtcbiAgbWFwLnNldCgneicsICd0cmFuc2xhdGVaJyk7XG4gIHJldHVybiBtYXA7XG59KSgpO1xuXG5jb25zdCB2YWxpZFRyYW5zZm9ybXMgPSBbXG4gICd0cmFuc2xhdGVYJyxcbiAgJ3RyYW5zbGF0ZVknLFxuICAndHJhbnNsYXRlWicsXG4gICdyb3RhdGUnLFxuICAncm90YXRlWCcsXG4gICdyb3RhdGVZJyxcbiAgJ3JvdGF0ZVonLFxuICAnc2NhbGUnLFxuICAnc2NhbGVYJyxcbiAgJ3NjYWxlWScsXG4gICdzY2FsZVonLFxuICAnc2tldycsXG4gICdza2V3WCcsXG4gICdza2V3WScsXG4gICdwZXJzcGVjdGl2ZScsXG4gICdtYXRyaXgnLFxuICAnbWF0cml4M2QnLFxuXTtcblxuY29uc3QgdHJhbnNmb3Jtc0ZyYWdtZW50U3RyaW5ncyA9IC8qI19fUFVSRV9fKi8gdmFsaWRUcmFuc2Zvcm1zLnJlZHVjZSgoYSwgdikgPT4gKHsuLi5hLCBbdl06IHYgKyAnKCd9KSwge30pO1xuXG4vLyBGdW5jdGlvbnNcblxuLyoqIEByZXR1cm4ge3ZvaWR9ICovXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbi8vIFJlZ2V4XG5cbmNvbnN0IGhleFRlc3RSZ3ggPSAvKF4jKFtcXGRhLWZdezN9KXsxLDJ9JCl8KF4jKFtcXGRhLWZdezR9KXsxLDJ9JCkvaTtcbmNvbnN0IHJnYkV4ZWNSZ3ggPSAvcmdiXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccypcXCkvaTtcbmNvbnN0IHJnYmFFeGVjUmd4ID0gL3JnYmFcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKC0/XFxkK3wtP1xcZCouXFxkKylcXHMqXFwpL2k7XG5jb25zdCBoc2xFeGVjUmd4ID0gL2hzbFxcKFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspJVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspJVxccypcXCkvaTtcbmNvbnN0IGhzbGFFeGVjUmd4ID0gL2hzbGFcXChcXHMqKC0/XFxkK3wtP1xcZCouXFxkKylcXHMqLFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKSVcXHMqLFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKSVcXHMqLFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKVxccypcXCkvaTtcbi8vIGV4cG9ydCBjb25zdCBkaWdpdFdpdGhFeHBvbmVudFJneCA9IC9bLStdP1xcZCpcXC4/XFxkKyg/OltlRV1bLStdP1xcZCspPy9nO1xuY29uc3QgZGlnaXRXaXRoRXhwb25lbnRSZ3ggPSAvWy0rXT9cXGQqXFwuP1xcZCsoPzplWy0rXT9cXGQpPy9naTtcbi8vIGV4cG9ydCBjb25zdCB1bml0c0V4ZWNSZ3ggPSAvXihbLStdP1xcZCpcXC4/XFxkKyg/OltlRV1bLStdP1xcZCspPykrKFthLXpdK3wlKSQvaTtcbmNvbnN0IHVuaXRzRXhlY1JneCA9IC9eKFstK10/XFxkKlxcLj9cXGQrKD86ZVstK10/XFxkKyk/KShbYS16XSt8JSkkL2k7XG5jb25zdCBsb3dlckNhc2VSZ3ggPSAvKFthLXpdKShbQS1aXSkvZztcbmNvbnN0IHRyYW5zZm9ybXNFeGVjUmd4ID0gLyhcXHcrKShcXChbXildK1xcKSspL2c7IC8vIE1hdGNoIGlubGluZSB0cmFuc2Zvcm1zIHdpdGggY2FjbCgpIHZhbHVlcywgcmV0dXJucyB0aGUgdmFsdWUgd3JhcHBlZCBpbiAoKVxuY29uc3QgcmVsYXRpdmVWYWx1ZXNFeGVjUmd4ID0gLyhcXCo9fFxcKz18LT0pLztcblxuXG5cblxuLyoqIEB0eXBlIHtEZWZhdWx0c1BhcmFtc30gKi9cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBpZDogbnVsbCxcbiAga2V5ZnJhbWVzOiBudWxsLFxuICBwbGF5YmFja0Vhc2U6IG51bGwsXG4gIHBsYXliYWNrUmF0ZTogMSxcbiAgZnJhbWVSYXRlOiBtYXhGcHMsXG4gIGxvb3A6IDAsXG4gIHJldmVyc2VkOiBmYWxzZSxcbiAgYWx0ZXJuYXRlOiBmYWxzZSxcbiAgYXV0b3BsYXk6IHRydWUsXG4gIGR1cmF0aW9uOiBLLFxuICBkZWxheTogMCxcbiAgbG9vcERlbGF5OiAwLFxuICBlYXNlOiAnb3V0KDIpJyxcbiAgY29tcG9zaXRpb246IGNvbXBvc2l0aW9uVHlwZXMucmVwbGFjZSxcbiAgbW9kaWZpZXI6IHYgPT4gdixcbiAgb25CZWdpbjogbm9vcCxcbiAgb25CZWZvcmVVcGRhdGU6IG5vb3AsXG4gIG9uVXBkYXRlOiBub29wLFxuICBvbkxvb3A6IG5vb3AsXG4gIG9uUGF1c2U6IG5vb3AsXG4gIG9uQ29tcGxldGU6IG5vb3AsXG4gIG9uUmVuZGVyOiBub29wLFxufTtcblxuY29uc3Qgc2NvcGUgPSB7XG4gIC8qKiBAdHlwZSB7U2NvcGV9ICovXG4gIGN1cnJlbnQ6IG51bGwsXG4gIC8qKiBAdHlwZSB7RG9jdW1lbnR8RE9NVGFyZ2V0fSAqL1xuICByb290OiBkb2MsXG59O1xuXG5jb25zdCBnbG9iYWxzID0ge1xuICAvKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuICBkZWZhdWx0cyxcbiAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gIHByZWNpc2lvbjogNCxcbiAgLyoqIEB0eXBlIHtOdW1iZXJ9IGVxdWFscyAxIGluIG1zIG1vZGUsIDAuMDAxIGluIHMgbW9kZSAqL1xuICB0aW1lU2NhbGU6IDEsXG4gIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICB0aWNrVGhyZXNob2xkOiAyMDAsXG59O1xuXG5jb25zdCBnbG9iYWxWZXJzaW9ucyA9IHsgdmVyc2lvbjogJzQuMS40JywgZW5naW5lOiBudWxsIH07XG5cbmlmIChpc0Jyb3dzZXIpIHtcbiAgaWYgKCF3aW4uQW5pbWVKUykgd2luLkFuaW1lSlMgPSBbXTtcbiAgd2luLkFuaW1lSlMucHVzaChnbG9iYWxWZXJzaW9ucyk7XG59XG5cbi8vIFN0cmluZ3NcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCB0b0xvd2VyQ2FzZSA9IHN0ciA9PiBzdHIucmVwbGFjZShsb3dlckNhc2VSZ3gsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbi8qKlxuICogUHJpb3JpdGl6ZSB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIHJlZ2V4IHdoZW4gcG9zc2libGVcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN1YlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuY29uc3Qgc3RyaW5nU3RhcnRzV2l0aCA9IChzdHIsIHN1YikgPT4gc3RyLmluZGV4T2Yoc3ViKSA9PT0gMDtcblxuLy8gTm90ZTogRGF0ZS5ub3cgaXMgdXNlZCBpbnN0ZWFkIG9mIHBlcmZvcm1hbmNlLm5vdyBzaW5jZSBpdCBpcyBwcmVjaXNlIGVub3VnaCBmb3IgdGltaW5ncyBjYWxjdWxhdGlvbnMsIHBlcmZvcm1zIHNsaWdodGx5IGZhc3RlciBhbmQgd29ya3MgaW4gTm9kZS5qcyBlbnZpcm9uZW1lbnQuXG5jb25zdCBub3cgPSBEYXRlLm5vdztcblxuLy8gVHlwZXMgY2hlY2tlcnNcblxuY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5O1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7YSBpcyBSZWNvcmQ8U3RyaW5nLCBhbnk+fSAqL1xuY29uc3QgaXNPYmogPSBhID0+IGEgJiYgYS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7YSBpcyBOdW1iZXJ9ICovXG5jb25zdCBpc051bSA9IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInICYmICFpc05hTihhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgU3RyaW5nfSAqL1xuY29uc3QgaXNTdHIgPSBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJztcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgRnVuY3Rpb259ICovXG5jb25zdCBpc0ZuYyA9IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHthIGlzIHVuZGVmaW5lZH0gKi9cbmNvbnN0IGlzVW5kID0gYSA9PiB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCc7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHthIGlzIG51bGwgfCB1bmRlZmluZWR9ICovXG5jb25zdCBpc05pbCA9IGEgPT4gaXNVbmQoYSkgfHwgYSA9PT0gbnVsbDtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgU1ZHRWxlbWVudH0gKi9cbmNvbnN0IGlzU3ZnID0gYSA9PiBpc0Jyb3dzZXIgJiYgYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHtCb29sZWFufSAqL1xuY29uc3QgaXNIZXggPSBhID0+IGhleFRlc3RSZ3gudGVzdChhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge0Jvb2xlYW59ICovXG5jb25zdCBpc1JnYiA9IGEgPT4gc3RyaW5nU3RhcnRzV2l0aChhLCAncmdiJyk7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHtCb29sZWFufSAqL1xuY29uc3QgaXNIc2wgPSBhID0+IHN0cmluZ1N0YXJ0c1dpdGgoYSwgJ2hzbCcpO1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7Qm9vbGVhbn0gKi9cbmNvbnN0IGlzQ29sID0gYSA9PiBpc0hleChhKSB8fCBpc1JnYihhKSB8fCBpc0hzbChhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge0Jvb2xlYW59ICovXG5jb25zdCBpc0tleSA9IGEgPT4gIWdsb2JhbHMuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoYSk7XG5cbi8vIE51bWJlclxuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBwYXJzZU51bWJlciA9IHN0ciA9PiBpc1N0cihzdHIpID9cbiAgcGFyc2VGbG9hdCgvKiogQHR5cGUge1N0cmluZ30gKi8oc3RyKSkgOlxuICAvKiogQHR5cGUge051bWJlcn0gKi8oc3RyKTtcblxuLy8gTWF0aFxuXG5jb25zdCBwb3cgPSBNYXRoLnBvdztcbmNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG5jb25zdCBzaW4gPSBNYXRoLnNpbjtcbmNvbnN0IGNvcyA9IE1hdGguY29zO1xuY29uc3QgYWJzID0gTWF0aC5hYnM7XG5jb25zdCBleHAgPSBNYXRoLmV4cDtcbmNvbnN0IGNlaWwgPSBNYXRoLmNlaWw7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBhc2luID0gTWF0aC5hc2luO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCBhdGFuMiA9IE1hdGguYXRhbjI7XG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBfcm91bmQgPSBNYXRoLnJvdW5kO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdlxuICogQHBhcmFtICB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGNsYW1wID0gKHYsIG1pbiwgbWF4KSA9PiB2IDwgbWluID8gbWluIDogdiA+IG1heCA/IG1heCA6IHY7XG5cbmNvbnN0IHBvd0NhY2hlID0ge307XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlY2ltYWxMZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgcm91bmQgPSAodiwgZGVjaW1hbExlbmd0aCkgPT4ge1xuICBpZiAoZGVjaW1hbExlbmd0aCA8IDApIHJldHVybiB2O1xuICBpZiAoIWRlY2ltYWxMZW5ndGgpIHJldHVybiBfcm91bmQodik7XG4gIGxldCBwID0gcG93Q2FjaGVbZGVjaW1hbExlbmd0aF07XG4gIGlmICghcCkgcCA9IHBvd0NhY2hlW2RlY2ltYWxMZW5ndGhdID0gMTAgKiogZGVjaW1hbExlbmd0aDtcbiAgcmV0dXJuIF9yb3VuZCh2ICogcCkgLyBwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheTxOdW1iZXI+fSBpbmNyZW1lbnRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgc25hcCA9ICh2LCBpbmNyZW1lbnQpID0+IGlzQXJyKGluY3JlbWVudCkgPyBpbmNyZW1lbnQucmVkdWNlKChjbG9zZXN0LCBjdikgPT4gKGFicyhjdiAtIHYpIDwgYWJzKGNsb3Nlc3QgLSB2KSA/IGN2IDogY2xvc2VzdCkpIDogaW5jcmVtZW50ID8gX3JvdW5kKHYgLyBpbmNyZW1lbnQpICogaW5jcmVtZW50IDogdjtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZFxuICogQHBhcmFtICB7TnVtYmVyfSBwcm9ncmVzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBpbnRlcnBvbGF0ZSA9IChzdGFydCwgZW5kLCBwcm9ncmVzcykgPT4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcHJvZ3Jlc3M7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtkZWNpbWFsTGVuZ3RoXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCByYW5kb20gPSAobWluLCBtYXgsIGRlY2ltYWxMZW5ndGgpID0+IHsgY29uc3QgbSA9IDEwICoqIChkZWNpbWFsTGVuZ3RoIHx8IDApOyByZXR1cm4gZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgKDEgLyBtKSkgKyBtaW4pICogbSkgLyBtIH07XG5cbi8qKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vYm9zdC5vY2tzLm9yZy9taWtlL3NodWZmbGUvXG4gKiBAcGFyYW0gIHtBcnJheX0gaXRlbXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5jb25zdCBzaHVmZmxlID0gaXRlbXMgPT4ge1xuICBsZXQgbSA9IGl0ZW1zLmxlbmd0aCwgdCwgaTtcbiAgd2hpbGUgKG0pIHsgaSA9IHJhbmRvbSgwLCAtLW0pOyB0ID0gaXRlbXNbbV07IGl0ZW1zW21dID0gaXRlbXNbaV07IGl0ZW1zW2ldID0gdDsgfVxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBjbGFtcEluZmluaXR5ID0gdiA9PiB2ID09PSBJbmZpbml0eSA/IG1heFZhbHVlIDogdiA9PT0gLUluZmluaXR5ID8gLW1heFZhbHVlIDogdjtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgbm9ybWFsaXplVGltZSA9IHYgPT4gdiA8PSBtaW5WYWx1ZSA/IG1pblZhbHVlIDogY2xhbXBJbmZpbml0eShyb3VuZCh2LCAxMSkpO1xuXG4vLyBBcnJheXNcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUW119IGFcbiAqIEByZXR1cm4ge1RbXX1cbiAqL1xuY29uc3QgY2xvbmVBcnJheSA9IGEgPT4gaXNBcnIoYSkgPyBbIC4uLmEgXSA6IGE7XG5cbi8vIE9iamVjdHNcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFVcbiAqIEBwYXJhbSB7VH0gbzFcbiAqIEBwYXJhbSB7VX0gbzJcbiAqIEByZXR1cm4ge1QgJiBVfVxuICovXG5jb25zdCBtZXJnZU9iamVjdHMgPSAobzEsIG8yKSA9PiB7XG4gIGNvbnN0IG1lcmdlZCA9IC8qKiBAdHlwZSB7VCAmIFV9ICovKHsgLi4ubzEgfSk7XG4gIGZvciAobGV0IHAgaW4gbzIpIHtcbiAgICBjb25zdCBvMXAgPSAvKiogQHR5cGUge1QgJiBVfSAqLyhvMSlbcF07XG4gICAgbWVyZ2VkW3BdID0gaXNVbmQobzFwKSA/IC8qKiBAdHlwZSB7VCAmIFV9ICovKG8yKVtwXSA6IG8xcDtcbiAgfSAgcmV0dXJuIG1lcmdlZDtcbn07XG5cbi8vIExpbmtlZCBsaXN0c1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXZlcnNlXVxuICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2UHJvcF1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmV4dFByb3BdXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5jb25zdCBmb3JFYWNoQ2hpbGRyZW4gPSAocGFyZW50LCBjYWxsYmFjaywgcmV2ZXJzZSwgcHJldlByb3AgPSAnX3ByZXYnLCBuZXh0UHJvcCA9ICdfbmV4dCcpID0+IHtcbiAgbGV0IG5leHQgPSBwYXJlbnQuX2hlYWQ7XG4gIGxldCBhZGp1c3RlZE5leHRQcm9wID0gbmV4dFByb3A7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgbmV4dCA9IHBhcmVudC5fdGFpbDtcbiAgICBhZGp1c3RlZE5leHRQcm9wID0gcHJldlByb3A7XG4gIH1cbiAgd2hpbGUgKG5leHQpIHtcbiAgICBjb25zdCBjdXJyZW50TmV4dCA9IG5leHRbYWRqdXN0ZWROZXh0UHJvcF07XG4gICAgY2FsbGJhY2sobmV4dCk7XG4gICAgbmV4dCA9IGN1cnJlbnROZXh0O1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0gIHtPYmplY3R9IGNoaWxkXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtwcmV2UHJvcF1cbiAqIEBwYXJhbSAge1N0cmluZ30gW25leHRQcm9wXVxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuY29uc3QgcmVtb3ZlQ2hpbGQgPSAocGFyZW50LCBjaGlsZCwgcHJldlByb3AgPSAnX3ByZXYnLCBuZXh0UHJvcCA9ICdfbmV4dCcpID0+IHtcbiAgY29uc3QgcHJldiA9IGNoaWxkW3ByZXZQcm9wXTtcbiAgY29uc3QgbmV4dCA9IGNoaWxkW25leHRQcm9wXTtcbiAgcHJldiA/IHByZXZbbmV4dFByb3BdID0gbmV4dCA6IHBhcmVudC5faGVhZCA9IG5leHQ7XG4gIG5leHQgPyBuZXh0W3ByZXZQcm9wXSA9IHByZXYgOiBwYXJlbnQuX3RhaWwgPSBwcmV2O1xuICBjaGlsZFtwcmV2UHJvcF0gPSBudWxsO1xuICBjaGlsZFtuZXh0UHJvcF0gPSBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtICB7T2JqZWN0fSBjaGlsZFxuICogQHBhcmFtICB7RnVuY3Rpb259IFtzb3J0TWV0aG9kXVxuICogQHBhcmFtICB7U3RyaW5nfSBwcmV2UHJvcFxuICogQHBhcmFtICB7U3RyaW5nfSBuZXh0UHJvcFxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuY29uc3QgYWRkQ2hpbGQgPSAocGFyZW50LCBjaGlsZCwgc29ydE1ldGhvZCwgcHJldlByb3AgPSAnX3ByZXYnLCBuZXh0UHJvcCA9ICdfbmV4dCcpID0+IHtcbiAgbGV0IHByZXYgPSBwYXJlbnQuX3RhaWw7XG4gIHdoaWxlIChwcmV2ICYmIHNvcnRNZXRob2QgJiYgc29ydE1ldGhvZChwcmV2LCBjaGlsZCkpIHByZXYgPSBwcmV2W3ByZXZQcm9wXTtcbiAgY29uc3QgbmV4dCA9IHByZXYgPyBwcmV2W25leHRQcm9wXSA6IHBhcmVudC5faGVhZDtcbiAgcHJldiA/IHByZXZbbmV4dFByb3BdID0gY2hpbGQgOiBwYXJlbnQuX2hlYWQgPSBjaGlsZDtcbiAgbmV4dCA/IG5leHRbcHJldlByb3BdID0gY2hpbGQgOiBwYXJlbnQuX3RhaWwgPSBjaGlsZDtcbiAgY2hpbGRbcHJldlByb3BdID0gcHJldjtcbiAgY2hpbGRbbmV4dFByb3BdID0gbmV4dDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7KC4uLmFyZ3M6IGFueVtdKSA9PiBUaWNrYWJsZSB8ICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpfSBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7KC4uLmFyZ3M6IGFueVtdKSA9PiBUaWNrYWJsZSB8ICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpfVxuICovXG5jb25zdCBjcmVhdGVSZWZyZXNoYWJsZSA9IGNvbnN0cnVjdG9yID0+IHtcbiAgLyoqIEB0eXBlIHtUaWNrYWJsZX0gKi9cbiAgbGV0IHRyYWNrZWQ7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGxldCBjdXJyZW50SXRlcmF0aW9uLCBjdXJyZW50SXRlcmF0aW9uUHJvZ3Jlc3MsIHJldmVyc2VkLCBhbHRlcm5hdGU7XG4gICAgaWYgKHRyYWNrZWQpIHtcbiAgICAgIGN1cnJlbnRJdGVyYXRpb24gPSB0cmFja2VkLmN1cnJlbnRJdGVyYXRpb247XG4gICAgICBjdXJyZW50SXRlcmF0aW9uUHJvZ3Jlc3MgPSB0cmFja2VkLml0ZXJhdGlvblByb2dyZXNzO1xuICAgICAgcmV2ZXJzZWQgPSB0cmFja2VkLnJldmVyc2VkO1xuICAgICAgYWx0ZXJuYXRlID0gdHJhY2tlZC5fYWx0ZXJuYXRlO1xuICAgICAgdHJhY2tlZC5yZXZlcnQoKTtcbiAgICB9XG4gICAgY29uc3QgY2xlYW51cCA9IGNvbnN0cnVjdG9yKC4uLmFyZ3MpO1xuICAgIGlmIChjbGVhbnVwICYmICFpc0ZuYyhjbGVhbnVwKSAmJiBjbGVhbnVwLnJldmVydCkgdHJhY2tlZCA9IGNsZWFudXA7XG4gICAgaWYgKCFpc1VuZChjdXJyZW50SXRlcmF0aW9uUHJvZ3Jlc3MpKSB7XG4gICAgICAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0cmFja2VkKS5jdXJyZW50SXRlcmF0aW9uID0gY3VycmVudEl0ZXJhdGlvbjtcbiAgICAgIC8qKiBAdHlwZSB7VGlja2FibGV9ICovKHRyYWNrZWQpLml0ZXJhdGlvblByb2dyZXNzID0gKGFsdGVybmF0ZSA/ICEoY3VycmVudEl0ZXJhdGlvbiAlIDIpID8gcmV2ZXJzZWQgOiAhcmV2ZXJzZWQgOiByZXZlcnNlZCkgPyAxIC0gY3VycmVudEl0ZXJhdGlvblByb2dyZXNzIDogY3VycmVudEl0ZXJhdGlvblByb2dyZXNzO1xuICAgIH1cbiAgICByZXR1cm4gY2xlYW51cCB8fCBub29wO1xuICB9XG59O1xuXG4vKlxuICogQmFzZSBjbGFzcyB0byBjb250cm9sIGZyYW1lcmF0ZSBhbmQgcGxheWJhY2sgcmF0ZS5cbiAqIEluaGVyaXRlZCBieSBFbmdpbmUsIFRpbWVyLCBBbmltYXRpb24gYW5kIFRpbWVsaW5lLlxuICovXG5jbGFzcyBDbG9jayB7XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBbaW5pdFRpbWVdICovXG4gIGNvbnN0cnVjdG9yKGluaXRUaW1lID0gMCkge1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZGVsdGFUaW1lID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IGluaXRUaW1lO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gaW5pdFRpbWU7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gaW5pdFRpbWU7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fbGFzdFRpbWUgPSBpbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zY2hlZHVsZWRUaW1lID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9mcmFtZUR1cmF0aW9uID0gcm91bmQoSyAvIG1heEZwcywgMCk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZnBzID0gbWF4RnBzO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX3NwZWVkID0gMTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge1RpY2thYmxlfFR3ZWVufSAqL1xuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7VGlja2FibGV8VHdlZW59ICovXG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gIH1cblxuICBnZXQgZnBzKCkge1xuICAgIHJldHVybiB0aGlzLl9mcHM7XG4gIH1cblxuICBzZXQgZnBzKGZyYW1lUmF0ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzRnJhbWVEdXJhdGlvbiA9IHRoaXMuX2ZyYW1lRHVyYXRpb247XG4gICAgY29uc3QgZnIgPSArZnJhbWVSYXRlO1xuICAgIGNvbnN0IGZwcyA9IGZyIDwgbWluVmFsdWUgPyBtaW5WYWx1ZSA6IGZyO1xuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSByb3VuZChLIC8gZnBzLCAwKTtcbiAgICB0aGlzLl9mcHMgPSBmcHM7XG4gICAgdGhpcy5fZnJhbWVEdXJhdGlvbiA9IGZyYW1lRHVyYXRpb247XG4gICAgdGhpcy5fc2NoZWR1bGVkVGltZSArPSBmcmFtZUR1cmF0aW9uIC0gcHJldmlvdXNGcmFtZUR1cmF0aW9uO1xuICB9XG5cbiAgZ2V0IHNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zcGVlZDtcbiAgfVxuXG4gIHNldCBzcGVlZChwbGF5YmFja1JhdGUpIHtcbiAgICBjb25zdCBwYnIgPSArcGxheWJhY2tSYXRlO1xuICAgIHRoaXMuX3NwZWVkID0gcGJyIDwgbWluVmFsdWUgPyBtaW5WYWx1ZSA6IHBicjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVcbiAgICogQHJldHVybiB7dGlja01vZGVzfVxuICAgKi9cbiAgcmVxdWVzdFRpY2sodGltZSkge1xuICAgIGNvbnN0IHNjaGVkdWxlZFRpbWUgPSB0aGlzLl9zY2hlZHVsZWRUaW1lO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gdGhpcy5fZWxhcHNlZFRpbWU7XG4gICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gKHRpbWUgLSBlbGFwc2VkVGltZSk7XG4gICAgLy8gSWYgdGhlIGVsYXBzZWQgdGltZSBpcyBsb3dlciB0aGFuIHRoZSBzY2hlZHVsZWQgdGltZVxuICAgIC8vIHRoaXMgbWVhbnMgbm90IGVub3VnaCB0aW1lIGhhcyBwYXNzZWQgdG8gaGl0IG9uZSBmcmFtZUR1cmF0aW9uXG4gICAgLy8gc28gc2tpcCB0aGF0IGZyYW1lXG4gICAgaWYgKGVsYXBzZWRUaW1lIDwgc2NoZWR1bGVkVGltZSkgcmV0dXJuIHRpY2tNb2Rlcy5OT05FO1xuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSB0aGlzLl9mcmFtZUR1cmF0aW9uO1xuICAgIGNvbnN0IGZyYW1lRGVsdGEgPSBlbGFwc2VkVGltZSAtIHNjaGVkdWxlZFRpbWU7XG4gICAgLy8gRW5zdXJlcyB0aGF0IF9zY2hlZHVsZWRUaW1lIHByb2dyZXNzZXMgaW4gc3RlcHMgb2YgYXQgbGVhc3QgMSBmcmFtZUR1cmF0aW9uLlxuICAgIC8vIFNraXBzIGFoZWFkIGlmIHRoZSBhY3R1YWwgZWxhcHNlZCB0aW1lIGlzIGhpZ2hlci5cbiAgICB0aGlzLl9zY2hlZHVsZWRUaW1lICs9IGZyYW1lRGVsdGEgPCBmcmFtZUR1cmF0aW9uID8gZnJhbWVEdXJhdGlvbiA6IGZyYW1lRGVsdGE7XG4gICAgcmV0dXJuIHRpY2tNb2Rlcy5BVVRPO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdGltZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb21wdXRlRGVsdGFUaW1lKHRpbWUpIHtcbiAgICBjb25zdCBkZWx0YSA9IHRpbWUgLSB0aGlzLl9sYXN0VGltZTtcbiAgICB0aGlzLmRlbHRhVGltZSA9IGRlbHRhO1xuICAgIHRoaXMuX2xhc3RUaW1lID0gdGltZTtcbiAgICByZXR1cm4gZGVsdGE7XG4gIH1cblxufVxuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge1RpY2thYmxlfSB0aWNrYWJsZVxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG11dGVDYWxsYmFja3NcbiAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAqIEBwYXJhbSAge3RpY2tNb2Rlc30gdGlja01vZGVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcmVuZGVyID0gKHRpY2thYmxlLCB0aW1lLCBtdXRlQ2FsbGJhY2tzLCBpbnRlcm5hbFJlbmRlciwgdGlja01vZGUpID0+IHtcblxuICBjb25zdCBwYXJlbnQgPSB0aWNrYWJsZS5wYXJlbnQ7XG4gIGNvbnN0IGR1cmF0aW9uID0gdGlja2FibGUuZHVyYXRpb247XG4gIGNvbnN0IGNvbXBsZXRlZCA9IHRpY2thYmxlLmNvbXBsZXRlZDtcbiAgY29uc3QgaXRlcmF0aW9uRHVyYXRpb24gPSB0aWNrYWJsZS5pdGVyYXRpb25EdXJhdGlvbjtcbiAgY29uc3QgaXRlcmF0aW9uQ291bnQgPSB0aWNrYWJsZS5pdGVyYXRpb25Db3VudDtcbiAgY29uc3QgX2N1cnJlbnRJdGVyYXRpb24gPSB0aWNrYWJsZS5fY3VycmVudEl0ZXJhdGlvbjtcbiAgY29uc3QgX2xvb3BEZWxheSA9IHRpY2thYmxlLl9sb29wRGVsYXk7XG4gIGNvbnN0IF9yZXZlcnNlZCA9IHRpY2thYmxlLl9yZXZlcnNlZDtcbiAgY29uc3QgX2FsdGVybmF0ZSA9IHRpY2thYmxlLl9hbHRlcm5hdGU7XG4gIGNvbnN0IF9oYXNDaGlsZHJlbiA9IHRpY2thYmxlLl9oYXNDaGlsZHJlbjtcbiAgY29uc3QgdGlja2FibGVEZWxheSA9IHRpY2thYmxlLl9kZWxheTtcbiAgY29uc3QgdGlja2FibGVQcmV2QWJzb2x1dGVUaW1lID0gdGlja2FibGUuX2N1cnJlbnRUaW1lOyAvLyBUT0RPOiByZW5hbWUgLl9jdXJyZW50VGltZSB0byAuX2Fic29sdXRlQ3VycmVudFRpbWVcblxuICBjb25zdCB0aWNrYWJsZUVuZFRpbWUgPSB0aWNrYWJsZURlbGF5ICsgaXRlcmF0aW9uRHVyYXRpb247XG4gIGNvbnN0IHRpY2thYmxlQWJzb2x1dGVUaW1lID0gdGltZSAtIHRpY2thYmxlRGVsYXk7XG4gIGNvbnN0IHRpY2thYmxlUHJldlRpbWUgPSBjbGFtcCh0aWNrYWJsZVByZXZBYnNvbHV0ZVRpbWUsIC10aWNrYWJsZURlbGF5LCBkdXJhdGlvbik7XG4gIGNvbnN0IHRpY2thYmxlQ3VycmVudFRpbWUgPSBjbGFtcCh0aWNrYWJsZUFic29sdXRlVGltZSwgLXRpY2thYmxlRGVsYXksIGR1cmF0aW9uKTtcbiAgY29uc3QgZGVsdGFUaW1lID0gdGlja2FibGVBYnNvbHV0ZVRpbWUgLSB0aWNrYWJsZVByZXZBYnNvbHV0ZVRpbWU7XG4gIGNvbnN0IGlzQ3VycmVudFRpbWVBYm92ZVplcm8gPSB0aWNrYWJsZUN1cnJlbnRUaW1lID4gMDtcbiAgY29uc3QgaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID0gdGlja2FibGVDdXJyZW50VGltZSA+PSBkdXJhdGlvbjtcbiAgY29uc3QgaXNTZXR0ZXIgPSBkdXJhdGlvbiA8PSBtaW5WYWx1ZTtcbiAgY29uc3QgZm9yY2VkVGljayA9IHRpY2tNb2RlID09PSB0aWNrTW9kZXMuRk9SQ0U7XG5cbiAgbGV0IGlzT2RkID0gMDtcbiAgbGV0IGl0ZXJhdGlvbkVsYXBzZWRUaW1lID0gdGlja2FibGVBYnNvbHV0ZVRpbWU7XG4gIC8vIFJlbmRlciBjaGVja3NcbiAgLy8gVXNlZCB0byBhbHNvIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIHJlbmRlcmVkIGluIG9yZGVyIHRvIHRyaWdnZXIgdGhlIG9uUmVuZGVyIGNhbGxiYWNrIG9uIHRoZSBwYXJlbnQgdGltZXJcbiAgbGV0IGhhc1JlbmRlcmVkID0gMDtcblxuICAvLyBFeGVjdXRlIHRoZSBcImV4cGVuc2l2ZVwiIGl0ZXJhdGlvbnMgY2FsY3VsYXRpb25zIG9ubHkgd2hlbiBuZWNlc3NhcnlcbiAgaWYgKGl0ZXJhdGlvbkNvdW50ID4gMSkge1xuICAgIC8vIGJpdHdpc2UgTk9UIG9wZXJhdG9yIHNlZW1zIHRvIGJlIGdlbmVyYWxseSBmYXN0ZXIgdGhhbiBNYXRoLmZsb29yKCkgYWNyb3NzIGJyb3dzZXJzXG4gICAgY29uc3QgY3VycmVudEl0ZXJhdGlvbiA9IH5+KHRpY2thYmxlQ3VycmVudFRpbWUgLyAoaXRlcmF0aW9uRHVyYXRpb24gKyAoaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID8gMCA6IF9sb29wRGVsYXkpKSk7XG4gICAgdGlja2FibGUuX2N1cnJlbnRJdGVyYXRpb24gPSBjbGFtcChjdXJyZW50SXRlcmF0aW9uLCAwLCBpdGVyYXRpb25Db3VudCk7XG4gICAgLy8gUHJldmVudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIGdvIGFib3ZlIHRoZSBtYXggaXRlcmF0aW9ucyB3aGVuIHJlYWNoaW5nIHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvblxuICAgIGlmIChpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24pIHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uLS07XG4gICAgaXNPZGQgPSB0aWNrYWJsZS5fY3VycmVudEl0ZXJhdGlvbiAlIDI7XG4gICAgaXRlcmF0aW9uRWxhcHNlZFRpbWUgPSB0aWNrYWJsZUN1cnJlbnRUaW1lICUgKGl0ZXJhdGlvbkR1cmF0aW9uICsgX2xvb3BEZWxheSkgfHwgMDtcbiAgfVxuXG4gIC8vIENoZWNrcyBpZiBleGFjdGx5IG9uZSBvZiBfcmV2ZXJzZWQgYW5kIChfYWx0ZXJuYXRlICYmIGlzT2RkKSBpcyB0cnVlXG4gIGNvbnN0IGlzUmV2ZXJzZWQgPSBfcmV2ZXJzZWQgXiAoX2FsdGVybmF0ZSAmJiBpc09kZCk7XG4gIGNvbnN0IF9lYXNlID0gLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqLyh0aWNrYWJsZSkuX2Vhc2U7XG4gIGxldCBpdGVyYXRpb25UaW1lID0gaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID8gaXNSZXZlcnNlZCA/IDAgOiBkdXJhdGlvbiA6IGlzUmV2ZXJzZWQgPyBpdGVyYXRpb25EdXJhdGlvbiAtIGl0ZXJhdGlvbkVsYXBzZWRUaW1lIDogaXRlcmF0aW9uRWxhcHNlZFRpbWU7XG4gIGlmIChfZWFzZSkgaXRlcmF0aW9uVGltZSA9IGl0ZXJhdGlvbkR1cmF0aW9uICogX2Vhc2UoaXRlcmF0aW9uVGltZSAvIGl0ZXJhdGlvbkR1cmF0aW9uKSB8fCAwO1xuICBjb25zdCBpc1J1bm5pbmdCYWNrd2FyZHMgPSAocGFyZW50ID8gcGFyZW50LmJhY2t3YXJkcyA6IHRpY2thYmxlQWJzb2x1dGVUaW1lIDwgdGlja2FibGVQcmV2QWJzb2x1dGVUaW1lKSA/ICFpc1JldmVyc2VkIDogISFpc1JldmVyc2VkO1xuXG4gIHRpY2thYmxlLl9jdXJyZW50VGltZSA9IHRpY2thYmxlQWJzb2x1dGVUaW1lO1xuICB0aWNrYWJsZS5faXRlcmF0aW9uVGltZSA9IGl0ZXJhdGlvblRpbWU7XG4gIHRpY2thYmxlLmJhY2t3YXJkcyA9IGlzUnVubmluZ0JhY2t3YXJkcztcblxuICBpZiAoaXNDdXJyZW50VGltZUFib3ZlWmVybyAmJiAhdGlja2FibGUuYmVnYW4pIHtcbiAgICB0aWNrYWJsZS5iZWdhbiA9IHRydWU7XG4gICAgaWYgKCFtdXRlQ2FsbGJhY2tzICYmICEocGFyZW50ICYmIChpc1J1bm5pbmdCYWNrd2FyZHMgfHwgIXBhcmVudC5iZWdhbikpKSB7XG4gICAgICB0aWNrYWJsZS5vbkJlZ2luKC8qKiBAdHlwZSB7Q2FsbGJhY2tBcmd1bWVudH0gKi8odGlja2FibGUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGlja2FibGVBYnNvbHV0ZVRpbWUgPD0gMCkge1xuICAgIHRpY2thYmxlLmJlZ2FuID0gZmFsc2U7XG4gIH1cblxuICAvLyBPbmx5IHRyaWdnZXJzIG9uTG9vcCBmb3IgdGlja2FibGUgd2l0aG91dCBjaGlsZHJlbiwgb3RoZXJ3aXNlIGNhbGwgdGhlIHRoZSBvbkxvb3AgY2FsbGJhY2sgaW4gdGhlIHRpY2sgZnVuY3Rpb25cbiAgLy8gTWFrZSBzdXJlIHRvIHRyaWdnZXIgdGhlIG9uTG9vcCBiZWZvcmUgcmVuZGVyaW5nIHRvIGFsbG93IC5yZWZyZXNoKCkgdG8gcGlja3VwIHRoZSBjdXJyZW50IHZhbHVlc1xuICBpZiAoIW11dGVDYWxsYmFja3MgJiYgIV9oYXNDaGlsZHJlbiAmJiBpc0N1cnJlbnRUaW1lQWJvdmVaZXJvICYmIHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uICE9PSBfY3VycmVudEl0ZXJhdGlvbikge1xuICAgIHRpY2thYmxlLm9uTG9vcCgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRpY2thYmxlKSk7XG4gIH1cblxuICBpZiAoXG4gICAgZm9yY2VkVGljayB8fFxuICAgIHRpY2tNb2RlID09PSB0aWNrTW9kZXMuQVVUTyAmJiAoXG4gICAgICB0aW1lID49IHRpY2thYmxlRGVsYXkgJiYgdGltZSA8PSB0aWNrYWJsZUVuZFRpbWUgfHwgLy8gTm9ybWFsIHJlbmRlclxuICAgICAgdGltZSA8PSB0aWNrYWJsZURlbGF5ICYmIHRpY2thYmxlUHJldlRpbWUgPiB0aWNrYWJsZURlbGF5IHx8IC8vIFBsYXloZWFkIGlzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0IHRpbWUgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgYXQgaXRzIGluaXRpYWwgc3RhdGVcbiAgICAgIHRpbWUgPj0gdGlja2FibGVFbmRUaW1lICYmIHRpY2thYmxlUHJldlRpbWUgIT09IGR1cmF0aW9uIC8vIFBsYXloZWFkIGlzIGFmdGVyIHRoZSBhbmltYXRpb24gZW5kIHRpbWUgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgYXQgaXRzIGVuZCBzdGF0ZVxuICAgICkgfHxcbiAgICBpdGVyYXRpb25UaW1lID49IHRpY2thYmxlRW5kVGltZSAmJiB0aWNrYWJsZVByZXZUaW1lICE9PSBkdXJhdGlvbiB8fFxuICAgIGl0ZXJhdGlvblRpbWUgPD0gdGlja2FibGVEZWxheSAmJiB0aWNrYWJsZVByZXZUaW1lID4gMCB8fFxuICAgIHRpbWUgPD0gdGlja2FibGVQcmV2VGltZSAmJiB0aWNrYWJsZVByZXZUaW1lID09PSBkdXJhdGlvbiAmJiBjb21wbGV0ZWQgfHwgLy8gRm9yY2UgYSByZW5kZXIgaWYgYSBzZWVrIG9jY3VycyBvbiBhbiBjb21wbGV0ZWQgYW5pbWF0aW9uXG4gICAgaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uICYmICFjb21wbGV0ZWQgJiYgaXNTZXR0ZXIgLy8gVGhpcyBwcmV2ZW50cyAwIGR1cmF0aW9uIHRpY2thYmxlcyB0byBiZSBza2lwcGVkXG4gICkge1xuXG4gICAgaWYgKGlzQ3VycmVudFRpbWVBYm92ZVplcm8pIHtcbiAgICAgIC8vIFRyaWdnZXIgb25VcGRhdGUgY2FsbGJhY2sgYmVmb3JlIHJlbmRlcmluZ1xuICAgICAgdGlja2FibGUuY29tcHV0ZURlbHRhVGltZSh0aWNrYWJsZVByZXZUaW1lKTtcbiAgICAgIGlmICghbXV0ZUNhbGxiYWNrcykgdGlja2FibGUub25CZWZvcmVVcGRhdGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHR3ZWVucyByZW5kZXJpbmdcbiAgICBpZiAoIV9oYXNDaGlsZHJlbikge1xuXG4gICAgICAvLyBUaW1lIGhhcyBqdW1wZWQgbW9yZSB0aGFuIGdsb2JhbHMudGlja1RocmVzaG9sZCBzbyBjb25zaWRlciB0aGlzIHRpY2sgbWFudWFsXG4gICAgICBjb25zdCBmb3JjZWRSZW5kZXIgPSBmb3JjZWRUaWNrIHx8IChpc1J1bm5pbmdCYWNrd2FyZHMgPyBkZWx0YVRpbWUgKiAtMSA6IGRlbHRhVGltZSkgPj0gZ2xvYmFscy50aWNrVGhyZXNob2xkO1xuICAgICAgY29uc3QgYWJzb2x1dGVUaW1lID0gdGlja2FibGUuX29mZnNldCArIChwYXJlbnQgPyBwYXJlbnQuX29mZnNldCA6IDApICsgdGlja2FibGVEZWxheSArIGl0ZXJhdGlvblRpbWU7XG5cbiAgICAgIC8vIE9ubHkgQW5pbWF0aW9uIGNhbiBoYXZlIHR3ZWVucywgVGltZXIgcmV0dXJucyB1bmRlZmluZWRcbiAgICAgIGxldCB0d2VlbiA9IC8qKiBAdHlwZSB7VHdlZW59ICovKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKHRpY2thYmxlKS5faGVhZCk7XG4gICAgICBsZXQgdHdlZW5UYXJnZXQ7XG4gICAgICBsZXQgdHdlZW5TdHlsZTtcbiAgICAgIGxldCB0d2VlblRhcmdldFRyYW5zZm9ybXM7XG4gICAgICBsZXQgdHdlZW5UYXJnZXRUcmFuc2Zvcm1zUHJvcGVydGllcztcbiAgICAgIGxldCB0d2VlblRyYW5zZm9ybXNOZWVkVXBkYXRlID0gMDtcblxuICAgICAgd2hpbGUgKHR3ZWVuKSB7XG5cbiAgICAgICAgY29uc3QgdHdlZW5Db21wb3NpdGlvbiA9IHR3ZWVuLl9jb21wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdHdlZW5DdXJyZW50VGltZSA9IHR3ZWVuLl9jdXJyZW50VGltZTtcbiAgICAgICAgY29uc3QgdHdlZW5DaGFuZ2VEdXJhdGlvbiA9IHR3ZWVuLl9jaGFuZ2VEdXJhdGlvbjtcbiAgICAgICAgY29uc3QgdHdlZW5BYnNFbmRUaW1lID0gdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lICsgdHdlZW4uX2NoYW5nZUR1cmF0aW9uO1xuICAgICAgICBjb25zdCB0d2Vlbk5leHRSZXAgPSB0d2Vlbi5fbmV4dFJlcDtcbiAgICAgICAgY29uc3QgdHdlZW5QcmV2UmVwID0gdHdlZW4uX3ByZXZSZXA7XG4gICAgICAgIGNvbnN0IHR3ZWVuSGFzQ29tcG9zaXRpb24gPSB0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLm5vbmU7XG5cbiAgICAgICAgaWYgKChmb3JjZWRSZW5kZXIgfHwgKFxuICAgICAgICAgICAgKHR3ZWVuQ3VycmVudFRpbWUgIT09IHR3ZWVuQ2hhbmdlRHVyYXRpb24gfHwgYWJzb2x1dGVUaW1lIDw9IHR3ZWVuQWJzRW5kVGltZSArICh0d2Vlbk5leHRSZXAgPyB0d2Vlbk5leHRSZXAuX2RlbGF5IDogMCkpICYmXG4gICAgICAgICAgICAodHdlZW5DdXJyZW50VGltZSAhPT0gMCB8fCBhYnNvbHV0ZVRpbWUgPj0gdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lKVxuICAgICAgICAgICkpICYmICghdHdlZW5IYXNDb21wb3NpdGlvbiB8fCAoXG4gICAgICAgICAgICAhdHdlZW4uX2lzT3ZlcnJpZGRlbiAmJlxuICAgICAgICAgICAgKCF0d2Vlbi5faXNPdmVybGFwcGVkIHx8IGFic29sdXRlVGltZSA8PSB0d2VlbkFic0VuZFRpbWUpICYmXG4gICAgICAgICAgICAoIXR3ZWVuTmV4dFJlcCB8fCAodHdlZW5OZXh0UmVwLl9pc092ZXJyaWRkZW4gfHwgYWJzb2x1dGVUaW1lIDw9IHR3ZWVuTmV4dFJlcC5fYWJzb2x1dGVTdGFydFRpbWUpKSAmJlxuICAgICAgICAgICAgKCF0d2VlblByZXZSZXAgfHwgKHR3ZWVuUHJldlJlcC5faXNPdmVycmlkZGVuIHx8IChhYnNvbHV0ZVRpbWUgPj0gKHR3ZWVuUHJldlJlcC5fYWJzb2x1dGVTdGFydFRpbWUgKyB0d2VlblByZXZSZXAuX2NoYW5nZUR1cmF0aW9uKSArIHR3ZWVuLl9kZWxheSkpKVxuICAgICAgICAgICkpXG4gICAgICAgICkge1xuXG4gICAgICAgICAgY29uc3QgdHdlZW5OZXdUaW1lID0gdHdlZW4uX2N1cnJlbnRUaW1lID0gY2xhbXAoaXRlcmF0aW9uVGltZSAtIHR3ZWVuLl9zdGFydFRpbWUsIDAsIHR3ZWVuQ2hhbmdlRHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuUHJvZ3Jlc3MgPSB0d2Vlbi5fZWFzZSh0d2Vlbk5ld1RpbWUgLyB0d2Vlbi5fdXBkYXRlRHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuTW9kaWZpZXIgPSB0d2Vlbi5fbW9kaWZpZXI7XG4gICAgICAgICAgY29uc3QgdHdlZW5WYWx1ZVR5cGUgPSB0d2Vlbi5fdmFsdWVUeXBlO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuVHlwZSA9IHR3ZWVuLl90d2VlblR5cGU7XG4gICAgICAgICAgY29uc3QgdHdlZW5Jc09iamVjdCA9IHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5PQkpFQ1Q7XG4gICAgICAgICAgY29uc3QgdHdlZW5Jc051bWJlciA9IHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLk5VTUJFUjtcbiAgICAgICAgICAvLyBPbmx5IHJvdW5kIHRoZSBpbi1iZXR3ZWVuIGZyYW1lcyB2YWx1ZXMgaWYgdGhlIGZpbmFsIHZhbHVlIGlzIGEgc3RyaW5nXG4gICAgICAgICAgY29uc3QgdHdlZW5QcmVjaXNpb24gPSAodHdlZW5Jc051bWJlciAmJiB0d2VlbklzT2JqZWN0KSB8fCB0d2VlblByb2dyZXNzID09PSAwIHx8IHR3ZWVuUHJvZ3Jlc3MgPT09IDEgPyAtMSA6IGdsb2JhbHMucHJlY2lzaW9uO1xuXG4gICAgICAgICAgLy8gUmVjb21wb3NlIHR3ZWVuIHZhbHVlXG4gICAgICAgICAgLyoqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfSAqL1xuICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICAgICBsZXQgbnVtYmVyO1xuXG4gICAgICAgICAgaWYgKHR3ZWVuSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIocm91bmQoaW50ZXJwb2xhdGUodHdlZW4uX2Zyb21OdW1iZXIsIHR3ZWVuLl90b051bWJlciwgIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbiApKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0d2VlblZhbHVlVHlwZSA9PT0gdmFsdWVUeXBlcy5VTklUKSB7XG4gICAgICAgICAgICAvLyBSb3VuZGluZyB0aGUgdmFsdWVzIHNwZWVkIHVwIHN0cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgICAgbnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIocm91bmQoaW50ZXJwb2xhdGUodHdlZW4uX2Zyb21OdW1iZXIsIHR3ZWVuLl90b051bWJlciwgIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKTtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7bnVtYmVyfSR7dHdlZW4uX3VuaXR9YDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTE9SKSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHR3ZWVuLl9mcm9tTnVtYmVycztcbiAgICAgICAgICAgIGNvbnN0IHRuID0gdHdlZW4uX3RvTnVtYmVycztcbiAgICAgICAgICAgIGNvbnN0IHIgPSByb3VuZChjbGFtcCgvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihpbnRlcnBvbGF0ZShmblswXSwgdG5bMF0sIHR3ZWVuUHJvZ3Jlc3MpKSksIDAsIDI1NSksIDApO1xuICAgICAgICAgICAgY29uc3QgZyA9IHJvdW5kKGNsYW1wKC8qKiBAdHlwZSB7TnVtYmVyfSAqLyh0d2Vlbk1vZGlmaWVyKGludGVycG9sYXRlKGZuWzFdLCB0blsxXSwgdHdlZW5Qcm9ncmVzcykpKSwgMCwgMjU1KSwgMCk7XG4gICAgICAgICAgICBjb25zdCBiID0gcm91bmQoY2xhbXAoLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIoaW50ZXJwb2xhdGUoZm5bMl0sIHRuWzJdLCB0d2VlblByb2dyZXNzKSkpLCAwLCAyNTUpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBjbGFtcCgvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihyb3VuZChpbnRlcnBvbGF0ZShmblszXSwgdG5bM10sIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKSwgMCwgMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGByZ2JhKCR7cn0sJHtnfSwke2J9LCR7YX0pYDtcbiAgICAgICAgICAgIGlmICh0d2Vlbkhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5zID0gdHdlZW4uX251bWJlcnM7XG4gICAgICAgICAgICAgIG5zWzBdID0gcjtcbiAgICAgICAgICAgICAgbnNbMV0gPSBnO1xuICAgICAgICAgICAgICBuc1syXSA9IGI7XG4gICAgICAgICAgICAgIG5zWzNdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTVBMRVgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHdlZW4uX3N0cmluZ3NbMF07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbCA9IHR3ZWVuLl90b051bWJlcnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSAvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihyb3VuZChpbnRlcnBvbGF0ZSh0d2Vlbi5fZnJvbU51bWJlcnNbal0sIHR3ZWVuLl90b051bWJlcnNbal0sIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKTtcbiAgICAgICAgICAgICAgY29uc3QgcyA9IHR3ZWVuLl9zdHJpbmdzW2ogKyAxXTtcbiAgICAgICAgICAgICAgdmFsdWUgKz0gYCR7cyA/IG4gKyBzIDogbn1gO1xuICAgICAgICAgICAgICBpZiAodHdlZW5IYXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHR3ZWVuLl9udW1iZXJzW2pdID0gbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZvciBhZGRpdGl2ZSB0d2VlbnMgYW5kIEFuaW1hdGFibGVzXG4gICAgICAgICAgaWYgKHR3ZWVuSGFzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHR3ZWVuLl9udW1iZXIgPSBudW1iZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbnRlcm5hbFJlbmRlciAmJiB0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLmJsZW5kKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuUHJvcGVydHkgPSB0d2Vlbi5wcm9wZXJ0eTtcbiAgICAgICAgICAgIHR3ZWVuVGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAodHdlZW5Jc09iamVjdCkge1xuICAgICAgICAgICAgICB0d2VlblRhcmdldFt0d2VlblByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgIC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc2V0QXR0cmlidXRlKHR3ZWVuUHJvcGVydHksIC8qKiBAdHlwZSB7U3RyaW5nfSAqLyh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW5TdHlsZSA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc3R5bGU7XG4gICAgICAgICAgICAgIGlmICh0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR3ZWVuVGFyZ2V0ICE9PSB0d2VlblRhcmdldFRyYW5zZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgIHR3ZWVuVGFyZ2V0VHJhbnNmb3JtcyA9IHR3ZWVuVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgLy8gTk9URTogUmVmZXJlbmNpbmcgdGhlIGNhY2hlZFRyYW5zZm9ybXMgaW4gdGhlIHR3ZWVuIHByb3BlcnR5IGRpcmVjdGx5IGNhbiBiZSBhIGxpdHRsZSBiaXQgZmFzdGVyIGJ1dCBhcHBlYXJzIHRvIGluY3JlYXNlIG1lbW9yeSB1c2FnZS5cbiAgICAgICAgICAgICAgICAgIHR3ZWVuVGFyZ2V0VHJhbnNmb3Jtc1Byb3BlcnRpZXMgPSB0d2VlblRhcmdldFt0cmFuc2Zvcm1zU3ltYm9sXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHdlZW5UYXJnZXRUcmFuc2Zvcm1zUHJvcGVydGllc1t0d2VlblByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHR3ZWVuVHJhbnNmb3Jtc05lZWRVcGRhdGUgPSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5DU1MpIHtcbiAgICAgICAgICAgICAgICB0d2VlblN0eWxlW3R3ZWVuUHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLkNTU19WQVIpIHtcbiAgICAgICAgICAgICAgICB0d2VlblN0eWxlLnNldFByb3BlcnR5KHR3ZWVuUHJvcGVydHksLyoqIEB0eXBlIHtTdHJpbmd9ICovKHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQ3VycmVudFRpbWVBYm92ZVplcm8pIGhhc1JlbmRlcmVkID0gMTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2VkIGZvciBjb21wb3NpbmcgdGltZWxpbmUgdHdlZW5zIHdpdGhvdXQgaGF2aW5nIHRvIGRvIGEgcmVhbCByZW5kZXJcbiAgICAgICAgICAgIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTk9URTogUG9zc2libGUgaW1wcm92ZW1lbnQ6IFVzZSB0cmFuc2xhdGUoeCx5KSAvIHRyYW5zbGF0ZTNkKHgseSx6KSBzeW50YXhcbiAgICAgICAgLy8gdG8gcmVkdWNlIG1lbW9yeSB1c2FnZSBvbiBzdHJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgaWYgKHR3ZWVuVHJhbnNmb3Jtc05lZWRVcGRhdGUgJiYgdHdlZW4uX3JlbmRlclRyYW5zZm9ybXMpIHtcbiAgICAgICAgICBsZXQgc3RyID0gZW1wdHlTdHJpbmc7XG4gICAgICAgICAgZm9yIChsZXQga2V5IGluIHR3ZWVuVGFyZ2V0VHJhbnNmb3Jtc1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHN0ciArPSBgJHt0cmFuc2Zvcm1zRnJhZ21lbnRTdHJpbmdzW2tleV19JHt0d2VlblRhcmdldFRyYW5zZm9ybXNQcm9wZXJ0aWVzW2tleV19KSBgO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0d2VlblN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICAgICAgICB0d2VlblRyYW5zZm9ybXNOZWVkVXBkYXRlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHR3ZWVuID0gdHdlZW4uX25leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghbXV0ZUNhbGxiYWNrcyAmJiBoYXNSZW5kZXJlZCkge1xuICAgICAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqLyh0aWNrYWJsZSkub25SZW5kZXIoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8odGlja2FibGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgaXNDdXJyZW50VGltZUFib3ZlWmVybykge1xuICAgICAgdGlja2FibGUub25VcGRhdGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgIH1cblxuICB9XG5cbiAgLy8gRW5kIHR3ZWVucyByZW5kZXJpbmdcblxuICAvLyBIYW5kbGUgc2V0dGVycyBvbiB0aW1lbGluZSBkaWZmZXJlbnRseSBhbmQgYWxsb3cgcmUtdHJpZ2VyaW5nIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIHdoZW4gc2Vla2luZyBiYWNrd2FyZHNcbiAgaWYgKHBhcmVudCAmJiBpc1NldHRlcikge1xuICAgIGlmICghbXV0ZUNhbGxiYWNrcyAmJiAoXG4gICAgICAocGFyZW50LmJlZ2FuICYmICFpc1J1bm5pbmdCYWNrd2FyZHMgJiYgdGlja2FibGVBYnNvbHV0ZVRpbWUgPj0gZHVyYXRpb24gJiYgIWNvbXBsZXRlZCkgfHxcbiAgICAgIChpc1J1bm5pbmdCYWNrd2FyZHMgJiYgdGlja2FibGVBYnNvbHV0ZVRpbWUgPD0gbWluVmFsdWUgJiYgY29tcGxldGVkKVxuICAgICkpIHtcbiAgICAgIHRpY2thYmxlLm9uQ29tcGxldGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgICAgdGlja2FibGUuY29tcGxldGVkID0gIWlzUnVubmluZ0JhY2t3YXJkcztcbiAgICB9XG4gIC8vIElmIGN1cnJlbnRUaW1lIGlzIGJvdGggYWJvdmUgMCBhbmQgYXQgbGVhc3QgZXF1YWxzIHRvIGR1cmF0aW9uLCBoYW5kbGVzIG5vcm1hbCBvbkNvbXBsZXRlIG9yIGluZmluaXRlIGxvb3BzXG4gIH0gZWxzZSBpZiAoaXNDdXJyZW50VGltZUFib3ZlWmVybyAmJiBpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24pIHtcbiAgICBpZiAoaXRlcmF0aW9uQ291bnQgPT09IEluZmluaXR5KSB7XG4gICAgICAvLyBPZmZzZXQgdGhlIHRpY2thYmxlIF9zdGFydFRpbWUgd2l0aCBpdHMgZHVyYXRpb24gdG8gcmVzZXQgX2N1cnJlbnRUaW1lIHRvIDAgYW5kIGNvbnRpbnVlIHRoZSBpbmZpbml0ZSB0aW1lclxuICAgICAgdGlja2FibGUuX3N0YXJ0VGltZSArPSB0aWNrYWJsZS5kdXJhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uID49IGl0ZXJhdGlvbkNvdW50IC0gMSkge1xuICAgICAgLy8gQnkgc2V0dGluZyBwYXVzZWQgdG8gdHJ1ZSwgd2UgdGVsbCB0aGUgZW5naW5lIGxvb3AgdG8gbm90IHJlbmRlciB0aGlzIHRpY2thYmxlIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGxpc3Qgb24gdGhlIG5leHQgdGlja1xuICAgICAgdGlja2FibGUucGF1c2VkID0gdHJ1ZTtcbiAgICAgIGlmICghY29tcGxldGVkICYmICFfaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgLy8gSWYgdGhlIHRpY2thYmxlIGhhcyBjaGlsZHJlbiwgdHJpZ2dlcnMgb25Db21wbGV0ZSgpIG9ubHkgd2hlbiBhbGwgY2hpbGRyZW4gaGF2ZSBjb21wbGV0ZWQgaW4gdGhlIHRpY2sgZnVuY3Rpb25cbiAgICAgICAgdGlja2FibGUuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFtdXRlQ2FsbGJhY2tzICYmICEocGFyZW50ICYmIChpc1J1bm5pbmdCYWNrd2FyZHMgfHwgIXBhcmVudC5iZWdhbikpKSB7XG4gICAgICAgICAgdGlja2FibGUub25Db21wbGV0ZSgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRpY2thYmxlKSk7XG4gICAgICAgICAgdGlja2FibGUuX3Jlc29sdmUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBjb21wbGV0ZWQgZmxhZyB0byBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHRpY2thYmxlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gTk9URTogaGFzUmVuZGVyZWQgKiBkaXJlY3Rpb24gKG5lZ2F0aXZlIGZvciBiYWNrd2FyZHMpIHRoaXMgd2F5IHdlIGNhbiByZW1vdmUgdGhlIHRpY2thYmxlLmJhY2t3YXJkcyBwcm9wZXJ0eSBjb21wbGV0bHkgP1xuICByZXR1cm4gaGFzUmVuZGVyZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RpY2thYmxlfSB0aWNrYWJsZVxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG11dGVDYWxsYmFja3NcbiAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAqIEBwYXJhbSAge051bWJlcn0gdGlja01vZGVcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmNvbnN0IHRpY2sgPSAodGlja2FibGUsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZSkgPT4ge1xuICBjb25zdCBfY3VycmVudEl0ZXJhdGlvbiA9IHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uO1xuICByZW5kZXIodGlja2FibGUsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZSk7XG4gIGlmICh0aWNrYWJsZS5faGFzQ2hpbGRyZW4pIHtcbiAgICBjb25zdCB0bCA9IC8qKiBAdHlwZSB7VGltZWxpbmV9ICovKHRpY2thYmxlKTtcbiAgICBjb25zdCB0bElzUnVubmluZ0JhY2t3YXJkcyA9IHRsLmJhY2t3YXJkcztcbiAgICBjb25zdCB0bENoaWxkcmVuVGltZSA9IGludGVybmFsUmVuZGVyID8gdGltZSA6IHRsLl9pdGVyYXRpb25UaW1lO1xuICAgIGNvbnN0IHRsQ2lsZHJlblRpY2tUaW1lID0gbm93KCk7XG5cbiAgICBsZXQgdGxDaGlsZHJlbkhhc1JlbmRlcmVkID0gMDtcbiAgICBsZXQgdGxDaGlsZHJlbkhhdmVDb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgLy8gSWYgdGhlIHRpbWVsaW5lIGhhcyBsb29wZWQgZm9yd2FyZCwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VycyBjaGlsZHJlbiBza2lwcGVkIGNhbGxiYWNrc1xuICAgIGlmICghaW50ZXJuYWxSZW5kZXIgJiYgdGwuX2N1cnJlbnRJdGVyYXRpb24gIT09IF9jdXJyZW50SXRlcmF0aW9uKSB7XG4gICAgICBjb25zdCB0bEl0ZXJhdGlvbkR1cmF0aW9uID0gdGwuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGwsICgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL2NoaWxkKSA9PiB7XG4gICAgICAgIGlmICghdGxJc1J1bm5pbmdCYWNrd2FyZHMpIHtcbiAgICAgICAgICAvLyBGb3JjZSBhbiBpbnRlcm5hbCByZW5kZXIgdG8gdHJpZ2dlciB0aGUgY2FsbGJhY2tzIGlmIHRoZSBjaGlsZCBoYXMgbm90IGNvbXBsZXRlZCBvbiBsb29wXG4gICAgICAgICAgaWYgKCFjaGlsZC5jb21wbGV0ZWQgJiYgIWNoaWxkLmJhY2t3YXJkcyAmJiBjaGlsZC5fY3VycmVudFRpbWUgPCBjaGlsZC5pdGVyYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgcmVuZGVyKGNoaWxkLCB0bEl0ZXJhdGlvbkR1cmF0aW9uLCBtdXRlQ2FsbGJhY2tzLCAxLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGVpciBiZWdhbiBhbmQgY29tcGxldGVkIGZsYWdzIHRvIGFsbG93IHJldHJpZ2VyaW5nIGNhbGxiYWNrcyBvbiB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICBjaGlsZC5iZWdhbiA9IGZhbHNlO1xuICAgICAgICAgIGNoaWxkLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNoaWxkRHVyYXRpb24gPSBjaGlsZC5kdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBjaGlsZFN0YXJ0VGltZSA9IGNoaWxkLl9vZmZzZXQgKyBjaGlsZC5fZGVsYXk7XG4gICAgICAgICAgY29uc3QgY2hpbGRFbmRUaW1lID0gY2hpbGRTdGFydFRpbWUgKyBjaGlsZER1cmF0aW9uO1xuICAgICAgICAgIC8vIFRyaWdnZXJzIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIG9uIHJldmVyc2UgZm9yIGNoaWxkcmVuIG9uIHRoZSBlZGdlcyBvZiB0aGUgdGltZWxpbmVcbiAgICAgICAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgY2hpbGREdXJhdGlvbiA8PSBtaW5WYWx1ZSAmJiAoIWNoaWxkU3RhcnRUaW1lIHx8IGNoaWxkRW5kVGltZSA9PT0gdGxJdGVyYXRpb25EdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGNoaWxkLm9uQ29tcGxldGUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIW11dGVDYWxsYmFja3MpIHRsLm9uTG9vcCgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG4gICAgfVxuXG4gICAgZm9yRWFjaENoaWxkcmVuKHRsLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRUaW1lID0gcm91bmQoKHRsQ2hpbGRyZW5UaW1lIC0gY2hpbGQuX29mZnNldCkgKiBjaGlsZC5fc3BlZWQsIDEyKTsgLy8gUm91bmRpbmcgaXMgbmVlZGVkIHdoZW4gdXNpbmcgc2Vjb25kc1xuICAgICAgY29uc3QgY2hpbGRUaWNrTW9kZSA9IGNoaWxkLl9mcHMgPCB0bC5fZnBzID8gY2hpbGQucmVxdWVzdFRpY2sodGxDaWxkcmVuVGlja1RpbWUpIDogdGlja01vZGU7XG4gICAgICB0bENoaWxkcmVuSGFzUmVuZGVyZWQgKz0gcmVuZGVyKGNoaWxkLCBjaGlsZFRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCBjaGlsZFRpY2tNb2RlKTtcbiAgICAgIGlmICghY2hpbGQuY29tcGxldGVkICYmIHRsQ2hpbGRyZW5IYXZlQ29tcGxldGVkKSB0bENoaWxkcmVuSGF2ZUNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH0sIHRsSXNSdW5uaW5nQmFja3dhcmRzKTtcblxuICAgIC8vIFJlbmRlcnMgb24gdGltZWxpbmUgYXJlIHRyaWdnZXJlZCBieSBpdHMgY2hpbGRyZW4gc28gaXQgbmVlZHMgdG8gYmUgc2V0IGFmdGVyIHJlbmRlcmluZyB0aGUgY2hpbGRyZW5cbiAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgdGxDaGlsZHJlbkhhc1JlbmRlcmVkKSB0bC5vblJlbmRlcigvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG5cbiAgICAvLyBUcmlnZ2VycyB0aGUgdGltZWxpbmUgb25Db21wbGV0ZSgpIG9uY2UgYWxsIGNoaW5kcmVuIGFsbCBjb21wbGV0ZWQgYW5kIHRoZSBjdXJyZW50IHRpbWUgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgIGlmICgodGxDaGlsZHJlbkhhdmVDb21wbGV0ZWQgfHwgdGxJc1J1bm5pbmdCYWNrd2FyZHMpICYmIHRsLl9jdXJyZW50VGltZSA+PSB0bC5kdXJhdGlvbikge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXVzZWQgZmxhZyBpcyBmYWxzZSBpbiBjYXNlIGl0IGhhcyBiZWVuIHNraXBwZWQgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgICAgdGwucGF1c2VkID0gdHJ1ZTtcbiAgICAgIGlmICghdGwuY29tcGxldGVkKSB7XG4gICAgICAgIHRsLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICghbXV0ZUNhbGxiYWNrcykge1xuICAgICAgICAgIHRsLm9uQ29tcGxldGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0bCkpO1xuICAgICAgICAgIHRsLl9yZXNvbHZlKC8qKiBAdHlwZSB7Q2FsbGJhY2tBcmd1bWVudH0gKi8odGwpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG5cblxuY29uc3QgYWRkaXRpdmUgPSB7XG4gIGFuaW1hdGlvbjogbnVsbCxcbiAgdXBkYXRlOiBub29wLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBBZGRpdGl2ZUFuaW1hdGlvblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGR1cmF0aW9uXG4gKiBAcHJvcGVydHkge051bWJlcn0gX29mZnNldFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9kZWxheVxuICogQHByb3BlcnR5IHtUd2Vlbn0gX2hlYWRcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF90YWlsXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gIHtUd2VlbkFkZGl0aXZlTG9va3Vwc30gbG9va3Vwc1xuICogQHJldHVybiB7QWRkaXRpdmVBbmltYXRpb259XG4gKi9cbmNvbnN0IGFkZEFkZGl0aXZlQW5pbWF0aW9uID0gbG9va3VwcyA9PiB7XG4gIGxldCBhbmltYXRpb24gPSBhZGRpdGl2ZS5hbmltYXRpb247XG4gIGlmICghYW5pbWF0aW9uKSB7XG4gICAgYW5pbWF0aW9uID0ge1xuICAgICAgZHVyYXRpb246IG1pblZhbHVlLFxuICAgICAgY29tcHV0ZURlbHRhVGltZTogbm9vcCxcbiAgICAgIF9vZmZzZXQ6IDAsXG4gICAgICBfZGVsYXk6IDAsXG4gICAgICBfaGVhZDogbnVsbCxcbiAgICAgIF90YWlsOiBudWxsLFxuICAgIH07XG4gICAgYWRkaXRpdmUuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgIGFkZGl0aXZlLnVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGxvb2t1cHMuZm9yRWFjaChwcm9wZXJ0eUFuaW1hdGlvbiA9PiB7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0eUFuaW1hdGlvbikge1xuICAgICAgICAgIGNvbnN0IHR3ZWVucyA9IHByb3BlcnR5QW5pbWF0aW9uW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgY29uc3QgbG9va3VwVHdlZW4gPSB0d2VlbnMuX2hlYWQ7XG4gICAgICAgICAgaWYgKGxvb2t1cFR3ZWVuKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBsb29rdXBUd2Vlbi5fdmFsdWVUeXBlO1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpdmVWYWx1ZXMgPSB2YWx1ZVR5cGUgPT09IHZhbHVlVHlwZXMuQ09NUExFWCB8fCB2YWx1ZVR5cGUgPT09IHZhbHVlVHlwZXMuQ09MT1IgPyBjbG9uZUFycmF5KGxvb2t1cFR3ZWVuLl9mcm9tTnVtYmVycykgOiBudWxsO1xuICAgICAgICAgICAgbGV0IGFkZGl0aXZlVmFsdWUgPSBsb29rdXBUd2Vlbi5fZnJvbU51bWJlcjtcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHR3ZWVucy5fdGFpbDtcbiAgICAgICAgICAgIHdoaWxlICh0d2VlbiAmJiB0d2VlbiAhPT0gbG9va3VwVHdlZW4pIHtcbiAgICAgICAgICAgICAgaWYgKGFkZGl0aXZlVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0d2Vlbi5fbnVtYmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIGFkZGl0aXZlVmFsdWVzW2ldICs9IHR3ZWVuLl9udW1iZXJzW2ldO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZGl0aXZlVmFsdWUgKz0gdHdlZW4uX251bWJlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0d2VlbiA9IHR3ZWVuLl9wcmV2QWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9va3VwVHdlZW4uX3RvTnVtYmVyID0gYWRkaXRpdmVWYWx1ZTtcbiAgICAgICAgICAgIGxvb2t1cFR3ZWVuLl90b051bWJlcnMgPSBhZGRpdGl2ZVZhbHVlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gVE9ETzogQXZvaWQgcG9seW1vcnBoaXNtIGhlcmUsIGlkZWFseSB0aGUgYWRkaXRpdmUgYW5pbWF0aW9uIHNob3VsZCBiZSBhIHJlZ3VsYXIgYW5pbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJpb3JpdHkgaW4gdGhlIHJlbmRlciBsb29wXG4gICAgICByZW5kZXIoYW5pbWF0aW9uLCAxLCAxLCAwLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn07XG5cbmNvbnN0IGVuZ2luZVRpY2tNZXRob2QgPSAvKiNfX1BVUkVfXyovICgoKSA9PiBpc0Jyb3dzZXIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRJbW1lZGlhdGUpKCk7XG5jb25zdCBlbmdpbmVDYW5jZWxNZXRob2QgPSAvKiNfX1BVUkVfXyovICgoKSA9PiBpc0Jyb3dzZXIgPyBjYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFySW1tZWRpYXRlKSgpO1xuXG5jbGFzcyBFbmdpbmUgZXh0ZW5kcyBDbG9jayB7XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBbaW5pdFRpbWVdICovXG4gIGNvbnN0cnVjdG9yKGluaXRUaW1lKSB7XG4gICAgc3VwZXIoaW5pdFRpbWUpO1xuICAgIHRoaXMudXNlRGVmYXVsdE1haW5Mb29wID0gdHJ1ZTtcbiAgICB0aGlzLnBhdXNlT25Eb2N1bWVudEhpZGRlbiA9IHRydWU7XG4gICAgLyoqIEB0eXBlIHtEZWZhdWx0c1BhcmFtc30gKi9cbiAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgLy8gdGhpcy5wYXVzZWQgPSBpc0Jyb3dzZXIgJiYgZG9jLmhpZGRlbiA/IHRydWUgIDogZmFsc2U7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfE5vZGVKUy5JbW1lZGlhdGV9ICovXG4gICAgdGhpcy5yZXFJZCA9IDA7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMuX2N1cnJlbnRUaW1lID0gbm93KCk7XG4gICAgaWYgKHRoaXMucmVxdWVzdFRpY2sodGltZSkpIHtcbiAgICAgIHRoaXMuY29tcHV0ZURlbHRhVGltZSh0aW1lKTtcbiAgICAgIGNvbnN0IGVuZ2luZVNwZWVkID0gdGhpcy5fc3BlZWQ7XG4gICAgICBjb25zdCBlbmdpbmVGcHMgPSB0aGlzLl9mcHM7XG4gICAgICBsZXQgYWN0aXZlVGlja2FibGUgPSAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0aGlzLl9oZWFkKTtcbiAgICAgIHdoaWxlIChhY3RpdmVUaWNrYWJsZSkge1xuICAgICAgICBjb25zdCBuZXh0VGlja2FibGUgPSBhY3RpdmVUaWNrYWJsZS5fbmV4dDtcbiAgICAgICAgaWYgKCFhY3RpdmVUaWNrYWJsZS5wYXVzZWQpIHtcbiAgICAgICAgICB0aWNrKFxuICAgICAgICAgICAgYWN0aXZlVGlja2FibGUsXG4gICAgICAgICAgICAodGltZSAtIGFjdGl2ZVRpY2thYmxlLl9zdGFydFRpbWUpICogYWN0aXZlVGlja2FibGUuX3NwZWVkICogZW5naW5lU3BlZWQsXG4gICAgICAgICAgICAwLCAvLyAhbXV0ZUNhbGxiYWNrc1xuICAgICAgICAgICAgMCwgLy8gIWludGVybmFsUmVuZGVyXG4gICAgICAgICAgICBhY3RpdmVUaWNrYWJsZS5fZnBzIDwgZW5naW5lRnBzID8gYWN0aXZlVGlja2FibGUucmVxdWVzdFRpY2sodGltZSkgOiB0aWNrTW9kZXMuQVVUT1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQodGhpcywgYWN0aXZlVGlja2FibGUpO1xuICAgICAgICAgIHRoaXMuX2hhc0NoaWxkcmVuID0gISF0aGlzLl90YWlsO1xuICAgICAgICAgIGFjdGl2ZVRpY2thYmxlLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGFjdGl2ZVRpY2thYmxlLmNvbXBsZXRlZCAmJiAhYWN0aXZlVGlja2FibGUuX2NhbmNlbGxlZCkge1xuICAgICAgICAgICAgYWN0aXZlVGlja2FibGUuY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVRpY2thYmxlID0gbmV4dFRpY2thYmxlO1xuICAgICAgfVxuICAgICAgYWRkaXRpdmUudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgd2FrZSgpIHtcbiAgICBpZiAodGhpcy51c2VEZWZhdWx0TWFpbkxvb3AgJiYgIXRoaXMucmVxSWQpIHtcbiAgICAgIC8vIEltZWRpYXRseSByZXF1ZXN0IGEgdGljayB0byB1cGRhdGUgZW5naW5lLl9lbGFwc2VkVGltZSBhbmQgZ2V0IGFjY3VyYXRlIG9mZnNldFBvc2l0aW9uIGNhbGN1bGF0aW9uIGluIHRpbWVyLmpzXG4gICAgICB0aGlzLnJlcXVlc3RUaWNrKG5vdygpKTtcbiAgICAgIHRoaXMucmVxSWQgPSBlbmdpbmVUaWNrTWV0aG9kKHRpY2tFbmdpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIGlmICghdGhpcy5yZXFJZCkgcmV0dXJuO1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICByZXR1cm4ga2lsbEVuZ2luZSgpO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHJldHVybjtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtUaWNrYWJsZX0gKi9jaGlsZCkgPT4gY2hpbGQucmVzZXRUaW1lKCkpO1xuICAgIHJldHVybiB0aGlzLndha2UoKTtcbiAgfVxuXG4gIC8vIEdldHRlciBhbmQgc2V0dGVyIGZvciBzcGVlZFxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwZWVkICogKGdsb2JhbHMudGltZVNjYWxlID09PSAxID8gMSA6IEspO1xuICB9XG5cbiAgc2V0IHNwZWVkKHBsYXliYWNrUmF0ZSkge1xuICAgIHRoaXMuX3NwZWVkID0gcGxheWJhY2tSYXRlICogZ2xvYmFscy50aW1lU2NhbGU7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1RpY2thYmxlfSAqL2NoaWxkKSA9PiBjaGlsZC5zcGVlZCA9IGNoaWxkLl9zcGVlZCk7XG4gIH1cblxuICAvLyBHZXR0ZXIgYW5kIHNldHRlciBmb3IgdGltZVVuaXRcbiAgZ2V0IHRpbWVVbml0KCkge1xuICAgIHJldHVybiBnbG9iYWxzLnRpbWVTY2FsZSA9PT0gMSA/ICdtcycgOiAncyc7XG4gIH07XG5cbiAgc2V0IHRpbWVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBzZWNvbmRzU2NhbGUgPSAwLjAwMTtcbiAgICBjb25zdCBpc1NlY29uZCA9IHVuaXQgPT09ICdzJztcbiAgICBjb25zdCBuZXdTY2FsZSA9IGlzU2Vjb25kID8gc2Vjb25kc1NjYWxlIDogMTtcbiAgICBpZiAoZ2xvYmFscy50aW1lU2NhbGUgIT09IG5ld1NjYWxlKSB7XG4gICAgICBnbG9iYWxzLnRpbWVTY2FsZSA9IG5ld1NjYWxlO1xuICAgICAgZ2xvYmFscy50aWNrVGhyZXNob2xkID0gMjAwICogbmV3U2NhbGU7XG4gICAgICBjb25zdCBzY2FsZUZhY3RvciA9IGlzU2Vjb25kID8gc2Vjb25kc1NjYWxlIDogSztcbiAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgICAgKHRoaXMuZGVmYXVsdHMuZHVyYXRpb24pICo9IHNjYWxlRmFjdG9yO1xuICAgICAgdGhpcy5fc3BlZWQgKj0gc2NhbGVGYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHByZWNpc2lvblxuICBnZXQgcHJlY2lzaW9uKCkge1xuICAgIHJldHVybiBnbG9iYWxzLnByZWNpc2lvbjtcbiAgfVxuXG4gIHNldCBwcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgZ2xvYmFscy5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gIH1cblxufVxuY29uc3QgZW5naW5lID0gLyojX19QVVJFX18qLygoKSA9PiB7XG4gIGNvbnN0IGVuZ2luZSA9IG5ldyBFbmdpbmUobm93KCkpO1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgZ2xvYmFsVmVyc2lvbnMuZW5naW5lID0gZW5naW5lO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgaWYgKCFlbmdpbmUucGF1c2VPbkRvY3VtZW50SGlkZGVuKSByZXR1cm47XG4gICAgICBkb2MuaGlkZGVuID8gZW5naW5lLnBhdXNlKCkgOiBlbmdpbmUucmVzdW1lKCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuZ2luZTtcbn0pKCk7XG5cblxuY29uc3QgdGlja0VuZ2luZSA9ICgpID0+IHtcbiAgaWYgKGVuZ2luZS5faGVhZCkge1xuICAgIGVuZ2luZS5yZXFJZCA9IGVuZ2luZVRpY2tNZXRob2QodGlja0VuZ2luZSk7XG4gICAgZW5naW5lLnVwZGF0ZSgpO1xuICB9IGVsc2Uge1xuICAgIGVuZ2luZS5yZXFJZCA9IDA7XG4gIH1cbn07XG5cbmNvbnN0IGtpbGxFbmdpbmUgPSAoKSA9PiB7XG4gIGVuZ2luZUNhbmNlbE1ldGhvZCgvKiogQHR5cGUge05vZGVKUy5JbW1lZGlhdGUgJiBOdW1iZXJ9ICovKGVuZ2luZS5yZXFJZCkpO1xuICBlbmdpbmUucmVxSWQgPSAwO1xuICByZXR1cm4gZW5naW5lO1xufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtET01UYXJnZXR9IHRhcmdldFxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBhbmltYXRpb25JbmxpbmVTdHlsZXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3QgcGFyc2VJbmxpbmVUcmFuc2Zvcm1zID0gKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgPT4ge1xuICBjb25zdCBpbmxpbmVUcmFuc2Zvcm1zID0gdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybTtcbiAgbGV0IGlubGluZWRTdHlsZXNQcm9wZXJ0eVZhbHVlO1xuICBpZiAoaW5saW5lVHJhbnNmb3Jtcykge1xuICAgIGNvbnN0IGNhY2hlZFRyYW5zZm9ybXMgPSB0YXJnZXRbdHJhbnNmb3Jtc1N5bWJvbF07XG4gICAgbGV0IHQ7IHdoaWxlICh0ID0gdHJhbnNmb3Jtc0V4ZWNSZ3guZXhlYyhpbmxpbmVUcmFuc2Zvcm1zKSkge1xuICAgICAgY29uc3QgaW5saW5lUHJvcGVydHlOYW1lID0gdFsxXTtcbiAgICAgIC8vIGNvbnN0IGlubGluZVByb3BlcnR5VmFsdWUgPSB0WzJdO1xuICAgICAgY29uc3QgaW5saW5lUHJvcGVydHlWYWx1ZSA9IHRbMl0uc2xpY2UoMSwgLTEpO1xuICAgICAgY2FjaGVkVHJhbnNmb3Jtc1tpbmxpbmVQcm9wZXJ0eU5hbWVdID0gaW5saW5lUHJvcGVydHlWYWx1ZTtcbiAgICAgIGlmIChpbmxpbmVQcm9wZXJ0eU5hbWUgPT09IHByb3BOYW1lKSB7XG4gICAgICAgIGlubGluZWRTdHlsZXNQcm9wZXJ0eVZhbHVlID0gaW5saW5lUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIG5ldyBwYXJzZWQgaW5saW5lIHN0eWxlcyBpZiBhbmltYXRpb25JbmxpbmVTdHlsZXMgaXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFuaW1hdGlvbklubGluZVN0eWxlcykge1xuICAgICAgICAgIGFuaW1hdGlvbklubGluZVN0eWxlc1twcm9wTmFtZV0gPSBpbmxpbmVQcm9wZXJ0eVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmxpbmVUcmFuc2Zvcm1zICYmICFpc1VuZChpbmxpbmVkU3R5bGVzUHJvcGVydHlWYWx1ZSkgPyBpbmxpbmVkU3R5bGVzUHJvcGVydHlWYWx1ZSA6XG4gICAgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3NjYWxlJykgPyAnMScgOlxuICAgIHN0cmluZ1N0YXJ0c1dpdGgocHJvcE5hbWUsICdyb3RhdGUnKSB8fCBzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAnc2tldycpID8gJzBkZWcnIDogJzBweCc7XG59O1xuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge0RPTVRhcmdldHNQYXJhbXxUYXJnZXRzUGFyYW19IHZcbiAqIEByZXR1cm4ge05vZGVMaXN0fEhUTUxDb2xsZWN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXROb2RlTGlzdCh2KSB7XG4gIGNvbnN0IG4gPSBpc1N0cih2KSA/IHNjb3BlLnJvb3QucXVlcnlTZWxlY3RvckFsbCh2KSA6IHY7XG4gIGlmIChuIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgbiBpbnN0YW5jZW9mIEhUTUxDb2xsZWN0aW9uKSByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0RPTVRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHJldHVybiB7RE9NVGFyZ2V0c0FycmF5fVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7SlNUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEByZXR1cm4ge0pTVGFyZ2V0c0FycmF5fVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcmV0dXJuIHtUYXJnZXRzQXJyYXl9XG4gKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfEpTVGFyZ2V0c1BhcmFtfFRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICovXG5mdW5jdGlvbiBwYXJzZVRhcmdldHModGFyZ2V0cykge1xuICBpZiAoaXNOaWwodGFyZ2V0cykpIHJldHVybiAvKiogQHR5cGUge1RhcmdldHNBcnJheX0gKi8oW10pO1xuICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIC8qKiBAdHlwZSB7SlNUYXJnZXRzQXJyYXl9ICovKGlzQXJyKHRhcmdldHMpICYmIHRhcmdldHMuZmxhdChJbmZpbml0eSkgfHwgW3RhcmdldHNdKTtcbiAgaWYgKGlzQXJyKHRhcmdldHMpKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkID0gdGFyZ2V0cy5mbGF0KEluZmluaXR5KTtcbiAgICAvKiogQHR5cGUge1RhcmdldHNBcnJheX0gKi9cbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGZsYXR0ZW5lZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBmbGF0dGVuZWRbaV07XG4gICAgICBpZiAoIWlzTmlsKGl0ZW0pKSB7XG4gICAgICAgIGNvbnN0IG5vZGVMaXN0ID0gZ2V0Tm9kZUxpc3QoaXRlbSk7XG4gICAgICAgIGlmIChub2RlTGlzdCkge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG5vZGVMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Ykl0ZW0gPSBub2RlTGlzdFtqXTtcbiAgICAgICAgICAgIGlmICghaXNOaWwoc3ViSXRlbSkpIHtcbiAgICAgICAgICAgICAgbGV0IGlzRHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwLCBrbCA9IHBhcnNlZC5sZW5ndGg7IGsgPCBrbDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFtrXSA9PT0gc3ViSXRlbSkge1xuICAgICAgICAgICAgICAgICAgaXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucHVzaChzdWJJdGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaXNEdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBwYXJzZWQubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnNlZFtqXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICBpc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICAgICAgICBwYXJzZWQucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBjb25zdCBub2RlTGlzdCA9IGdldE5vZGVMaXN0KHRhcmdldHMpO1xuICBpZiAobm9kZUxpc3QpIHJldHVybiAvKiogQHR5cGUge0RPTVRhcmdldHNBcnJheX0gKi8oQXJyYXkuZnJvbShub2RlTGlzdCkpO1xuICByZXR1cm4gLyoqIEB0eXBlIHtUYXJnZXRzQXJyYXl9ICovKFt0YXJnZXRzXSk7XG59XG5cbi8qKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtET01UYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEByZXR1cm4ge0RPTVRhcmdldHNBcnJheX1cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0pTVGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcmV0dXJuIHtKU1RhcmdldHNBcnJheX1cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHJldHVybiB7VGFyZ2V0c0FycmF5fVxuICpcbiAqIEBwYXJhbSAge0RPTVRhcmdldHNQYXJhbXxKU1RhcmdldHNQYXJhbXxUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJUYXJnZXRzKHRhcmdldHMpIHtcbiAgY29uc3QgcGFyc2VkVGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICBjb25zdCBwYXJzZWRUYXJnZXRzTGVuZ3RoID0gcGFyc2VkVGFyZ2V0c0FycmF5Lmxlbmd0aDtcbiAgaWYgKHBhcnNlZFRhcmdldHNMZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZFRhcmdldHNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VkVGFyZ2V0c0FycmF5W2ldO1xuICAgICAgaWYgKCF0YXJnZXRbaXNSZWdpc3RlcmVkVGFyZ2V0U3ltYm9sXSkge1xuICAgICAgICB0YXJnZXRbaXNSZWdpc3RlcmVkVGFyZ2V0U3ltYm9sXSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGlzU3ZnVHlwZSA9IGlzU3ZnKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzRG9tID0gLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCkubm9kZVR5cGUgfHwgaXNTdmdUeXBlO1xuICAgICAgICBpZiAoaXNEb20pIHtcbiAgICAgICAgICB0YXJnZXRbaXNEb21TeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgICB0YXJnZXRbaXNTdmdTeW1ib2xdID0gaXNTdmdUeXBlO1xuICAgICAgICAgIHRhcmdldFt0cmFuc2Zvcm1zU3ltYm9sXSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZWRUYXJnZXRzQXJyYXk7XG59XG5cblxuXG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSBwYXRoXG4gKiBAcmV0dXJuIHtTVkdHZW9tZXRyeUVsZW1lbnR8dW5kZWZpbmVkfVxuICovXG5jb25zdCBnZXRQYXRoID0gcGF0aCA9PiB7XG4gIGNvbnN0IHBhcnNlZFRhcmdldHMgPSBwYXJzZVRhcmdldHMocGF0aCk7XG4gIGNvbnN0ICRwYXJzZWRTdmcgPSAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8ocGFyc2VkVGFyZ2V0c1swXSk7XG4gIGlmICghJHBhcnNlZFN2ZyB8fCAhaXNTdmcoJHBhcnNlZFN2ZykpIHJldHVybjtcbiAgcmV0dXJuICRwYXJzZWRTdmc7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gcGF0aDJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9uVmFsdWV9XG4gKi9cbmNvbnN0IG1vcnBoVG8gPSAocGF0aDIsIHByZWNpc2lvbiA9IC4zMykgPT4gKCRwYXRoMSkgPT4ge1xuICBjb25zdCAkcGF0aDIgPSAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oZ2V0UGF0aChwYXRoMikpO1xuICBpZiAoISRwYXRoMikgcmV0dXJuO1xuICBjb25zdCBpc1BhdGggPSAkcGF0aDEudGFnTmFtZSA9PT0gJ3BhdGgnO1xuICBjb25zdCBzZXBhcmF0b3IgPSBpc1BhdGggPyAnICcgOiAnLCc7XG4gIGNvbnN0IHByZXZpb3VzUG9pbnRzID0gJHBhdGgxW21vcnBoUG9pbnRzU3ltYm9sXTtcbiAgaWYgKHByZXZpb3VzUG9pbnRzKSAkcGF0aDEuc2V0QXR0cmlidXRlKGlzUGF0aCA/ICdkJyA6ICdwb2ludHMnLCBwcmV2aW91c1BvaW50cyk7XG5cbiAgbGV0IHYxID0gJycsIHYyID0gJyc7XG5cbiAgaWYgKCFwcmVjaXNpb24pIHtcbiAgICB2MSA9ICRwYXRoMS5nZXRBdHRyaWJ1dGUoaXNQYXRoID8gJ2QnIDogJ3BvaW50cycpO1xuICAgIHYyID0gJHBhdGgyLmdldEF0dHJpYnV0ZShpc1BhdGggPyAnZCcgOiAncG9pbnRzJyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVuZ3RoMSA9IC8qKiBAdHlwZSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAqLygkcGF0aDEpLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgY29uc3QgbGVuZ3RoMiA9ICRwYXRoMi5nZXRUb3RhbExlbmd0aCgpO1xuICAgIGNvbnN0IG1heFBvaW50cyA9IE1hdGgubWF4KE1hdGguY2VpbChsZW5ndGgxICogcHJlY2lzaW9uKSwgTWF0aC5jZWlsKGxlbmd0aDIgKiBwcmVjaXNpb24pKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFBvaW50czsgaSsrKSB7XG4gICAgICBjb25zdCB0ID0gaSAvIChtYXhQb2ludHMgLSAxKTtcbiAgICAgIGNvbnN0IHBvaW50T25QYXRoMSA9IC8qKiBAdHlwZSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAqLygkcGF0aDEpLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoMSAqIHQpO1xuICAgICAgY29uc3QgcG9pbnRPblBhdGgyID0gJHBhdGgyLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoMiAqIHQpO1xuICAgICAgY29uc3QgcHJlZml4ID0gaXNQYXRoID8gKGkgPT09IDAgPyAnTScgOiAnTCcpIDogJyc7XG4gICAgICB2MSArPSBwcmVmaXggKyByb3VuZChwb2ludE9uUGF0aDEueCwgMykgKyBzZXBhcmF0b3IgKyBwb2ludE9uUGF0aDEueSArICcgJztcbiAgICAgIHYyICs9IHByZWZpeCArIHJvdW5kKHBvaW50T25QYXRoMi54LCAzKSArIHNlcGFyYXRvciArIHBvaW50T25QYXRoMi55ICsgJyAnO1xuICAgIH1cbiAgfVxuXG4gICRwYXRoMVttb3JwaFBvaW50c1N5bWJvbF0gPSB2MjtcblxuICByZXR1cm4gW3YxLCB2Ml07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U1ZHR2VvbWV0cnlFbGVtZW50fSBbJGVsXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBnZXRTY2FsZUZhY3RvciA9ICRlbCA9PiB7XG4gIGxldCBzY2FsZUZhY3RvciA9IDE7XG4gIGlmICgkZWwgJiYgJGVsLmdldENUTSkge1xuICAgIGNvbnN0IGN0bSA9ICRlbC5nZXRDVE0oKTtcbiAgICBpZiAoY3RtKSB7XG4gICAgICBjb25zdCBzY2FsZVggPSBzcXJ0KGN0bS5hICogY3RtLmEgKyBjdG0uYiAqIGN0bS5iKTtcbiAgICAgIGNvbnN0IHNjYWxlWSA9IHNxcnQoY3RtLmMgKiBjdG0uYyArIGN0bS5kICogY3RtLmQpO1xuICAgICAgc2NhbGVGYWN0b3IgPSAoc2NhbGVYICsgc2NhbGVZKSAvIDI7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY2FsZUZhY3Rvcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb3h5IHRoYXQgd3JhcHMgYW4gU1ZHR2VvbWV0cnlFbGVtZW50IGFuZCBhZGRzIGRyYXdpbmcgZnVuY3Rpb25hbGl0eS5cbiAqIEBwYXJhbSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAkZWwgLSBUaGUgU1ZHIGVsZW1lbnQgdG8gdHJhbnNmb3JtIGludG8gYSBkcmF3YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gU3RhcnRpbmcgcG9zaXRpb24gKDAtMSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBFbmRpbmcgcG9zaXRpb24gKDAtMSlcbiAqIEByZXR1cm4ge0RyYXdhYmxlU1ZHR2VvbWV0cnl9IC0gUmV0dXJucyBhIHByb3h5IHRoYXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBlbGVtZW50J3MgdHlwZSB3aXRoIGFkZGl0aW9uYWwgJ2RyYXcnIGF0dHJpYnV0ZSBmdW5jdGlvbmFsaXR5XG4gKi9cbmNvbnN0IGNyZWF0ZURyYXdhYmxlUHJveHkgPSAoJGVsLCBzdGFydCwgZW5kKSA9PiB7XG4gIGNvbnN0IHBhdGhMZW5ndGggPSBLO1xuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoJGVsKTtcbiAgY29uc3Qgc3Ryb2tlTGluZUNhcCA9IGNvbXB1dGVkU3R5bGVzLnN0cm9rZUxpbmVjYXA7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgJHNjYWxsZWQgPSBjb21wdXRlZFN0eWxlcy52ZWN0b3JFZmZlY3QgPT09ICdub24tc2NhbGluZy1zdHJva2UnID8gJGVsIDogbnVsbDtcbiAgbGV0IGN1cnJlbnRDYXAgPSBzdHJva2VMaW5lQ2FwO1xuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KCRlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtwcm9wZXJ0eV07XG4gICAgICBpZiAocHJvcGVydHkgPT09IHByb3h5VGFyZ2V0U3ltYm9sKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgaWYgKHByb3BlcnR5ID09PSAnc2V0QXR0cmlidXRlJykge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBpZiAoYXJnc1swXSA9PT0gJ2RyYXcnKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgY29uc3QgdjEgPSArdmFsdWVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdjIgPSArdmFsdWVzWzFdO1xuICAgICAgICAgICAgLy8gVE9UTzogQmVuY2htYXJrIGlmIHBlcmZvcm1pbmcgdHdvIHNsaWNlcyBpcyBtb3JlIHBlcmZvcm1hbnQgdGhhbiBvbmUgc3BsaXRcbiAgICAgICAgICAgIC8vIGNvbnN0IHNwYWNlSW5kZXggPSB2YWx1ZS5pbmRleE9mKCcgJyk7XG4gICAgICAgICAgICAvLyBjb25zdCB2MSA9IHJvdW5kKCt2YWx1ZS5zbGljZSgwLCBzcGFjZUluZGV4KSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IHYyID0gcm91bmQoK3ZhbHVlLnNsaWNlKHNwYWNlSW5kZXggKyAxKSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gZ2V0U2NhbGVGYWN0b3IoJHNjYWxsZWQpO1xuICAgICAgICAgICAgY29uc3Qgb3MgPSB2MSAqIC1wYXRoTGVuZ3RoICogc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICBjb25zdCBkMSA9ICh2MiAqIHBhdGhMZW5ndGggKiBzY2FsZUZhY3RvcikgKyBvcztcbiAgICAgICAgICAgIGNvbnN0IGQyID0gKHBhdGhMZW5ndGggKiBzY2FsZUZhY3RvciArXG4gICAgICAgICAgICAgICAgICAgICAgKCh2MSA9PT0gMCAmJiB2MiA9PT0gMSkgfHwgKHYxID09PSAxICYmIHYyID09PSAwKSA/IDAgOiAxMCAqIHNjYWxlRmFjdG9yKSAtIGQxKTtcbiAgICAgICAgICAgIGlmIChzdHJva2VMaW5lQ2FwICE9PSAnYnV0dCcpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3Q2FwID0gdjEgPT09IHYyID8gJ2J1dHQnIDogc3Ryb2tlTGluZUNhcDtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDYXAgIT09IG5ld0NhcCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5zdHJva2VMaW5lY2FwID0gYCR7bmV3Q2FwfWA7XG4gICAgICAgICAgICAgICAgY3VycmVudENhcCA9IG5ld0NhcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBgJHtvc31gKTtcbiAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBgJHtkMX0gJHtkMn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodmFsdWUsIHRhcmdldCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZuYyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBSZWZsZWN0LmFwcGx5KHZhbHVlLCB0YXJnZXQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCRlbC5nZXRBdHRyaWJ1dGUoJ3BhdGhMZW5ndGgnKSAhPT0gYCR7cGF0aExlbmd0aH1gKSB7XG4gICAgJGVsLnNldEF0dHJpYnV0ZSgncGF0aExlbmd0aCcsIGAke3BhdGhMZW5ndGh9YCk7XG4gICAgcHJveHkuc2V0QXR0cmlidXRlKCdkcmF3JywgYCR7c3RhcnR9ICR7ZW5kfWApO1xuICB9XG5cbiAgcmV0dXJuIC8qKiBAdHlwZSB7RHJhd2FibGVTVkdHZW9tZXRyeX0gKi8ocHJveHkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGRyYXdhYmxlIHByb3hpZXMgZm9yIG11bHRpcGxlIFNWRyBlbGVtZW50cy5cbiAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSBzZWxlY3RvciAtIENTUyBzZWxlY3RvciwgU1ZHIGVsZW1lbnQsIG9yIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBzZWxlY3RvcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gLSBTdGFydGluZyBwb3NpdGlvbiAoMC0xKVxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9MF0gLSBFbmRpbmcgcG9zaXRpb24gKDAtMSlcbiAqIEByZXR1cm4ge0FycmF5PERyYXdhYmxlU1ZHR2VvbWV0cnk+fSAtIEFycmF5IG9mIHByb3hpZWQgZWxlbWVudHMgd2l0aCBkcmF3aW5nIGZ1bmN0aW9uYWxpdHlcbiAqL1xuY29uc3QgY3JlYXRlRHJhd2FibGUgPSAoc2VsZWN0b3IsIHN0YXJ0ID0gMCwgZW5kID0gMCkgPT4ge1xuICBjb25zdCBlbHMgPSBwYXJzZVRhcmdldHMoc2VsZWN0b3IpO1xuICByZXR1cm4gZWxzLm1hcCgkZWwgPT4gY3JlYXRlRHJhd2FibGVQcm94eShcbiAgICAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oJGVsKSxcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgKSk7XG59O1xuXG4vLyBNb3Rpb24gcGF0aCBhbmltYXRpb25cblxuLyoqXG4gKiBAcGFyYW0ge1NWR0dlb21ldHJ5RWxlbWVudH0gJHBhdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzc1xuICogQHBhcmFtIHtOdW1iZXJ9bG9va3VwXG4gKiBAcmV0dXJuIHtET01Qb2ludH1cbiAqL1xuY29uc3QgZ2V0UGF0aFBvaW50ID0gKCRwYXRoLCBwcm9ncmVzcywgbG9va3VwID0gMCkgPT4ge1xuICByZXR1cm4gJHBhdGguZ2V0UG9pbnRBdExlbmd0aChwcm9ncmVzcyArIGxvb2t1cCA+PSAxID8gcHJvZ3Jlc3MgKyBsb29rdXAgOiAwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTVkdHZW9tZXRyeUVsZW1lbnR9ICRwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFByb3BlcnR5XG4gKiBAcmV0dXJuIHtGdW5jdGlvblZhbHVlfVxuICovXG5jb25zdCBnZXRQYXRoUHJvZ2VzcyA9ICgkcGF0aCwgcGF0aFByb3BlcnR5KSA9PiB7XG4gIHJldHVybiAkZWwgPT4ge1xuICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gKygkcGF0aC5nZXRUb3RhbExlbmd0aCgpKTtcbiAgICBjb25zdCBpblN2ZyA9ICRlbFtpc1N2Z1N5bWJvbF07XG4gICAgY29uc3QgY3RtID0gJHBhdGguZ2V0Q1RNKCk7XG4gICAgLyoqIEB0eXBlIHtUd2Vlbk9iamVjdFZhbHVlfSAqL1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IHRvdGFsTGVuZ3RoLFxuICAgICAgLyoqIEB0eXBlIHtUd2Vlbk1vZGlmaWVyfSAqL1xuICAgICAgbW9kaWZpZXI6IHByb2dyZXNzID0+IHtcbiAgICAgICAgaWYgKHBhdGhQcm9wZXJ0eSA9PT0gJ2EnKSB7XG4gICAgICAgICAgY29uc3QgcDAgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAtMSk7XG4gICAgICAgICAgY29uc3QgcDEgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAxKTtcbiAgICAgICAgICByZXR1cm4gYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KSAqIDE4MCAvIFBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHAgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAwKTtcbiAgICAgICAgICByZXR1cm4gcGF0aFByb3BlcnR5ID09PSAneCcgP1xuICAgICAgICAgICAgaW5TdmcgfHwgIWN0bSA/IHAueCA6IHAueCAqIGN0bS5hICsgcC55ICogY3RtLmMgKyBjdG0uZSA6XG4gICAgICAgICAgICBpblN2ZyB8fCAhY3RtID8gcC55IDogcC54ICogY3RtLmIgKyBwLnkgKiBjdG0uZCArIGN0bS5mXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHBhdGhcbiAqL1xuY29uc3QgY3JlYXRlTW90aW9uUGF0aCA9IHBhdGggPT4ge1xuICBjb25zdCAkcGF0aCA9IGdldFBhdGgocGF0aCk7XG4gIGlmICghJHBhdGgpIHJldHVybjtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBnZXRQYXRoUHJvZ2VzcygkcGF0aCwgJ3gnKSxcbiAgICB0cmFuc2xhdGVZOiBnZXRQYXRoUHJvZ2VzcygkcGF0aCwgJ3knKSxcbiAgICByb3RhdGU6IGdldFBhdGhQcm9nZXNzKCRwYXRoLCAnYScpLFxuICB9XG59O1xuXG4vLyBDaGVjayBmb3IgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuXG5jb25zdCBjc3NSZXNlcnZlZFByb3BlcnRpZXMgPSBbJ29wYWNpdHknLCAncm90YXRlJywgJ292ZXJmbG93JywgJ2NvbG9yJ107XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVmFsaWRTVkdBdHRyaWJ1dGUgPSAoZWwsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAvLyBSZXR1cm4gZWFybHkgYW5kIHVzZSBDU1Mgb3BhY2l0eSBhbmltYXRpb24gaW5zdGVhZCAoYWxyZWFkeSBiZXR0ZXIgZGVmYXVsdCB2YWx1ZXMgKG9wYWNpdHk6IDEgaW5zdGVhZCBvZiAwKSkgYW5kIHJvdGF0ZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIHRyYW5zZm9ybVxuICBpZiAoY3NzUmVzZXJ2ZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKHByb3BlcnR5TmFtZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGVsLmdldEF0dHJpYnV0ZShwcm9wZXJ0eU5hbWUpIHx8IHByb3BlcnR5TmFtZSBpbiBlbCkge1xuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdzY2FsZScpIHsgLy8gU2NhbGVcbiAgICAgIGNvbnN0IGVsUGFyZW50Tm9kZSA9IC8qKiBAdHlwZSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAqLygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oZWwpLnBhcmVudE5vZGUpO1xuICAgICAgLy8gT25seSBjb25zaWRlciBzY2FsZSBhcyBhIHZhbGlkIFNWRyBhdHRyaWJ1dGUgb24gZmlsdGVyIGVsZW1lbnRcbiAgICAgIHJldHVybiBlbFBhcmVudE5vZGUgJiYgZWxQYXJlbnROb2RlLnRhZ05hbWUgPT09ICdmaWx0ZXInO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuY29uc3Qgc3ZnID0ge1xuICBtb3JwaFRvLFxuICBjcmVhdGVNb3Rpb25QYXRoLFxuICBjcmVhdGVEcmF3YWJsZSxcbn07XG5cblxuXG5cbi8qKlxuICogUkdCIC8gUkdCQSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gcmdiVmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IHJnYlRvUmdiYSA9IHJnYlZhbHVlID0+IHtcbiAgY29uc3QgcmdiYSA9IHJnYkV4ZWNSZ3guZXhlYyhyZ2JWYWx1ZSkgfHwgcmdiYUV4ZWNSZ3guZXhlYyhyZ2JWYWx1ZSk7XG4gIGNvbnN0IGEgPSAhaXNVbmQocmdiYVs0XSkgPyArcmdiYVs0XSA6IDE7XG4gIHJldHVybiBbXG4gICAgK3JnYmFbMV0sXG4gICAgK3JnYmFbMl0sXG4gICAgK3JnYmFbM10sXG4gICAgYVxuICBdXG59O1xuXG4vKipcbiAqIEhFWDMgLyBIRVgzQSAvIEhFWDYgLyBIRVg2QSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gaGV4VmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGhleFRvUmdiYSA9IGhleFZhbHVlID0+IHtcbiAgY29uc3QgaGV4TGVuZ3RoID0gaGV4VmFsdWUubGVuZ3RoO1xuICBjb25zdCBpc1Nob3J0ID0gaGV4TGVuZ3RoID09PSA0IHx8IGhleExlbmd0aCA9PT0gNTtcbiAgcmV0dXJuIFtcbiAgICArKCcweCcgKyBoZXhWYWx1ZVsxXSArIGhleFZhbHVlW2lzU2hvcnQgPyAxIDogMl0pLFxuICAgICsoJzB4JyArIGhleFZhbHVlW2lzU2hvcnQgPyAyIDogM10gKyBoZXhWYWx1ZVtpc1Nob3J0ID8gMiA6IDRdKSxcbiAgICArKCcweCcgKyBoZXhWYWx1ZVtpc1Nob3J0ID8gMyA6IDVdICsgaGV4VmFsdWVbaXNTaG9ydCA/IDMgOiA2XSksXG4gICAgKChoZXhMZW5ndGggPT09IDUgfHwgaGV4TGVuZ3RoID09PSA5KSA/ICsoKygnMHgnICsgaGV4VmFsdWVbaXNTaG9ydCA/IDQgOiA3XSArIGhleFZhbHVlW2lzU2hvcnQgPyA0IDogOF0pIC8gMjU1KS50b0ZpeGVkKDMpIDogMSlcbiAgXVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBcbiAqIEBwYXJhbSAge051bWJlcn0gcVxuICogQHBhcmFtICB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGh1ZTJyZ2IgPSAocCwgcSwgdCkgPT4ge1xuICBpZiAodCA8IDApIHQgKz0gMTtcbiAgaWYgKHQgPiAxKSB0IC09IDE7XG4gIHJldHVybiB0IDwgMSAvIDYgPyBwICsgKHEgLSBwKSAqIDYgKiB0IDpcbiAgICAgICAgIHQgPCAxIC8gMiA/IHEgOlxuICAgICAgICAgdCA8IDIgLyAzID8gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDYgOlxuICAgICAgICAgcDtcbn07XG5cbi8qKlxuICogSFNMIC8gSFNMQSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gaHNsVmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGhzbFRvUmdiYSA9IGhzbFZhbHVlID0+IHtcbiAgY29uc3QgaHNsYSA9IGhzbEV4ZWNSZ3guZXhlYyhoc2xWYWx1ZSkgfHwgaHNsYUV4ZWNSZ3guZXhlYyhoc2xWYWx1ZSk7XG4gIGNvbnN0IGggPSAraHNsYVsxXSAvIDM2MDtcbiAgY29uc3QgcyA9ICtoc2xhWzJdIC8gMTAwO1xuICBjb25zdCBsID0gK2hzbGFbM10gLyAxMDA7XG4gIGNvbnN0IGEgPSAhaXNVbmQoaHNsYVs0XSkgPyAraHNsYVs0XSA6IDE7XG4gIGxldCByLCBnLCBiO1xuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcSA9IGwgPCAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSByb3VuZChodWUycmdiKHAsIHEsIGggKyAxIC8gMykgKiAyNTUsIDApO1xuICAgIGcgPSByb3VuZChodWUycmdiKHAsIHEsIGgpICogMjU1LCAwKTtcbiAgICBiID0gcm91bmQoaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpICogMjU1LCAwKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufTtcblxuLyoqXG4gKiBBbGwgaW4gb25lIGNvbG9yIGNvbnZlcnRlciB0aGF0IGNvbnZlcnRzIGEgY29sb3Igc3RyaW5nIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgUkdCQSB2YWx1ZXNcbiAqIEBwYXJhbSAge1N0cmluZ30gY29sb3JTdHJpbmdcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGNvbnZlcnRDb2xvclN0cmluZ1ZhbHVlc1RvUmdiYUFycmF5ID0gY29sb3JTdHJpbmcgPT4ge1xuICByZXR1cm4gaXNSZ2IoY29sb3JTdHJpbmcpID8gcmdiVG9SZ2JhKGNvbG9yU3RyaW5nKSA6XG4gICAgICAgICBpc0hleChjb2xvclN0cmluZykgPyBoZXhUb1JnYmEoY29sb3JTdHJpbmcpIDpcbiAgICAgICAgIGlzSHNsKGNvbG9yU3RyaW5nKSA/IGhzbFRvUmdiYShjb2xvclN0cmluZykgOlxuICAgICAgICAgWzAsIDAsIDAsIDFdO1xufTtcblxuXG5cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgRFxuICogQHBhcmFtIHtUfHVuZGVmaW5lZH0gdGFyZ2V0VmFsdWVcbiAqIEBwYXJhbSB7RH0gZGVmYXVsdFZhbHVlXG4gKiBAcmV0dXJuIHtUfER9XG4gKi9cbmNvbnN0IHNldFZhbHVlID0gKHRhcmdldFZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzVW5kKHRhcmdldFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHRhcmdldFZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2VlblByb3BWYWx1ZX0gdmFsdWVcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRvdGFsXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtzdG9yZV1cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgZ2V0RnVuY3Rpb25WYWx1ZSA9ICh2YWx1ZSwgdGFyZ2V0LCBpbmRleCwgdG90YWwsIHN0b3JlKSA9PiB7XG4gIGlmIChpc0ZuYyh2YWx1ZSkpIHtcbiAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkodGFyZ2V0LCBpbmRleCwgdG90YWwpO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gMCBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB1bmRlZmluZWQgLyBOYU4gLyBudWxsIC8gZmFsc2UgLyAwXG4gICAgICByZXR1cm4gIWlzTmFOKCtjb21wdXRlZCkgPyArY29tcHV0ZWQgOiBjb21wdXRlZCB8fCAwO1xuICAgIH07XG4gICAgaWYgKHN0b3JlKSB7XG4gICAgICBzdG9yZS5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7dHdlZW5UeXBlc31cbiAqL1xuY29uc3QgZ2V0VHdlZW5UeXBlID0gKHRhcmdldCwgcHJvcCkgPT4ge1xuICByZXR1cm4gIXRhcmdldFtpc0RvbVN5bWJvbF0gPyB0d2VlblR5cGVzLk9CSkVDVCA6XG4gICAgLy8gSGFuZGxlIFNWRyBhdHRyaWJ1dGVzXG4gICAgdGFyZ2V0W2lzU3ZnU3ltYm9sXSAmJiBpc1ZhbGlkU1ZHQXR0cmlidXRlKHRhcmdldCwgcHJvcCkgPyB0d2VlblR5cGVzLkFUVFJJQlVURSA6XG4gICAgLy8gSGFuZGxlIENTUyBUcmFuc2Zvcm0gcHJvcGVydGllcyBkaWZmZXJlbnRseSB0aGFuIENTUyB0byBhbGxvdyBpbmRpdmlkdWFsIGFuaW1hdGlvbnNcbiAgICB2YWxpZFRyYW5zZm9ybXMuaW5jbHVkZXMocHJvcCkgfHwgc2hvcnRUcmFuc2Zvcm1zLmdldChwcm9wKSA/IHR3ZWVuVHlwZXMuVFJBTlNGT1JNIDpcbiAgICAvLyBDU1MgdmFyaWFibGVzXG4gICAgc3RyaW5nU3RhcnRzV2l0aChwcm9wLCAnLS0nKSA/IHR3ZWVuVHlwZXMuQ1NTX1ZBUiA6XG4gICAgLy8gQWxsIG90aGVyIENTUyBwcm9wZXJ0aWVzXG4gICAgcHJvcCBpbiAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odGFyZ2V0KS5zdHlsZSA/IHR3ZWVuVHlwZXMuQ1NTIDpcbiAgICAvLyBIYW5kbGUgb3RoZXIgRE9NIEF0dHJpYnV0ZXNcbiAgICBwcm9wIGluIHRhcmdldCA/IHR3ZWVuVHlwZXMuT0JKRUNUIDpcbiAgICB0d2VlblR5cGVzLkFUVFJJQlVURTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gYW5pbWF0aW9uSW5saW5lU3R5bGVzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IGdldENTU1ZhbHVlID0gKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgPT4ge1xuICBjb25zdCBpbmxpbmVTdHlsZXMgPSB0YXJnZXQuc3R5bGVbcHJvcE5hbWVdO1xuICBpZiAoaW5saW5lU3R5bGVzICYmIGFuaW1hdGlvbklubGluZVN0eWxlcykge1xuICAgIGFuaW1hdGlvbklubGluZVN0eWxlc1twcm9wTmFtZV0gPSBpbmxpbmVTdHlsZXM7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBpbmxpbmVTdHlsZXMgfHwgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRbcHJveHlUYXJnZXRTeW1ib2xdIHx8IHRhcmdldCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSk7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gJzAnIDogdmFsdWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtIHt0d2VlblR5cGVzfSBbdHdlZW5UeXBlXVxuICogQHBhcmFtIHtPYmplY3R8dm9pZH0gW2FuaW1hdGlvbklubGluZVN0eWxlc11cbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKi9cbmNvbnN0IGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlID0gKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbWF0aW9uSW5saW5lU3R5bGVzKSA9PiB7XG4gIGNvbnN0IHR5cGUgPSAhaXNVbmQodHdlZW5UeXBlKSA/IHR3ZWVuVHlwZSA6IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgcmV0dXJuIHR5cGUgPT09IHR3ZWVuVHlwZXMuT0JKRUNUID8gdGFyZ2V0W3Byb3BOYW1lXSB8fCAwIDpcbiAgICAgICAgIHR5cGUgPT09IHR3ZWVuVHlwZXMuQVRUUklCVVRFID8gLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCkuZ2V0QXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICB0eXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSA/IHBhcnNlSW5saW5lVHJhbnNmb3JtcygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odGFyZ2V0KSwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgOlxuICAgICAgICAgdHlwZSA9PT0gdHdlZW5UeXBlcy5DU1NfVkFSID8gZ2V0Q1NTVmFsdWUoLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCksIHByb3BOYW1lLCBhbmltYXRpb25JbmxpbmVTdHlsZXMpLnRyaW1TdGFydCgpIDpcbiAgICAgICAgIGdldENTU1ZhbHVlKC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCBwcm9wTmFtZSwgYW5pbWF0aW9uSW5saW5lU3R5bGVzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSAge1N0cmluZ30gb3BlcmF0b3JcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgZ2V0UmVsYXRpdmVWYWx1ZSA9ICh4LCB5LCBvcGVyYXRvcikgPT4ge1xuICByZXR1cm4gb3BlcmF0b3IgPT09ICctJyA/IHggLSB5IDpcbiAgICAgICAgIG9wZXJhdG9yID09PSAnKycgPyB4ICsgeSA6XG4gICAgICAgICB4ICogeTtcbn07XG5cbi8qKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gKi9cbmNvbnN0IGNyZWF0ZURlY29tcG9zZWRWYWx1ZVRhcmdldE9iamVjdCA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAvKiogQHR5cGUge3ZhbHVlVHlwZXN9ICovXG4gICAgdDogdmFsdWVUeXBlcy5OVU1CRVIsXG4gICAgbjogMCxcbiAgICB1OiBudWxsLFxuICAgIG86IG51bGwsXG4gICAgZDogbnVsbCxcbiAgICBzOiBudWxsLFxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9IHJhd1ZhbHVlXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gdGFyZ2V0T2JqZWN0XG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgZGVjb21wb3NlUmF3VmFsdWUgPSAocmF3VmFsdWUsIHRhcmdldE9iamVjdCkgPT4ge1xuICAvKiogQHR5cGUge3ZhbHVlVHlwZXN9ICovXG4gIHRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5OVU1CRVI7XG4gIHRhcmdldE9iamVjdC5uID0gMDtcbiAgdGFyZ2V0T2JqZWN0LnUgPSBudWxsO1xuICB0YXJnZXRPYmplY3QubyA9IG51bGw7XG4gIHRhcmdldE9iamVjdC5kID0gbnVsbDtcbiAgdGFyZ2V0T2JqZWN0LnMgPSBudWxsO1xuICBpZiAoIXJhd1ZhbHVlKSByZXR1cm4gdGFyZ2V0T2JqZWN0O1xuICBjb25zdCBudW0gPSArcmF3VmFsdWU7XG4gIGlmICghaXNOYU4obnVtKSkge1xuICAgIC8vIEl0J3MgYSBudW1iZXJcbiAgICB0YXJnZXRPYmplY3QubiA9IG51bTtcbiAgICByZXR1cm4gdGFyZ2V0T2JqZWN0O1xuICB9IGVsc2Uge1xuICAgIC8vIGxldCBzdHIgPSAvKiogQHR5cGUge1N0cmluZ30gKi8ocmF3VmFsdWUpLnRyaW0oKTtcbiAgICBsZXQgc3RyID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHJhd1ZhbHVlKTtcbiAgICAvLyBQYXJzaW5nIG9wZXJhdG9ycyAoKz0sIC09LCAqPSkgbWFudWFsbHkgaXMgbXVjaCBmYXN0ZXIgdGhhbiB1c2luZyByZWdleCBoZXJlXG4gICAgaWYgKHN0clsxXSA9PT0gJz0nKSB7XG4gICAgICB0YXJnZXRPYmplY3QubyA9IHN0clswXTtcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgyKTtcbiAgICB9XG4gICAgLy8gU2tpcCBleGVjIHJlZ2V4IGlmIHRoZSB2YWx1ZSB0eXBlIGlzIGNvbXBsZXggb3IgY29sb3IgdG8gYXZvaWQgbG9uZyByZWdleCBiYWNrdHJhY2tpbmdcbiAgICBjb25zdCB1bml0TWF0Y2ggPSBzdHIuaW5jbHVkZXMoJyAnKSA/IGZhbHNlIDogdW5pdHNFeGVjUmd4LmV4ZWMoc3RyKTtcbiAgICBpZiAodW5pdE1hdGNoKSB7XG4gICAgICAvLyBIYXMgYSBudW1iZXIgYW5kIGEgdW5pdFxuICAgICAgdGFyZ2V0T2JqZWN0LnQgPSB2YWx1ZVR5cGVzLlVOSVQ7XG4gICAgICB0YXJnZXRPYmplY3QubiA9ICt1bml0TWF0Y2hbMV07XG4gICAgICB0YXJnZXRPYmplY3QudSA9IHVuaXRNYXRjaFsyXTtcbiAgICAgIHJldHVybiB0YXJnZXRPYmplY3Q7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRPYmplY3Qubykge1xuICAgICAgLy8gSGFzIGFuIG9wZXJhdG9yICgrPSwgLT0sICo9KVxuICAgICAgdGFyZ2V0T2JqZWN0Lm4gPSArc3RyO1xuICAgICAgcmV0dXJuIHRhcmdldE9iamVjdDtcbiAgICB9IGVsc2UgaWYgKGlzQ29sKHN0cikpIHtcbiAgICAgIC8vIElzIGEgY29sb3JcbiAgICAgIHRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5DT0xPUjtcbiAgICAgIHRhcmdldE9iamVjdC5kID0gY29udmVydENvbG9yU3RyaW5nVmFsdWVzVG9SZ2JhQXJyYXkoc3RyKTtcbiAgICAgIHJldHVybiB0YXJnZXRPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElzIGEgbW9yZSBjb21wbGV4IHN0cmluZyAoZ2VuZXJhbGx5IHN2ZyBjb29yZHMsIGNhbGMoKSBvciBmaWx0ZXJzIENTUyB2YWx1ZXMpXG4gICAgICBjb25zdCBtYXRjaGVkTnVtYmVycyA9IHN0ci5tYXRjaChkaWdpdFdpdGhFeHBvbmVudFJneCk7XG4gICAgICB0YXJnZXRPYmplY3QudCA9IHZhbHVlVHlwZXMuQ09NUExFWDtcbiAgICAgIHRhcmdldE9iamVjdC5kID0gbWF0Y2hlZE51bWJlcnMgPyBtYXRjaGVkTnVtYmVycy5tYXAoTnVtYmVyKSA6IFtdO1xuICAgICAgdGFyZ2V0T2JqZWN0LnMgPSBzdHIuc3BsaXQoZGlnaXRXaXRoRXhwb25lbnRSZ3gpIHx8IFtdO1xuICAgICAgcmV0dXJuIHRhcmdldE9iamVjdDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtICB7VHdlZW59IHR3ZWVuXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gdGFyZ2V0T2JqZWN0XG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgZGVjb21wb3NlVHdlZW5WYWx1ZSA9ICh0d2VlbiwgdGFyZ2V0T2JqZWN0KSA9PiB7XG4gIHRhcmdldE9iamVjdC50ID0gdHdlZW4uX3ZhbHVlVHlwZTtcbiAgdGFyZ2V0T2JqZWN0Lm4gPSB0d2Vlbi5fdG9OdW1iZXI7XG4gIHRhcmdldE9iamVjdC51ID0gdHdlZW4uX3VuaXQ7XG4gIHRhcmdldE9iamVjdC5vID0gbnVsbDtcbiAgdGFyZ2V0T2JqZWN0LmQgPSBjbG9uZUFycmF5KHR3ZWVuLl90b051bWJlcnMpO1xuICB0YXJnZXRPYmplY3QucyA9IGNsb25lQXJyYXkodHdlZW4uX3N0cmluZ3MpO1xuICByZXR1cm4gdGFyZ2V0T2JqZWN0O1xufTtcblxuY29uc3QgZGVjb21wb3NlZE9yaWdpbmFsVmFsdWUgPSBjcmVhdGVEZWNvbXBvc2VkVmFsdWVUYXJnZXRPYmplY3QoKTtcblxuXG5cblxuY29uc3QgbG9va3VwcyA9IHtcbiAgLyoqIEB0eXBlIHtUd2VlblJlcGxhY2VMb29rdXBzfSAqL1xuICBfcmVwOiBuZXcgV2Vha01hcCgpLFxuICAvKiogQHR5cGUge1R3ZWVuQWRkaXRpdmVMb29rdXBzfSAqL1xuICBfYWRkOiBuZXcgTWFwKCksXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0gIHtTdHJpbmd9IGxvb2t1cFxuICogQHJldHVybiB7VHdlZW5Qcm9wZXJ0eVNpYmxpbmdzfVxuICovXG5jb25zdCBnZXRUd2VlblNpYmxpbmdzID0gKHRhcmdldCwgcHJvcGVydHksIGxvb2t1cCA9ICdfcmVwJykgPT4ge1xuICBjb25zdCBsb29rdXBNYXAgPSBsb29rdXBzW2xvb2t1cF07XG4gIGxldCB0YXJnZXRMb29rdXAgPSBsb29rdXBNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghdGFyZ2V0TG9va3VwKSB7XG4gICAgdGFyZ2V0TG9va3VwID0ge307XG4gICAgbG9va3VwTWFwLnNldCh0YXJnZXQsIHRhcmdldExvb2t1cCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldExvb2t1cFtwcm9wZXJ0eV0gPyB0YXJnZXRMb29rdXBbcHJvcGVydHldIDogdGFyZ2V0TG9va3VwW3Byb3BlcnR5XSA9IHtcbiAgICBfaGVhZDogbnVsbCxcbiAgICBfdGFpbDogbnVsbCxcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gcFxuICogQHBhcmFtICB7VHdlZW59IGNcbiAqIEByZXR1cm4ge051bWJlcnxCb29sZWFufVxuICovXG5jb25zdCBhZGRUd2VlblNvcnRNZXRob2QgPSAocCwgYykgPT4ge1xuICByZXR1cm4gcC5faXNPdmVycmlkZGVuIHx8IHAuX2Fic29sdXRlU3RhcnRUaW1lID4gYy5fYWJzb2x1dGVTdGFydFRpbWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuXG4gKi9cbmNvbnN0IG92ZXJyaWRlVHdlZW4gPSB0d2VlbiA9PiB7XG4gIHR3ZWVuLl9pc092ZXJsYXBwZWQgPSAxO1xuICB0d2Vlbi5faXNPdmVycmlkZGVuID0gMTtcbiAgdHdlZW4uX2NoYW5nZUR1cmF0aW9uID0gbWluVmFsdWU7XG4gIHR3ZWVuLl9jdXJyZW50VGltZSA9IG1pblZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gdHdlZW5cbiAqIEBwYXJhbSAge1R3ZWVuUHJvcGVydHlTaWJsaW5nc30gc2libGluZ3NcbiAqIEByZXR1cm4ge1R3ZWVufVxuICovXG5jb25zdCBjb21wb3NlVHdlZW4gPSAodHdlZW4sIHNpYmxpbmdzKSA9PiB7XG5cbiAgY29uc3QgdHdlZW5Db21wb3NpdGlvblR5cGUgPSB0d2Vlbi5fY29tcG9zaXRpb247XG5cbiAgLy8gSGFuZGxlIHJlcGxhY2VkIHR3ZWVuc1xuXG4gIGlmICh0d2VlbkNvbXBvc2l0aW9uVHlwZSA9PT0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlKSB7XG5cbiAgICBjb25zdCB0d2VlbkFic1N0YXJ0VGltZSA9IHR3ZWVuLl9hYnNvbHV0ZVN0YXJ0VGltZTtcblxuICAgIGFkZENoaWxkKHNpYmxpbmdzLCB0d2VlbiwgYWRkVHdlZW5Tb3J0TWV0aG9kLCAnX3ByZXZSZXAnLCAnX25leHRSZXAnKTtcblxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdHdlZW4uX3ByZXZSZXA7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHByZXZpb3VzIHNpYmxpbmdzIGZvciBjb21wb3NpdGlvbiByZXBsYWNlIHR3ZWVuc1xuXG4gICAgaWYgKHByZXZTaWJsaW5nKSB7XG5cbiAgICAgIGNvbnN0IHByZXZQYXJlbnQgPSBwcmV2U2libGluZy5wYXJlbnQ7XG4gICAgICBjb25zdCBwcmV2QWJzRW5kVGltZSA9IHByZXZTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSArIHByZXZTaWJsaW5nLl9jaGFuZ2VEdXJhdGlvbjtcblxuICAgICAgLy8gSGFuZGxlIGxvb3BlZCBhbmltYXRpb25zIHR3ZWVuXG5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByZXZpb3VzIHR3ZWVuIGlzIGZyb20gYSBkaWZmZXJlbnQgYW5pbWF0aW9uXG4gICAgICAgIHR3ZWVuLnBhcmVudC5pZCAhPT0gcHJldlBhcmVudC5pZCAmJlxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYW5pbWF0aW9uIGhhcyBsb29wc1xuICAgICAgICBwcmV2UGFyZW50Lml0ZXJhdGlvbkNvdW50PiAxICYmXG4gICAgICAgIC8vIENoZWNrIGlmIF9hYnNvbHV0ZUNoYW5nZUVuZFRpbWUgb2YgbGFzdCBsb29wIG92ZXJsYXBzIHRoZSBjdXJyZW50IHR3ZWVuXG4gICAgICAgIHByZXZBYnNFbmRUaW1lICsgKHByZXZQYXJlbnQuZHVyYXRpb24gLSBwcmV2UGFyZW50Lml0ZXJhdGlvbkR1cmF0aW9uKSA+IHR3ZWVuQWJzU3RhcnRUaW1lXG4gICAgICApIHtcblxuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgd2F5IHRvIG9ubHkgb3ZlcnJpZGUgdGhlIGl0ZXJhdGlvbnMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgdHdlZW5cbiAgICAgICAgb3ZlcnJpZGVUd2VlbihwcmV2U2libGluZyk7XG5cbiAgICAgICAgbGV0IHByZXZQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLl9wcmV2UmVwO1xuXG4gICAgICAgIC8vIElmIHRoZSB0d2VlbiB3YXMgcGFydCBvZiBhIHNldCBvZiBrZXlmcmFtZXMsIG92ZXJyaWRlIGl0cyBzaWJsaW5nc1xuICAgICAgICB3aGlsZSAocHJldlByZXZTaWJsaW5nICYmIHByZXZQcmV2U2libGluZy5wYXJlbnQuaWQgPT09IHByZXZQYXJlbnQuaWQpIHtcbiAgICAgICAgICBvdmVycmlkZVR3ZWVuKHByZXZQcmV2U2libGluZyk7XG4gICAgICAgICAgcHJldlByZXZTaWJsaW5nID0gcHJldlByZXZTaWJsaW5nLl9wcmV2UmVwO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgY29uc3QgYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUgPSB0d2VlbkFic1N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheTtcblxuICAgICAgaWYgKHByZXZBYnNFbmRUaW1lID4gYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUpIHtcblxuICAgICAgICBjb25zdCBwcmV2Q2hhbmdlU3RhcnRUaW1lID0gcHJldlNpYmxpbmcuX3N0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgcHJldlRMT2Zmc2V0ID0gcHJldkFic0VuZFRpbWUgLSAocHJldkNoYW5nZVN0YXJ0VGltZSArIHByZXZTaWJsaW5nLl91cGRhdGVEdXJhdGlvbik7XG4gICAgICAgIC8vIFJvdW5kaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIHRvIG1pbmltaXplIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3aGVuIHdvcmtpbmcgaW4gc2Vjb25kc1xuICAgICAgICBjb25zdCB1cGRhdGVkUHJldkNoYW5nZUR1cmF0aW9uID0gcm91bmQoYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUgLSBwcmV2VExPZmZzZXQgLSBwcmV2Q2hhbmdlU3RhcnRUaW1lLCAxMik7XG5cbiAgICAgICAgcHJldlNpYmxpbmcuX2NoYW5nZUR1cmF0aW9uID0gdXBkYXRlZFByZXZDaGFuZ2VEdXJhdGlvbjtcbiAgICAgICAgcHJldlNpYmxpbmcuX2N1cnJlbnRUaW1lID0gdXBkYXRlZFByZXZDaGFuZ2VEdXJhdGlvbjtcbiAgICAgICAgcHJldlNpYmxpbmcuX2lzT3ZlcmxhcHBlZCA9IDE7XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIHByZXZpb3VzIHR3ZWVuIGlmIGl0cyBuZXcgX2NoYW5nZUR1cmF0aW9uIGlzIGxvd2VyIHRoYW4gbWluVmFsdWVcbiAgICAgICAgLy8gVE9ETzogU2VlIGlmIGl0J3MgZXZlbiBuZWNlc2VlYXJ5IHRvIHRlc3QgYWdhaW5zdCBtaW5WYWx1ZSwgY2hlY2tpbmcgZm9yIDAgbWlnaHQgYmUgZW5vdWdoXG4gICAgICAgIGlmICh1cGRhdGVkUHJldkNoYW5nZUR1cmF0aW9uIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICBvdmVycmlkZVR3ZWVuKHByZXZTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQYXVzZSAoYW5kIGNhbmNlbCkgdGhlIHBhcmVudCBpZiBpdCBvbmx5IGNvbnRhaW5zIG92ZXJsYXBwZWQgdHdlZW5zXG5cbiAgICAgIGxldCBwYXVzZVByZXZQYXJlbnRBbmltYXRpb24gPSB0cnVlO1xuXG4gICAgICBmb3JFYWNoQ2hpbGRyZW4ocHJldlBhcmVudCwgKC8qKiBAdHlwZSBUd2VlbiAqL3QpID0+IHtcbiAgICAgICAgaWYgKCF0Ll9pc092ZXJsYXBwZWQpIHBhdXNlUHJldlBhcmVudEFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChwYXVzZVByZXZQYXJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgY29uc3QgcHJldlBhcmVudFRMID0gcHJldlBhcmVudC5wYXJlbnQ7XG4gICAgICAgIGlmIChwcmV2UGFyZW50VEwpIHtcbiAgICAgICAgICBsZXQgcGF1c2VQcmV2UGFyZW50VEwgPSB0cnVlO1xuICAgICAgICAgIGZvckVhY2hDaGlsZHJlbihwcmV2UGFyZW50VEwsICgvKiogQHR5cGUgSlNBbmltYXRpb24gKi9hKSA9PiB7XG4gICAgICAgICAgICBpZiAoYSAhPT0gcHJldlBhcmVudCkge1xuICAgICAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oYSwgKC8qKiBAdHlwZSBUd2VlbiAqL3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXQuX2lzT3ZlcmxhcHBlZCkgcGF1c2VQcmV2UGFyZW50VEwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHBhdXNlUHJldlBhcmVudFRMKSB7XG4gICAgICAgICAgICBwcmV2UGFyZW50VEwuY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZQYXJlbnQuY2FuY2VsKCk7XG4gICAgICAgICAgLy8gUHJldmlvdXNseSwgY2FsbGluZyAuY2FuY2VsKCkgb24gYSB0aW1lbGluZSBjaGlsZCB3b3VsZCBhZmZlY3QgdGhlIHJlbmRlciBvcmRlciBvZiBvdGhlciBjaGlsZHJlblxuICAgICAgICAgIC8vIFdvcmtlZCBhcm91bmQgdGhpcyBieSBtYXJraW5nIGl0IGFzIC5jb21wbGV0ZWQgYW5kIHVzaW5nIC5wYXVzZSgpIGZvciBzYWZlIHJlbW92YWwgaW4gdGhlIGVuZ2luZSBsb29wXG4gICAgICAgICAgLy8gVGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIHNpbmNlIHRpbWVsaW5lIHR3ZWVuIGNvbXBvc2l0aW9uIGlzIG5vdyBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAgICAgICAvLyBLZWVwaW5nIHRoaXMgaGVyZSBmb3IgcmVmZXJlbmNlXG4gICAgICAgICAgLy8gcHJldlBhcmVudC5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIHByZXZQYXJlbnQucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gbGV0IG5leHRTaWJsaW5nID0gdHdlZW4uX25leHRSZXA7XG5cbiAgICAvLyAvLyBBbGwgdGhlIG5leHQgc2libGluZ3MgYXJlIGF1dG9tYXRpY2FsbHkgb3ZlcnJpZGRlblxuXG4gICAgLy8gaWYgKG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSA+PSB0d2VlbkFic1N0YXJ0VGltZSkge1xuICAgIC8vICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgLy8gICAgIG92ZXJyaWRlVHdlZW4obmV4dFNpYmxpbmcpO1xuICAgIC8vICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLl9uZXh0UmVwO1xuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAgIC8vIGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5fYWJzb2x1dGVTdGFydFRpbWUgPCB0d2VlbkFic1N0YXJ0VGltZSkge1xuICAgIC8vICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgLy8gICAgIG92ZXJyaWRlVHdlZW4obmV4dFNpYmxpbmcpO1xuICAgIC8vICAgICBjb25zb2xlLmxvZyh0d2Vlbi5pZCwgbmV4dFNpYmxpbmcuaWQpO1xuICAgIC8vICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLl9uZXh0UmVwO1xuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAvLyBIYW5kbGUgYWRkaXRpdmUgdHdlZW5zIGNvbXBvc2l0aW9uXG5cbiAgfSBlbHNlIGlmICh0d2VlbkNvbXBvc2l0aW9uVHlwZSA9PT0gY29tcG9zaXRpb25UeXBlcy5ibGVuZCkge1xuXG4gICAgY29uc3QgYWRkaXRpdmVUd2VlblNpYmxpbmdzID0gZ2V0VHdlZW5TaWJsaW5ncyh0d2Vlbi50YXJnZXQsIHR3ZWVuLnByb3BlcnR5LCAnX2FkZCcpO1xuICAgIGNvbnN0IGFkZGl0aXZlQW5pbWF0aW9uID0gYWRkQWRkaXRpdmVBbmltYXRpb24obG9va3Vwcy5fYWRkKTtcblxuICAgIGxldCBsb29rdXBUd2VlbiA9IGFkZGl0aXZlVHdlZW5TaWJsaW5ncy5faGVhZDtcblxuICAgIGlmICghbG9va3VwVHdlZW4pIHtcbiAgICAgIGxvb2t1cFR3ZWVuID0geyAuLi50d2VlbiB9O1xuICAgICAgbG9va3VwVHdlZW4uX2NvbXBvc2l0aW9uID0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlO1xuICAgICAgbG9va3VwVHdlZW4uX3VwZGF0ZUR1cmF0aW9uID0gbWluVmFsdWU7XG4gICAgICBsb29rdXBUd2Vlbi5fc3RhcnRUaW1lID0gMDtcbiAgICAgIGxvb2t1cFR3ZWVuLl9udW1iZXJzID0gY2xvbmVBcnJheSh0d2Vlbi5fZnJvbU51bWJlcnMpO1xuICAgICAgbG9va3VwVHdlZW4uX251bWJlciA9IDA7XG4gICAgICBsb29rdXBUd2Vlbi5fbmV4dCA9IG51bGw7XG4gICAgICBsb29rdXBUd2Vlbi5fcHJldiA9IG51bGw7XG4gICAgICBhZGRDaGlsZChhZGRpdGl2ZVR3ZWVuU2libGluZ3MsIGxvb2t1cFR3ZWVuKTtcbiAgICAgIGFkZENoaWxkKGFkZGl0aXZlQW5pbWF0aW9uLCBsb29rdXBUd2Vlbik7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0aGUgdmFsdWVzIG9mIFRPIHRvIEZST00gYW5kIHNldCBUTyB0byAwXG5cbiAgICBjb25zdCB0b051bWJlciA9IHR3ZWVuLl90b051bWJlcjtcbiAgICB0d2Vlbi5fZnJvbU51bWJlciA9IGxvb2t1cFR3ZWVuLl9mcm9tTnVtYmVyIC0gdG9OdW1iZXI7XG4gICAgdHdlZW4uX3RvTnVtYmVyID0gMDtcbiAgICB0d2Vlbi5fbnVtYmVycyA9IGNsb25lQXJyYXkodHdlZW4uX2Zyb21OdW1iZXJzKTtcbiAgICB0d2Vlbi5fbnVtYmVyID0gMDtcbiAgICBsb29rdXBUd2Vlbi5fZnJvbU51bWJlciA9IHRvTnVtYmVyO1xuXG4gICAgaWYgKHR3ZWVuLl90b051bWJlcnMpIHtcbiAgICAgIGNvbnN0IHRvTnVtYmVycyA9IGNsb25lQXJyYXkodHdlZW4uX3RvTnVtYmVycyk7XG4gICAgICBpZiAodG9OdW1iZXJzKSB7XG4gICAgICAgIHRvTnVtYmVycy5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgIHR3ZWVuLl9mcm9tTnVtYmVyc1tpXSA9IGxvb2t1cFR3ZWVuLl9mcm9tTnVtYmVyc1tpXSAtIHZhbHVlO1xuICAgICAgICAgIHR3ZWVuLl90b051bWJlcnNbaV0gPSAwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxvb2t1cFR3ZWVuLl9mcm9tTnVtYmVycyA9IHRvTnVtYmVycztcbiAgICB9XG5cbiAgICBhZGRDaGlsZChhZGRpdGl2ZVR3ZWVuU2libGluZ3MsIHR3ZWVuLCBudWxsLCAnX3ByZXZBZGQnLCAnX25leHRBZGQnKTtcblxuICB9XG5cbiAgcmV0dXJuIHR3ZWVuO1xuXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1R3ZWVufSB0d2VlblxuICogQHJldHVybiB7VHdlZW59XG4gKi9cbmNvbnN0IHJlbW92ZVR3ZWVuU2xpYmxpbmdzID0gdHdlZW4gPT4ge1xuICBjb25zdCB0d2VlbkNvbXBvc2l0aW9uID0gdHdlZW4uX2NvbXBvc2l0aW9uO1xuICBpZiAodHdlZW5Db21wb3NpdGlvbiAhPT0gY29tcG9zaXRpb25UeXBlcy5ub25lKSB7XG4gICAgY29uc3QgdHdlZW5UYXJnZXQgPSB0d2Vlbi50YXJnZXQ7XG4gICAgY29uc3QgdHdlZW5Qcm9wZXJ0eSA9IHR3ZWVuLnByb3BlcnR5O1xuICAgIGNvbnN0IHJlcGxhY2VUd2VlbnNMb29rdXAgPSBsb29rdXBzLl9yZXA7XG4gICAgY29uc3QgcmVwbGFjZVRhcmdldFByb3BzID0gcmVwbGFjZVR3ZWVuc0xvb2t1cC5nZXQodHdlZW5UYXJnZXQpO1xuICAgIGNvbnN0IHR3ZWVuUmVwbGFjZVNpYmxpbmdzID0gcmVwbGFjZVRhcmdldFByb3BzW3R3ZWVuUHJvcGVydHldO1xuICAgIHJlbW92ZUNoaWxkKHR3ZWVuUmVwbGFjZVNpYmxpbmdzLCB0d2VlbiwgJ19wcmV2UmVwJywgJ19uZXh0UmVwJyk7XG4gICAgaWYgKHR3ZWVuQ29tcG9zaXRpb24gPT09IGNvbXBvc2l0aW9uVHlwZXMuYmxlbmQpIHtcbiAgICAgIGNvbnN0IGFkZFR3ZWVuc0xvb2t1cCA9IGxvb2t1cHMuX2FkZDtcbiAgICAgIGNvbnN0IGFkZFRhcmdldFByb3BzID0gYWRkVHdlZW5zTG9va3VwLmdldCh0d2VlblRhcmdldCk7XG4gICAgICBpZiAoIWFkZFRhcmdldFByb3BzKSByZXR1cm47XG4gICAgICBjb25zdCBhZGRpdGl2ZVR3ZWVuU2libGluZ3MgPSBhZGRUYXJnZXRQcm9wc1t0d2VlblByb3BlcnR5XTtcbiAgICAgIGNvbnN0IGFkZGl0aXZlQW5pbWF0aW9uID0gYWRkaXRpdmUuYW5pbWF0aW9uO1xuICAgICAgcmVtb3ZlQ2hpbGQoYWRkaXRpdmVUd2VlblNpYmxpbmdzLCB0d2VlbiwgJ19wcmV2QWRkJywgJ19uZXh0QWRkJyk7XG4gICAgICAvLyBJZiBvbmx5IG9uZSB0d2VlbiBpcyBsZWZ0IGluIHRoZSBhZGRpdGl2ZSBsb29rdXAsIGl0J3MgdGhlIHR3ZWVuIGxvb2t1cFxuICAgICAgY29uc3QgbG9va3VwVHdlZW4gPSBhZGRpdGl2ZVR3ZWVuU2libGluZ3MuX2hlYWQ7XG4gICAgICBpZiAobG9va3VwVHdlZW4gJiYgbG9va3VwVHdlZW4gPT09IGFkZGl0aXZlVHdlZW5TaWJsaW5ncy5fdGFpbCkge1xuICAgICAgICByZW1vdmVDaGlsZChhZGRpdGl2ZVR3ZWVuU2libGluZ3MsIGxvb2t1cFR3ZWVuLCAnX3ByZXZBZGQnLCAnX25leHRBZGQnKTtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoYWRkaXRpdmVBbmltYXRpb24sIGxvb2t1cFR3ZWVuKTtcbiAgICAgICAgbGV0IHNob3VsZENsZWFuID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBhZGRUYXJnZXRQcm9wcykge1xuICAgICAgICAgIGlmIChhZGRUYXJnZXRQcm9wc1twcm9wXS5faGVhZCkge1xuICAgICAgICAgICAgc2hvdWxkQ2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkQ2xlYW4pIHtcbiAgICAgICAgICBhZGRUd2VlbnNMb29rdXAuZGVsZXRlKHR3ZWVuVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHdlZW47XG59O1xuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge1RpbWVyfSB0aW1lclxuICogQHJldHVybiB7VGltZXJ9XG4gKi9cbmNvbnN0IHJlc2V0VGltZXJQcm9wZXJ0aWVzID0gdGltZXIgPT4ge1xuICB0aW1lci5wYXVzZWQgPSB0cnVlO1xuICB0aW1lci5iZWdhbiA9IGZhbHNlO1xuICB0aW1lci5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRpbWVyO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUaW1lcn0gdGltZXJcbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCByZXZpdmVUaW1lciA9IHRpbWVyID0+IHtcbiAgaWYgKCF0aW1lci5fY2FuY2VsbGVkKSByZXR1cm4gdGltZXI7XG4gIGlmICh0aW1lci5faGFzQ2hpbGRyZW4pIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGltZXIsIHJldml2ZVRpbWVyKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGltZXIsICgvKiogQHR5cGUge1R3ZWVufSB0d2VlbiovdHdlZW4pID0+IHtcbiAgICAgIGlmICh0d2Vlbi5fY29tcG9zaXRpb24gIT09IGNvbXBvc2l0aW9uVHlwZXMubm9uZSkge1xuICAgICAgICBjb21wb3NlVHdlZW4odHdlZW4sIGdldFR3ZWVuU2libGluZ3ModHdlZW4udGFyZ2V0LCB0d2Vlbi5wcm9wZXJ0eSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRpbWVyLl9jYW5jZWxsZWQgPSAwO1xuICByZXR1cm4gdGltZXI7XG59O1xuXG5sZXQgdGltZXJJZCA9IDA7XG5cbi8qKlxuICogQmFzZSBjbGFzcyB1c2VkIHRvIGNyZWF0ZSBUaW1lcnMsIEFuaW1hdGlvbnMgYW5kIFRpbWVsaW5lc1xuICovXG5jbGFzcyBUaW1lciBleHRlbmRzIENsb2NrIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGltZXJQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICAgKiBAcGFyYW0ge1RpbWVsaW5lfSBbcGFyZW50XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmVudFBvc2l0aW9uXVxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9LCBwYXJlbnQgPSBudWxsLCBwYXJlbnRQb3NpdGlvbiA9IDApIHtcblxuICAgIHN1cGVyKDApO1xuXG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBkZWxheSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgcmV2ZXJzZWQsXG4gICAgICBhbHRlcm5hdGUsXG4gICAgICBsb29wLFxuICAgICAgbG9vcERlbGF5LFxuICAgICAgYXV0b3BsYXksXG4gICAgICBmcmFtZVJhdGUsXG4gICAgICBwbGF5YmFja1JhdGUsXG4gICAgICBvbkNvbXBsZXRlLFxuICAgICAgb25Mb29wLFxuICAgICAgb25QYXVzZSxcbiAgICAgIG9uQmVnaW4sXG4gICAgICBvbkJlZm9yZVVwZGF0ZSxcbiAgICAgIG9uVXBkYXRlLFxuICAgIH0gPSBwYXJhbWV0ZXJzO1xuXG4gICAgaWYgKHNjb3BlLmN1cnJlbnQpIHNjb3BlLmN1cnJlbnQucmVnaXN0ZXIodGhpcyk7XG5cbiAgICBjb25zdCB0aW1lckluaXRUaW1lID0gcGFyZW50ID8gMCA6IGVuZ2luZS5fZWxhcHNlZFRpbWU7XG4gICAgY29uc3QgdGltZXJEZWZhdWx0cyA9IHBhcmVudCA/IHBhcmVudC5kZWZhdWx0cyA6IGdsb2JhbHMuZGVmYXVsdHM7XG4gICAgY29uc3QgdGltZXJEZWxheSA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhpc0ZuYyhkZWxheSkgfHwgaXNVbmQoZGVsYXkpID8gdGltZXJEZWZhdWx0cy5kZWxheSA6ICtkZWxheSk7XG4gICAgY29uc3QgdGltZXJEdXJhdGlvbiA9IGlzRm5jKGR1cmF0aW9uKSB8fCBpc1VuZChkdXJhdGlvbikgPyBJbmZpbml0eSA6ICtkdXJhdGlvbjtcbiAgICBjb25zdCB0aW1lckxvb3AgPSBzZXRWYWx1ZShsb29wLCB0aW1lckRlZmF1bHRzLmxvb3ApO1xuICAgIGNvbnN0IHRpbWVyTG9vcERlbGF5ID0gc2V0VmFsdWUobG9vcERlbGF5LCB0aW1lckRlZmF1bHRzLmxvb3BEZWxheSk7XG4gICAgY29uc3QgdGltZXJJdGVyYXRpb25Db3VudCA9IHRpbWVyTG9vcCA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lckxvb3AgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqLyh0aW1lckxvb3ApIDwgMCA/IEluZmluaXR5IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRpbWVyTG9vcCkgKyAxO1xuXG5cbiAgICBsZXQgb2Zmc2V0UG9zaXRpb24gPSAwO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgb2Zmc2V0UG9zaXRpb24gPSBwYXJlbnRQb3NpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWFrZSBzdXJlIHRvIHRpY2sgdGhlIGVuZ2luZSBvbmNlIGlmIG5vdCBjdXJyZW50bHkgcnVubmluZyB0byBnZXQgdXAgdG8gZGF0ZSBlbmdpbmUuX2VsYXBzZWRUaW1lXG4gICAgICAvLyB0byBhdm9pZCBiaWcgZ2FwcyB3aXRoIHRoZSBmb2xsb3dpbmcgb2Zmc2V0UG9zaXRpb24gY2FsY3VsYXRpb25cbiAgICAgIGlmICghZW5naW5lLnJlcUlkKSBlbmdpbmUucmVxdWVzdFRpY2sobm93KCkpO1xuICAgICAgLy8gTWFrZSBzdXJlIHRvIHNjYWxlIHRoZSBvZmZzZXQgcG9zaXRpb24gd2l0aCBnbG9iYWxzLnRpbWVTY2FsZSB0byBwcm9wZXJseSBoYW5kbGUgc2Vjb25kcyB1bml0XG4gICAgICBvZmZzZXRQb3NpdGlvbiA9IChlbmdpbmUuX2VsYXBzZWRUaW1lIC0gZW5naW5lLl9zdGFydFRpbWUpICogZ2xvYmFscy50aW1lU2NhbGU7XG4gICAgfVxuXG4gICAgLy8gVGltZXIncyBwYXJhbWV0ZXJzXG4gICAgdGhpcy5pZCA9ICFpc1VuZChpZCkgPyBpZCA6ICsrdGltZXJJZDtcbiAgICAvKiogQHR5cGUge1RpbWVsaW5lfSAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIC8vIFRvdGFsIGR1cmF0aW9uIG9mIHRoZSB0aW1lclxuICAgIHRoaXMuZHVyYXRpb24gPSBjbGFtcEluZmluaXR5KCgodGltZXJEdXJhdGlvbiArIHRpbWVyTG9vcERlbGF5KSAqIHRpbWVySXRlcmF0aW9uQ291bnQpIC0gdGltZXJMb29wRGVsYXkpIHx8IG1pblZhbHVlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJhY2t3YXJkcyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuYmVnYW4gPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25CZWdpbiA9IG9uQmVnaW4gfHwgdGltZXJEZWZhdWx0cy5vbkJlZ2luO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vbkJlZm9yZVVwZGF0ZSA9IG9uQmVmb3JlVXBkYXRlIHx8IHRpbWVyRGVmYXVsdHMub25CZWZvcmVVcGRhdGU7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uVXBkYXRlID0gb25VcGRhdGUgfHwgdGltZXJEZWZhdWx0cy5vblVwZGF0ZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25Mb29wID0gb25Mb29wIHx8IHRpbWVyRGVmYXVsdHMub25Mb29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblBhdXNlID0gb25QYXVzZSB8fCB0aW1lckRlZmF1bHRzLm9uUGF1c2U7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlIHx8IHRpbWVyRGVmYXVsdHMub25Db21wbGV0ZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gdGltZXJEdXJhdGlvbjsgLy8gRHVyYXRpb24gb2Ygb25lIGxvb3BcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkNvdW50ID0gdGltZXJJdGVyYXRpb25Db3VudDsgLy8gTnVtYmVyIG9mIGxvb3BzXG4gICAgLyoqIEB0eXBlIHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuX2F1dG9wbGF5ID0gcGFyZW50ID8gZmFsc2UgOiBzZXRWYWx1ZShhdXRvcGxheSwgdGltZXJEZWZhdWx0cy5hdXRvcGxheSk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0UG9zaXRpb247XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZGVsYXkgPSB0aW1lckRlbGF5O1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2xvb3BEZWxheSA9IHRpbWVyTG9vcERlbGF5O1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2l0ZXJhdGlvblRpbWUgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24gPSAwOyAvLyBDdXJyZW50IGxvb3AgaW5kZXhcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuX3Jlc29sdmUgPSBub29wOyAvLyBVc2VkIGJ5IC50aGVuKClcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX3JldmVyc2VkID0gK3NldFZhbHVlKHJldmVyc2VkLCB0aW1lckRlZmF1bHRzLnJldmVyc2VkKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9yZXZlcnNlID0gdGhpcy5fcmV2ZXJzZWQ7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fY2FuY2VsbGVkID0gMDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5fYWx0ZXJuYXRlID0gc2V0VmFsdWUoYWx0ZXJuYXRlLCB0aW1lckRlZmF1bHRzLmFsdGVybmF0ZSk7XG4gICAgLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqL1xuICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi9cbiAgICB0aGlzLl9uZXh0ID0gbnVsbDtcblxuICAgIC8vIENsb2NrJ3MgcGFyYW1ldGVyc1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gdGltZXJJbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lckluaXRUaW1lO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2xhc3RUaW1lID0gdGltZXJJbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9mcHMgPSBzZXRWYWx1ZShmcmFtZVJhdGUsIHRpbWVyRGVmYXVsdHMuZnJhbWVSYXRlKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zcGVlZCA9IHNldFZhbHVlKHBsYXliYWNrUmF0ZSwgdGltZXJEZWZhdWx0cy5wbGF5YmFja1JhdGUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGxlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9jYW5jZWxsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxsZWQgICovXG4gIHNldCBjYW5jZWxsZWQoY2FuY2VsbGVkKSB7XG4gICAgY2FuY2VsbGVkID8gdGhpcy5jYW5jZWwoKSA6IHRoaXMucmVzZXQoMSkucGxheSgpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiBjbGFtcChyb3VuZCh0aGlzLl9jdXJyZW50VGltZSwgZ2xvYmFscy5wcmVjaXNpb24pLCAtdGhpcy5fZGVsYXksIHRoaXMuZHVyYXRpb24pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICAqL1xuICBzZXQgY3VycmVudFRpbWUodGltZSkge1xuICAgIGNvbnN0IHBhdXNlZCA9IHRoaXMucGF1c2VkO1xuICAgIC8vIFBhdXNpbmcgdGhlIHRpbWVyIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCB0aW1lIGp1bXBzIG9uIGEgcnVubmluZyBpbnN0YW5jZVxuICAgIHRoaXMucGF1c2UoKS5zZWVrKCt0aW1lKTtcbiAgICBpZiAoIXBhdXNlZCkgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGdldCBpdGVyYXRpb25DdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gcm91bmQodGhpcy5faXRlcmF0aW9uVGltZSwgZ2xvYmFscy5wcmVjaXNpb24pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICAqL1xuICBzZXQgaXRlcmF0aW9uQ3VycmVudFRpbWUodGltZSkge1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAodGhpcy5pdGVyYXRpb25EdXJhdGlvbiAqIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24pICsgdGltZTtcbiAgfVxuXG4gIGdldCBwcm9ncmVzcygpIHtcbiAgICByZXR1cm4gY2xhbXAocm91bmQodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmR1cmF0aW9uLCAxMCksIDAsIDEpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAgKi9cbiAgc2V0IHByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IHRoaXMuZHVyYXRpb24gKiBwcm9ncmVzcztcbiAgfVxuXG4gIGdldCBpdGVyYXRpb25Qcm9ncmVzcygpIHtcbiAgICByZXR1cm4gY2xhbXAocm91bmQodGhpcy5faXRlcmF0aW9uVGltZSAvIHRoaXMuaXRlcmF0aW9uRHVyYXRpb24sIDEwKSwgMCwgMSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzICAqL1xuICBzZXQgaXRlcmF0aW9uUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICBjb25zdCBpdGVyYXRpb25EdXJhdGlvbiA9IHRoaXMuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IChpdGVyYXRpb25EdXJhdGlvbiAqIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24pICsgKGl0ZXJhdGlvbkR1cmF0aW9uICogcHJvZ3Jlc3MpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRJdGVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRJdGVyYXRpb247XG4gIH1cblxuICAvKiogQHBhcmFtIHtOdW1iZXJ9IGl0ZXJhdGlvbkNvdW50ICAqL1xuICBzZXQgY3VycmVudEl0ZXJhdGlvbihpdGVyYXRpb25Db3VudCkge1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAodGhpcy5pdGVyYXRpb25EdXJhdGlvbiAqIGNsYW1wKCtpdGVyYXRpb25Db3VudCwgMCwgdGhpcy5pdGVyYXRpb25Db3VudCAtIDEpKTtcbiAgfVxuXG4gIGdldCByZXZlcnNlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yZXZlcnNlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge0Jvb2xlYW59IHJldmVyc2UgICovXG4gIHNldCByZXZlcnNlZChyZXZlcnNlKSB7XG4gICAgcmV2ZXJzZSA/IHRoaXMucmV2ZXJzZSgpIDogdGhpcy5wbGF5KCk7XG4gIH1cblxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNwZWVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwbGF5YmFja1JhdGUgICovXG4gIHNldCBzcGVlZChwbGF5YmFja1JhdGUpIHtcbiAgICBzdXBlci5zcGVlZCA9IHBsYXliYWNrUmF0ZTtcbiAgICB0aGlzLnJlc2V0VGltZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHJlc2V0KGludGVybmFsUmVuZGVyID0gMCkge1xuICAgIC8vIElmIGNhbmNlbGxlZCwgcmV2aXZlIHRoZSB0aW1lciBiZWZvcmUgcmVuZGVyaW5nIGluIG9yZGVyIHRvIGhhdmUgcHJvcGVydGx5IGNvbXBvc2VkIHR3ZWVucyBzaWJsaW5nc1xuICAgIHJldml2ZVRpbWVyKHRoaXMpO1xuICAgIGlmICh0aGlzLl9yZXZlcnNlZCAmJiAhdGhpcy5fcmV2ZXJzZSkgdGhpcy5yZXZlcnNlZCA9IGZhbHNlO1xuICAgIC8vIFJlbmRlcmluZyBiZWZvcmUgdXBkYXRpbmcgdGhlIGNvbXBsZXRlZCBmbGFnIHRvIHByZXZlbnQgc2tpcHMgYW5kIHRvIG1ha2Ugc3VyZSB0aGUgcHJvcGVydGllcyBhcmUgbm90IG92ZXJyaWRkZW5cbiAgICAvLyBTZXR0aW5nIHRoZSBpdGVyYXRpb25UaW1lIGF0IHRoZSBlbmQgdG8gZm9yY2UgdGhlIHJlbmRlcmluZyB0byBoYXBwZW5kIGJhY2t3YXJkcywgb3RoZXJ3aXNlIGNhbGxpbmcgLnJlc2V0KCkgb24gVGltZWxpbmVzIG1pZ2h0IG5vdCByZW5kZXIgY2hpbGRyZW4gaW4gdGhlIHJpZ2h0IG9yZGVyXG4gICAgLy8gTk9URTogVGhpcyBpcyBvbmx5IHJlcXVpcmVkIGZvciBUaW1lbGluZXMgYW5kIG1pZ2h0IGJlIGJldHRlciB0byBtb3ZlIHRvIHRoZSBUaW1lbGluZSBjbGFzcz9cbiAgICB0aGlzLl9pdGVyYXRpb25UaW1lID0gdGhpcy5pdGVyYXRpb25EdXJhdGlvbjtcbiAgICAvLyBTZXQgdGlja01vZGUgdG8gdGlja01vZGVzLkZPUkNFIHRvIGZvcmNlIHJlbmRlcmluZ1xuICAgIHRpY2sodGhpcywgMCwgMSwgaW50ZXJuYWxSZW5kZXIsIHRpY2tNb2Rlcy5GT1JDRSk7XG4gICAgLy8gUmVzZXQgdGltZXIgcHJvcGVydGllcyBhZnRlciByZXZpdmUgLyByZW5kZXIgdG8gbWFrZSBzdXJlIHRoZSBwcm9wcyBhcmUgbm90IHVwZGF0ZWQgYWdhaW5cbiAgICByZXNldFRpbWVyUHJvcGVydGllcyh0aGlzKTtcbiAgICAvLyBBbHNvIHJlc2V0IGNoaWxkcmVuIHByb3BlcnRpZXNcbiAgICBpZiAodGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCByZXNldFRpbWVyUHJvcGVydGllcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGluaXQoaW50ZXJuYWxSZW5kZXIgPSAwKSB7XG4gICAgdGhpcy5mcHMgPSB0aGlzLl9mcHM7XG4gICAgdGhpcy5zcGVlZCA9IHRoaXMuX3NwZWVkO1xuICAgIC8vIE1hbnVhbGx5IGNhbGxpbmcgLmluaXQoKSBvbiB0aW1lbGluZXMgc2hvdWxkIHJlbmRlciBhbGwgY2hpbGRyZW4gaW50aWFsIHN0YXRlXG4gICAgLy8gRm9yY2VzIGFsbCBjaGlsZHJlbiB0byByZW5kZXIgb25jZSB0aGVuIHJlbmRlciB0byAwIHdoZW4gcmVzZXRlZFxuICAgIGlmICghaW50ZXJuYWxSZW5kZXIgJiYgdGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIHRpY2sodGhpcywgdGhpcy5kdXJhdGlvbiwgMSwgaW50ZXJuYWxSZW5kZXIsIHRpY2tNb2Rlcy5GT1JDRSk7XG4gICAgfVxuICAgIHRoaXMucmVzZXQoaW50ZXJuYWxSZW5kZXIpO1xuICAgIC8vIE1ha2Ugc3VyZSB0byBzZXQgYXV0b3BsYXkgdG8gZmFsc2UgdG8gY2hpbGQgdGltZXJzIHNvIGl0IGRvZXNuJ3QgYXR0ZW1wdCB0byBhdXRvcGxheSAvIGxpbmtcbiAgICBjb25zdCBhdXRvcGxheSA9IHRoaXMuX2F1dG9wbGF5O1xuICAgIGlmIChhdXRvcGxheSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKGF1dG9wbGF5ICYmICFpc1VuZCgvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqLyhhdXRvcGxheSkubGlua2VkKSkge1xuICAgICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi8oYXV0b3BsYXkpLmxpbmsodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge3RoaXN9ICovXG4gIHJlc2V0VGltZSgpIHtcbiAgICBjb25zdCB0aW1lU2NhbGUgPSAxIC8gKHRoaXMuX3NwZWVkICogZW5naW5lLl9zcGVlZCk7XG4gICAgLy8gVE9ETzogU2VlIGlmIHdlIGNhbiBzYWZlbHkgdXNlIGVuZ2luZS5fZWxhcHNlZFRpbWUgaGVyZVxuICAgIC8vIGlmICghZW5naW5lLnJlcUlkKSBlbmdpbmUucmVxdWVzdFRpY2sobm93KCkpXG4gICAgLy8gdGhpcy5fc3RhcnRUaW1lID0gZW5naW5lLl9lbGFwc2VkVGltZSAtICh0aGlzLl9jdXJyZW50VGltZSArIHRoaXMuX2RlbGF5KSAqIHRpbWVTY2FsZTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBub3coKSAtICh0aGlzLl9jdXJyZW50VGltZSArIHRoaXMuX2RlbGF5KSAqIHRpbWVTY2FsZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICBwYXVzZSgpIHtcbiAgICBpZiAodGhpcy5wYXVzZWQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9uUGF1c2UodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgLy8gV2UgY2FuIHNhZmVseSBpbWVkaWF0bHkgcmVuZGVyIGEgdGltZXIgdGhhdCBoYXMgbm8gZHVyYXRpb24gYW5kIG5vIGNoaWxkcmVuXG4gICAgaWYgKHRoaXMuZHVyYXRpb24gPD0gbWluVmFsdWUgJiYgIXRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICB0aWNrKHRoaXMsIG1pblZhbHVlLCAwLCAwLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgYWRkQ2hpbGQoZW5naW5lLCB0aGlzKTtcbiAgICAgICAgZW5naW5lLl9oYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldFRpbWUoKTtcbiAgICAgIC8vIEZvcmNlcyB0aGUgdGltZXIgdG8gYWR2YW5jZSBieSBhdCBsZWFzdCBvbmUgZnJhbWUgd2hlbiB0aGUgbmV4dCB0aWNrIG9jY3Vyc1xuICAgICAgdGhpcy5fc3RhcnRUaW1lIC09IDEyO1xuICAgICAgZW5naW5lLndha2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgcmVzdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNldCgwKS5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVcbiAgICogQHBhcmFtICB7Qm9vbGVhbnxOdW1iZXJ9IFttdXRlQ2FsbGJhY2tzXVxuICAgKiBAcGFyYW0gIHtCb29sZWFufE51bWJlcn0gW2ludGVybmFsUmVuZGVyXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2Vlayh0aW1lLCBtdXRlQ2FsbGJhY2tzID0gMCwgaW50ZXJuYWxSZW5kZXIgPSAwKSB7XG4gICAgLy8gUmVjb21wb3NlIHRoZSB0d2VlbiBzaWJsaW5ncyBpbiBjYXNlIHRoZSB0aW1lciBoYXMgYmVlbiBjYW5jZWxsZWRcbiAgICByZXZpdmVUaW1lcih0aGlzKTtcbiAgICAvLyBJZiB5b3Ugc2VlayBhIGNvbXBsZXRlZCBhbmltYXRpb24sIG90aGVyd2lzZSB0aGUgbmV4dCBwbGF5IHdpbGwgc3RhcnRzIGF0IDBcbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlzUGF1c2VkID0gdGhpcy5wYXVzZWQ7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIC8vIHRpbWVyLCB0aW1lLCBtdXRlQ2FsbGJhY2tzLCBpbnRlcm5hbFJlbmRlciwgdGlja01vZGVcbiAgICB0aWNrKHRoaXMsIHRpbWUgKyB0aGlzLl9kZWxheSwgfn5tdXRlQ2FsbGJhY2tzLCB+fmludGVybmFsUmVuZGVyLCB0aWNrTW9kZXMuQVVUTyk7XG4gICAgcmV0dXJuIGlzUGF1c2VkID8gdGhpcyA6IHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgYWx0ZXJuYXRlKCkge1xuICAgIGNvbnN0IHJldmVyc2VkID0gdGhpcy5fcmV2ZXJzZWQ7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLml0ZXJhdGlvbkNvdW50O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5pdGVyYXRpb25EdXJhdGlvbjtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1heGltdW0gaXRlcmF0aW9ucyBwb3NzaWJsZSBnaXZlbiB0aGUgaXRlcmF0aW9uIGR1cmF0aW9uXG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IGNvdW50ID09PSBJbmZpbml0eSA/IGZsb29yKG1heFZhbHVlIC8gZHVyYXRpb24pIDogY291bnQ7XG4gICAgdGhpcy5fcmV2ZXJzZWQgPSArKHRoaXMuX2FsdGVybmF0ZSAmJiAhKGl0ZXJhdGlvbnMgJSAyKSA/IHJldmVyc2VkIDogIXJldmVyc2VkKTtcbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSB7XG4gICAgICAvLyBIYW5kbGUgaW5maW5pdGUgbG9vcHMgdG8gbG9vcCBvbiB0aGVtc2VsZlxuICAgICAgdGhpcy5pdGVyYXRpb25Qcm9ncmVzcyA9IHRoaXMuX3JldmVyc2VkID8gMSAtIHRoaXMuaXRlcmF0aW9uUHJvZ3Jlc3MgOiB0aGlzLml0ZXJhdGlvblByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlZWsoKGR1cmF0aW9uICogaXRlcmF0aW9ucykgLSB0aGlzLl9jdXJyZW50VGltZSk7XG4gICAgfVxuICAgIHRoaXMucmVzZXRUaW1lKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZWQpIHRoaXMuYWx0ZXJuYXRlKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgcmV2ZXJzZSgpIHtcbiAgICBpZiAoIXRoaXMuX3JldmVyc2VkKSB0aGlzLmFsdGVybmF0ZSgpO1xuICAgIHJldHVybiB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgLy8gVE9ETzogTW92ZSBhbGwgdGhlIGFuaW1hdGlvbiAvIHR3ZWVucyAvIGNoaWxkcmVuIHJlbGF0ZWQgY29kZSB0byBBbmltYXRpb24gLyBUaW1lbGluZVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi9jaGlsZCkgPT4gY2hpbGQuY2FuY2VsKCksIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgcmVtb3ZlVHdlZW5TbGlibGluZ3MpO1xuICAgIH1cbiAgICB0aGlzLl9jYW5jZWxsZWQgPSAxO1xuICAgIC8vIFBhdXNpbmcgdGhlIHRpbWVyIHJlbW92ZXMgaXQgZnJvbSB0aGUgZW5naW5lXG4gICAgcmV0dXJuIHRoaXMucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG5ld0R1cmF0aW9uXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzdHJldGNoKG5ld0R1cmF0aW9uKSB7XG4gICAgY29uc3QgY3VycmVudER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBjb25zdCBub3JtbGl6ZWREdXJhdGlvbiA9IG5vcm1hbGl6ZVRpbWUobmV3RHVyYXRpb24pO1xuICAgIGlmIChjdXJyZW50RHVyYXRpb24gPT09IG5vcm1saXplZER1cmF0aW9uKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB0aW1lU2NhbGUgPSBuZXdEdXJhdGlvbiAvIGN1cnJlbnREdXJhdGlvbjtcbiAgICBjb25zdCBpc1NldHRlciA9IG5ld0R1cmF0aW9uIDw9IG1pblZhbHVlO1xuICAgIHRoaXMuZHVyYXRpb24gPSBpc1NldHRlciA/IG1pblZhbHVlIDogbm9ybWxpemVkRHVyYXRpb247XG4gICAgdGhpcy5pdGVyYXRpb25EdXJhdGlvbiA9IGlzU2V0dGVyID8gbWluVmFsdWUgOiBub3JtYWxpemVUaW1lKHRoaXMuaXRlcmF0aW9uRHVyYXRpb24gKiB0aW1lU2NhbGUpO1xuICAgIHRoaXMuX29mZnNldCAqPSB0aW1lU2NhbGU7XG4gICAgdGhpcy5fZGVsYXkgKj0gdGltZVNjYWxlO1xuICAgIHRoaXMuX2xvb3BEZWxheSAqPSB0aW1lU2NhbGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuIC8qKlxuICAgKiBDYW5jZWxzIHRoZSB0aW1lciBieSBzZWVraW5nIGl0IGJhY2sgdG8gMCBhbmQgcmV2ZXJ0aW5nIHRoZSBhdHRhY2hlZCBzY3JvbGxlciBpZiBuZWNlc3NhcnlcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHJldmVydCgpIHtcbiAgICB0aWNrKHRoaXMsIDAsIDEsIDAsIHRpY2tNb2Rlcy5BVVRPKTtcbiAgICBjb25zdCBhcCA9IC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovKHRoaXMuX2F1dG9wbGF5KTtcbiAgICBpZiAoYXAgJiYgYXAubGlua2VkICYmIGFwLmxpbmtlZCA9PT0gdGhpcykgYXAucmV2ZXJ0KCk7XG4gICAgcmV0dXJuIHRoaXMuY2FuY2VsKCk7XG4gIH1cblxuIC8qKlxuICAgKiBJbWVkaWF0bHkgY29tcGxldGVzIHRoZSB0aW1lciwgY2FuY2VscyBpdCBhbmQgdHJpZ2dlcnMgdGhlIG9uQ29tcGxldGUgY2FsbGJhY2tcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGNvbXBsZXRlKCkge1xuICAgIHJldHVybiB0aGlzLnNlZWsodGhpcy5kdXJhdGlvbikuY2FuY2VsKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7Q2FsbGJhY2s8dGhpcz59IFtjYWxsYmFja11cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHRoZW4oY2FsbGJhY2sgPSBub29wKSB7XG4gICAgY29uc3QgdGhlbiA9IHRoaXMudGhlbjtcbiAgICBjb25zdCBvblJlc29sdmUgPSAoKSA9PiB7XG4gICAgICAvLyB0aGlzLnRoZW4gPSBudWxsIHByZXZlbnRzIGluZmluaXRlIHJlY3Vyc2lvbiBpZiByZXR1cm5lZCBieSBhbiBhc3luYyBmdW5jdGlvblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2p1bGlhbmdhcm5pZXJvcmcvYW5pbWUtYmV0YS9pc3N1ZXMvMjZcbiAgICAgIHRoaXMudGhlbiA9IG51bGw7XG4gICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgIHRoaXMudGhlbiA9IHRoZW47XG4gICAgICB0aGlzLl9yZXNvbHZlID0gbm9vcDtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSAoKSA9PiByKG9uUmVzb2x2ZSgpKTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0byByZXNvbHZlIGltZWRpYXRseSBpZiB0aGUgdGltZXIgaGFzIGFscmVhZHkgY29tcGxldGVkXG4gICAgICBpZiAodGhpcy5jb21wbGV0ZWQpIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVyUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCBjcmVhdGVUaW1lciA9IHBhcmFtZXRlcnMgPT4gbmV3IFRpbWVyKHBhcmFtZXRlcnMsIG51bGwsIDApLmluaXQoKTtcblxuXG5cblxuLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbmNvbnN0IG5vbmUgPSB0ID0+IHQ7XG5cbi8vIEN1YmljIEJlemllciBzb2x2ZXIgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2UgwqkgR2HDq3RhbiBSZW5hdWRlYXVcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFUXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFBMVxuICogQHBhcmFtICB7TnVtYmVyfSBhQTJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgY2FsY0JlemllciA9IChhVCwgYUExLCBhQTIpID0+ICgoKDEgLSAzICogYUEyICsgMyAqIGFBMSkgKiBhVCArICgzICogYUEyIC0gNiAqIGFBMSkpICogYVQgKyAoMyAqIGFBMSkpICogYVQ7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSBhWFxuICogQHBhcmFtICB7TnVtYmVyfSBtWDFcbiAqIEBwYXJhbSAge051bWJlcn0gbVgyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGJpbmFyeVN1YmRpdmlkZSA9IChhWCwgbVgxLCBtWDIpID0+IHtcbiAgbGV0IGFBID0gMCwgYUIgPSAxLCBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xuICBkbyB7XG4gICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDI7XG4gICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICBpZiAoY3VycmVudFggPiAwKSB7XG4gICAgICBhQiA9IGN1cnJlbnRUO1xuICAgIH0gZWxzZSB7XG4gICAgICBhQSA9IGN1cnJlbnRUO1xuICAgIH1cbiAgfSB3aGlsZSAoYWJzKGN1cnJlbnRYKSA+IC4wMDAwMDAxICYmICsraSA8IDEwMCk7XG4gIHJldHVybiBjdXJyZW50VDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSBbbVgxXSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludFxuICogQHBhcmFtICB7TnVtYmVyfSBbbVkxXSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludFxuICogQHBhcmFtICB7TnVtYmVyfSBbbVgyXSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSAge051bWJlcn0gW21ZMl0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50XG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuXG5jb25zdCBjdWJpY0JlemllciA9IChtWDEgPSAwLjUsIG1ZMSA9IDAuMCwgbVgyID0gMC41LCBtWTIgPSAxLjApID0+IChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgPyBub25lIDpcbiAgdCA9PiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDpcbiAgY2FsY0JlemllcihiaW5hcnlTdWJkaXZpZGUodCwgbVgxLCBtWDIpLCBtWTEsIG1ZMik7XG5cbi8qKlxuICogU3RlcHMgZWFzZSBpbXBsZW1lbnRhdGlvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9mci9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cbiAqIE9ubHkgY292ZXJzICdlbmQnIGFuZCAnc3RhcnQnIGp1bXB0ZXJtc1xuICogQHBhcmFtICB7TnVtYmVyfSBzdGVwc1xuICogQHBhcmFtICB7Qm9vbGVhbn0gW2Zyb21TdGFydF1cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBzdGVwcyA9IChzdGVwcyA9IDEwLCBmcm9tU3RhcnQpID0+IHtcbiAgY29uc3Qgcm91bmRNZXRob2QgPSBmcm9tU3RhcnQgPyBjZWlsIDogZmxvb3I7XG4gIHJldHVybiB0ID0+IHJvdW5kTWV0aG9kKGNsYW1wKHQsIDAsIDEpICogc3RlcHMpICogKDEgLyBzdGVwcyk7XG59O1xuXG4vKipcbiAqIFdpdGhvdXQgcGFyYW1ldGVycywgdGhlIGxpbmVhciBmdW5jdGlvbiBjcmVhdGVzIGEgbm9uLWVhc2VkIHRyYW5zaXRpb24uXG4gKiBQYXJhbWV0ZXJzLCBpZiB1c2VkLCBjcmVhdGVzIGEgcGllY2V3aXNlIGxpbmVhciBlYXNpbmcgYnkgaW50ZXJwb2xhdGluZyBsaW5lYXJseSBiZXR3ZWVuIHRoZSBzcGVjaWZpZWQgcG9pbnRzLlxuICogQHBhcmFtICB7Li4uKFN0cmluZ3xOdW1iZXIpfSBhcmdzIC0gUG9pbnRzXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuY29uc3QgbGluZWFyID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICBpZiAoIWFyZ3NMZW5ndGgpIHJldHVybiBub25lO1xuICBjb25zdCB0b3RhbFBvaW50cyA9IGFyZ3NMZW5ndGggLSAxO1xuICBjb25zdCBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gIGNvbnN0IGxhc3RBcmcgPSBhcmdzW3RvdGFsUG9pbnRzXTtcbiAgY29uc3QgeFBvaW50cyA9IFswXTtcbiAgY29uc3QgeVBvaW50cyA9IFtwYXJzZU51bWJlcihmaXJzdEFyZyldO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHRvdGFsUG9pbnRzOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgIGNvbnN0IHNwbGl0VmFsdWUgPSBpc1N0cihhcmcpID9cbiAgICAvKiogQHR5cGUge1N0cmluZ30gKi8oYXJnKS50cmltKCkuc3BsaXQoJyAnKSA6XG4gICAgW2FyZ107XG4gICAgY29uc3QgdmFsdWUgPSBzcGxpdFZhbHVlWzBdO1xuICAgIGNvbnN0IHBlcmNlbnQgPSBzcGxpdFZhbHVlWzFdO1xuICAgIHhQb2ludHMucHVzaCghaXNVbmQocGVyY2VudCkgPyBwYXJzZU51bWJlcihwZXJjZW50KSAvIDEwMCA6IGkgLyB0b3RhbFBvaW50cyk7XG4gICAgeVBvaW50cy5wdXNoKHBhcnNlTnVtYmVyKHZhbHVlKSk7XG4gIH1cbiAgeVBvaW50cy5wdXNoKHBhcnNlTnVtYmVyKGxhc3RBcmcpKTtcbiAgeFBvaW50cy5wdXNoKDEpO1xuICByZXR1cm4gZnVuY3Rpb24gZWFzZUxpbmVhcih0KSB7XG4gICAgZm9yIChsZXQgaSA9IDEsIGwgPSB4UG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudFggPSB4UG9pbnRzW2ldO1xuICAgICAgaWYgKHQgPD0gY3VycmVudFgpIHtcbiAgICAgICAgY29uc3QgcHJldlggPSB4UG9pbnRzW2kgLSAxXTtcbiAgICAgICAgY29uc3QgcHJldlkgPSB5UG9pbnRzW2kgLSAxXTtcbiAgICAgICAgcmV0dXJuIHByZXZZICsgKHlQb2ludHNbaV0gLSBwcmV2WSkgKiAodCAtIHByZXZYKSAvIChjdXJyZW50WCAtIHByZXZYKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHlQb2ludHNbeVBvaW50cy5sZW5ndGggLSAxXTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSByYW5kb20gc3RlcHNcbiAqIEBwYXJhbSAge051bWJlcn0gW2xlbmd0aF0gLSBUaGUgbnVtYmVyIG9mIHN0ZXBzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtyYW5kb21uZXNzXSAtIEhvdyBzdHJvbmcgdGhlIHJhbmRvbW5lc3MgaXNcbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBpcnJlZ3VsYXIgPSAobGVuZ3RoID0gMTAsIHJhbmRvbW5lc3MgPSAxKSA9PiB7XG4gIGNvbnN0IHZhbHVlcyA9IFswXTtcbiAgY29uc3QgdG90YWwgPSBsZW5ndGggLSAxO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdmFsdWVzW2kgLSAxXTtcbiAgICBjb25zdCBzcGFjaW5nID0gaSAvIHRvdGFsO1xuICAgIGNvbnN0IHNlZ21lbnRFbmQgPSAoaSArIDEpIC8gdG90YWw7XG4gICAgY29uc3QgcmFuZG9tVmFyaWF0aW9uID0gc3BhY2luZyArIChzZWdtZW50RW5kIC0gc3BhY2luZykgKiBNYXRoLnJhbmRvbSgpO1xuICAgIC8vIE1peCB0aGUgZXZlbiBzcGFjaW5nIGFuZCByYW5kb20gdmFyaWF0aW9uIGJhc2VkIG9uIHRoZSByYW5kb21uZXNzIHBhcmFtZXRlclxuICAgIGNvbnN0IHJhbmRvbVZhbHVlID0gc3BhY2luZyAqICgxIC0gcmFuZG9tbmVzcykgKyByYW5kb21WYXJpYXRpb24gKiByYW5kb21uZXNzO1xuICAgIHZhbHVlcy5wdXNoKGNsYW1wKHJhbmRvbVZhbHVlLCBwcmV2aW91c1ZhbHVlLCAxKSk7XG4gIH1cbiAgdmFsdWVzLnB1c2goMSk7XG4gIHJldHVybiBsaW5lYXIoLi4udmFsdWVzKTtcbn07XG5cbi8vIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNlIMKpIFJvYmVydCBQZW5uZXJcblxuLyoqXG4gKiBAY2FsbGJhY2sgUG93ZXJFYXNpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3Bvd2VyPTEuNjc1XVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQmFja0Vhc2luZ1xuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3ZlcnNob290PTEuNzAxNThdXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGFzdGljRWFzaW5nXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFthbXBsaXR1ZGU9MV1cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3BlcmlvZD0uM11cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVhc2VGYWN0b3J5XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtwYXJhbUFdXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtwYXJhbUJdXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbnxOdW1iZXJ9XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtQb3dlckVhc2luZ3xCYWNrRWFzaW5nfEVsYXN0aWNFYXNpbmd9IEVhc2VzRmFjdG9yeSAqL1xuXG5jb25zdCBoYWxmUEkgPSBQSSAvIDI7XG5jb25zdCBkb3VibGVQSSA9IFBJICogMjtcbi8qKiBAdHlwZSB7UG93ZXJFYXNpbmd9ICovXG5jb25zdCBlYXNlSW5Qb3dlciA9IChwID0gMS42OCkgPT4gdCA9PiBwb3codCwgK3ApO1xuXG4vKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2VzRmFjdG9yeXxFYXNpbmdGdW5jdGlvbj59ICovXG5jb25zdCBlYXNlSW5GdW5jdGlvbnMgPSB7XG4gIFtlbXB0eVN0cmluZ106IGVhc2VJblBvd2VyLFxuICBRdWFkOiBlYXNlSW5Qb3dlcigyKSxcbiAgQ3ViaWM6IGVhc2VJblBvd2VyKDMpLFxuICBRdWFydDogZWFzZUluUG93ZXIoNCksXG4gIFF1aW50OiBlYXNlSW5Qb3dlcig1KSxcbiAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgU2luZTogdCA9PiAxIC0gY29zKHQgKiBoYWxmUEkpLFxuICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICBDaXJjOiB0ID0+IDEgLSBzcXJ0KDEgLSB0ICogdCksXG4gIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gIEV4cG86IHQgPT4gdCA/IHBvdygyLCAxMCAqIHQgLSAxMCkgOiAwLFxuICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICBCb3VuY2U6IHQgPT4ge1xuICAgIGxldCBwb3cyLCBiID0gNDtcbiAgICB3aGlsZSAodCA8ICgocG93MiA9IHBvdygyLCAtLWIpKSAtIDEpIC8gMTEpO1xuICAgIHJldHVybiAxIC8gcG93KDQsIDMgLSBiKSAtIDcuNTYyNSAqIHBvdygocG93MiAqIDMgLSAyKSAvIDIyIC0gdCwgMik7XG4gIH0sXG4gIC8qKiBAdHlwZSB7QmFja0Vhc2luZ30gKi9cbiAgQmFjazogKG92ZXJzaG9vdCA9IDEuNzAxNTgpID0+IHQgPT4gKCtvdmVyc2hvb3QgKyAxKSAqIHQgKiB0ICogdCAtICtvdmVyc2hvb3QgKiB0ICogdCxcbiAgLyoqIEB0eXBlIHtFbGFzdGljRWFzaW5nfSAqL1xuICBFbGFzdGljOiAoYW1wbGl0dWRlID0gMSwgcGVyaW9kID0gLjMpID0+IHtcbiAgICBjb25zdCBhID0gY2xhbXAoK2FtcGxpdHVkZSwgMSwgMTApO1xuICAgIGNvbnN0IHAgPSBjbGFtcCgrcGVyaW9kLCBtaW5WYWx1ZSwgMik7XG4gICAgY29uc3QgcyA9IChwIC8gZG91YmxlUEkpICogYXNpbigxIC8gYSk7XG4gICAgY29uc3QgZSA9IGRvdWJsZVBJIC8gcDtcbiAgICByZXR1cm4gdCA9PiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDogLWEgKiBwb3coMiwgLTEwICogKDEgLSB0KSkgKiBzaW4oKCgxIC0gdCkgLSBzKSAqIGUpO1xuICB9XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBFYXNlVHlwZVxuICogQHBhcmFtIHtFYXNpbmdGdW5jdGlvbn0gRWFzZVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cblxuLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBFYXNlVHlwZT59ICovXG5jb25zdCBlYXNlVHlwZXMgPSB7XG4gIGluOiBlYXNlSW4gPT4gdCA9PiBlYXNlSW4odCksXG4gIG91dDogZWFzZUluID0+IHQgPT4gMSAtIGVhc2VJbigxIC0gdCksXG4gIGluT3V0OiBlYXNlSW4gPT4gdCA9PiB0IDwgLjUgPyBlYXNlSW4odCAqIDIpIC8gMiA6IDEgLSBlYXNlSW4odCAqIC0yICsgMikgLyAyLFxuICBvdXRJbjogZWFzZUluID0+IHQgPT4gdCA8IC41ID8gKDEgLSBlYXNlSW4oMSAtIHQgKiAyKSkgLyAyIDogKGVhc2VJbih0ICogMiAtIDEpICsgMSkgLyAyLFxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtICB7UmVjb3JkPFN0cmluZywgRWFzZXNGYWN0b3J5fEVhc2luZ0Z1bmN0aW9uPn0gZWFzZXNGdW5jdGlvbnNcbiAqIEBwYXJhbSAge09iamVjdH0gZWFzZXNMb29rdXBzXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuY29uc3QgcGFyc2VFYXNlU3RyaW5nID0gKHN0cmluZywgZWFzZXNGdW5jdGlvbnMsIGVhc2VzTG9va3VwcykgPT4ge1xuICBpZiAoZWFzZXNMb29rdXBzW3N0cmluZ10pIHJldHVybiBlYXNlc0xvb2t1cHNbc3RyaW5nXTtcbiAgaWYgKHN0cmluZy5pbmRleE9mKCcoJykgPD0gLTEpIHtcbiAgICBjb25zdCBoYXNQYXJhbXMgPSBlYXNlVHlwZXNbc3RyaW5nXSB8fCBzdHJpbmcuaW5jbHVkZXMoJ0JhY2snKSB8fCBzdHJpbmcuaW5jbHVkZXMoJ0VsYXN0aWMnKTtcbiAgICBjb25zdCBwYXJzZWRGbiA9IC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovKGhhc1BhcmFtcyA/IC8qKiBAdHlwZSB7RWFzZXNGYWN0b3J5fSAqLyhlYXNlc0Z1bmN0aW9uc1tzdHJpbmddKSgpIDogZWFzZXNGdW5jdGlvbnNbc3RyaW5nXSk7XG4gICAgcmV0dXJuIHBhcnNlZEZuID8gZWFzZXNMb29rdXBzW3N0cmluZ10gPSBwYXJzZWRGbiA6IG5vbmU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3BsaXQgPSBzdHJpbmcuc2xpY2UoMCwgLTEpLnNwbGl0KCcoJyk7XG4gICAgY29uc3QgcGFyc2VkRm4gPSAvKiogQHR5cGUge0Vhc2VzRmFjdG9yeX0gKi8oZWFzZXNGdW5jdGlvbnNbc3BsaXRbMF1dKTtcbiAgICByZXR1cm4gcGFyc2VkRm4gPyBlYXNlc0xvb2t1cHNbc3RyaW5nXSA9IHBhcnNlZEZuKC4uLnNwbGl0WzFdLnNwbGl0KCcsJykpIDogbm9uZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiAge09iamVjdH0gRWFzZXNGdW5jdGlvbnNcbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGxpbmVhcn0gbGluZWFyXG4gKiBAcHJvcGVydHkge3R5cGVvZiBpcnJlZ3VsYXJ9IGlycmVndWxhclxuICogQHByb3BlcnR5IHt0eXBlb2Ygc3RlcHN9IHN0ZXBzXG4gKiBAcHJvcGVydHkge3R5cGVvZiBjdWJpY0Jlemllcn0gY3ViaWNCZXppZXJcbiAqIEBwcm9wZXJ0eSB7UG93ZXJFYXNpbmd9IGluXG4gKiBAcHJvcGVydHkge1Bvd2VyRWFzaW5nfSBvdXRcbiAqIEBwcm9wZXJ0eSB7UG93ZXJFYXNpbmd9IGluT3V0XG4gKiBAcHJvcGVydHkge1Bvd2VyRWFzaW5nfSBvdXRJblxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5RdWFkXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRRdWFkXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dFF1YWRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluUXVhZFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5DdWJpY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0Q3ViaWNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0Q3ViaWNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluQ3ViaWNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluUXVhcnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dFF1YXJ0XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dFF1YXJ0XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRJblF1YXJ0XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpblF1aW50XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRRdWludFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5PdXRRdWludFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5RdWludFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5TaW5lXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRTaW5lXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dFNpbmVcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluU2luZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5DaXJjXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRDaXJjXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dENpcmNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluQ2lyY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5FeHBvXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRFeHBvXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dEV4cG9cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluRXhwb1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5Cb3VuY2VcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEJvdW5jZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5PdXRCb3VuY2VcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluQm91bmNlXG4gKiBAcHJvcGVydHkge0JhY2tFYXNpbmd9IGluQmFja1xuICogQHByb3BlcnR5IHtCYWNrRWFzaW5nfSBvdXRCYWNrXG4gKiBAcHJvcGVydHkge0JhY2tFYXNpbmd9IGluT3V0QmFja1xuICogQHByb3BlcnR5IHtCYWNrRWFzaW5nfSBvdXRJbkJhY2tcbiAqIEBwcm9wZXJ0eSB7RWxhc3RpY0Vhc2luZ30gaW5FbGFzdGljXG4gKiBAcHJvcGVydHkge0VsYXN0aWNFYXNpbmd9IG91dEVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RWxhc3RpY0Vhc2luZ30gaW5PdXRFbGFzdGljXG4gKiBAcHJvcGVydHkge0VsYXN0aWNFYXNpbmd9IG91dEluRWxhc3RpY1xuICovXG5cbmNvbnN0IGVhc2VzID0gKC8qI19fUFVSRV9fKi8gKCgpID0+IHtcbiAgY29uc3QgbGlzdCA9IHsgbGluZWFyLCBpcnJlZ3VsYXIsIHN0ZXBzLCBjdWJpY0JlemllciB9O1xuICBmb3IgKGxldCB0eXBlIGluIGVhc2VUeXBlcykge1xuICAgIGZvciAobGV0IG5hbWUgaW4gZWFzZUluRnVuY3Rpb25zKSB7XG4gICAgICBjb25zdCBlYXNlSW4gPSBlYXNlSW5GdW5jdGlvbnNbbmFtZV07XG4gICAgICBjb25zdCBlYXNlVHlwZSA9IGVhc2VUeXBlc1t0eXBlXTtcbiAgICAgIGxpc3RbdHlwZSArIG5hbWVdID0gLyoqIEB0eXBlIHtFYXNlc0ZhY3Rvcnl8RWFzaW5nRnVuY3Rpb259ICovKFxuICAgICAgICBuYW1lID09PSBlbXB0eVN0cmluZyB8fCBuYW1lID09PSAnQmFjaycgfHwgbmFtZSA9PT0gJ0VsYXN0aWMnID9cbiAgICAgICAgKGEsIGIpID0+IGVhc2VUeXBlKC8qKiBAdHlwZSB7RWFzZXNGYWN0b3J5fSAqLyhlYXNlSW4pKGEsIGIpKSA6XG4gICAgICAgIGVhc2VUeXBlKC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovKGVhc2VJbikpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtFYXNlc0Z1bmN0aW9uc30gKi8obGlzdCk7XG59KSgpKTtcblxuLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBFYXNpbmdGdW5jdGlvbj59ICovXG5jb25zdCBKU0Vhc2VzTG9va3VwcyA9IHsgbGluZWFyOiBub25lIH07XG5cbi8qKlxuICogQHBhcmFtICB7RWFzaW5nUGFyYW19IGVhc2VcbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBwYXJzZUVhc2luZ3MgPSBlYXNlID0+IGlzRm5jKGVhc2UpID8gZWFzZSA6XG4gIGlzU3RyKGVhc2UpID8gcGFyc2VFYXNlU3RyaW5nKC8qKiBAdHlwZSB7U3RyaW5nfSAqLyhlYXNlKSwgZWFzZXMsIEpTRWFzZXNMb29rdXBzKSA6XG4gIG5vbmU7XG5cblxuXG5cbmNvbnN0IHByb3BlcnR5TmFtZXNDYWNoZSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHlOYW1lXG4gKiBAcGFyYW0gIHtUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtICB7dHdlZW5UeXBlc30gdHdlZW5UeXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHNhbml0aXplUHJvcGVydHlOYW1lID0gKHByb3BlcnR5TmFtZSwgdGFyZ2V0LCB0d2VlblR5cGUpID0+IHtcbiAgaWYgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk0pIHtcbiAgICBjb25zdCB0ID0gc2hvcnRUcmFuc2Zvcm1zLmdldChwcm9wZXJ0eU5hbWUpO1xuICAgIHJldHVybiB0ID8gdCA6IHByb3BlcnR5TmFtZTtcbiAgfSBlbHNlIGlmIChcbiAgICB0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuQ1NTIHx8XG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXMgd2hlcmUgcHJvcGVydGllcyBsaWtlIFwic3Ryb2tlRGFzaG9mZnNldFwiIG5lZWRzIHRvIGJlIHNldCBhcyBcInN0cm9rZS1kYXNob2Zmc2V0XCJcbiAgICAvLyBidXQgcHJvcGVydGllcyBsaWtlIFwiYmFzZUZyZXF1ZW5jeVwiIHNob3VsZCBzdGF5IGluIGxvd2VyQ2FtZWxDYXNlXG4gICAgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5BVFRSSUJVVEUgJiYgKGlzU3ZnKHRhcmdldCkgJiYgcHJvcGVydHlOYW1lIGluIC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLnN0eWxlKSlcbiAgKSB7XG4gICAgY29uc3QgY2FjaGVkUHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc0NhY2hlW3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKGNhY2hlZFByb3BlcnR5TmFtZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb3BlcnR5TmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IHByb3BlcnR5TmFtZSA/IHRvTG93ZXJDYXNlKHByb3BlcnR5TmFtZSkgOiBwcm9wZXJ0eU5hbWU7XG4gICAgICBwcm9wZXJ0eU5hbWVzQ2FjaGVbcHJvcGVydHlOYW1lXSA9IGxvd2VyQ2FzZU5hbWU7XG4gICAgICByZXR1cm4gbG93ZXJDYXNlTmFtZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByb3BlcnR5TmFtZTtcbiAgfVxufTtcblxuXG5cblxuY29uc3QgYW5nbGVVbml0c01hcCA9IHsgJ2RlZyc6IDEsICdyYWQnOiAxODAgLyBQSSwgJ3R1cm4nOiAzNjAgfTtcbmNvbnN0IGNvbnZlcnRlZFZhbHVlc0NhY2hlID0ge307XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSBlbFxuICogQHBhcmFtICB7VHdlZW5EZWNvbXBvc2VkVmFsdWV9IGRlY29tcG9zZWRWYWx1ZVxuICogQHBhcmFtICB7U3RyaW5nfSB1bml0XG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZm9yY2VdXG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgY29udmVydFZhbHVlVW5pdCA9IChlbCwgZGVjb21wb3NlZFZhbHVlLCB1bml0LCBmb3JjZSA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRVbml0ID0gZGVjb21wb3NlZFZhbHVlLnU7XG4gIGNvbnN0IGN1cnJlbnROdW1iZXIgPSBkZWNvbXBvc2VkVmFsdWUubjtcbiAgaWYgKGRlY29tcG9zZWRWYWx1ZS50ID09PSB2YWx1ZVR5cGVzLlVOSVQgJiYgY3VycmVudFVuaXQgPT09IHVuaXQpIHsgLy8gVE9ETzogQ2hlY2sgaWYgY2hlY2tpbmcgYWdhaW5zdCB0aGUgc2FtZSB1bml0IHN0cmluZyBpcyBuZWNlc3NhcnlcbiAgICByZXR1cm4gZGVjb21wb3NlZFZhbHVlO1xuICB9XG4gIGNvbnN0IGNhY2hlZEtleSA9IGN1cnJlbnROdW1iZXIgKyBjdXJyZW50VW5pdCArIHVuaXQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNvbnZlcnRlZFZhbHVlc0NhY2hlW2NhY2hlZEtleV07XG4gIGlmICghaXNVbmQoY2FjaGVkKSAmJiAhZm9yY2UpIHtcbiAgICBkZWNvbXBvc2VkVmFsdWUubiA9IGNhY2hlZDtcbiAgfSBlbHNlIHtcbiAgICBsZXQgY29udmVydGVkVmFsdWU7XG4gICAgaWYgKGN1cnJlbnRVbml0IGluIGFuZ2xlVW5pdHNNYXApIHtcbiAgICAgIGNvbnZlcnRlZFZhbHVlID0gY3VycmVudE51bWJlciAqIGFuZ2xlVW5pdHNNYXBbY3VycmVudFVuaXRdIC8gYW5nbGVVbml0c01hcFt1bml0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFzZWxpbmUgPSAxMDA7XG4gICAgICBjb25zdCB0ZW1wRWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oZWwuY2xvbmVOb2RlKCkpO1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBwYXJlbnRFbCA9IChwYXJlbnROb2RlICYmIChwYXJlbnROb2RlICE9PSBkb2MpKSA/IHBhcmVudE5vZGUgOiBkb2MuYm9keTtcbiAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKHRlbXBFbCk7XG4gICAgICBjb25zdCBlbFN0eWxlID0gdGVtcEVsLnN0eWxlO1xuICAgICAgZWxTdHlsZS53aWR0aCA9IGJhc2VsaW5lICsgY3VycmVudFVuaXQ7XG4gICAgICBjb25zdCBjdXJyZW50VW5pdFdpZHRoID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8odGVtcEVsKS5vZmZzZXRXaWR0aCB8fCBiYXNlbGluZTtcbiAgICAgIGVsU3R5bGUud2lkdGggPSBiYXNlbGluZSArIHVuaXQ7XG4gICAgICBjb25zdCBuZXdVbml0V2lkdGggPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyh0ZW1wRWwpLm9mZnNldFdpZHRoIHx8IGJhc2VsaW5lO1xuICAgICAgY29uc3QgZmFjdG9yID0gY3VycmVudFVuaXRXaWR0aCAvIG5ld1VuaXRXaWR0aDtcbiAgICAgIHBhcmVudEVsLnJlbW92ZUNoaWxkKHRlbXBFbCk7XG4gICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGZhY3RvciAqIGN1cnJlbnROdW1iZXI7XG4gICAgfVxuICAgIGRlY29tcG9zZWRWYWx1ZS5uID0gY29udmVydGVkVmFsdWU7XG4gICAgY29udmVydGVkVmFsdWVzQ2FjaGVbY2FjaGVkS2V5XSA9IGNvbnZlcnRlZFZhbHVlO1xuICB9XG4gIGRlY29tcG9zZWRWYWx1ZS50ID09PSB2YWx1ZVR5cGVzLlVOSVQ7XG4gIGRlY29tcG9zZWRWYWx1ZS51ID0gdW5pdDtcbiAgcmV0dXJuIGRlY29tcG9zZWRWYWx1ZTtcbn07XG5cblxuXG5cbi8qKlxuICogQHRlbXBsYXRlIHtSZW5kZXJhYmxlfSBUXG4gKiBAcGFyYW0ge1R9IHJlbmRlcmFibGVcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmNvbnN0IGNsZWFuSW5saW5lU3R5bGVzID0gcmVuZGVyYWJsZSA9PiB7XG4gIC8vIEFsbG93IGNsZWFuSW5saW5lU3R5bGVzKCkgdG8gYmUgY2FsbGVkIG9uIHRpbWVsaW5lc1xuICBpZiAocmVuZGVyYWJsZS5faGFzQ2hpbGRyZW4pIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4ocmVuZGVyYWJsZSwgY2xlYW5JbmxpbmVTdHlsZXMsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKHJlbmRlcmFibGUpO1xuICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIGZvckVhY2hDaGlsZHJlbihhbmltYXRpb24sICgvKiogQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgICBjb25zdCB0d2VlblByb3BlcnR5ID0gdHdlZW4ucHJvcGVydHk7XG4gICAgICBjb25zdCB0d2VlblRhcmdldCA9IHR3ZWVuLnRhcmdldDtcbiAgICAgIGlmICh0d2VlblRhcmdldFtpc0RvbVN5bWJvbF0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3R5bGUgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odHdlZW5UYXJnZXQpLnN0eWxlO1xuICAgICAgICBjb25zdCBvcmlnaW5hbElubGluZWRWYWx1ZSA9IGFuaW1hdGlvbi5faW5saW5lU3R5bGVzW3R3ZWVuUHJvcGVydHldO1xuICAgICAgICBpZiAodHdlZW4uX3R3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk0pIHtcbiAgICAgICAgICBjb25zdCBjYWNoZWRUcmFuc2Zvcm1zID0gdHdlZW5UYXJnZXRbdHJhbnNmb3Jtc1N5bWJvbF07XG4gICAgICAgICAgaWYgKGlzVW5kKG9yaWdpbmFsSW5saW5lZFZhbHVlKSB8fCBvcmlnaW5hbElubGluZWRWYWx1ZSA9PT0gZW1wdHlTdHJpbmcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZWRUcmFuc2Zvcm1zW3R3ZWVuUHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRUcmFuc2Zvcm1zW3R3ZWVuUHJvcGVydHldID0gb3JpZ2luYWxJbmxpbmVkVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0d2Vlbi5fcmVuZGVyVHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhjYWNoZWRUcmFuc2Zvcm1zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0U3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IHN0ciA9IGVtcHR5U3RyaW5nO1xuICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gY2FjaGVkVHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgICAgIHN0ciArPSB0cmFuc2Zvcm1zRnJhZ21lbnRTdHJpbmdzW2tleV0gKyBjYWNoZWRUcmFuc2Zvcm1zW2tleV0gKyAnKSAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldFN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzVW5kKG9yaWdpbmFsSW5saW5lZFZhbHVlKSB8fCBvcmlnaW5hbElubGluZWRWYWx1ZSA9PT0gZW1wdHlTdHJpbmcpIHtcbiAgICAgICAgICAgIHRhcmdldFN0eWxlLnJlbW92ZVByb3BlcnR5KHR3ZWVuUHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRTdHlsZVt0d2VlblByb3BlcnR5XSA9IG9yaWdpbmFsSW5saW5lZFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uLl90YWlsID09PSB0d2Vlbikge1xuICAgICAgICAgIGFuaW1hdGlvbi50YXJnZXRzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICBpZiAodC5nZXRBdHRyaWJ1dGUgJiYgdC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgPT09IGVtcHR5U3RyaW5nKSB7XG4gICAgICAgICAgICAgIHQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgfSAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZW5kZXJhYmxlO1xufTtcblxuLy8gRGVmaW5lcyBkZWNvbXBvc2VkIHZhbHVlcyB0YXJnZXQgb2JqZWN0cyBvbmx5IG9uY2UgYW5kIG11dGF0ZSB0aGVpciBwcm9wZXJ0aWVzIGxhdGVyIHRvIGF2b2lkIEdDXG4vLyBUT0RPOiBNYXliZSBtb3ZlIHRoZSBvYmplY3RzIGNyZWF0aW9uIHRvIHZhbHVlcy5qcyBhbmQgdXNlIHRoZSBkZWNvbXBvc2UgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBiYXNlIG9iamVjdFxuY29uc3QgZnJvbVRhcmdldE9iamVjdCA9IGNyZWF0ZURlY29tcG9zZWRWYWx1ZVRhcmdldE9iamVjdCgpO1xuY29uc3QgdG9UYXJnZXRPYmplY3QgPSBjcmVhdGVEZWNvbXBvc2VkVmFsdWVUYXJnZXRPYmplY3QoKTtcbmNvbnN0IHRvRnVuY3Rpb25TdG9yZSA9IHsgZnVuYzogbnVsbCB9O1xuY29uc3Qga2V5ZnJhbWVzVGFyZ2V0QXJyYXkgPSBbbnVsbF07XG5jb25zdCBmYXN0U2V0VmFsdWVzQXJyYXkgPSBbbnVsbCwgbnVsbF07XG4vKiogQHR5cGUge1R3ZWVuS2V5VmFsdWV9ICovXG5jb25zdCBrZXlPYmplY3RUYXJnZXQgPSB7IHRvOiBudWxsIH07XG5cbmxldCB0d2VlbklkID0gMDtcbmxldCBrZXlmcmFtZXM7XG4vKiogQHR5cGUge1R3ZWVuUGFyYW1zT3B0aW9ucyAmIFR3ZWVuVmFsdWVzfSAqL1xubGV0IGtleTtcblxuLyoqXG4gKiBAcGFyYW0ge0R1cmF0aW9uS2V5ZnJhbWVzIHwgUGVyY2VudGFnZUtleWZyYW1lc30ga2V5ZnJhbWVzXG4gKiBAcGFyYW0ge0FuaW1hdGlvblBhcmFtc30gcGFyYW1ldGVyc1xuICogQHJldHVybiB7QW5pbWF0aW9uUGFyYW1zfVxuICovXG5jb25zdCBnZW5lcmF0ZUtleWZyYW1lcyA9IChrZXlmcmFtZXMsIHBhcmFtZXRlcnMpID0+IHtcbiAgLyoqIEB0eXBlIHtBbmltYXRpb25QYXJhbXN9ICovXG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgaWYgKGlzQXJyKGtleWZyYW1lcykpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gW10uY29uY2F0KC4uLi8qKiBAdHlwZSB7RHVyYXRpb25LZXlmcmFtZXN9ICovKGtleWZyYW1lcykubWFwKGtleSA9PiBPYmplY3Qua2V5cyhrZXkpKSkuZmlsdGVyKGlzS2V5KTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9wTmFtZSA9IHByb3BlcnR5TmFtZXNbaV07XG4gICAgICBjb25zdCBwcm9wQXJyYXkgPSAvKiogQHR5cGUge0R1cmF0aW9uS2V5ZnJhbWVzfSAqLyhrZXlmcmFtZXMpLm1hcChrZXkgPT4ge1xuICAgICAgICAvKiogQHR5cGUge1R3ZWVuS2V5VmFsdWV9ICovXG4gICAgICAgIGNvbnN0IG5ld0tleSA9IHt9O1xuICAgICAgICBmb3IgKGxldCBwIGluIGtleSkge1xuICAgICAgICAgIGNvbnN0IGtleVZhbHVlID0gLyoqIEB0eXBlIHtUd2VlblByb3BWYWx1ZX0gKi8oa2V5W3BdKTtcbiAgICAgICAgICBpZiAoaXNLZXkocCkpIHtcbiAgICAgICAgICAgIGlmIChwID09PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICBuZXdLZXkudG8gPSBrZXlWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3S2V5W3BdID0ga2V5VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgICB9KTtcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gLyoqIEB0eXBlIHtBcnJheVN5bnRheFZhbHVlfSAqLyhwcm9wQXJyYXkpO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSAvKiogQHR5cGUge051bWJlcn0gKi8oc2V0VmFsdWUocGFyYW1ldGVycy5kdXJhdGlvbiwgZ2xvYmFscy5kZWZhdWx0cy5kdXJhdGlvbikpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhrZXlmcmFtZXMpXG4gICAgLm1hcChrZXkgPT4geyByZXR1cm4ge286IHBhcnNlRmxvYXQoa2V5KSAvIDEwMCwgcDoga2V5ZnJhbWVzW2tleV19IH0pXG4gICAgLnNvcnQoKGEsIGIpID0+IGEubyAtIGIubyk7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBrZXkubztcbiAgICAgIGNvbnN0IHByb3AgPSBrZXkucDtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJvcCkge1xuICAgICAgICBpZiAoaXNLZXkobmFtZSkpIHtcbiAgICAgICAgICBsZXQgcHJvcEFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8ocHJvcGVydGllc1tuYW1lXSk7XG4gICAgICAgICAgaWYgKCFwcm9wQXJyYXkpIHByb3BBcnJheSA9IHByb3BlcnRpZXNbbmFtZV0gPSBbXTtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IG9mZnNldCAqIHRvdGFsRHVyYXRpb247XG4gICAgICAgICAgbGV0IGxlbmd0aCA9IHByb3BBcnJheS5sZW5ndGg7XG4gICAgICAgICAgbGV0IHByZXZLZXkgPSBwcm9wQXJyYXlbbGVuZ3RoIC0gMV07XG4gICAgICAgICAgY29uc3Qga2V5T2JqID0geyB0bzogcHJvcFtuYW1lXSB9O1xuICAgICAgICAgIGxldCBkdXJQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZHVyUHJvZ3Jlc3MgKz0gcHJvcEFycmF5W2ldLmR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBrZXlPYmouZnJvbSA9IHByZXZLZXkudG87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wLmVhc2UpIHtcbiAgICAgICAgICAgIGtleU9iai5lYXNlID0gcHJvcC5lYXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlPYmouZHVyYXRpb24gPSBkdXJhdGlvbiAtIChsZW5ndGggPyBkdXJQcm9ncmVzcyA6IDApO1xuICAgICAgICAgIHByb3BBcnJheS5wdXNoKGtleU9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBuYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGNvbnN0IHByb3BBcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKHByb3BlcnRpZXNbbmFtZV0pO1xuICAgICAgbGV0IHByZXZFYXNlO1xuICAgICAgLy8gbGV0IGR1clByb2dyZXNzID0gMFxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wQXJyYXlbaV07XG4gICAgICAgIC8vIEVtdWxhdGUgV0FQUEkgZWFzaW5nIHBhcmFtZXRlciBwb3NpdGlvblxuICAgICAgICBjb25zdCBjdXJyZW50RWFzZSA9IHByb3AuZWFzZTtcbiAgICAgICAgcHJvcC5lYXNlID0gcHJldkVhc2UgPyBwcmV2RWFzZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcHJldkVhc2UgPSBjdXJyZW50RWFzZTtcbiAgICAgICAgLy8gZHVyUHJvZ3Jlc3MgKz0gcHJvcC5kdXJhdGlvbjtcbiAgICAgICAgLy8gaWYgKGkgPT09IGwgLSAxICYmIGR1clByb2dyZXNzICE9PSB0b3RhbER1cmF0aW9uKSB7XG4gICAgICAgIC8vICAgcHJvcEFycmF5LnB1c2goeyBmcm9tOiBwcm9wLnRvLCBlYXNlOiBwcm9wLmVhc2UsIGR1cmF0aW9uOiB0b3RhbER1cmF0aW9uIC0gZHVyUHJvZ3Jlc3MgfSlcbiAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9wQXJyYXlbMF0uZHVyYXRpb24pIHtcbiAgICAgICAgcHJvcEFycmF5LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gcHJvcGVydGllcztcbn07XG5cbmNsYXNzIEpTQW5pbWF0aW9uIGV4dGVuZHMgVGltZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAgICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtUaW1lbGluZX0gW3BhcmVudF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJlbnRQb3NpdGlvbl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZmFzdFNldD1mYWxzZV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleD0wXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aD0wXVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgdGFyZ2V0cyxcbiAgICBwYXJhbWV0ZXJzLFxuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQb3NpdGlvbixcbiAgICBmYXN0U2V0ID0gZmFsc2UsXG4gICAgaW5kZXggPSAwLFxuICAgIGxlbmd0aCA9IDBcbiAgKSB7XG5cbiAgICBzdXBlcigvKiogQHR5cGUge1RpbWVyUGFyYW1zJkFuaW1hdGlvblBhcmFtc30gKi8ocGFyYW1ldGVycyksIHBhcmVudCwgcGFyZW50UG9zaXRpb24pO1xuXG4gICAgY29uc3QgcGFyc2VkVGFyZ2V0cyA9IHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICBjb25zdCB0YXJnZXRzTGVuZ3RoID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICAvLyBJZiB0aGUgcGFyYW1ldGVycyBvYmplY3QgY29udGFpbnMgYSBcImtleWZyYW1lc1wiIHByb3BlcnR5LCBjb252ZXJ0IGFsbCB0aGUga2V5ZnJhbWVzIHZhbHVlcyB0byByZWd1bGFyIHByb3BlcnRpZXNcblxuICAgIGNvbnN0IGtmUGFyYW1zID0gLyoqIEB0eXBlIHtBbmltYXRpb25QYXJhbXN9ICovKHBhcmFtZXRlcnMpLmtleWZyYW1lcztcbiAgICBjb25zdCBwYXJhbXMgPSAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi8oa2ZQYXJhbXMgPyBtZXJnZU9iamVjdHMoZ2VuZXJhdGVLZXlmcmFtZXMoLyoqIEB0eXBlIHtEdXJhdGlvbktleWZyYW1lc30gKi8oa2ZQYXJhbXMpLCBwYXJhbWV0ZXJzKSwgcGFyYW1ldGVycykgOiBwYXJhbWV0ZXJzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGRlbGF5LFxuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNlLFxuICAgICAgcGxheWJhY2tFYXNlLFxuICAgICAgbW9kaWZpZXIsXG4gICAgICBjb21wb3NpdGlvbixcbiAgICAgIG9uUmVuZGVyLFxuICAgIH0gPSBwYXJhbXM7XG5cbiAgICBjb25zdCBhbmltRGVmYXVsdHMgPSBwYXJlbnQgPyBwYXJlbnQuZGVmYXVsdHMgOiBnbG9iYWxzLmRlZmF1bHRzO1xuICAgIGNvbnN0IGFuaW1hUGxheWJhY2tFYXNlID0gc2V0VmFsdWUocGxheWJhY2tFYXNlLCBhbmltRGVmYXVsdHMucGxheWJhY2tFYXNlKTtcbiAgICBjb25zdCBhbmltRWFzZSA9IGFuaW1hUGxheWJhY2tFYXNlID8gcGFyc2VFYXNpbmdzKGFuaW1hUGxheWJhY2tFYXNlKSA6IG51bGw7XG4gICAgY29uc3QgaGFzU3ByaW5nID0gIWlzVW5kKGVhc2UpICYmICFpc1VuZCgvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSk7XG4gICAgY29uc3QgdEVhc2luZyA9IGhhc1NwcmluZyA/IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlIDogc2V0VmFsdWUoZWFzZSwgYW5pbUVhc2UgPyAnbGluZWFyJyA6IGFuaW1EZWZhdWx0cy5lYXNlKTtcbiAgICBjb25zdCB0RHVyYXRpb24gPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZHVyYXRpb24gOiBzZXRWYWx1ZShkdXJhdGlvbiwgYW5pbURlZmF1bHRzLmR1cmF0aW9uKTtcbiAgICBjb25zdCB0RGVsYXkgPSBzZXRWYWx1ZShkZWxheSwgYW5pbURlZmF1bHRzLmRlbGF5KTtcbiAgICBjb25zdCB0TW9kaWZpZXIgPSBtb2RpZmllciB8fCBhbmltRGVmYXVsdHMubW9kaWZpZXI7XG4gICAgLy8gSWYgbm8gY29tcG9zaXRpb24gaXMgZGVmaW5lZCBhbmQgdGhlIHRhcmdldHMgbGVuZ3RoIGlzIGhpZ2ggKD49IDEwMDApIHNldCB0aGUgY29tcG9zaXRpb24gdG8gJ25vbmUnICgwKSBmb3IgZmFzdGVyIHR3ZWVuIGNyZWF0aW9uXG4gICAgY29uc3QgdENvbXBvc2l0aW9uID0gaXNVbmQoY29tcG9zaXRpb24pICYmIHRhcmdldHNMZW5ndGggPj0gSyA/IGNvbXBvc2l0aW9uVHlwZXMubm9uZSA6ICFpc1VuZChjb21wb3NpdGlvbikgPyBjb21wb3NpdGlvbiA6IGFuaW1EZWZhdWx0cy5jb21wb3NpdGlvbjtcbiAgICAvLyBUT0RPOiBEbyBub3QgY3JlYXRlIGFuIGVtcHR5IG9iamVjdCB1bnRpbCB3ZSBrbm93IHRoZSBhbmltYXRpb24gd2lsbCBnZW5lcmF0ZSBpbmxpbmUgc3R5bGVzXG4gICAgY29uc3QgYW5pbUlubGluZVN0eWxlcyA9IHt9O1xuICAgIC8vIGNvbnN0IGFic29sdXRlT2Zmc2V0VGltZSA9IHRoaXMuX29mZnNldDtcbiAgICBjb25zdCBhYnNvbHV0ZU9mZnNldFRpbWUgPSB0aGlzLl9vZmZzZXQgKyAocGFyZW50ID8gcGFyZW50Ll9vZmZzZXQgOiAwKTtcblxuICAgIGxldCBpdGVyYXRpb25EdXJhdGlvbiA9IE5hTjtcbiAgICBsZXQgaXRlcmF0aW9uRGVsYXkgPSBOYU47XG4gICAgbGV0IGFuaW1hdGlvbkFuaW1hdGlvbkxlbmd0aCA9IDA7XG4gICAgbGV0IHNob3VsZFRyaWdnZXJSZW5kZXIgPSAwO1xuXG4gICAgZm9yIChsZXQgdGFyZ2V0SW5kZXggPSAwOyB0YXJnZXRJbmRleCA8IHRhcmdldHNMZW5ndGg7IHRhcmdldEluZGV4KyspIHtcblxuICAgICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VkVGFyZ2V0c1t0YXJnZXRJbmRleF07XG4gICAgICBjb25zdCB0aSA9IGluZGV4IHx8IHRhcmdldEluZGV4O1xuICAgICAgY29uc3QgdGwgPSBsZW5ndGggfHwgdGFyZ2V0c0xlbmd0aDtcblxuICAgICAgbGV0IGxhc3RUcmFuc2Zvcm1Hcm91cEluZGV4ID0gTmFOO1xuICAgICAgbGV0IGxhc3RUcmFuc2Zvcm1Hcm91cExlbmd0aCA9IE5hTjtcblxuICAgICAgZm9yIChsZXQgcCBpbiBwYXJhbXMpIHtcblxuICAgICAgICBpZiAoaXNLZXkocCkpIHtcblxuICAgICAgICAgIGNvbnN0IHR3ZWVuVHlwZSA9IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHApO1xuXG4gICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBzYW5pdGl6ZVByb3BlcnR5TmFtZShwLCB0YXJnZXQsIHR3ZWVuVHlwZSk7XG5cbiAgICAgICAgICBsZXQgcHJvcFZhbHVlID0gcGFyYW1zW3BdO1xuXG4gICAgICAgICAgY29uc3QgaXNQcm9wVmFsdWVBcnJheSA9IGlzQXJyKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgICBpZiAoZmFzdFNldCAmJiAhaXNQcm9wVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgZmFzdFNldFZhbHVlc0FycmF5WzBdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgZmFzdFNldFZhbHVlc0FycmF5WzFdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgcHJvcFZhbHVlID0gZmFzdFNldFZhbHVlc0FycmF5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE86IEFsbG93IG5lc3RlZCBrZXlmcmFtZXMgaW5zaWRlIE9iamVjdFZhbHVlIHZhbHVlIChwcm9wOiB7IHRvOiBbLjUsIDEsIC43NSwgMiwgM10gfSlcbiAgICAgICAgICAvLyBOb3JtYWxpemUgcHJvcGVydHkgdmFsdWVzIHRvIHZhbGlkIGtleWZyYW1lIHN5bnRheDpcbiAgICAgICAgICAvLyBbeCwgeV0gdG8gW3t0bzogW3gsIHldfV0gb3Ige3RvOiB4fSB0byBbe3RvOiB4fV0gb3Iga2VlcCBrZXlzIHN5bnRheCBbe30sIHt9LCB7fS4uLl1cbiAgICAgICAgICAvLyBjb25zdCBrZXlmcmFtZXMgPSBpc0Fycihwcm9wVmFsdWUpID8gcHJvcFZhbHVlLmxlbmd0aCA9PT0gMiAmJiAhaXNPYmoocHJvcFZhbHVlWzBdKSA/IFt7IHRvOiBwcm9wVmFsdWUgfV0gOiBwcm9wVmFsdWUgOiBbcHJvcFZhbHVlXTtcbiAgICAgICAgICBpZiAoaXNQcm9wVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSAvKiogQHR5cGUge0FycmF5fSAqLyhwcm9wVmFsdWUpLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGlzTm90T2JqZWN0VmFsdWUgPSAhaXNPYmoocHJvcFZhbHVlWzBdKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgW3gsIHldIHRvIFt7dG86IFt4LCB5XX1dXG4gICAgICAgICAgICBpZiAoYXJyYXlMZW5ndGggPT09IDIgJiYgaXNOb3RPYmplY3RWYWx1ZSkge1xuICAgICAgICAgICAgICBrZXlPYmplY3RUYXJnZXQudG8gPSAvKiogQHR5cGUge1R3ZWVuUGFyYW1WYWx1ZX0gKi8oLyoqIEB0eXBlIHt1bmtub3dufSAqLyhwcm9wVmFsdWUpKTtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzVGFyZ2V0QXJyYXlbMF0gPSBrZXlPYmplY3RUYXJnZXQ7XG4gICAgICAgICAgICAgIGtleWZyYW1lcyA9IGtleWZyYW1lc1RhcmdldEFycmF5O1xuICAgICAgICAgICAgLy8gQ29udmVydCBbeCwgeSwgel0gdG8gW1t4LCB5XSwgel1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyYXlMZW5ndGggPiAyICYmIGlzTm90T2JqZWN0VmFsdWUpIHtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzID0gW107XG4gICAgICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPE51bWJlcj59ICovKHByb3BWYWx1ZSkuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgICAgZmFzdFNldFZhbHVlc0FycmF5WzBdID0gdjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGZhc3RTZXRWYWx1ZXNBcnJheVsxXSA9IHY7XG4gICAgICAgICAgICAgICAgICBrZXlmcmFtZXMucHVzaChmYXN0U2V0VmFsdWVzQXJyYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBrZXlmcmFtZXMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzID0gLyoqIEB0eXBlIHtBcnJheS48VHdlZW5LZXlWYWx1ZT59ICovKHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleWZyYW1lc1RhcmdldEFycmF5WzBdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAga2V5ZnJhbWVzID0ga2V5ZnJhbWVzVGFyZ2V0QXJyYXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHNpYmxpbmdzID0gbnVsbDtcbiAgICAgICAgICBsZXQgcHJldlR3ZWVuID0gbnVsbDtcbiAgICAgICAgICBsZXQgZmlyc3RUd2VlbkNoYW5nZVN0YXJ0VGltZSA9IE5hTjtcbiAgICAgICAgICBsZXQgbGFzdFR3ZWVuQ2hhbmdlRW5kVGltZSA9IDA7XG4gICAgICAgICAgbGV0IHR3ZWVuSW5kZXggPSAwO1xuXG4gICAgICAgICAgZm9yIChsZXQgbCA9IGtleWZyYW1lcy5sZW5ndGg7IHR3ZWVuSW5kZXggPCBsOyB0d2VlbkluZGV4KyspIHtcblxuICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBrZXlmcmFtZXNbdHdlZW5JbmRleF07XG5cbiAgICAgICAgICAgIGlmIChpc09iaihrZXlmcmFtZSkpIHtcbiAgICAgICAgICAgICAga2V5ID0ga2V5ZnJhbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBrZXlPYmplY3RUYXJnZXQudG8gPSAvKiogQHR5cGUge1R3ZWVuUGFyYW1WYWx1ZX0gKi8oa2V5ZnJhbWUpO1xuICAgICAgICAgICAgICBrZXkgPSBrZXlPYmplY3RUYXJnZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvRnVuY3Rpb25TdG9yZS5mdW5jID0gbnVsbDtcblxuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRUb1ZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZShrZXkudG8sIHRhcmdldCwgdGksIHRsLCB0b0Z1bmN0aW9uU3RvcmUpO1xuXG4gICAgICAgICAgICBsZXQgdHdlZW5Ub1ZhbHVlO1xuICAgICAgICAgICAgLy8gQWxsb3dzIGZ1bmN0aW9uIGJhc2VkIHZhbHVlcyB0byByZXR1cm4gYW4gb2JqZWN0IHN5bnRheCB2YWx1ZSAoe3RvOiB2fSlcbiAgICAgICAgICAgIGlmIChpc09iaihjb21wdXRlZFRvVmFsdWUpICYmICFpc1VuZChjb21wdXRlZFRvVmFsdWUudG8pKSB7XG4gICAgICAgICAgICAgIGtleSA9IGNvbXB1dGVkVG9WYWx1ZTtcbiAgICAgICAgICAgICAgdHdlZW5Ub1ZhbHVlID0gY29tcHV0ZWRUb1ZhbHVlLnRvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW5Ub1ZhbHVlID0gY29tcHV0ZWRUb1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHdlZW5Gcm9tVmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKGtleS5mcm9tLCB0YXJnZXQsIHRpLCB0bCk7XG4gICAgICAgICAgICBjb25zdCBrZXlFYXNpbmcgPSBrZXkuZWFzZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1NwcmluZyA9ICFpc1VuZChrZXlFYXNpbmcpICYmICFpc1VuZCgvKiogQHR5cGUge1NwcmluZ30gKi8oa2V5RWFzaW5nKS5lYXNlKTtcbiAgICAgICAgICAgIC8vIEVhc2luZyBhcmUgdHJlYXRlZCBkaWZmZXJlbnRseSBhbmQgZG9uJ3QgYWNjZXB0IGZ1bmN0aW9uIGJhc2VkIHZhbHVlIHRvIHByZXZlbnQgaGF2aW5nIHRvIHBhc3MgYSBmdW5jdGlvbiB3cmFwcGVyIHRoYXQgcmV0dXJucyBhbiBvdGhlciBmdW5jdGlvbiBhbGwgdGhlIHRpbWVcbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuRWFzaW5nID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGtleUVhc2luZykuZWFzZSA6IGtleUVhc2luZyB8fCB0RWFzaW5nO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGRlZmF1bHQgaW5kaXZpZHVhbCBrZXlmcmFtZSBkdXJhdGlvbiBieSBkaXZpZGluZyB0aGUgdGwgb2Yga2V5ZnJhbWVzXG4gICAgICAgICAgICBjb25zdCB0d2VlbkR1cmF0aW9uID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGtleUVhc2luZykuZHVyYXRpb24gOiBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKGtleS5kdXJhdGlvbiwgKGwgPiAxID8gZ2V0RnVuY3Rpb25WYWx1ZSh0RHVyYXRpb24sIHRhcmdldCwgdGksIHRsKSAvIGwgOiB0RHVyYXRpb24pKSwgdGFyZ2V0LCB0aSwgdGwpO1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBkZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBmaXJzdCB0d2VlblxuICAgICAgICAgICAgY29uc3QgdHdlZW5EZWxheSA9IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUoa2V5LmRlbGF5LCAoIXR3ZWVuSW5kZXggPyB0RGVsYXkgOiAwKSksIHRhcmdldCwgdGksIHRsKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkQ29tcG9zaXRpb24gPSBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKGtleS5jb21wb3NpdGlvbiwgdENvbXBvc2l0aW9uKSwgdGFyZ2V0LCB0aSwgdGwpO1xuICAgICAgICAgICAgY29uc3QgdHdlZW5Db21wb3NpdGlvbiA9IGlzTnVtKGNvbXB1dGVkQ29tcG9zaXRpb24pID8gY29tcHV0ZWRDb21wb3NpdGlvbiA6IGNvbXBvc2l0aW9uVHlwZXNbY29tcHV0ZWRDb21wb3NpdGlvbl07XG4gICAgICAgICAgICAvLyBNb2RpZmllcnMgYXJlIHRyZWF0ZWQgZGlmZmVyZW50bHkgYW5kIGRvbid0IGFjY2VwdCBmdW5jdGlvbiBiYXNlZCB2YWx1ZSB0byBwcmV2ZW50IGhhdmluZyB0byBwYXNzIGEgZnVuY3Rpb24gd3JhcHBlclxuICAgICAgICAgICAgY29uc3QgdHdlZW5Nb2RpZmllciA9IGtleS5tb2RpZmllciB8fCB0TW9kaWZpZXI7XG4gICAgICAgICAgICBjb25zdCBoYXNGcm9tdmFsdWUgPSAhaXNVbmQodHdlZW5Gcm9tVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgaGFzVG9WYWx1ZSA9ICFpc1VuZCh0d2VlblRvVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgaXNGcm9tVG9BcnJheSA9IGlzQXJyKHR3ZWVuVG9WYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBpc0Zyb21Ub1ZhbHVlID0gaXNGcm9tVG9BcnJheSB8fCAoaGFzRnJvbXZhbHVlICYmIGhhc1RvVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdHdlZW5TdGFydFRpbWUgPSBwcmV2VHdlZW4gPyBsYXN0VHdlZW5DaGFuZ2VFbmRUaW1lICsgdHdlZW5EZWxheSA6IHR3ZWVuRGVsYXk7XG4gICAgICAgICAgICAvLyBSb3VuZGluZyBpcyBuZWNlc3NhcnkgaGVyZSB0byBtaW5pbWl6ZSBmbG9hdGluZyBwb2ludCBlcnJvcnMgd2hlbiB3b3JraW5nIGluIHNlY29uZHNcbiAgICAgICAgICAgIGNvbnN0IGFic29sdXRlU3RhcnRUaW1lID0gcm91bmQoYWJzb2x1dGVPZmZzZXRUaW1lICsgdHdlZW5TdGFydFRpbWUsIDEyKTtcblxuICAgICAgICAgICAgLy8gRm9yY2UgYSBvblJlbmRlciBjYWxsYmFjayBpZiB0aGUgYW5pbWF0aW9uIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBmcm9tIHZhbHVlIGFuZCBhdXRvcGxheSBpcyBzZXQgdG8gZmFsc2VcbiAgICAgICAgICAgIGlmICghc2hvdWxkVHJpZ2dlclJlbmRlciAmJiAoaGFzRnJvbXZhbHVlIHx8IGlzRnJvbVRvQXJyYXkpKSBzaG91bGRUcmlnZ2VyUmVuZGVyID0gMTtcblxuICAgICAgICAgICAgbGV0IHByZXZTaWJsaW5nID0gcHJldlR3ZWVuO1xuXG4gICAgICAgICAgICBpZiAodHdlZW5Db21wb3NpdGlvbiAhPT0gY29tcG9zaXRpb25UeXBlcy5ub25lKSB7XG4gICAgICAgICAgICAgIGlmICghc2libGluZ3MpIHNpYmxpbmdzID0gZ2V0VHdlZW5TaWJsaW5ncyh0YXJnZXQsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gc2libGluZ3MuX2hlYWQ7XG4gICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdHJvdWdoIGFsbCB0aGUgbmV4dCBzaWJsaW5ncyB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyB3aXRoIGFuIGVxdWFsIG9yIGluZmVyaW9yIHN0YXJ0IHRpbWVcbiAgICAgICAgICAgICAgd2hpbGUgKG5leHRTaWJsaW5nICYmICFuZXh0U2libGluZy5faXNPdmVycmlkZGVuICYmIG5leHRTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSA8PSBhYnNvbHV0ZVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5fbmV4dFJlcDtcbiAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgYWxsIHRoZSBuZXh0IHNpYmxpbmdzIGlmIHRoZSBuZXh0IHNpYmxpbmcgc3RhcnRzIGF0IHRoZSBzYW1lIHRpbWUgb2YgYWZ0ZXIgYXMgdGhlIG5ldyB0d2VlbiBzdGFydCB0aW1lXG4gICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSA+PSBhYnNvbHV0ZVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlVHdlZW4obmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgZW5kcyBib3RoIHRoZSBjdXJyZW50IHdoaWxlIGxvb3AgYW5kIHRoZSB1cHBlciBvbmUgb25jZSBhbGwgdGhlIG5leHQgc2libGxpbmdzIGhhdmUgYmVlbiBvdmVycmlkZW5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5fbmV4dFJlcDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVjb21wb3NlIHZhbHVlc1xuICAgICAgICAgICAgaWYgKGlzRnJvbVRvVmFsdWUpIHtcbiAgICAgICAgICAgICAgZGVjb21wb3NlUmF3VmFsdWUoaXNGcm9tVG9BcnJheSA/IGdldEZ1bmN0aW9uVmFsdWUodHdlZW5Ub1ZhbHVlWzBdLCB0YXJnZXQsIHRpLCB0bCkgOiB0d2VlbkZyb21WYWx1ZSwgZnJvbVRhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKGlzRnJvbVRvQXJyYXkgPyBnZXRGdW5jdGlvblZhbHVlKHR3ZWVuVG9WYWx1ZVsxXSwgdGFyZ2V0LCB0aSwgdGwsIHRvRnVuY3Rpb25TdG9yZSkgOiB0d2VlblRvVmFsdWUsIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgaWYgKGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmV2U2libGluZy5fdmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLlVOSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5VTklUO1xuICAgICAgICAgICAgICAgICAgICBmcm9tVGFyZ2V0T2JqZWN0LnUgPSBwcmV2U2libGluZy5fdW5pdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGVjb21wb3NlUmF3VmFsdWUoXG4gICAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbUlubGluZVN0eWxlcyksXG4gICAgICAgICAgICAgICAgICAgIGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tVGFyZ2V0T2JqZWN0LnQgPSB2YWx1ZVR5cGVzLlVOSVQ7XG4gICAgICAgICAgICAgICAgICAgIGZyb21UYXJnZXRPYmplY3QudSA9IGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaGFzVG9WYWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKHR3ZWVuVG9WYWx1ZSwgdG9UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2VHdlZW4pIHtcbiAgICAgICAgICAgICAgICAgIGRlY29tcG9zZVR3ZWVuVmFsdWUocHJldlR3ZWVuLCB0b1RhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZ2V0IGFuZCBwYXJzZSB0aGUgb3JpZ2luYWwgdmFsdWUgaWYgdGhlIHR3ZWVuIGlzIHBhcnQgb2YgYSB0aW1lbGluZSBhbmQgaGFzIGEgcHJldmlvdXMgc2libGluZyBwYXJ0IG9mIHRoZSBzYW1lIHRpbWVsaW5lXG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZShwYXJlbnQgJiYgcHJldlNpYmxpbmcgJiYgcHJldlNpYmxpbmcucGFyZW50LnBhcmVudCA9PT0gcGFyZW50ID8gcHJldlNpYmxpbmcuX3ZhbHVlIDpcbiAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbUlubGluZVN0eWxlcyksIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGhhc0Zyb212YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKHR3ZWVuRnJvbVZhbHVlLCBmcm9tVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlR3ZWVuKSB7XG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VUd2VlblZhbHVlKHByZXZUd2VlbiwgZnJvbVRhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKHBhcmVudCAmJiBwcmV2U2libGluZyAmJiBwcmV2U2libGluZy5wYXJlbnQucGFyZW50ID09PSBwYXJlbnQgPyBwcmV2U2libGluZy5fdmFsdWUgOlxuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBnZXQgYW5kIHBhcnNlIHRoZSBvcmlnaW5hbCB2YWx1ZSBpZiB0aGUgdHdlZW4gaXMgcGFydCBvZiBhIHRpbWVsaW5lIGFuZCBoYXMgYSBwcmV2aW91cyBzaWJsaW5nIHBhcnQgb2YgdGhlIHNhbWUgdGltZWxpbmVcbiAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbUlubGluZVN0eWxlcyksIGZyb21UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBvcGVyYXRvcnNcbiAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0Lm8pIHtcbiAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC5uID0gZ2V0UmVsYXRpdmVWYWx1ZShcbiAgICAgICAgICAgICAgICAhcHJldlNpYmxpbmcgPyBkZWNvbXBvc2VSYXdWYWx1ZShcbiAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbUlubGluZVN0eWxlcyksXG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZVxuICAgICAgICAgICAgICAgICkubiA6IHByZXZTaWJsaW5nLl90b051bWJlcixcbiAgICAgICAgICAgICAgICBmcm9tVGFyZ2V0T2JqZWN0Lm4sXG4gICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC5vXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b1RhcmdldE9iamVjdC5vKSB7XG4gICAgICAgICAgICAgIHRvVGFyZ2V0T2JqZWN0Lm4gPSBnZXRSZWxhdGl2ZVZhbHVlKGZyb21UYXJnZXRPYmplY3QubiwgdG9UYXJnZXRPYmplY3QubiwgdG9UYXJnZXRPYmplY3Qubyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZhbHVlcyBvbW9nZW5pc2F0aW9uIGluIGNhc2VzIG9mIHR5cGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFwiZnJvbVwiIGFuZCBcInRvXCJcbiAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnQgIT09IHRvVGFyZ2V0T2JqZWN0LnQpIHtcbiAgICAgICAgICAgICAgaWYgKGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT01QTEVYIHx8IHRvVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09NUExFWCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXhWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT01QTEVYID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdENvbXBsZXhWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT01QTEVYID8gdG9UYXJnZXRPYmplY3QgOiBmcm9tVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIG5vdENvbXBsZXhWYWx1ZS50ID0gdmFsdWVUeXBlcy5DT01QTEVYO1xuICAgICAgICAgICAgICAgIG5vdENvbXBsZXhWYWx1ZS5zID0gY2xvbmVBcnJheShjb21wbGV4VmFsdWUucyk7XG4gICAgICAgICAgICAgICAgbm90Q29tcGxleFZhbHVlLmQgPSBjb21wbGV4VmFsdWUuZC5tYXAoKCkgPT4gbm90Q29tcGxleFZhbHVlLm4pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5VTklUIHx8IHRvVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuVU5JVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuaXRWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5VTklUID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdFVuaXRWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5VTklUID8gdG9UYXJnZXRPYmplY3QgOiBmcm9tVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIG5vdFVuaXRWYWx1ZS50ID0gdmFsdWVUeXBlcy5VTklUO1xuICAgICAgICAgICAgICAgIG5vdFVuaXRWYWx1ZS51ID0gdW5pdFZhbHVlLnU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbVRhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTE9SIHx8IHRvVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09MT1IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvclZhbHVlID0gZnJvbVRhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTE9SID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdENvbG9yVmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09MT1IgPyB0b1RhcmdldE9iamVjdCA6IGZyb21UYXJnZXRPYmplY3Q7XG4gICAgICAgICAgICAgICAgbm90Q29sb3JWYWx1ZS50ID0gdmFsdWVUeXBlcy5DT0xPUjtcbiAgICAgICAgICAgICAgICBub3RDb2xvclZhbHVlLnMgPSBjb2xvclZhbHVlLnM7XG4gICAgICAgICAgICAgICAgbm90Q29sb3JWYWx1ZS5kID0gWzAsIDAsIDAsIDFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVuaXQgY29udmVyc2lvblxuICAgICAgICAgICAgaWYgKGZyb21UYXJnZXRPYmplY3QudSAhPT0gdG9UYXJnZXRPYmplY3QudSkge1xuICAgICAgICAgICAgICBsZXQgdmFsdWVUb0NvbnZlcnQgPSB0b1RhcmdldE9iamVjdC51ID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICB2YWx1ZVRvQ29udmVydCA9IGNvbnZlcnRWYWx1ZVVuaXQoLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCksIHZhbHVlVG9Db252ZXJ0LCB0b1RhcmdldE9iamVjdC51ID8gdG9UYXJnZXRPYmplY3QudSA6IGZyb21UYXJnZXRPYmplY3QudSwgZmFsc2UpO1xuICAgICAgICAgICAgICAvLyBUT0RPOlxuICAgICAgICAgICAgICAvLyBjb252ZXJ0VmFsdWVVbml0KHRhcmdldCwgdG8udSA/IGZyb20gOiB0bywgdG8udSA/IHRvLnUgOiBmcm9tLnUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIGluIG5vbiBleGlzdGluZyBjb21wbGV4IHZhbHVlc1xuICAgICAgICAgICAgaWYgKHRvVGFyZ2V0T2JqZWN0LmQgJiYgZnJvbVRhcmdldE9iamVjdC5kICYmICh0b1RhcmdldE9iamVjdC5kLmxlbmd0aCAhPT0gZnJvbVRhcmdldE9iamVjdC5kLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgbG9uZ2VzdFZhbHVlID0gZnJvbVRhcmdldE9iamVjdC5kLmxlbmd0aCA+IHRvVGFyZ2V0T2JqZWN0LmQubGVuZ3RoID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICBjb25zdCBzaG9ydGVzdFZhbHVlID0gbG9uZ2VzdFZhbHVlID09PSBmcm9tVGFyZ2V0T2JqZWN0ID8gdG9UYXJnZXRPYmplY3QgOiBmcm9tVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiBuIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgMCBmb3IgZGVmYXVsdCBjb21wbGV4IHZhbHVlc1xuICAgICAgICAgICAgICBzaG9ydGVzdFZhbHVlLmQgPSBsb25nZXN0VmFsdWUuZC5tYXAoKF8sIGkpID0+IGlzVW5kKHNob3J0ZXN0VmFsdWUuZFtpXSkgPyAwIDogc2hvcnRlc3RWYWx1ZS5kW2ldKTtcbiAgICAgICAgICAgICAgc2hvcnRlc3RWYWx1ZS5zID0gY2xvbmVBcnJheShsb25nZXN0VmFsdWUucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFR3ZWVuIGZhY3RvcnlcblxuICAgICAgICAgICAgLy8gUm91bmRpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgdG8gbWluaW1pemUgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHdoZW4gd29ya2luZyBpbiBzZWNvbmRzXG4gICAgICAgICAgICBjb25zdCB0d2VlblVwZGF0ZUR1cmF0aW9uID0gcm91bmQoK3R3ZWVuRHVyYXRpb24gfHwgbWluVmFsdWUsIDEyKTtcblxuICAgICAgICAgICAgLyoqIEB0eXBlIHtUd2Vlbn0gKi9cbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgIGlkOiB0d2VlbklkKyssXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgIF92YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgX2Z1bmM6IHRvRnVuY3Rpb25TdG9yZS5mdW5jLFxuICAgICAgICAgICAgICBfZWFzZTogcGFyc2VFYXNpbmdzKHR3ZWVuRWFzaW5nKSxcbiAgICAgICAgICAgICAgX2Zyb21OdW1iZXJzOiBjbG9uZUFycmF5KGZyb21UYXJnZXRPYmplY3QuZCksXG4gICAgICAgICAgICAgIF90b051bWJlcnM6IGNsb25lQXJyYXkodG9UYXJnZXRPYmplY3QuZCksXG4gICAgICAgICAgICAgIF9zdHJpbmdzOiBjbG9uZUFycmF5KHRvVGFyZ2V0T2JqZWN0LnMpLFxuICAgICAgICAgICAgICBfZnJvbU51bWJlcjogZnJvbVRhcmdldE9iamVjdC5uLFxuICAgICAgICAgICAgICBfdG9OdW1iZXI6IHRvVGFyZ2V0T2JqZWN0Lm4sXG4gICAgICAgICAgICAgIF9udW1iZXJzOiBjbG9uZUFycmF5KGZyb21UYXJnZXRPYmplY3QuZCksIC8vIEZvciBhZGRpdGl2ZSB0d2VlbiBhbmQgYW5pbWF0YWJsZXNcbiAgICAgICAgICAgICAgX251bWJlcjogZnJvbVRhcmdldE9iamVjdC5uLCAvLyBGb3IgYWRkaXRpdmUgdHdlZW4gYW5kIGFuaW1hdGFibGVzXG4gICAgICAgICAgICAgIF91bml0OiB0b1RhcmdldE9iamVjdC51LFxuICAgICAgICAgICAgICBfbW9kaWZpZXI6IHR3ZWVuTW9kaWZpZXIsXG4gICAgICAgICAgICAgIF9jdXJyZW50VGltZTogMCxcbiAgICAgICAgICAgICAgX3N0YXJ0VGltZTogdHdlZW5TdGFydFRpbWUsXG4gICAgICAgICAgICAgIF9kZWxheTogK3R3ZWVuRGVsYXksXG4gICAgICAgICAgICAgIF91cGRhdGVEdXJhdGlvbjogdHdlZW5VcGRhdGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgX2NoYW5nZUR1cmF0aW9uOiB0d2VlblVwZGF0ZUR1cmF0aW9uLFxuICAgICAgICAgICAgICBfYWJzb2x1dGVTdGFydFRpbWU6IGFic29sdXRlU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAvLyBOT1RFOiBJbnZlc3RpZ2F0ZSBiaXQgcGFja2luZyB0byBzdG9yZXMgRU5VTSAvIEJPT0xcbiAgICAgICAgICAgICAgX3R3ZWVuVHlwZTogdHdlZW5UeXBlLFxuICAgICAgICAgICAgICBfdmFsdWVUeXBlOiB0b1RhcmdldE9iamVjdC50LFxuICAgICAgICAgICAgICBfY29tcG9zaXRpb246IHR3ZWVuQ29tcG9zaXRpb24sXG4gICAgICAgICAgICAgIF9pc092ZXJsYXBwZWQ6IDAsXG4gICAgICAgICAgICAgIF9pc092ZXJyaWRkZW46IDAsXG4gICAgICAgICAgICAgIF9yZW5kZXJUcmFuc2Zvcm1zOiAwLFxuICAgICAgICAgICAgICBfcHJldlJlcDogbnVsbCwgLy8gRm9yIHJlcGxhY2VkIHR3ZWVuXG4gICAgICAgICAgICAgIF9uZXh0UmVwOiBudWxsLCAvLyBGb3IgcmVwbGFjZWQgdHdlZW5cbiAgICAgICAgICAgICAgX3ByZXZBZGQ6IG51bGwsIC8vIEZvciBhZGRpdGl2ZSB0d2VlblxuICAgICAgICAgICAgICBfbmV4dEFkZDogbnVsbCwgLy8gRm9yIGFkZGl0aXZlIHR3ZWVuXG4gICAgICAgICAgICAgIF9wcmV2OiBudWxsLFxuICAgICAgICAgICAgICBfbmV4dDogbnVsbCxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLm5vbmUpIHtcbiAgICAgICAgICAgICAgY29tcG9zZVR3ZWVuKHR3ZWVuLCBzaWJsaW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc05hTihmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lKSkge1xuICAgICAgICAgICAgICBmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lID0gdHdlZW4uX3N0YXJ0VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIHRvIG1pbmltaXplIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3aGVuIHdvcmtpbmcgaW4gc2Vjb25kc1xuICAgICAgICAgICAgbGFzdFR3ZWVuQ2hhbmdlRW5kVGltZSA9IHJvdW5kKHR3ZWVuU3RhcnRUaW1lICsgdHdlZW5VcGRhdGVEdXJhdGlvbiwgMTIpO1xuICAgICAgICAgICAgcHJldlR3ZWVuID0gdHdlZW47XG4gICAgICAgICAgICBhbmltYXRpb25BbmltYXRpb25MZW5ndGgrKztcblxuICAgICAgICAgICAgYWRkQ2hpbGQodGhpcywgdHdlZW4pO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIGFuaW1hdGlvbiB0aW1pbmdzIHdpdGggdGhlIGFkZGVkIHR3ZWVucyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgICBpZiAoaXNOYU4oaXRlcmF0aW9uRGVsYXkpIHx8IGZpcnN0VHdlZW5DaGFuZ2VTdGFydFRpbWUgPCBpdGVyYXRpb25EZWxheSkge1xuICAgICAgICAgICAgaXRlcmF0aW9uRGVsYXkgPSBmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc05hTihpdGVyYXRpb25EdXJhdGlvbikgfHwgbGFzdFR3ZWVuQ2hhbmdlRW5kVGltZSA+IGl0ZXJhdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpdGVyYXRpb25EdXJhdGlvbiA9IGxhc3RUd2VlbkNoYW5nZUVuZFRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogRmluZCBhIHdheSB0byBpbmxpbmUgdHdlZW4uX3JlbmRlclRyYW5zZm9ybXMgPSAxIGhlcmVcbiAgICAgICAgICBpZiAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSkge1xuICAgICAgICAgICAgbGFzdFRyYW5zZm9ybUdyb3VwSW5kZXggPSBhbmltYXRpb25BbmltYXRpb25MZW5ndGggLSB0d2VlbkluZGV4O1xuICAgICAgICAgICAgbGFzdFRyYW5zZm9ybUdyb3VwTGVuZ3RoID0gYW5pbWF0aW9uQW5pbWF0aW9uTGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gU2V0IF9yZW5kZXJUcmFuc2Zvcm1zIHRvIGxhc3QgdHJhbnNmb3JtIHByb3BlcnR5IHRvIGNvcnJlY3RseSByZW5kZXIgdGhlIHRyYW5zZm9ybXMgbGlzdFxuICAgICAgaWYgKCFpc05hTihsYXN0VHJhbnNmb3JtR3JvdXBJbmRleCkpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7VHdlZW59ICovdHdlZW4pID0+IHtcbiAgICAgICAgICBpZiAoaSA+PSBsYXN0VHJhbnNmb3JtR3JvdXBJbmRleCAmJiBpIDwgbGFzdFRyYW5zZm9ybUdyb3VwTGVuZ3RoKSB7XG4gICAgICAgICAgICB0d2Vlbi5fcmVuZGVyVHJhbnNmb3JtcyA9IDE7XG4gICAgICAgICAgICBpZiAodHdlZW4uX2NvbXBvc2l0aW9uID09PSBjb21wb3NpdGlvblR5cGVzLmJsZW5kKSB7XG4gICAgICAgICAgICAgIGZvckVhY2hDaGlsZHJlbihhZGRpdGl2ZS5hbmltYXRpb24sICgvKiogQHR5cGUge1R3ZWVufSAqL2FkZGl0aXZlVHdlZW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpdmVUd2Vlbi5pZCA9PT0gdHdlZW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgIGFkZGl0aXZlVHdlZW4uX3JlbmRlclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldHNMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTm8gdGFyZ2V0IGZvdW5kLiBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgeW91J3JlIHRyeWluZyB0byBhbmltYXRlIGlzIGFjY2Vzc2libGUgYmVmb3JlIGNyZWF0aW5nIHlvdXIgYW5pbWF0aW9uLmApO1xuICAgIH1cblxuICAgIGlmIChpdGVyYXRpb25EZWxheSkge1xuICAgICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgICAgIC8vIElmIChzdGFydFRpbWUgLSBkZWxheSkgZXF1YWxzIDAsIHRoaXMgbWVhbnMgdGhlIHR3ZWVuIGlzIGF0IHRoZSBiZWdpbmluZyBvZiB0aGUgYW5pbWF0aW9uIHNvIHdlIG5lZWQgdG8gdHJpbSB0aGUgZGVsYXkgdG9vXG4gICAgICAgIGlmICghKHR3ZWVuLl9zdGFydFRpbWUgLSB0d2Vlbi5fZGVsYXkpKSB7XG4gICAgICAgICAgdHdlZW4uX2RlbGF5IC09IGl0ZXJhdGlvbkRlbGF5O1xuICAgICAgICB9XG4gICAgICAgIHR3ZWVuLl9zdGFydFRpbWUgLT0gaXRlcmF0aW9uRGVsYXk7XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGlvbkR1cmF0aW9uIC09IGl0ZXJhdGlvbkRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRpb25EZWxheSA9IDA7XG4gICAgfVxuXG4gICAgLy8gUHJldmVudHMgaXRlcmF0aW9uRHVyYXRpb24gdG8gYmUgTmFOIGlmIG5vIHZhbGlkIGFuaW1hdGFibGUgcHJvcHMgaGF2ZSBiZWVuIHByb3ZpZGVkXG4gICAgLy8gUHJldmVudHMgX2l0ZXJhdGlvbkNvdW50IHRvIGJlIE5hTiBpZiBubyB2YWxpZCBhbmltYXRhYmxlIHByb3BzIGhhdmUgYmVlbiBwcm92aWRlZFxuICAgIGlmICghaXRlcmF0aW9uRHVyYXRpb24pIHtcbiAgICAgIGl0ZXJhdGlvbkR1cmF0aW9uID0gbWluVmFsdWU7XG4gICAgICB0aGlzLml0ZXJhdGlvbkNvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtUYXJnZXRzQXJyYXl9ICovXG4gICAgdGhpcy50YXJnZXRzID0gcGFyc2VkVGFyZ2V0cztcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmR1cmF0aW9uID0gaXRlcmF0aW9uRHVyYXRpb24gPT09IG1pblZhbHVlID8gbWluVmFsdWUgOiBjbGFtcEluZmluaXR5KCgoaXRlcmF0aW9uRHVyYXRpb24gKyB0aGlzLl9sb29wRGVsYXkpICogdGhpcy5pdGVyYXRpb25Db3VudCkgLSB0aGlzLl9sb29wRGVsYXkpIHx8IG1pblZhbHVlO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblJlbmRlciA9IG9uUmVuZGVyIHx8IGFuaW1EZWZhdWx0cy5vblJlbmRlcjtcbiAgICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuX2Vhc2UgPSBhbmltRWFzZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9kZWxheSA9IGl0ZXJhdGlvbkRlbGF5O1xuICAgIC8vIE5PVEU6IEknbSBrZWVwaW5nIGRlbGF5IHZhbHVlcyBzZXBhcmF0ZWQgZnJvbSBvZmZzZXRzIGluIHRpbWVsaW5lcyBiZWNhdXNlIGRlbGF5cyBjYW4gb3ZlcnJpZGUgcHJldmlvdXMgdHdlZW5zIGFuZCBpdCBjb3VsZCBiZSBjb25mdXNpbmcgdG8gZGVidWcgYSB0aW1lbGluZSB3aXRoIG92ZXJyaWRkZW4gdHdlZW5zIGFuZCBubyBhc3NvY2lhdGVkIHZpc2libGUgZGVsYXlzLlxuICAgIC8vIHRoaXMuX2RlbGF5ID0gcGFyZW50ID8gMCA6IGl0ZXJhdGlvbkRlbGF5O1xuICAgIC8vIHRoaXMuX29mZnNldCArPSBwYXJlbnQgPyBpdGVyYXRpb25EZWxheSA6IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5pdGVyYXRpb25EdXJhdGlvbiA9IGl0ZXJhdGlvbkR1cmF0aW9uO1xuICAgIC8qKiBAdHlwZSB7e319ICovXG4gICAgdGhpcy5faW5saW5lU3R5bGVzID0gYW5pbUlubGluZVN0eWxlcztcblxuICAgIGlmICghdGhpcy5fYXV0b3BsYXkgJiYgc2hvdWxkVHJpZ2dlclJlbmRlcikgdGhpcy5vblJlbmRlcih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG5ld0R1cmF0aW9uXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzdHJldGNoKG5ld0R1cmF0aW9uKSB7XG4gICAgY29uc3QgY3VycmVudER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBpZiAoY3VycmVudER1cmF0aW9uID09PSBub3JtYWxpemVUaW1lKG5ld0R1cmF0aW9uKSkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdGltZVNjYWxlID0gbmV3RHVyYXRpb24gLyBjdXJyZW50RHVyYXRpb247XG4gICAgLy8gTk9URTogRmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoZSBzdHJldGNoIG9mIGFuIGFuaW1hdGlvbiBhZnRlciBzdHJldGNoID0gMFxuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi90d2VlbikgPT4ge1xuICAgICAgLy8gUm91bmRpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgdG8gbWluaW1pemUgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gICAgICB0d2Vlbi5fdXBkYXRlRHVyYXRpb24gPSBub3JtYWxpemVUaW1lKHR3ZWVuLl91cGRhdGVEdXJhdGlvbiAqIHRpbWVTY2FsZSk7XG4gICAgICB0d2Vlbi5fY2hhbmdlRHVyYXRpb24gPSBub3JtYWxpemVUaW1lKHR3ZWVuLl9jaGFuZ2VEdXJhdGlvbiAqIHRpbWVTY2FsZSk7XG4gICAgICB0d2Vlbi5fY3VycmVudFRpbWUgKj0gdGltZVNjYWxlO1xuICAgICAgdHdlZW4uX3N0YXJ0VGltZSAqPSB0aW1lU2NhbGU7XG4gICAgICB0d2Vlbi5fYWJzb2x1dGVTdGFydFRpbWUgKj0gdGltZVNjYWxlO1xuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5zdHJldGNoKG5ld0R1cmF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7VHdlZW59ICovdHdlZW4pID0+IHtcbiAgICAgIGNvbnN0IHR3ZWVuRnVuYyA9IHR3ZWVuLl9mdW5jO1xuICAgICAgaWYgKHR3ZWVuRnVuYykge1xuICAgICAgICBjb25zdCBvZ1ZhbHVlID0gZ2V0T3JpZ2luYWxBbmltYXRhYmxlVmFsdWUodHdlZW4udGFyZ2V0LCB0d2Vlbi5wcm9wZXJ0eSwgdHdlZW4uX3R3ZWVuVHlwZSk7XG4gICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKG9nVmFsdWUsIGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlKTtcbiAgICAgICAgZGVjb21wb3NlUmF3VmFsdWUodHdlZW5GdW5jKCksIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXJzID0gY2xvbmVBcnJheShkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5kKTtcbiAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXIgPSBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5uO1xuICAgICAgICB0d2Vlbi5fdG9OdW1iZXJzID0gY2xvbmVBcnJheSh0b1RhcmdldE9iamVjdC5kKTtcbiAgICAgICAgdHdlZW4uX3N0cmluZ3MgPSBjbG9uZUFycmF5KHRvVGFyZ2V0T2JqZWN0LnMpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gYXBwbHkgcmVsYXRpdmUgb3BlcmF0b3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWxpYW5nYXJuaWVyL2FuaW1lL2lzc3Vlcy8xMDI1XG4gICAgICAgIHR3ZWVuLl90b051bWJlciA9IHRvVGFyZ2V0T2JqZWN0Lm8gPyBnZXRSZWxhdGl2ZVZhbHVlKGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLm4sIHRvVGFyZ2V0T2JqZWN0Lm4sIHRvVGFyZ2V0T2JqZWN0Lm8pIDogdG9UYXJnZXRPYmplY3QubjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIGFuaW1hdGlvbiBhbmQgcmV2ZXJ0IGFsbCB0aGUgdmFsdWVzIGFmZmVjdGVkIGJ5IHRoaXMgYW5pbWF0aW9uIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZXZlcnQoKSB7XG4gICAgc3VwZXIucmV2ZXJ0KCk7XG4gICAgcmV0dXJuIGNsZWFuSW5saW5lU3R5bGVzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbGxiYWNrPHRoaXM+fSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB0aGVuKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRoZW4oY2FsbGJhY2spO1xuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0pTQW5pbWF0aW9ufVxuICovXG5jb25zdCBhbmltYXRlID0gKHRhcmdldHMsIHBhcmFtZXRlcnMpID0+IG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLCBwYXJhbWV0ZXJzLCBudWxsLCAwLCBmYWxzZSkuaW5pdCgpO1xuXG5cblxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGVhc2luZyBmdW5jdGlvbiBpbnRvIGEgdmFsaWQgQ1NTIGxpbmVhcigpIHRpbWluZyBmdW5jdGlvbiBzdHJpbmdcbiAqIEBwYXJhbSB7RWFzaW5nRnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9MTAwXVxuICogQHJldHVybnMge3N0cmluZ30gQ1NTIGxpbmVhcigpIHRpbWluZyBmdW5jdGlvblxuICovXG5jb25zdCBlYXNpbmdUb0xpbmVhciA9IChmbiwgc2FtcGxlcyA9IDEwMCkgPT4ge1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2FtcGxlczsgaSsrKSBwb2ludHMucHVzaChmbihpIC8gc2FtcGxlcykpO1xuICByZXR1cm4gYGxpbmVhcigke3BvaW50cy5qb2luKCcsICcpfSlgO1xufTtcblxuY29uc3QgV0FBUElFYXNlc0xvb2t1cHMgPSB7XG4gIGluOiAnZWFzZS1pbicsXG4gIG91dDogJ2Vhc2Utb3V0JyxcbiAgaW5PdXQ6ICdlYXNlLWluLW91dCcsXG59O1xuXG5jb25zdCBXQUFQSWVhc2VzID0gLyojX19QVVJFX18qLygoKSA9PiB7XG4gIGNvbnN0IGxpc3QgPSB7fTtcbiAgZm9yIChsZXQgdHlwZSBpbiBlYXNlVHlwZXMpIGxpc3RbdHlwZV0gPSAoLyoqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfSAqL3ApID0+IGVhc2VUeXBlc1t0eXBlXShlYXNlSW5Qb3dlcihwKSk7XG4gIHJldHVybiAvKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2luZ0Z1bmN0aW9uPn0gKi8obGlzdCk7XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSAge0Vhc2luZ1BhcmFtfSBlYXNlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhcnNlV0FBUElFYXNpbmcgPSAoZWFzZSkgPT4ge1xuICBsZXQgcGFyc2VkRWFzZSA9IFdBQVBJRWFzZXNMb29rdXBzW2Vhc2VdO1xuICBpZiAocGFyc2VkRWFzZSkgcmV0dXJuIHBhcnNlZEVhc2U7XG4gIHBhcnNlZEVhc2UgPSAnbGluZWFyJztcbiAgaWYgKGlzU3RyKGVhc2UpKSB7XG4gICAgaWYgKFxuICAgICAgc3RyaW5nU3RhcnRzV2l0aChlYXNlLCAnbGluZWFyJykgfHxcbiAgICAgIHN0cmluZ1N0YXJ0c1dpdGgoZWFzZSwgJ2N1YmljLScpIHx8XG4gICAgICBzdHJpbmdTdGFydHNXaXRoKGVhc2UsICdzdGVwcycpIHx8XG4gICAgICBzdHJpbmdTdGFydHNXaXRoKGVhc2UsICdlYXNlJylcbiAgICApIHtcbiAgICAgIHBhcnNlZEVhc2UgPSBlYXNlO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nU3RhcnRzV2l0aChlYXNlLCAnY3ViaWNCJykpIHtcbiAgICAgIHBhcnNlZEVhc2UgPSB0b0xvd2VyQ2FzZShlYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VFYXNlU3RyaW5nKGVhc2UsIFdBQVBJZWFzZXMsIFdBQVBJRWFzZXNMb29rdXBzKTtcbiAgICAgIGlmIChpc0ZuYyhwYXJzZWQpKSBwYXJzZWRFYXNlID0gcGFyc2VkID09PSBub25lID8gJ2xpbmVhcicgOiBlYXNpbmdUb0xpbmVhcihwYXJzZWQpO1xuICAgIH1cbiAgICBXQUFQSUVhc2VzTG9va3Vwc1tlYXNlXSA9IHBhcnNlZEVhc2U7XG4gIH0gZWxzZSBpZiAoaXNGbmMoZWFzZSkpIHtcbiAgICBjb25zdCBlYXNpbmcgPSBlYXNpbmdUb0xpbmVhcihlYXNlKTtcbiAgICBpZiAoZWFzaW5nKSBwYXJzZWRFYXNlID0gZWFzaW5nO1xuICB9IGVsc2UgaWYgKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKSB7XG4gICAgcGFyc2VkRWFzZSA9IGVhc2luZ1RvTGluZWFyKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkRWFzZTtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybXNTaG9ydGhhbmRzID0gWyd4JywgJ3knLCAneiddO1xuY29uc3QgY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcyA9IFtcbiAgJ3BlcnNwZWN0aXZlJyxcbiAgJ3dpZHRoJyxcbiAgJ2hlaWdodCcsXG4gICdtYXJnaW4nLFxuICAncGFkZGluZycsXG4gICd0b3AnLFxuICAncmlnaHQnLFxuICAnYm90dG9tJyxcbiAgJ2xlZnQnLFxuICAnYm9yZGVyV2lkdGgnLFxuICAnZm9udFNpemUnLFxuICAnYm9yZGVyUmFkaXVzJyxcbiAgLi4udHJhbnNmb3Jtc1Nob3J0aGFuZHNcbl07XG5cbmNvbnN0IHZhbGlkSW5kaXZpZHVhbFRyYW5zZm9ybXMgPSAvKiNfX1BVUkVfXyovICgoKSA9PiBbLi4udHJhbnNmb3Jtc1Nob3J0aGFuZHMsIC4uLnZhbGlkVHJhbnNmb3Jtcy5maWx0ZXIodCA9PiBbJ1gnLCAnWScsICdaJ10uc29tZShheGlzID0+IHQuZW5kc1dpdGgoYXhpcykpKV0pKCk7XG5cbmxldCB0cmFuc2Zvcm1zUHJvcGVydGllc1JlZ2lzdGVyZWQgPSBudWxsO1xuXG5jb25zdCBXQUFQSUFuaW1hdGlvbnNMb29rdXBzID0ge1xuICBfaGVhZDogbnVsbCxcbiAgX3RhaWw6IG51bGwsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldXG4gKiBAcGFyYW0ge1dBQVBJQW5pbWF0aW9ufSBbcGFyZW50XVxuICovXG5jb25zdCByZW1vdmVXQUFQSUFuaW1hdGlvbiA9ICgkZWwsIHByb3BlcnR5LCBwYXJlbnQpID0+IHtcbiAgbGV0IG5leHRMb29rdXAgPSBXQUFQSUFuaW1hdGlvbnNMb29rdXBzLl9oZWFkO1xuICB3aGlsZSAobmV4dExvb2t1cCkge1xuICAgIGNvbnN0IG5leHQgPSBuZXh0TG9va3VwLl9uZXh0O1xuICAgIGNvbnN0IG1hdGNoVGFyZ2V0ID0gbmV4dExvb2t1cC4kZWwgPT09ICRlbDtcbiAgICBjb25zdCBtYXRjaFByb3BlcnR5ID0gIXByb3BlcnR5IHx8IG5leHRMb29rdXAucHJvcGVydHkgPT09IHByb3BlcnR5O1xuICAgIGNvbnN0IG1hdGNoUGFyZW50ID0gIXBhcmVudCB8fCBuZXh0TG9va3VwLnBhcmVudCA9PT0gcGFyZW50O1xuICAgIGlmIChtYXRjaFRhcmdldCAmJiBtYXRjaFByb3BlcnR5ICYmIG1hdGNoUGFyZW50KSB7XG4gICAgICBjb25zdCBhbmltID0gbmV4dExvb2t1cC5hbmltYXRpb247XG4gICAgICB0cnkgeyBhbmltLmNvbW1pdFN0eWxlcygpOyB9IGNhdGNoIHt9ICAgICAgYW5pbS5jYW5jZWwoKTtcbiAgICAgIHJlbW92ZUNoaWxkKFdBQVBJQW5pbWF0aW9uc0xvb2t1cHMsIG5leHRMb29rdXApO1xuICAgICAgY29uc3QgbG9va3VwUGFyZW50ID0gbmV4dExvb2t1cC5wYXJlbnQ7XG4gICAgICBpZiAobG9va3VwUGFyZW50KSB7XG4gICAgICAgIGxvb2t1cFBhcmVudC5fY29tcGxldGVkKys7XG4gICAgICAgIGlmIChsb29rdXBQYXJlbnQuYW5pbWF0aW9ucy5sZW5ndGggPT09IGxvb2t1cFBhcmVudC5fY29tcGxldGVkKSB7XG4gICAgICAgICAgbG9va3VwUGFyZW50LmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFsb29rdXBQYXJlbnQubXV0ZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgbG9va3VwUGFyZW50LnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBsb29rdXBQYXJlbnQub25Db21wbGV0ZShsb29rdXBQYXJlbnQpO1xuICAgICAgICAgICAgbG9va3VwUGFyZW50Ll9yZXNvbHZlKGxvb2t1cFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5leHRMb29rdXAgPSBuZXh0O1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7V0FBUElBbmltYXRpb259IHBhcmVudFxuICogQHBhcmFtIHtET01UYXJnZXR9ICRlbFxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge1Byb3BlcnR5SW5kZXhlZEtleWZyYW1lc30ga2V5ZnJhbWVzXG4gKiBAcGFyYW0ge0tleWZyYW1lQW5pbWF0aW9uT3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dW4ge0FuaW1hdGlvbn1cbiAqL1xuY29uc3QgYWRkV0FBUElBbmltYXRpb24gPSAocGFyZW50LCAkZWwsIHByb3BlcnR5LCBrZXlmcmFtZXMsIHBhcmFtcykgPT4ge1xuICBjb25zdCBhbmltYXRpb24gPSAkZWwuYW5pbWF0ZShrZXlmcmFtZXMsIHBhcmFtcyk7XG4gIGNvbnN0IGFuaW1Ub3RhbER1cmF0aW9uID0gcGFyYW1zLmRlbGF5ICsgKCtwYXJhbXMuZHVyYXRpb24gKiBwYXJhbXMuaXRlcmF0aW9ucyk7XG4gIGFuaW1hdGlvbi5wbGF5YmFja1JhdGUgPSBwYXJlbnQuX3NwZWVkO1xuICBpZiAocGFyZW50LnBhdXNlZCkgYW5pbWF0aW9uLnBhdXNlKCk7XG4gIGlmIChwYXJlbnQuZHVyYXRpb24gPCBhbmltVG90YWxEdXJhdGlvbikge1xuICAgIHBhcmVudC5kdXJhdGlvbiA9IGFuaW1Ub3RhbER1cmF0aW9uO1xuICAgIHBhcmVudC5jb250cm9sQW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICB9XG4gIHBhcmVudC5hbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgcmVtb3ZlV0FBUElBbmltYXRpb24oJGVsLCBwcm9wZXJ0eSk7XG4gIGFkZENoaWxkKFdBQVBJQW5pbWF0aW9uc0xvb2t1cHMsIHsgcGFyZW50LCBhbmltYXRpb24sICRlbCwgcHJvcGVydHksIF9uZXh0OiBudWxsLCBfcHJldjogbnVsbCB9KTtcbiAgY29uc3QgaGFuZGxlUmVtb3ZlID0gKCkgPT4geyByZW1vdmVXQUFQSUFuaW1hdGlvbigkZWwsIHByb3BlcnR5LCBwYXJlbnQpOyB9O1xuICBhbmltYXRpb24ub25yZW1vdmUgPSBoYW5kbGVSZW1vdmU7XG4gIGFuaW1hdGlvbi5vbmZpbmlzaCA9IGhhbmRsZVJlbW92ZTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtICB7V0FBUElLZXlmcmFtZVZhbHVlfSB2YWx1ZVxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSB0YXJnZXRzTGVuZ3RoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVR3ZWVuVmFsdWUgPSAocHJvcE5hbWUsIHZhbHVlLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpID0+IHtcbiAgbGV0IHYgPSBnZXRGdW5jdGlvblZhbHVlKC8qKiBAdHlwZSB7YW55fSAqLyh2YWx1ZSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gIGlmICghaXNOdW0odikpIHJldHVybiB2O1xuICBpZiAoY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcy5pbmNsdWRlcyhwcm9wTmFtZSkgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3RyYW5zbGF0ZScpKSByZXR1cm4gYCR7dn1weGA7XG4gIGlmIChzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3NrZXcnKSkgcmV0dXJuIGAke3Z9ZGVnYDtcbiAgcmV0dXJuIGAke3Z9YDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge1dBQVBJS2V5ZnJhbWVWYWx1ZX0gZnJvbVxuICogQHBhcmFtICB7V0FBUElLZXlmcmFtZVZhbHVlfSB0b1xuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRhcmdldHNMZW5ndGhcbiAqIEByZXR1cm4ge1dBQVBJVHdlZW5WYWx1ZX1cbiAqL1xuY29uc3QgcGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSA9ICgkZWwsIHByb3BOYW1lLCBmcm9tLCB0bywgaSwgdGFyZ2V0c0xlbmd0aCkgPT4ge1xuICAvKiogQHR5cGUge1dBQVBJVHdlZW5WYWx1ZX0gKi9cbiAgbGV0IHR3ZWVuVmFsdWUgPSAnMCc7XG4gIGNvbnN0IGNvbXB1dGVkVG8gPSAhaXNVbmQodG8pID8gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgdG8sICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkgOiBnZXRDb21wdXRlZFN0eWxlKCRlbClbcHJvcE5hbWVdO1xuICBpZiAoIWlzVW5kKGZyb20pKSB7XG4gICAgY29uc3QgY29tcHV0ZWRGcm9tID0gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgZnJvbSwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKTtcbiAgICB0d2VlblZhbHVlID0gW2NvbXB1dGVkRnJvbSwgY29tcHV0ZWRUb107XG4gIH0gZWxzZSB7XG4gICAgdHdlZW5WYWx1ZSA9IGlzQXJyKHRvKSA/IHRvLm1hcCgoLyoqIEB0eXBlIHthbnl9ICovdikgPT4gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgdiwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKSkgOiBjb21wdXRlZFRvO1xuICB9XG4gIHJldHVybiB0d2VlblZhbHVlO1xufTtcblxuY2xhc3MgV0FBUElBbmltYXRpb24ge1xuLyoqXG4gKiBAcGFyYW0ge0RPTVRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtIHtXQUFQSUFuaW1hdGlvblBhcmFtc30gcGFyYW1zXG4gKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0cywgcGFyYW1zKSB7XG5cbiAgICBpZiAoc2NvcGUuY3VycmVudCkgc2NvcGUuY3VycmVudC5yZWdpc3Rlcih0aGlzKTtcblxuICAgIC8vIFNraXAgdGhlIHJlZ2lzdHJhdGlvbiBhbmQgZmFsbGJhY2sgdG8gbm8gYW5pbWF0aW9uIGluIGNhc2UgQ1NTLnJlZ2lzdGVyUHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZFxuICAgIGlmIChpc05pbCh0cmFuc2Zvcm1zUHJvcGVydGllc1JlZ2lzdGVyZWQpKSB7XG4gICAgICBpZiAoaXNCcm93c2VyICYmIChpc1VuZChDU1MpIHx8ICFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChDU1MsICdyZWdpc3RlclByb3BlcnR5JykpKSB7XG4gICAgICAgIHRyYW5zZm9ybXNQcm9wZXJ0aWVzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRUcmFuc2Zvcm1zLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgY29uc3QgaXNTa2V3ID0gc3RyaW5nU3RhcnRzV2l0aCh0LCAnc2tldycpO1xuICAgICAgICAgIGNvbnN0IGlzU2NhbGUgPSBzdHJpbmdTdGFydHNXaXRoKHQsICdzY2FsZScpO1xuICAgICAgICAgIGNvbnN0IGlzUm90YXRlID0gc3RyaW5nU3RhcnRzV2l0aCh0LCAncm90YXRlJyk7XG4gICAgICAgICAgY29uc3QgaXNUcmFuc2xhdGUgPSBzdHJpbmdTdGFydHNXaXRoKHQsICd0cmFuc2xhdGUnKTtcbiAgICAgICAgICBjb25zdCBpc0FuZ2xlID0gaXNSb3RhdGUgfHwgaXNTa2V3O1xuICAgICAgICAgIGNvbnN0IHN5bnRheCA9IGlzQW5nbGUgPyAnPGFuZ2xlPicgOiBpc1NjYWxlID8gXCI8bnVtYmVyPlwiIDogaXNUcmFuc2xhdGUgPyBcIjxsZW5ndGgtcGVyY2VudGFnZT5cIiA6IFwiKlwiO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBDU1MucmVnaXN0ZXJQcm9wZXJ0eSh7XG4gICAgICAgICAgICAgIG5hbWU6ICctLScgKyB0LFxuICAgICAgICAgICAgICBzeW50YXgsXG4gICAgICAgICAgICAgIGluaGVyaXRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiBpc1RyYW5zbGF0ZSA/ICcwcHgnIDogaXNBbmdsZSA/ICcwZGVnJyA6IGlzU2NhbGUgPyAnMScgOiAnMCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIHt9ICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNmb3Jtc1Byb3BlcnRpZXNSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRUYXJnZXRzID0gcmVnaXN0ZXJUYXJnZXRzKHRhcmdldHMpO1xuICAgIGNvbnN0IHRhcmdldHNMZW5ndGggPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblxuICAgIGlmICghdGFyZ2V0c0xlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKGBObyB0YXJnZXQgZm91bmQuIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCB5b3UncmUgdHJ5aW5nIHRvIGFuaW1hdGUgaXMgYWNjZXNzaWJsZSBiZWZvcmUgY3JlYXRpbmcgeW91ciBhbmltYXRpb24uYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZWFzZSA9IHNldFZhbHVlKHBhcmFtcy5lYXNlLCBwYXJzZVdBQVBJRWFzaW5nKGdsb2JhbHMuZGVmYXVsdHMuZWFzZSkpO1xuICAgIGNvbnN0IHNwcmluZyA9IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlICYmIGVhc2U7XG4gICAgY29uc3QgYXV0b3BsYXkgPSBzZXRWYWx1ZShwYXJhbXMuYXV0b3BsYXksIGdsb2JhbHMuZGVmYXVsdHMuYXV0b3BsYXkpO1xuICAgIGNvbnN0IHNjcm9sbCA9IGF1dG9wbGF5ICYmIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovKGF1dG9wbGF5KS5saW5rID8gYXV0b3BsYXkgOiBmYWxzZTtcbiAgICBjb25zdCBhbHRlcm5hdGUgPSBwYXJhbXMuYWx0ZXJuYXRlICYmIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi8ocGFyYW1zLmFsdGVybmF0ZSkgPT09IHRydWU7XG4gICAgY29uc3QgcmV2ZXJzZWQgPSBwYXJhbXMucmV2ZXJzZWQgJiYgLyoqIEB0eXBlIHtCb29sZWFufSAqLyhwYXJhbXMucmV2ZXJzZWQpID09PSB0cnVlO1xuICAgIGNvbnN0IGxvb3AgPSBzZXRWYWx1ZShwYXJhbXMubG9vcCwgZ2xvYmFscy5kZWZhdWx0cy5sb29wKTtcbiAgICBjb25zdCBpdGVyYXRpb25zID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKChsb29wID09PSB0cnVlIHx8IGxvb3AgPT09IEluZmluaXR5KSA/IEluZmluaXR5IDogaXNOdW0obG9vcCkgPyBsb29wICsgMSA6IDEpO1xuICAgIC8qKiBAdHlwZSB7UGxheWJhY2tEaXJlY3Rpb259ICovXG4gICAgY29uc3QgZGlyZWN0aW9uID0gYWx0ZXJuYXRlID8gcmV2ZXJzZWQgPyAnYWx0ZXJuYXRlLXJldmVyc2UnIDogJ2FsdGVybmF0ZScgOiByZXZlcnNlZCA/ICdyZXZlcnNlJyA6ICdub3JtYWwnO1xuICAgIC8qKiBAdHlwZSB7RmlsbE1vZGV9ICovXG4gICAgY29uc3QgZmlsbCA9ICdmb3J3YXJkcyc7XG4gICAgLyoqIEB0eXBlIHtTdHJpbmd9ICovXG4gICAgY29uc3QgZWFzaW5nID0gcGFyc2VXQUFQSUVhc2luZyhlYXNlKTtcbiAgICBjb25zdCB0aW1lU2NhbGUgPSAoZ2xvYmFscy50aW1lU2NhbGUgPT09IDEgPyAxIDogSyk7XG5cbiAgICAvKiogQHR5cGUge0RPTVRhcmdldHNBcnJheX1dICovXG4gICAgdGhpcy50YXJnZXRzID0gcGFyc2VkVGFyZ2V0cztcbiAgICAvKiogQHR5cGUge0FycmF5PGdsb2JhbFRoaXMuQW5pbWF0aW9uPn1dICovXG4gICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgLyoqIEB0eXBlIHtnbG9iYWxUaGlzLkFuaW1hdGlvbn1dICovXG4gICAgdGhpcy5jb250cm9sQW5pbWF0aW9uID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25Db21wbGV0ZSA9IHBhcmFtcy5vbkNvbXBsZXRlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMubXV0ZUNhbGxiYWNrcyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnBhdXNlZCA9ICFhdXRvcGxheSB8fCBzY3JvbGwgIT09IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnJldmVyc2VkID0gcmV2ZXJzZWQ7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuYXV0b3BsYXkgPSBhdXRvcGxheTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zcGVlZCA9IHNldFZhbHVlKHBhcmFtcy5wbGF5YmFja1JhdGUsIGdsb2JhbHMuZGVmYXVsdHMucGxheWJhY2tSYXRlKTtcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuX3Jlc29sdmUgPSBub29wOyAvLyBVc2VkIGJ5IC50aGVuKClcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9jb21wbGV0ZWQgPSAwO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8T2JqZWN0Pn1dICovXG4gICAgdGhpcy5faW5saW5lU3R5bGVzID0gcGFyc2VkVGFyZ2V0cy5tYXAoJGVsID0+ICRlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuXG4gICAgcGFyc2VkVGFyZ2V0cy5mb3JFYWNoKCgkZWwsIGkpID0+IHtcblxuICAgICAgY29uc3QgY2FjaGVkVHJhbnNmb3JtcyA9ICRlbFt0cmFuc2Zvcm1zU3ltYm9sXTtcblxuICAgICAgY29uc3QgaGFzSW5kaXZpZHVhbFRyYW5zZm9ybXMgPSB2YWxpZEluZGl2aWR1YWxUcmFuc2Zvcm1zLnNvbWUodCA9PiBwYXJhbXMuaGFzT3duUHJvcGVydHkodCkpO1xuXG4gICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gKHNwcmluZyA/IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhzcHJpbmcpLmR1cmF0aW9uIDogZ2V0RnVuY3Rpb25WYWx1ZShzZXRWYWx1ZShwYXJhbXMuZHVyYXRpb24sIGdsb2JhbHMuZGVmYXVsdHMuZHVyYXRpb24pLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpKSAqIHRpbWVTY2FsZTtcbiAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgICAgY29uc3QgZGVsYXkgPSBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKHBhcmFtcy5kZWxheSwgZ2xvYmFscy5kZWZhdWx0cy5kZWxheSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkgKiB0aW1lU2NhbGU7XG4gICAgICAvKiogQHR5cGUge0NvbXBvc2l0ZU9wZXJhdGlvbn0gKi9cbiAgICAgIGNvbnN0IGNvbXBvc2l0ZSA9IC8qKiBAdHlwZSB7Q29tcG9zaXRlT3BlcmF0aW9ufSAqLyhzZXRWYWx1ZShwYXJhbXMuY29tcG9zaXRpb24sICdyZXBsYWNlJykpO1xuXG4gICAgICBmb3IgKGxldCBuYW1lIGluIHBhcmFtcykge1xuICAgICAgICBpZiAoIWlzS2V5KG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgLyoqIEB0eXBlIHtQcm9wZXJ0eUluZGV4ZWRLZXlmcmFtZXN9ICovXG4gICAgICAgIGNvbnN0IGtleWZyYW1lcyA9IHt9O1xuICAgICAgICAvKiogQHR5cGUge0tleWZyYW1lQW5pbWF0aW9uT3B0aW9uc30gKi9cbiAgICAgICAgY29uc3QgdHdlZW5QYXJhbXMgPSB7IGl0ZXJhdGlvbnMsIGRpcmVjdGlvbiwgZmlsbCwgZWFzaW5nLCBkdXJhdGlvbiwgZGVsYXksIGNvbXBvc2l0ZSB9O1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gcGFyYW1zW25hbWVdO1xuICAgICAgICBjb25zdCBpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHkgPSBoYXNJbmRpdmlkdWFsVHJhbnNmb3JtcyA/IHZhbGlkVHJhbnNmb3Jtcy5pbmNsdWRlcyhuYW1lKSA/IG5hbWUgOiBzaG9ydFRyYW5zZm9ybXMuZ2V0KG5hbWUpIDogZmFsc2U7XG4gICAgICAgIGxldCBwYXJzZWRQcm9wZXJ0eVZhbHVlO1xuICAgICAgICBpZiAoaXNPYmoocHJvcGVydHlWYWx1ZSkpIHtcbiAgICAgICAgICBjb25zdCB0d2Vlbk9wdGlvbnMgPSAvKiogQHR5cGUge1dBQVBJVHdlZW5PcHRpb25zfSAqLyhwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICBjb25zdCB0d2Vlbk9wdGlvbnNFYXNlID0gc2V0VmFsdWUodHdlZW5PcHRpb25zLmVhc2UsIGVhc2UpO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuT3B0aW9uc1NwcmluZyA9IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyh0d2Vlbk9wdGlvbnNFYXNlKS5lYXNlICYmIHR3ZWVuT3B0aW9uc0Vhc2U7XG4gICAgICAgICAgY29uc3QgdG8gPSAvKiogQHR5cGUge1dBQVBJVHdlZW5PcHRpb25zfSAqLyh0d2Vlbk9wdGlvbnMpLnRvO1xuICAgICAgICAgIGNvbnN0IGZyb20gPSAvKiogQHR5cGUge1dBQVBJVHdlZW5PcHRpb25zfSAqLyh0d2Vlbk9wdGlvbnMpLmZyb207XG4gICAgICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgICAgICAgdHdlZW5QYXJhbXMuZHVyYXRpb24gPSAodHdlZW5PcHRpb25zU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKHR3ZWVuT3B0aW9uc1NwcmluZykuZHVyYXRpb24gOiBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKHR3ZWVuT3B0aW9ucy5kdXJhdGlvbiwgZHVyYXRpb24pLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpKSAqIHRpbWVTY2FsZTtcbiAgICAgICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICAgICB0d2VlblBhcmFtcy5kZWxheSA9IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUodHdlZW5PcHRpb25zLmRlbGF5LCBkZWxheSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkgKiB0aW1lU2NhbGU7XG4gICAgICAgICAgLyoqIEB0eXBlIHtDb21wb3NpdGVPcGVyYXRpb259ICovXG4gICAgICAgICAgdHdlZW5QYXJhbXMuY29tcG9zaXRlID0gLyoqIEB0eXBlIHtDb21wb3NpdGVPcGVyYXRpb259ICovKHNldFZhbHVlKHR3ZWVuT3B0aW9ucy5jb21wb3NpdGlvbiwgY29tcG9zaXRlKSk7XG4gICAgICAgICAgLyoqIEB0eXBlIHtTdHJpbmd9ICovXG4gICAgICAgICAgdHdlZW5QYXJhbXMuZWFzaW5nID0gcGFyc2VXQUFQSUVhc2luZyh0d2Vlbk9wdGlvbnNFYXNlKTtcbiAgICAgICAgICBwYXJzZWRQcm9wZXJ0eVZhbHVlID0gcGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSgkZWwsIG5hbWUsIGZyb20sIHRvLCBpLCB0YXJnZXRzTGVuZ3RoKTtcbiAgICAgICAgICBpZiAoaW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5KSB7XG4gICAgICAgICAgICBrZXlmcmFtZXNbYC0tJHtpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHl9YF0gPSBwYXJzZWRQcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgY2FjaGVkVHJhbnNmb3Jtc1tpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHldID0gcGFyc2VkUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ZnJhbWVzW25hbWVdID0gcGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSgkZWwsIG5hbWUsIGZyb20sIHRvLCBpLCB0YXJnZXRzTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkV0FBUElBbmltYXRpb24odGhpcywgJGVsLCBuYW1lLCBrZXlmcmFtZXMsIHR3ZWVuUGFyYW1zKTtcbiAgICAgICAgICBpZiAoIWlzVW5kKGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWluZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAkZWwuc3R5bGVbbmFtZV0gPSBrZXlmcmFtZXNbbmFtZV1bMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgLS0ke2luZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eX1gO1xuICAgICAgICAgICAgICAkZWwuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCBrZXlmcmFtZXNba2V5XVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlZFByb3BlcnR5VmFsdWUgPSBpc0Fycihwcm9wZXJ0eVZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5VmFsdWUubWFwKCgvKiogQHR5cGUge2FueX0gKi92KSA9PiBub3JtYWxpemVUd2VlblZhbHVlKG5hbWUsIHYsICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplVHdlZW5WYWx1ZShuYW1lLCAvKiogQHR5cGUge2FueX0gKi8ocHJvcGVydHlWYWx1ZSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gICAgICAgICAgaWYgKGluZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eSkge1xuICAgICAgICAgICAga2V5ZnJhbWVzW2AtLSR7aW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5fWBdID0gcGFyc2VkUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgIGNhY2hlZFRyYW5zZm9ybXNbaW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5XSA9IHBhcnNlZFByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleWZyYW1lc1tuYW1lXSA9IHBhcnNlZFByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZFdBQVBJQW5pbWF0aW9uKHRoaXMsICRlbCwgbmFtZSwga2V5ZnJhbWVzLCB0d2VlblBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNJbmRpdmlkdWFsVHJhbnNmb3Jtcykge1xuICAgICAgICBsZXQgdHJhbnNmb3JtcyA9IGVtcHR5U3RyaW5nO1xuICAgICAgICBmb3IgKGxldCB0IGluIGNhY2hlZFRyYW5zZm9ybXMpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zICs9IGAke3RyYW5zZm9ybXNGcmFnbWVudFN0cmluZ3NbdF19dmFyKC0tJHt0fSkpIGA7XG4gICAgICAgIH1cbiAgICAgICAgJGVsLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybXM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqLyh0aGlzLmF1dG9wbGF5KS5saW5rKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgZm9yRWFjaENhbGxiYWNrXG4gICAqIEBwYXJhbSB7Z2xvYmFsVGhpcy5BbmltYXRpb259IGFuaW1hdGlvblxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtICB7Zm9yRWFjaENhbGxiYWNrfFN0cmluZ30gY2FsbGJhY2tcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBjb25zdCBjYiA9IGlzU3RyKGNhbGxiYWNrKSA/ICgvKiogQHR5cGUge2dsb2JhbFRoaXMuQW5pbWF0aW9ufSAqL2EpID0+IGFbY2FsbGJhY2tdKCkgOiBjYWxsYmFjaztcbiAgICB0aGlzLmFuaW1hdGlvbnMuZm9yRWFjaChjYik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwZWVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZCAqL1xuICBzZXQgc3BlZWQoc3BlZWQpIHtcbiAgICB0aGlzLl9zcGVlZCA9ICtzcGVlZDtcbiAgICB0aGlzLmZvckVhY2goYW5pbSA9PiBhbmltLnBsYXliYWNrUmF0ZSA9IHNwZWVkKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICBjb25zdCBjb250cm9sQW5pbWF0aW9uID0gdGhpcy5jb250cm9sQW5pbWF0aW9uO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IGdsb2JhbHMudGltZVNjYWxlO1xuICAgIHJldHVybiB0aGlzLmNvbXBsZXRlZCA/IHRoaXMuZHVyYXRpb24gOiBjb250cm9sQW5pbWF0aW9uID8gK2NvbnRyb2xBbmltYXRpb24uY3VycmVudFRpbWUgKiAodGltZVNjYWxlID09PSAxID8gMSA6IHRpbWVTY2FsZSkgOiAwO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICovXG4gIHNldCBjdXJyZW50VGltZSh0aW1lKSB7XG4gICAgY29uc3QgdCA9IHRpbWUgKiAoZ2xvYmFscy50aW1lU2NhbGUgPT09IDEgPyAxIDogSyk7XG4gICAgdGhpcy5mb3JFYWNoKGFuaW0gPT4ge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb24gcGxheVN0YXRlIGlzIG5vdCAncGF1c2VkJyBpbiBvcmRlciB0byBwcm9wZXJseSB0cmlnZ2VyIGFuIG9uZmluaXNoIGNhbGxiYWNrLlxuICAgICAgLy8gVGhlIFwicGF1c2VkXCIgcGxheSBzdGF0ZSBzdXBlcnNlZGVzIHRoZSBcImZpbmlzaGVkXCIgcGxheSBzdGF0ZTsgaWYgdGhlIGFuaW1hdGlvbiBpcyBib3RoIHBhdXNlZCBhbmQgZmluaXNoZWQsIHRoZSBcInBhdXNlZFwiIHN0YXRlIGlzIHRoZSBvbmUgdGhhdCB3aWxsIGJlIHJlcG9ydGVkLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbi9maW5pc2hfZXZlbnRcbiAgICAgIGlmICh0ID49IHRoaXMuZHVyYXRpb24pIGFuaW0ucGxheSgpO1xuICAgICAgYW5pbS5jdXJyZW50VGltZSA9IHQ7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUgLyB0aGlzLmR1cmF0aW9uO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAqL1xuICBzZXQgcHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmZvckVhY2goYW5pbSA9PiBhbmltLmN1cnJlbnRUaW1lID0gcHJvZ3Jlc3MgKiB0aGlzLmR1cmF0aW9uIHx8IDApO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgLy8gVE9ETzogU3RvcmUgdGhlIGN1cnJlbnQgdGltZSwgYW5kIHNlZWsgYmFjayB0byB0aGUgbGFzdCBwb3NpdGlvblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ3BsYXknKTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLnBhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ3BhdXNlJyk7XG4gIH1cblxuICBhbHRlcm5hdGUoKSB7XG4gICAgdGhpcy5yZXZlcnNlZCA9ICF0aGlzLnJldmVyc2VkO1xuICAgIHRoaXMuZm9yRWFjaCgncmV2ZXJzZScpO1xuICAgIGlmICh0aGlzLnBhdXNlZCkgdGhpcy5mb3JFYWNoKCdwYXVzZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5yZXZlcnNlZCkgdGhpcy5hbHRlcm5hdGUoKTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldmVyc2UoKSB7XG4gICAgaWYgKCF0aGlzLnJldmVyc2VkKSB0aGlzLmFsdGVybmF0ZSgpO1xuICAgIHJldHVybiB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAvKipcbiAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gbXV0ZUNhbGxiYWNrc1xuICAqL1xuICBzZWVrKHRpbWUsIG11dGVDYWxsYmFja3MgPSBmYWxzZSkge1xuICAgIGlmIChtdXRlQ2FsbGJhY2tzKSB0aGlzLm11dGVDYWxsYmFja3MgPSB0cnVlO1xuICAgIGlmICh0aW1lIDwgdGhpcy5kdXJhdGlvbikgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZTtcbiAgICB0aGlzLm11dGVDYWxsYmFja3MgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXVzZWQpIHRoaXMucGF1c2UoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlc3RhcnQoKSB7XG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zZWVrKDAsIHRydWUpLnJlc3VtZSgpO1xuICB9XG5cbiAgY29tbWl0U3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ2NvbW1pdFN0eWxlcycpO1xuICB9XG5cbiAgY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vlayh0aGlzLmR1cmF0aW9uKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmZvckVhY2goJ2NhbmNlbCcpO1xuICAgIHJldHVybiB0aGlzLnBhdXNlKCk7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcbiAgICB0aGlzLnRhcmdldHMuZm9yRWFjaCgoJGVsLCBpKSA9PiAkZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuX2lubGluZVN0eWxlc1tpXSkgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtXQUFQSUNhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB0aGVuKGNhbGxiYWNrID0gbm9vcCkge1xuICAgIGNvbnN0IHRoZW4gPSB0aGlzLnRoZW47XG4gICAgY29uc3Qgb25SZXNvbHZlID0gKCkgPT4ge1xuICAgICAgdGhpcy50aGVuID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgdGhpcy50aGVuID0gdGhlbjtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBub29wO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHIgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9ICgpID0+IHIob25SZXNvbHZlKCkpO1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVkKSB0aGlzLl9yZXNvbHZlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCB3YWFwaSA9IHtcbi8qKlxuICogQHBhcmFtIHtET01UYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEBwYXJhbSB7V0FBUElBbmltYXRpb25QYXJhbXN9IHBhcmFtc1xuICogQHJldHVybiB7V0FBUElBbmltYXRpb259XG4gKi9cbiAgYW5pbWF0ZTogKHRhcmdldHMsIHBhcmFtcykgPT4gbmV3IFdBQVBJQW5pbWF0aW9uKHRhcmdldHMsIHBhcmFtcyksXG4gIGNvbnZlcnRFYXNlOiBlYXNpbmdUb0xpbmVhclxufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtDYWxsYmFjazxUaW1lcj59IFtjYWxsYmFja11cbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCBzeW5jID0gKGNhbGxiYWNrID0gbm9vcCkgPT4ge1xuICByZXR1cm4gbmV3IFRpbWVyKHsgZHVyYXRpb246IDEgKiBnbG9iYWxzLnRpbWVTY2FsZSwgb25Db21wbGV0ZTogY2FsbGJhY2sgfSwgbnVsbCwgMCkucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0U2VsZWN0b3J9IHRhcmdldFNlbGVjdG9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgcHJvcE5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0pTVGFyZ2V0c1BhcmFtfSB0YXJnZXRTZWxlY3RvclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgIHByb3BOYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfSB0YXJnZXRTZWxlY3RvclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICBwcm9wTmFtZVxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICB1bml0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldFNlbGVjdG9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIHByb3BOYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgIHVuaXRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19ICAgdGFyZ2V0U2VsZWN0b3JcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICBwcm9wTmFtZVxuICogQHBhcmFtICB7U3RyaW5nfEJvb2xlYW59IFt1bml0XVxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRWYWx1ZSh0YXJnZXRTZWxlY3RvciwgcHJvcE5hbWUsIHVuaXQpIHtcbiAgY29uc3QgdGFyZ2V0cyA9IHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRTZWxlY3Rvcik7XG4gIGlmICghdGFyZ2V0cy5sZW5ndGgpIHJldHVybjtcbiAgY29uc3QgWyB0YXJnZXQgXSA9IHRhcmdldHM7XG4gIGNvbnN0IHR3ZWVuVHlwZSA9IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgY29uc3Qgbm9ybWFsaXplUHJvcE5hbWUgPSBzYW5pdGl6ZVByb3BlcnR5TmFtZShwcm9wTmFtZSwgdGFyZ2V0LCB0d2VlblR5cGUpO1xuICBsZXQgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgbm9ybWFsaXplUHJvcE5hbWUpO1xuICBpZiAoaXNVbmQodW5pdCkpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBkZWNvbXBvc2VSYXdWYWx1ZShvcmlnaW5hbFZhbHVlLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSk7XG4gICAgaWYgKGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuTlVNQkVSIHx8IGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVCkge1xuICAgICAgaWYgKHVuaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0VmFsdWVVbml0KC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSwgLyoqIEB0eXBlIHtTdHJpbmd9ICovKHVuaXQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBgJHtyb3VuZChjb252ZXJ0ZWRWYWx1ZS5uLCBnbG9iYWxzLnByZWNpc2lvbil9JHtjb252ZXJ0ZWRWYWx1ZS51fWA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSAgICB0YXJnZXRzXG4gKiBAcGFyYW0gIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0pTQW5pbWF0aW9ufVxuICovXG5jb25zdCBzZXRUYXJnZXRWYWx1ZXMgPSAodGFyZ2V0cywgcGFyYW1ldGVycykgPT4ge1xuICBpZiAoaXNVbmQocGFyYW1ldGVycykpIHJldHVybjtcbiAgcGFyYW1ldGVycy5kdXJhdGlvbiA9IG1pblZhbHVlO1xuICAvLyBEbyBub3Qgb3ZlcnJpZGVzIGN1cnJlbnRseSBhY3RpdmUgdHdlZW5zIGJ5IGRlZmF1bHRcbiAgcGFyYW1ldGVycy5jb21wb3NpdGlvbiA9IHNldFZhbHVlKHBhcmFtZXRlcnMuY29tcG9zaXRpb24sIGNvbXBvc2l0aW9uVHlwZXMubm9uZSk7XG4gIC8vIFNraXAgaW5pdCgpIGFuZCBmb3JjZSByZW5kZXJpbmcgYnkgcGxheWluZyB0aGUgYW5pbWF0aW9uXG4gIHJldHVybiBuZXcgSlNBbmltYXRpb24odGFyZ2V0cywgcGFyYW1ldGVycywgbnVsbCwgMCwgdHJ1ZSkucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNBcnJheX0gdGFyZ2V0c0FycmF5XG4gKiBAcGFyYW0gIHtKU0FuaW1hdGlvbn0gICAgYW5pbWF0aW9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIFtwcm9wZXJ0eU5hbWVdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbiA9ICh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbiwgcHJvcGVydHlOYW1lKSA9PiB7XG4gIGxldCB0d2VlbnNNYXRjaGVzVGFyZ2V0cyA9IGZhbHNlO1xuICBmb3JFYWNoQ2hpbGRyZW4oYW5pbWF0aW9uLCAoLyoqQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgY29uc3QgdHdlZW5UYXJnZXQgPSB0d2Vlbi50YXJnZXQ7XG4gICAgaWYgKHRhcmdldHNBcnJheS5pbmNsdWRlcyh0d2VlblRhcmdldCkpIHtcbiAgICAgIGNvbnN0IHR3ZWVuTmFtZSA9IHR3ZWVuLnByb3BlcnR5O1xuICAgICAgY29uc3QgdHdlZW5UeXBlID0gdHdlZW4uX3R3ZWVuVHlwZTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZVByb3BOYW1lID0gc2FuaXRpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lLCB0d2VlblRhcmdldCwgdHdlZW5UeXBlKTtcbiAgICAgIGlmICghbm9ybWFsaXplUHJvcE5hbWUgfHwgbm9ybWFsaXplUHJvcE5hbWUgJiYgbm9ybWFsaXplUHJvcE5hbWUgPT09IHR3ZWVuTmFtZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gZmxhZyB0aGUgcHJldmlvdXMgQ1NTIHRyYW5zZm9ybSB0d2VlbiB0byByZW5kZXJUcmFuc2Zvcm1cbiAgICAgICAgaWYgKHR3ZWVuLnBhcmVudC5fdGFpbCA9PT0gdHdlZW4gJiZcbiAgICAgICAgICAgIHR3ZWVuLl90d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuVFJBTlNGT1JNICYmXG4gICAgICAgICAgICB0d2Vlbi5fcHJldiAmJlxuICAgICAgICAgICAgdHdlZW4uX3ByZXYuX3R3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk1cbiAgICAgICAgKSB7XG4gICAgICAgICAgdHdlZW4uX3ByZXYuX3JlbmRlclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIHR3ZWVuIGZyb20gdGhlIHNlbGVjdGVkIGFuaW1hdGlvblxuICAgICAgICByZW1vdmVDaGlsZChhbmltYXRpb24sIHR3ZWVuKTtcbiAgICAgICAgLy8gRGV0YWNoIHRoZSB0d2VlbiBmcm9tIGl0cyBzaWJsaW5ncyB0byBtYWtlIHN1cmUgYmxlbmRlZCB0d2VlbnMgYXJlIGNvcnJlY3RsbHkgcmVtb3ZlZFxuICAgICAgICByZW1vdmVUd2VlblNsaWJsaW5ncyh0d2Vlbik7XG4gICAgICAgIHR3ZWVuc01hdGNoZXNUYXJnZXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUpO1xuICByZXR1cm4gdHdlZW5zTWF0Y2hlc1RhcmdldHM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtICB7UmVuZGVyYWJsZXxXQUFQSUFuaW1hdGlvbn0gW3JlbmRlcmFibGVdXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICBbcHJvcGVydHlOYW1lXVxuICogQHJldHVybiB7VGFyZ2V0c0FycmF5fVxuICovXG5jb25zdCByZW1vdmUgPSAodGFyZ2V0cywgcmVuZGVyYWJsZSwgcHJvcGVydHlOYW1lKSA9PiB7XG4gIGNvbnN0IHRhcmdldHNBcnJheSA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtSZW5kZXJhYmxlfHR5cGVvZiBlbmdpbmV9ICoqLyhyZW5kZXJhYmxlID8gcmVuZGVyYWJsZSA6IGVuZ2luZSk7XG4gIGNvbnN0IHdhYXBpQW5pbWF0aW9uID0gcmVuZGVyYWJsZSAmJiAvKiogQHR5cGUge1dBQVBJQW5pbWF0aW9ufSAqLyhyZW5kZXJhYmxlKS5jb250cm9sQW5pbWF0aW9uICYmIC8qKiBAdHlwZSB7V0FBUElBbmltYXRpb259ICovKHJlbmRlcmFibGUpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHRhcmdldHNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCAkZWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gICovKHRhcmdldHNBcnJheVtpXSk7XG4gICAgcmVtb3ZlV0FBUElBbmltYXRpb24oJGVsLCBwcm9wZXJ0eU5hbWUsIHdhYXBpQW5pbWF0aW9uKTtcbiAgfVxuICBsZXQgcmVtb3ZlTWF0Y2hlcztcbiAgaWYgKHBhcmVudC5faGFzQ2hpbGRyZW4pIHtcbiAgICBsZXQgaXRlcmF0aW9uRHVyYXRpb24gPSAwO1xuICAgIGZvckVhY2hDaGlsZHJlbihwYXJlbnQsICgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQuX2hhc0NoaWxkcmVuKSB7XG4gICAgICAgIHJlbW92ZU1hdGNoZXMgPSByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbih0YXJnZXRzQXJyYXksIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKGNoaWxkKSwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBmcm9tIGl0cyBwYXJlbnQgaWYgbm8gdHdlZW5zIGFuZCBubyBjaGlsZHJlbiBsZWZ0IGFmdGVyIHRoZSByZW1vdmFsXG4gICAgICAgIGlmIChyZW1vdmVNYXRjaGVzICYmICFjaGlsZC5faGVhZCkge1xuICAgICAgICAgIGNoaWxkLmNhbmNlbCgpO1xuICAgICAgICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IGl0ZXJhdGlvbkR1cmF0aW9uIHZhbHVlIHRvIGhhbmRsZSBvbkNvbXBsZXRlIHdpdGggbGFzdCBjaGlsZCBpbiByZW5kZXIoKVxuICAgICAgICAgIGNvbnN0IGNoaWxkVExPZmZzZXQgPSBjaGlsZC5fb2Zmc2V0ICsgY2hpbGQuX2RlbGF5O1xuICAgICAgICAgIGNvbnN0IGNoaWxkRHVyID0gY2hpbGRUTE9mZnNldCArIGNoaWxkLmR1cmF0aW9uO1xuICAgICAgICAgIGlmIChjaGlsZER1ciA+IGl0ZXJhdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpdGVyYXRpb25EdXJhdGlvbiA9IGNoaWxkRHVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIHRvIGFsc28gcmVtb3ZlIGVuZ2luZSdzIGNoaWxkcmVuIHRhcmdldHNcbiAgICAgIC8vIE5PVEU6IEF2b2lkIHJlY3Vyc2lvbj9cbiAgICAgIGlmIChjaGlsZC5faGVhZCkge1xuICAgICAgICByZW1vdmUodGFyZ2V0cywgY2hpbGQsIHByb3BlcnR5TmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcbiAgICAvLyBVcGRhdGUgaXRlcmF0aW9uRHVyYXRpb24gdmFsdWUgdG8gaGFuZGxlIG9uQ29tcGxldGUgd2l0aCBsYXN0IGNoaWxkIGluIHJlbmRlcigpXG4gICAgaWYgKCFpc1VuZCgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovKHBhcmVudCkuaXRlcmF0aW9uRHVyYXRpb24pKSB7XG4gICAgICAvKiogQHR5cGUge1JlbmRlcmFibGV9ICovKHBhcmVudCkuaXRlcmF0aW9uRHVyYXRpb24gPSBpdGVyYXRpb25EdXJhdGlvbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlTWF0Y2hlcyA9IHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9uKFxuICAgICAgdGFyZ2V0c0FycmF5LFxuICAgICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8ocGFyZW50KSxcbiAgICAgIHByb3BlcnR5TmFtZVxuICAgICk7XG4gIH1cblxuICBpZiAocmVtb3ZlTWF0Y2hlcyAmJiAhcGFyZW50Ll9oZWFkKSB7XG4gICAgcGFyZW50Ll9oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICAgIC8vIENhbmNlbCB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyB0d2VlbnMgYW5kIG5vIGNoaWxkcmVuIGxlZnQgYWZ0ZXIgdGhlIHJlbW92YWxcbiAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIHRoZSAuY2FuY2VsKCkgbWV0aG9kIGV4aXN0IHRvIGhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIHRoZSBlbmdpbmUgaXRzZWxmXG4gICAgaWYgKC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi8ocGFyZW50KS5jYW5jZWwpIC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi8ocGFyZW50KS5jYW5jZWwoKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRzQXJyYXk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAgeyguLi5hcmdzOiBhbnlbXSkgPT4gVGlja2FibGV9IGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHsoLi4uYXJnczogYW55W10pID0+IFRpY2thYmxlfVxuICovXG5jb25zdCBrZWVwVGltZSA9IGNyZWF0ZVJlZnJlc2hhYmxlO1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gaXRlbXNcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgcmFuZG9tUGljayA9IGl0ZW1zID0+IGl0ZW1zW3JhbmRvbSgwLCBpdGVtcy5sZW5ndGggLSAxKV07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gdlxuICogQHBhcmFtICB7TnVtYmVyfSBkZWNpbWFsTGVuZ3RoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHJvdW5kUGFkID0gKHYsIGRlY2ltYWxMZW5ndGgpID0+ICgrdikudG9GaXhlZChkZWNpbWFsTGVuZ3RoKTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcn0gdG90YWxMZW5ndGhcbiAqIEBwYXJhbSAge1N0cmluZ30gcGFkU3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhZFN0YXJ0ID0gKHYsIHRvdGFsTGVuZ3RoLCBwYWRTdHJpbmcpID0+IGAke3Z9YC5wYWRTdGFydCh0b3RhbExlbmd0aCwgcGFkU3RyaW5nKTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcn0gdG90YWxMZW5ndGhcbiAqIEBwYXJhbSAge1N0cmluZ30gcGFkU3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhZEVuZCA9ICh2LCB0b3RhbExlbmd0aCwgcGFkU3RyaW5nKSA9PiBgJHt2fWAucGFkRW5kKHRvdGFsTGVuZ3RoLCBwYWRTdHJpbmcpO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdlxuICogQHBhcmFtICB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IHdyYXAgPSAodiwgbWluLCBtYXgpID0+ICgoKHYgLSBtaW4pICUgKG1heCAtIG1pbikgKyAobWF4IC0gbWluKSkgJSAobWF4IC0gbWluKSkgKyBtaW47XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtICB7TnVtYmVyfSBpbkxvd1xuICogQHBhcmFtICB7TnVtYmVyfSBpbkhpZ2hcbiAqIEBwYXJhbSAge051bWJlcn0gb3V0TG93XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG91dEhpZ2hcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgbWFwUmFuZ2UgPSAodmFsdWUsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkgPT4gb3V0TG93ICsgKCh2YWx1ZSAtIGluTG93KSAvIChpbkhpZ2ggLSBpbkxvdykpICogKG91dEhpZ2ggLSBvdXRMb3cpO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gZGVncmVlc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBkZWdUb1JhZCA9IGRlZ3JlZXMgPT4gZGVncmVlcyAqIFBJIC8gMTgwO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gcmFkaWFuc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCByYWRUb0RlZyA9IHJhZGlhbnMgPT4gcmFkaWFucyAqIDE4MCAvIFBJO1xuXG4vKipcbiAqIGh0dHBzOi8vd3d3LnJvcnlkcmlzY29sbC5jb20vMjAxNi8wMy8wNy9mcmFtZS1yYXRlLWluZGVwZW5kZW50LWRhbXBpbmctdXNpbmctbGVycC9cbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSAge051bWJlcn0gZW5kXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFtb3VudFxuICogQHBhcmFtICB7UmVuZGVyYWJsZXxCb29sZWFufSBbcmVuZGVyYWJsZV1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgbGVycCA9IChzdGFydCwgZW5kLCBhbW91bnQsIHJlbmRlcmFibGUpID0+IHtcbiAgbGV0IGR0ID0gSyAvIGdsb2JhbHMuZGVmYXVsdHMuZnJhbWVSYXRlO1xuICBpZiAocmVuZGVyYWJsZSAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCB0aWNrZXIgPSAvKiogQHR5cGUgUmVuZGVyYWJsZSAqL1xuICAgICAgICAgICAgICAgICAgIChyZW5kZXJhYmxlKSB8fFxuICAgICAgICAgICAgICAgICAgIChlbmdpbmUuX2hhc0NoaWxkcmVuICYmIGVuZ2luZSk7XG4gICAgaWYgKHRpY2tlciAmJiB0aWNrZXIuZGVsdGFUaW1lKSB7XG4gICAgICBkdCA9IHRpY2tlci5kZWx0YVRpbWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IHQgPSAxIC0gTWF0aC5leHAoLWFtb3VudCAqIGR0ICogLjEpO1xuICByZXR1cm4gIWFtb3VudCA/IHN0YXJ0IDogYW1vdW50ID09PSAxID8gZW5kIDogKDEgLSB0KSAqIHN0YXJ0ICsgdCAqIGVuZDtcbn07XG5cbi8vIENoYWluLWFibGUgdXRpbGl0aWVzXG5cbi8qKlxuICogQGNhbGxiYWNrIFV0aWxpdHlGdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICpcbiAqIEBwYXJhbSB7VXRpbGl0eUZ1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IFtsYXN0PTBdXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi4oTnVtYmVyfFN0cmluZykpOiBmdW5jdGlvbihOdW1iZXJ8U3RyaW5nKTogKE51bWJlcnxTdHJpbmcpfVxuICovXG5jb25zdCBjdXJyeSA9IChmbiwgbGFzdCA9IDApID0+ICguLi5hcmdzKSA9PiBsYXN0ID8gdiA9PiBmbiguLi5hcmdzLCB2KSA6IHYgPT4gZm4odiwgLi4uYXJncyk7XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLihOdW1iZXJ8U3RyaW5nKSl9XG4gKi9cbmNvbnN0IGNoYWluID0gZm4gPT4ge1xuICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgcmV0dXJuIG5ldyBQcm94eShub29wLCB7XG4gICAgICBhcHBseTogKF8sIF9fLCBbdl0pID0+IHJlc3VsdCh2KSxcbiAgICAgIGdldDogKF8sIHByb3ApID0+IGNoYWluKC8qKkBwYXJhbSB7Li4uTnVtYmVyfFN0cmluZ30gbmV4dEFyZ3MgKi8oLi4ubmV4dEFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dFJlc3VsdCA9IHV0aWxzW3Byb3BdKC4uLm5leHRBcmdzKTtcbiAgICAgICAgcmV0dXJuICgvKipAdHlwZSB7TnVtYmVyfFN0cmluZ30gKi92KSA9PiBuZXh0UmVzdWx0KHJlc3VsdCh2KSk7XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VXRpbGl0eUZ1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IFtyaWdodF1cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLihOdW1iZXJ8U3RyaW5nKSk6IFV0aWxpdHlGdW5jdGlvbn1cbiAqL1xuY29uc3QgbWFrZUNoYWluYWJsZSA9IChmbiwgcmlnaHQgPSAwKSA9PiAoLi4uYXJncykgPT4gKGFyZ3MubGVuZ3RoIDwgZm4ubGVuZ3RoID8gY2hhaW4oY3VycnkoZm4sIHJpZ2h0KSkgOiBmbikoLi4uYXJncyk7XG5cbi8qKlxuICogQGNhbGxiYWNrIENoYWluZWRVdGlsc1Jlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhaW5hYmxlVXRpbHNcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZENsYW1wfSBjbGFtcFxuICogQHByb3BlcnR5IHtDaGFpbmVkUm91bmR9IHJvdW5kXG4gKiBAcHJvcGVydHkge0NoYWluZWRTbmFwfSBzbmFwXG4gKiBAcHJvcGVydHkge0NoYWluZWRXcmFwfSB3cmFwXG4gKiBAcHJvcGVydHkge0NoYWluZWRJbnRlcnBvbGF0ZX0gaW50ZXJwb2xhdGVcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZE1hcFJhbmdlfSBtYXBSYW5nZVxuICogQHByb3BlcnR5IHtDaGFpbmVkUm91bmRQYWR9IHJvdW5kUGFkXG4gKiBAcHJvcGVydHkge0NoYWluZWRQYWRTdGFydH0gcGFkU3RhcnRcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZFBhZEVuZH0gcGFkRW5kXG4gKiBAcHJvcGVydHkge0NoYWluZWREZWdUb1JhZH0gZGVnVG9SYWRcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZFJhZFRvRGVnfSByYWRUb0RlZ1xuICpcbiAqIEB0eXBlZGVmIHtDaGFpbmFibGVVdGlscyAmIENoYWluZWRVdGlsc1Jlc3VsdH0gQ2hhaW5hYmxlVXRpbFxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkQ2xhbXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRSb3VuZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlY2ltYWxMZW5ndGhcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRTbmFwXG4gKiBAcGFyYW0ge051bWJlcn0gaW5jcmVtZW50XG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkV3JhcFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZEludGVycG9sYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRNYXBSYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IGluTG93XG4gKiBAcGFyYW0ge051bWJlcn0gaW5IaWdoXG4gKiBAcGFyYW0ge051bWJlcn0gb3V0TG93XG4gKiBAcGFyYW0ge051bWJlcn0gb3V0SGlnaFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZFJvdW5kUGFkXG4gKiBAcGFyYW0ge051bWJlcn0gZGVjaW1hbExlbmd0aFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZFBhZFN0YXJ0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWRTdHJpbmdcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRQYWRFbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHBhZFN0cmluZ1xuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZERlZ1RvUmFkXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkUmFkVG9EZWdcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKi9cblxuY29uc3QgdXRpbHMgPSB7XG4gICQ6IHJlZ2lzdGVyVGFyZ2V0cyxcbiAgZ2V0OiBnZXRUYXJnZXRWYWx1ZSxcbiAgc2V0OiBzZXRUYXJnZXRWYWx1ZXMsXG4gIHJlbW92ZSxcbiAgY2xlYW5JbmxpbmVTdHlsZXMsXG4gIHJhbmRvbSxcbiAgcmFuZG9tUGljayxcbiAgc2h1ZmZsZSxcbiAgbGVycCxcbiAgc3luYyxcbiAga2VlcFRpbWUsXG4gIGNsYW1wOiAvKiogQHR5cGUge3R5cGVvZiBjbGFtcCAmIENoYWluZWRDbGFtcH0gKi8obWFrZUNoYWluYWJsZShjbGFtcCkpLFxuICByb3VuZDogLyoqIEB0eXBlIHt0eXBlb2Ygcm91bmQgJiBDaGFpbmVkUm91bmR9ICovKG1ha2VDaGFpbmFibGUocm91bmQpKSxcbiAgc25hcDogLyoqIEB0eXBlIHt0eXBlb2Ygc25hcCAmIENoYWluZWRTbmFwfSAqLyhtYWtlQ2hhaW5hYmxlKHNuYXApKSxcbiAgd3JhcDogLyoqIEB0eXBlIHt0eXBlb2Ygd3JhcCAmIENoYWluZWRXcmFwfSAqLyhtYWtlQ2hhaW5hYmxlKHdyYXApKSxcbiAgaW50ZXJwb2xhdGU6IC8qKiBAdHlwZSB7dHlwZW9mIGludGVycG9sYXRlICYgQ2hhaW5lZEludGVycG9sYXRlfSAqLyhtYWtlQ2hhaW5hYmxlKGludGVycG9sYXRlLCAxKSksXG4gIG1hcFJhbmdlOiAvKiogQHR5cGUge3R5cGVvZiBtYXBSYW5nZSAmIENoYWluZWRNYXBSYW5nZX0gKi8obWFrZUNoYWluYWJsZShtYXBSYW5nZSkpLFxuICByb3VuZFBhZDogLyoqIEB0eXBlIHt0eXBlb2Ygcm91bmRQYWQgJiBDaGFpbmVkUm91bmRQYWR9ICovKG1ha2VDaGFpbmFibGUocm91bmRQYWQpKSxcbiAgcGFkU3RhcnQ6IC8qKiBAdHlwZSB7dHlwZW9mIHBhZFN0YXJ0ICYgQ2hhaW5lZFBhZFN0YXJ0fSAqLyhtYWtlQ2hhaW5hYmxlKHBhZFN0YXJ0KSksXG4gIHBhZEVuZDogLyoqIEB0eXBlIHt0eXBlb2YgcGFkRW5kICYgQ2hhaW5lZFBhZEVuZH0gKi8obWFrZUNoYWluYWJsZShwYWRFbmQpKSxcbiAgZGVnVG9SYWQ6IC8qKiBAdHlwZSB7dHlwZW9mIGRlZ1RvUmFkICYgQ2hhaW5lZERlZ1RvUmFkfSAqLyhtYWtlQ2hhaW5hYmxlKGRlZ1RvUmFkKSksXG4gIHJhZFRvRGVnOiAvKiogQHR5cGUge3R5cGVvZiByYWRUb0RlZyAmIENoYWluZWRSYWRUb0RlZ30gKi8obWFrZUNoYWluYWJsZShyYWRUb0RlZykpLFxufTtcblxuXG5cblxuLyoqXG4gKiBUaW1lbGluZSdzIGNoaWxkcmVuIG9mZnNldHMgcG9zaXRpb25zIHBhcnNlclxuICogQHBhcmFtICB7VGltZWxpbmV9IHRpbWVsaW5lXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHRpbWVQb3NpdGlvblxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBnZXRQcmV2Q2hpbGRPZmZzZXQgPSAodGltZWxpbmUsIHRpbWVQb3NpdGlvbikgPT4ge1xuICBpZiAoc3RyaW5nU3RhcnRzV2l0aCh0aW1lUG9zaXRpb24sICc8JykpIHtcbiAgICBjb25zdCBnb1RvUHJldkFuaW1hdGlvbk9mZnNldCA9IHRpbWVQb3NpdGlvblsxXSA9PT0gJzwnO1xuICAgIGNvbnN0IHByZXZBbmltYXRpb24gPSAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0aW1lbGluZS5fdGFpbCk7XG4gICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZBbmltYXRpb24gPyBwcmV2QW5pbWF0aW9uLl9vZmZzZXQgKyBwcmV2QW5pbWF0aW9uLl9kZWxheSA6IDA7XG4gICAgcmV0dXJuIGdvVG9QcmV2QW5pbWF0aW9uT2Zmc2V0ID8gcHJldk9mZnNldCA6IHByZXZPZmZzZXQgKyBwcmV2QW5pbWF0aW9uLmR1cmF0aW9uO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RpbWVsaW5lfSB0aW1lbGluZVxuICogQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gW3RpbWVQb3NpdGlvbl1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcGFyc2VUaW1lbGluZVBvc2l0aW9uID0gKHRpbWVsaW5lLCB0aW1lUG9zaXRpb24pID0+IHtcbiAgbGV0IHRsRHVyYXRpb24gPSB0aW1lbGluZS5pdGVyYXRpb25EdXJhdGlvbjtcbiAgaWYgKHRsRHVyYXRpb24gPT09IG1pblZhbHVlKSB0bER1cmF0aW9uID0gMDtcbiAgaWYgKGlzVW5kKHRpbWVQb3NpdGlvbikpIHJldHVybiB0bER1cmF0aW9uO1xuICBpZiAoaXNOdW0oK3RpbWVQb3NpdGlvbikpIHJldHVybiArdGltZVBvc2l0aW9uO1xuICBjb25zdCB0aW1lUG9zU3RyID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHRpbWVQb3NpdGlvbik7XG4gIGNvbnN0IHRsTGFiZWxzID0gdGltZWxpbmUgPyB0aW1lbGluZS5sYWJlbHMgOiBudWxsO1xuICBjb25zdCBoYXNMYWJlbHMgPSAhaXNOaWwodGxMYWJlbHMpO1xuICBjb25zdCBwcmV2T2Zmc2V0ID0gZ2V0UHJldkNoaWxkT2Zmc2V0KHRpbWVsaW5lLCB0aW1lUG9zU3RyKTtcbiAgY29uc3QgaGFzU2libGluZyA9ICFpc1VuZChwcmV2T2Zmc2V0KTtcbiAgY29uc3QgbWF0Y2hlZFJlbGF0aXZlT3BlcmF0b3IgPSByZWxhdGl2ZVZhbHVlc0V4ZWNSZ3guZXhlYyh0aW1lUG9zU3RyKTtcbiAgaWYgKG1hdGNoZWRSZWxhdGl2ZU9wZXJhdG9yKSB7XG4gICAgY29uc3QgZnVsbE9wZXJhdG9yID0gbWF0Y2hlZFJlbGF0aXZlT3BlcmF0b3JbMF07XG4gICAgY29uc3Qgc3BsaXQgPSB0aW1lUG9zU3RyLnNwbGl0KGZ1bGxPcGVyYXRvcik7XG4gICAgY29uc3QgbGFiZWxPZmZzZXQgPSBoYXNMYWJlbHMgJiYgc3BsaXRbMF0gPyB0bExhYmVsc1tzcGxpdFswXV0gOiB0bER1cmF0aW9uO1xuICAgIGNvbnN0IHBhcnNlZE9mZnNldCA9IGhhc1NpYmxpbmcgPyBwcmV2T2Zmc2V0IDogaGFzTGFiZWxzID8gbGFiZWxPZmZzZXQgOiB0bER1cmF0aW9uO1xuICAgIGNvbnN0IHBhcnNlZE51bWVyaWNhbE9mZnNldCA9ICtzcGxpdFsxXTtcbiAgICByZXR1cm4gZ2V0UmVsYXRpdmVWYWx1ZShwYXJzZWRPZmZzZXQsIHBhcnNlZE51bWVyaWNhbE9mZnNldCwgZnVsbE9wZXJhdG9yWzBdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzU2libGluZyA/IHByZXZPZmZzZXQgOlxuICAgICAgICAgICBoYXNMYWJlbHMgPyAhaXNVbmQodGxMYWJlbHNbdGltZVBvc1N0cl0pID8gdGxMYWJlbHNbdGltZVBvc1N0cl0gOlxuICAgICAgICAgICB0bER1cmF0aW9uIDogdGxEdXJhdGlvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVsaW5lfSB0bFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRUaW1lbGluZVRvdGFsRHVyYXRpb24odGwpIHtcbiAgcmV0dXJuIGNsYW1wSW5maW5pdHkoKCh0bC5pdGVyYXRpb25EdXJhdGlvbiArIHRsLl9sb29wRGVsYXkpICogdGwuaXRlcmF0aW9uQ291bnQpIC0gdGwuX2xvb3BEZWxheSkgfHwgbWluVmFsdWU7XG59XG5cbi8qKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtUaW1lclBhcmFtc30gY2hpbGRQYXJhbXNcbiAqIEBwYXJhbSAge1RpbWVsaW5lfSB0bFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lUG9zaXRpb25cbiAqIEByZXR1cm4ge1RpbWVsaW5lfVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7QW5pbWF0aW9uUGFyYW1zfSBjaGlsZFBhcmFtc1xuICogQHBhcmFtICB7VGltZWxpbmV9IHRsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVQb3NpdGlvblxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtpbmRleF1cbiAqIEBwYXJhbSAge051bWJlcn0gW2xlbmd0aF1cbiAqIEByZXR1cm4ge1RpbWVsaW5lfVxuICpcbiAqIEBwYXJhbSAge1RpbWVyUGFyYW1zfEFuaW1hdGlvblBhcmFtc30gY2hpbGRQYXJhbXNcbiAqIEBwYXJhbSAge1RpbWVsaW5lfSB0bFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lUG9zaXRpb25cbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gW3RhcmdldHNdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtpbmRleF1cbiAqIEBwYXJhbSAge051bWJlcn0gW2xlbmd0aF1cbiAqL1xuZnVuY3Rpb24gYWRkVGxDaGlsZChjaGlsZFBhcmFtcywgdGwsIHRpbWVQb3NpdGlvbiwgdGFyZ2V0cywgaW5kZXgsIGxlbmd0aCkge1xuICBjb25zdCBpc1NldHRlciA9IGlzTnVtKGNoaWxkUGFyYW1zLmR1cmF0aW9uKSAmJiAvKiogQHR5cGUge051bWJlcn0gKi8oY2hpbGRQYXJhbXMuZHVyYXRpb24pIDw9IG1pblZhbHVlO1xuICAvLyBPZmZzZXQgdGhlIHRsIHBvc2l0aW9uIHdpdGggLW1pblZhbHVlIGZvciAwIGR1cmF0aW9uIGFuaW1hdGlvbnMgb3IgLnNldCgpIGNhbGxzIGluIG9yZGVyIHRvIGFsaWduIHRoZWlyIGVuZCB2YWx1ZSB3aXRoIHRoZSBkZWZpbmVkIHBvc2l0aW9uXG4gIGNvbnN0IGFkanVzdGVkUG9zaXRpb24gPSBpc1NldHRlciA/IHRpbWVQb3NpdGlvbiAtIG1pblZhbHVlIDogdGltZVBvc2l0aW9uO1xuICB0aWNrKHRsLCBhZGp1c3RlZFBvc2l0aW9uLCAxLCAxLCB0aWNrTW9kZXMuQVVUTyk7XG4gIGNvbnN0IHRsQ2hpbGQgPSB0YXJnZXRzID9cbiAgICBuZXcgSlNBbmltYXRpb24odGFyZ2V0cywvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi8oY2hpbGRQYXJhbXMpLCB0bCwgYWRqdXN0ZWRQb3NpdGlvbiwgZmFsc2UsIGluZGV4LCBsZW5ndGgpIDpcbiAgICBuZXcgVGltZXIoLyoqIEB0eXBlIHtUaW1lclBhcmFtc30gKi8oY2hpbGRQYXJhbXMpLCB0bCwgYWRqdXN0ZWRQb3NpdGlvbik7XG4gIHRsQ2hpbGQuaW5pdCgxKTtcbiAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIHRvIGluc2VydCBhdCBhIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHN0YXJ0VGltZT9cbiAgYWRkQ2hpbGQodGwsIHRsQ2hpbGQpO1xuICBmb3JFYWNoQ2hpbGRyZW4odGwsICgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovY2hpbGQpID0+IHtcbiAgICBjb25zdCBjaGlsZFRMT2Zmc2V0ID0gY2hpbGQuX29mZnNldCArIGNoaWxkLl9kZWxheTtcbiAgICBjb25zdCBjaGlsZER1ciA9IGNoaWxkVExPZmZzZXQgKyBjaGlsZC5kdXJhdGlvbjtcbiAgICBpZiAoY2hpbGREdXIgPiB0bC5pdGVyYXRpb25EdXJhdGlvbikgdGwuaXRlcmF0aW9uRHVyYXRpb24gPSBjaGlsZER1cjtcbiAgfSk7XG4gIHRsLmR1cmF0aW9uID0gZ2V0VGltZWxpbmVUb3RhbER1cmF0aW9uKHRsKTtcbiAgcmV0dXJuIHRsO1xufVxuXG5jbGFzcyBUaW1lbGluZSBleHRlbmRzIFRpbWVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtUaW1lbGluZVBhcmFtc30gW3BhcmFtZXRlcnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBzdXBlcigvKiogQHR5cGUge1RpbWVyUGFyYW1zJlRpbWVsaW5lUGFyYW1zfSAqLyhwYXJhbWV0ZXJzKSwgbnVsbCwgMCk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7IC8vIFRMIGR1cmF0aW9uIHN0YXJ0cyBhdCAwIGFuZCBncm93cyB3aGVuIGFkZGluZyBjaGlsZHJlblxuICAgIC8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgTnVtYmVyPn0gKi9cbiAgICB0aGlzLmxhYmVscyA9IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRzUGFyYW1zID0gcGFyYW1ldGVycy5kZWZhdWx0cztcbiAgICBjb25zdCBnbG9iYWxEZWZhdWx0cyA9IGdsb2JhbHMuZGVmYXVsdHM7XG4gICAgLyoqIEB0eXBlIHtEZWZhdWx0c1BhcmFtc30gKi9cbiAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHNQYXJhbXMgPyBtZXJnZU9iamVjdHMoZGVmYXVsdHNQYXJhbXMsIGdsb2JhbERlZmF1bHRzKSA6IGdsb2JhbERlZmF1bHRzO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblJlbmRlciA9IHBhcmFtZXRlcnMub25SZW5kZXIgfHwgZ2xvYmFsRGVmYXVsdHMub25SZW5kZXI7XG4gICAgY29uc3QgdGxQbGF5YmFja0Vhc2UgPSBzZXRWYWx1ZShwYXJhbWV0ZXJzLnBsYXliYWNrRWFzZSwgZ2xvYmFsRGVmYXVsdHMucGxheWJhY2tFYXNlKTtcbiAgICB0aGlzLl9lYXNlID0gdGxQbGF5YmFja0Vhc2UgPyBwYXJzZUVhc2luZ3ModGxQbGF5YmFja0Vhc2UpIDogbnVsbDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IGExXG4gICAqIEBwYXJhbSB7QW5pbWF0aW9uUGFyYW1zfSBhMlxuICAgKiBAcGFyYW0ge1RpbWVsaW5lUG9zaXRpb258U3RhZ2dlckZ1bmN0aW9uPE51bWJlcnxTdHJpbmc+fSBbYTNdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1RpbWVyUGFyYW1zfSBhMVxuICAgKiBAcGFyYW0ge1RpbWVsaW5lUG9zaXRpb259IFthMl1cbiAgICogQHJldHVybiB7dGhpc31cbiAgICpcbiAgICogQHBhcmFtIHtUYXJnZXRzUGFyYW18VGltZXJQYXJhbXN9IGExXG4gICAqIEBwYXJhbSB7VGltZWxpbmVQb3NpdGlvbnxBbmltYXRpb25QYXJhbXN9IGEyXG4gICAqIEBwYXJhbSB7VGltZWxpbmVQb3NpdGlvbnxTdGFnZ2VyRnVuY3Rpb248TnVtYmVyfFN0cmluZz59IFthM11cbiAgICovXG4gIGFkZChhMSwgYTIsIGEzKSB7XG4gICAgY29uc3QgaXNBbmltID0gaXNPYmooYTIpO1xuICAgIGNvbnN0IGlzVGltZXIgPSBpc09iaihhMSk7XG4gICAgaWYgKGlzQW5pbSB8fCBpc1RpbWVyKSB7XG4gICAgICB0aGlzLl9oYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgICBpZiAoaXNBbmltKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUGFyYW1zID0gLyoqIEB0eXBlIHtBbmltYXRpb25QYXJhbXN9ICovKGEyKTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGZ1bmN0aW9uIGZvciBjaGlsZHJlbiBzdGFnZ2VyIHBvc2l0aW9uc1xuICAgICAgICBpZiAoaXNGbmMoYTMpKSB7XG4gICAgICAgICAgY29uc3Qgc3RhZ2dlcmVkUG9zaXRpb24gPSBhMztcbiAgICAgICAgICBjb25zdCBwYXJzZWRUYXJnZXRzQXJyYXkgPSBwYXJzZVRhcmdldHMoLyoqIEB0eXBlIHtUYXJnZXRzUGFyYW19ICovKGExKSk7XG4gICAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBkdXJhdGlvbiBiZWZvcmUgYWRkaW5nIG5ldyBjaGlsZHJlbiB0aGF0IHdpbGwgY2hhbmdlIHRoZSBkdXJhdGlvblxuICAgICAgICAgIGNvbnN0IHRsRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgIC8vIFN0b3JlIGluaXRpYWwgX2l0ZXJhdGlvbkR1cmF0aW9uIGJlZm9yZSBhZGRpbmcgbmV3IGNoaWxkcmVuIHRoYXQgd2lsbCBjaGFuZ2UgdGhlIGR1cmF0aW9uXG4gICAgICAgICAgY29uc3QgdGxJdGVyYXRpb25EdXJhdGlvbiA9IHRoaXMuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGlkIGluIG9yZGVyIHRvIGFkZCBzcGVjaWZpYyBpbmRleGVzIHRvIHRoZSBuZXcgYW5pbWF0aW9ucyBpZHNcbiAgICAgICAgICBjb25zdCBpZCA9IGNoaWxkUGFyYW1zLmlkO1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICAgICBjb25zdCBwYXJzZWRMZW5ndGggPSAocGFyc2VkVGFyZ2V0c0FycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VkVGFyZ2V0c0FycmF5LmZvckVhY2goKC8qKiBAdHlwZSB7VGFyZ2V0fSAqL3RhcmdldCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhcmFtZXRlciBvYmplY3QgZm9yIGVhY2ggc3RhZ2dlcmVkIGNoaWxkcmVuXG4gICAgICAgICAgICBjb25zdCBzdGFnZ2VyZWRDaGlsZFBhcmFtcyA9IHsgLi4uY2hpbGRQYXJhbXMgfTtcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgdGltZWxpbmUgaXRlcmF0aW9uIGJlZm9yZSBlYWNoIHN0YWdnZXIgdG8gcHJldmVudCB3cm9uZyBzdGFydCB2YWx1ZSBjYWxjdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHRsRHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gdGxJdGVyYXRpb25EdXJhdGlvbjtcbiAgICAgICAgICAgIGlmICghaXNVbmQoaWQpKSBzdGFnZ2VyZWRDaGlsZFBhcmFtcy5pZCA9IGlkICsgJy0nICsgaTtcbiAgICAgICAgICAgIGFkZFRsQ2hpbGQoXG4gICAgICAgICAgICAgIHN0YWdnZXJlZENoaWxkUGFyYW1zLFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBwYXJzZVRpbWVsaW5lUG9zaXRpb24odGhpcywgc3RhZ2dlcmVkUG9zaXRpb24odGFyZ2V0LCBpLCBwYXJzZWRMZW5ndGgsIHRoaXMpKSxcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICBwYXJzZWRMZW5ndGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkVGxDaGlsZChcbiAgICAgICAgICAgIGNoaWxkUGFyYW1zLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHBhcnNlVGltZWxpbmVQb3NpdGlvbih0aGlzLCBhMyksXG4gICAgICAgICAgICAvKiogQHR5cGUge1RhcmdldHNQYXJhbX0gKi8oYTEpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0J3MgYSBUaW1lclxuICAgICAgICBhZGRUbENoaWxkKFxuICAgICAgICAgIC8qKiBAdHlwZSBUaW1lclBhcmFtcyAqLyhhMSksXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBwYXJzZVRpbWVsaW5lUG9zaXRpb24odGhpcyxhMiksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pbml0KDEpOyAvLyAxID0gaW50ZXJuYWxSZW5kZXJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7VGlja2FibGV9IFtzeW5jZWRdXG4gICAqIEBwYXJhbSB7VGltZWxpbmVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtnbG9iYWxUaGlzLkFuaW1hdGlvbn0gW3N5bmNlZF1cbiAgICogQHBhcmFtIHtUaW1lbGluZVBvc2l0aW9ufSBbcG9zaXRpb25dXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1dBQVBJQW5pbWF0aW9ufSBbc3luY2VkXVxuICAgKiBAcGFyYW0ge1RpbWVsaW5lUG9zaXRpb259IFtwb3NpdGlvbl1cbiAgICogQHJldHVybiB7dGhpc31cbiAgICpcbiAgICogQHBhcmFtIHtUaWNrYWJsZXxXQUFQSUFuaW1hdGlvbnxnbG9iYWxUaGlzLkFuaW1hdGlvbn0gW3N5bmNlZF1cbiAgICogQHBhcmFtIHtUaW1lbGluZVBvc2l0aW9ufSBbcG9zaXRpb25dXG4gICAqL1xuICBzeW5jKHN5bmNlZCwgcG9zaXRpb24pIHtcbiAgICBpZiAoaXNVbmQoc3luY2VkKSB8fCBzeW5jZWQgJiYgaXNVbmQoc3luY2VkLnBhdXNlKSkgcmV0dXJuIHRoaXM7XG4gICAgc3luY2VkLnBhdXNlKCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSArKC8qKiBAdHlwZSB7Z2xvYmFsVGhpcy5BbmltYXRpb259ICovKHN5bmNlZCkuZWZmZWN0ID8gLyoqIEB0eXBlIHtnbG9iYWxUaGlzLkFuaW1hdGlvbn0gKi8oc3luY2VkKS5lZmZlY3QuZ2V0VGltaW5nKCkuZHVyYXRpb24gOiAvKiogQHR5cGUge1RpY2thYmxlfSAqLyhzeW5jZWQpLmR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5hZGQoc3luY2VkLCB7IGN1cnJlbnRUaW1lOiBbMCwgZHVyYXRpb25dLCBkdXJhdGlvbiwgZWFzZTogJ2xpbmVhcicgfSwgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICAgKiBAcGFyYW0gIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAgICogQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0KHRhcmdldHMsIHBhcmFtZXRlcnMsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKHBhcmFtZXRlcnMpKSByZXR1cm4gdGhpcztcbiAgICBwYXJhbWV0ZXJzLmR1cmF0aW9uID0gbWluVmFsdWU7XG4gICAgcGFyYW1ldGVycy5jb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uVHlwZXMucmVwbGFjZTtcbiAgICByZXR1cm4gdGhpcy5hZGQodGFyZ2V0cywgcGFyYW1ldGVycywgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FsbGJhY2s8VGltZXI+fSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge1RpbWVsaW5lUG9zaXRpb259IFtwb3NpdGlvbl1cbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGNhbGwoY2FsbGJhY2ssIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKGNhbGxiYWNrKSB8fCBjYWxsYmFjayAmJiAhaXNGbmMoY2FsbGJhY2spKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gdGhpcy5hZGQoeyBkdXJhdGlvbjogMCwgb25Db21wbGV0ZTogKCkgPT4gY2FsbGJhY2sodGhpcykgfSwgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbE5hbWVcbiAgICogQHBhcmFtIHtUaW1lbGluZVBvc2l0aW9ufSBbcG9zaXRpb25dXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqL1xuICBsYWJlbChsYWJlbE5hbWUsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKGxhYmVsTmFtZSkgfHwgbGFiZWxOYW1lICYmICFpc1N0cihsYWJlbE5hbWUpKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLmxhYmVsc1tsYWJlbE5hbWVdID0gcGFyc2VUaW1lbGluZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbcHJvcGVydHlOYW1lXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmVtb3ZlKHRhcmdldHMsIHByb3BlcnR5TmFtZSkge1xuICAgIHJlbW92ZSh0YXJnZXRzLCB0aGlzLCBwcm9wZXJ0eU5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gbmV3RHVyYXRpb25cbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHN0cmV0Y2gobmV3RHVyYXRpb24pIHtcbiAgICBjb25zdCBjdXJyZW50RHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGlmIChjdXJyZW50RHVyYXRpb24gPT09IG5vcm1hbGl6ZVRpbWUobmV3RHVyYXRpb24pKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB0aW1lU2NhbGUgPSBuZXdEdXJhdGlvbiAvIGN1cnJlbnREdXJhdGlvbjtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovY2hpbGQpID0+IGNoaWxkLnN0cmV0Y2goY2hpbGQuZHVyYXRpb24gKiB0aW1lU2NhbGUpKTtcbiAgICBmb3IgKGxldCBsYWJlbE5hbWUgaW4gbGFiZWxzKSBsYWJlbHNbbGFiZWxOYW1lXSAqPSB0aW1lU2NhbGU7XG4gICAgcmV0dXJuIHN1cGVyLnN0cmV0Y2gobmV3RHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnJlZnJlc2gpIGNoaWxkLnJlZnJlc2goKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmV2ZXJ0KCkge1xuICAgIHN1cGVyLnJldmVydCgpO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4gY2hpbGQucmV2ZXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gY2xlYW5JbmxpbmVTdHlsZXModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7Q2FsbGJhY2s8dGhpcz59IFtjYWxsYmFja11cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHRoZW4oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc3VwZXIudGhlbihjYWxsYmFjayk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVsaW5lUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm4ge1RpbWVsaW5lfVxuICovXG5jb25zdCBjcmVhdGVUaW1lbGluZSA9IHBhcmFtZXRlcnMgPT4gbmV3IFRpbWVsaW5lKHBhcmFtZXRlcnMpLmluaXQoKTtcblxuXG5cblxuY2xhc3MgQW5pbWF0YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICAgKiBAcGFyYW0ge0FuaW1hdGFibGVQYXJhbXN9IHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldHMsIHBhcmFtZXRlcnMpIHtcbiAgICBpZiAoc2NvcGUuY3VycmVudCkgc2NvcGUuY3VycmVudC5yZWdpc3Rlcih0aGlzKTtcbiAgICBjb25zdCBiZWdpbkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jYWxsYmFja3MuY29tcGxldGVkKSB0aGlzLmNhbGxiYWNrcy5yZXNldCgpO1xuICAgICAgdGhpcy5jYWxsYmFja3MucGxheSgpO1xuICAgIH07XG4gICAgY29uc3QgcGF1c2VIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLmNvbXBsZXRlZCkgcmV0dXJuO1xuICAgICAgbGV0IHBhdXNlZCA9IHRydWU7XG4gICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuYW5pbWF0aW9ucykge1xuICAgICAgICBjb25zdCBhbmltID0gdGhpcy5hbmltYXRpb25zW25hbWVdO1xuICAgICAgICBpZiAoIWFuaW0ucGF1c2VkICYmIHBhdXNlZCkge1xuICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi9cbiAgICBjb25zdCBnbG9iYWxQYXJhbXMgPSB7XG4gICAgICBvbkJlZ2luOiBiZWdpbkhhbmRsZXIsXG4gICAgICBvbkNvbXBsZXRlOiBwYXVzZUhhbmRsZXIsXG4gICAgICBvblBhdXNlOiBwYXVzZUhhbmRsZXIsXG4gICAgfTtcbiAgICAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi9cbiAgICBjb25zdCBjYWxsYmFja3NBbmltYXRpb25QYXJhbXMgPSB7IHY6IDEsIGF1dG9wbGF5OiBmYWxzZSB9O1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufG51bGx9ICovXG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIGlmIChpc1VuZCh0YXJnZXRzKSB8fCBpc1VuZChwYXJhbWV0ZXJzKSkgcmV0dXJuO1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSBwYXJhbWV0ZXJzW3Byb3BOYW1lXTtcbiAgICAgIGlmIChpc0tleShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAnb24nKSkge1xuICAgICAgICBjYWxsYmFja3NBbmltYXRpb25QYXJhbXNbcHJvcE5hbWVdID0gcGFyYW1WYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbFBhcmFtc1twcm9wTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBKU0FuaW1hdGlvbih7IHY6IDAgfSwgY2FsbGJhY2tzQW5pbWF0aW9uUGFyYW1zKTtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgIGNvbnN0IGlzT2JqVmFsdWUgPSBpc09iaihwcm9wVmFsdWUpO1xuICAgICAgLyoqIEB0eXBlIHtUd2VlblBhcmFtc09wdGlvbnN9ICovXG4gICAgICBsZXQgcHJvcFBhcmFtcyA9IHt9O1xuICAgICAgbGV0IHRvID0gJys9MCc7XG4gICAgICBpZiAoaXNPYmpWYWx1ZSkge1xuICAgICAgICBjb25zdCB1bml0ID0gcHJvcFZhbHVlLnVuaXQ7XG4gICAgICAgIGlmIChpc1N0cih1bml0KSkgdG8gKz0gdW5pdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BQYXJhbXMuZHVyYXRpb24gPSBwcm9wVmFsdWU7XG4gICAgICB9XG4gICAgICBwcm9wUGFyYW1zW3Byb3BOYW1lXSA9IGlzT2JqVmFsdWUgPyBtZXJnZU9iamVjdHMoeyB0byB9LCBwcm9wVmFsdWUpIDogdG87XG4gICAgICBjb25zdCBhbmltUGFyYW1zID0gbWVyZ2VPYmplY3RzKGdsb2JhbFBhcmFtcywgcHJvcFBhcmFtcyk7XG4gICAgICBhbmltUGFyYW1zLmNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlO1xuICAgICAgYW5pbVBhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zW3Byb3BOYW1lXSA9IG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLCBhbmltUGFyYW1zLCBudWxsLCAwLCBmYWxzZSkuaW5pdCgpO1xuICAgICAgaWYgKCF0aGlzLnRhcmdldHMubGVuZ3RoKSB0aGlzLnRhcmdldHMucHVzaCguLi5hbmltYXRpb24udGFyZ2V0cyk7XG4gICAgICAvKiogQHR5cGUge0FuaW1hdGFibGVQcm9wZXJ0eX0gKi9cbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gKHRvLCBkdXJhdGlvbiwgZWFzZSkgPT4ge1xuICAgICAgICBjb25zdCB0d2VlbiA9IC8qKiBAdHlwZSB7VHdlZW59ICovKGFuaW1hdGlvbi5faGVhZCk7XG4gICAgICAgIGlmIChpc1VuZCh0bykgJiYgdHdlZW4pIHtcbiAgICAgICAgICBjb25zdCBudW1iZXJzID0gdHdlZW4uX251bWJlcnM7XG4gICAgICAgICAgaWYgKG51bWJlcnMgJiYgbnVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHdlZW4uX21vZGlmaWVyKHR3ZWVuLl9udW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oYW5pbWF0aW9uLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi90d2VlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQXJyKHRvKSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKHRvKS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kKHR3ZWVuLl9udW1iZXJzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXJzW2ldID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuLl9tb2RpZmllcih0d2Vlbi5fbnVtYmVyc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgdHdlZW4uX3RvTnVtYmVyc1tpXSA9IHRvW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXIgPSAvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW4uX21vZGlmaWVyKHR3ZWVuLl9udW1iZXIpKTtcbiAgICAgICAgICAgICAgdHdlZW4uX3RvTnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNVbmQoZWFzZSkpIHR3ZWVuLl9lYXNlID0gcGFyc2VFYXNpbmdzKGVhc2UpO1xuICAgICAgICAgICAgdHdlZW4uX2N1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWlzVW5kKGR1cmF0aW9uKSkgYW5pbWF0aW9uLnN0cmV0Y2goZHVyYXRpb24pO1xuICAgICAgICAgIGFuaW1hdGlvbi5yZXNldCgxKS5yZXN1bWUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gdGhpcy5hbmltYXRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vb3A7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNbcHJvcE5hbWVdLnJldmVydCgpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRhcmdldHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5jYWxsYmFja3MpIHRoaXMuY2FsbGJhY2tzLnJldmVydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEBwYXJhbSB7QW5pbWF0YWJsZVBhcmFtc30gcGFyYW1ldGVyc1xuICogQHJldHVybiB7QW5pbWF0YWJsZU9iamVjdH1cbiAqL1xuY29uc3QgY3JlYXRlQW5pbWF0YWJsZSA9ICh0YXJnZXRzLCBwYXJhbWV0ZXJzKSA9PiAvKiogQHR5cGUge0FuaW1hdGFibGVPYmplY3R9ICovIChuZXcgQW5pbWF0YWJsZSh0YXJnZXRzLCBwYXJhbWV0ZXJzKSk7XG5cblxuXG5cbi8qXG4gKiBTcHJpbmcgZWFzZSBzb2x2ZXIgYWRhcHRlZCBmcm9tIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG4gKiBXZWJraXQgQ29weXJpZ2h0IMKpIDIwMTYgQXBwbGUgSW5jXG4gKi9cblxuY29uc3QgbWF4U3ByaW5nUGFyYW1WYWx1ZSA9IEsgKiAxMDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcHJpbmdQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFzcz0xXSAtIE1hc3MsIGRlZmF1bHQgMVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdGlmZm5lc3M9MTAwXSAtIFN0aWZmbmVzcywgZGVmYXVsdCAxMDBcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGFtcGluZz0xMF0gLSBEYW1waW5nLCBkZWZhdWx0IDEwXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3ZlbG9jaXR5PTBdIC0gSW5pdGlhbCB2ZWxvY2l0eSwgZGVmYXVsdCAwXG4gKi9cbmNsYXNzIFNwcmluZyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1NwcmluZ1BhcmFtc30gW3BhcmFtZXRlcnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICB0aGlzLnRpbWVTdGVwID0gLjAyOyAvLyBJbnRlcnZhbCBmZWQgdG8gdGhlIHNvbHZlciB0byBjYWxjdWxhdGUgZHVyYXRpb25cbiAgICB0aGlzLnJlc3RUaHJlc2hvbGQgPSAuMDAwNTsgLy8gVmFsdWVzIGJlbG93IHRoaXMgdGhyZXNob2xkIGFyZSBjb25zaWRlcmVkIHJlc3RpbmcgcG9zaXRpb25cbiAgICB0aGlzLnJlc3REdXJhdGlvbiA9IDIwMDsgLy8gRHVyYXRpb24gaW4gbXMgdXNlZCB0byBjaGVjayBpZiB0aGUgc3ByaW5nIGlzIHJlc3RpbmcgYWZ0ZXIgcmVhY2hpbmcgcmVzdFRocmVzaG9sZFxuICAgIHRoaXMubWF4RHVyYXRpb24gPSA2MDAwMDsgLy8gVGhlIG1heGltdW0gYWxsb3dlZCBzcHJpbmcgZHVyYXRpb24gaW4gbXMgKGRlZmF1bHQgMSBtaW4pXG4gICAgdGhpcy5tYXhSZXN0U3RlcHMgPSB0aGlzLnJlc3REdXJhdGlvbiAvIHRoaXMudGltZVN0ZXAgLyBLOyAvLyBIb3cgbWFueSBzdGVwcyBhbGxvd2VkIGFmdGVyIHJlYWNoaW5nIHJlc3RUaHJlc2hvbGQgYmVmb3JlIHN0b3BwaW5nIHRoZSBkdXJhdGlvbiBjYWxjdWxhdGlvblxuICAgIHRoaXMubWF4SXRlcmF0aW9ucyA9IHRoaXMubWF4RHVyYXRpb24gLyB0aGlzLnRpbWVTdGVwIC8gSzsgLy8gQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIGl0ZXJhdGlvbnMgYWxsb3dlZCBiYXNlZCBvbiBtYXhEdXJhdGlvblxuICAgIHRoaXMubSA9IGNsYW1wKHNldFZhbHVlKHBhcmFtZXRlcnMubWFzcywgMSksIDAsIG1heFNwcmluZ1BhcmFtVmFsdWUpO1xuICAgIHRoaXMucyA9IGNsYW1wKHNldFZhbHVlKHBhcmFtZXRlcnMuc3RpZmZuZXNzLCAxMDApLCAxLCBtYXhTcHJpbmdQYXJhbVZhbHVlKTtcbiAgICB0aGlzLmQgPSBjbGFtcChzZXRWYWx1ZShwYXJhbWV0ZXJzLmRhbXBpbmcsIDEwKSwgLjEsIG1heFNwcmluZ1BhcmFtVmFsdWUpO1xuICAgIHRoaXMudiA9IGNsYW1wKHNldFZhbHVlKHBhcmFtZXRlcnMudmVsb2NpdHksIDApLCAtbWF4U3ByaW5nUGFyYW1WYWx1ZSwgbWF4U3ByaW5nUGFyYW1WYWx1ZSk7XG4gICAgdGhpcy53MCA9IDA7XG4gICAgdGhpcy56ZXRhID0gMDtcbiAgICB0aGlzLndkID0gMDtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuc29sdmVyRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gICAgdGhpcy5lYXNlID0gdCA9PiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDogdGhpcy5zb2x2ZSh0ICogdGhpcy5zb2x2ZXJEdXJhdGlvbik7XG4gIH1cblxuICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICBzb2x2ZSh0aW1lKSB7XG4gICAgY29uc3QgeyB6ZXRhLCB3MCwgd2QsIGIgfSA9IHRoaXM7XG4gICAgbGV0IHQgPSB0aW1lO1xuICAgIGlmICh6ZXRhIDwgMSkge1xuICAgICAgdCA9IGV4cCgtdCAqIHpldGEgKiB3MCkgKiAoMSAqIGNvcyh3ZCAqIHQpICsgYiAqIHNpbih3ZCAqIHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdCA9ICgxICsgYiAqIHQpICogZXhwKC10ICogdzApO1xuICAgIH1cbiAgICByZXR1cm4gMSAtIHQ7XG4gIH1cblxuICBjb21wdXRlKCkge1xuICAgIGNvbnN0IHsgbWF4UmVzdFN0ZXBzLCBtYXhJdGVyYXRpb25zLCByZXN0VGhyZXNob2xkLCB0aW1lU3RlcCwgbSwgZCwgcywgdiB9ID0gdGhpcztcbiAgICBjb25zdCB3MCA9IHRoaXMudzAgPSBjbGFtcChzcXJ0KHMgLyBtKSwgbWluVmFsdWUsIEspO1xuICAgIGNvbnN0IHpldGEgPSB0aGlzLnpldGEgPSBkIC8gKDIgKiBzcXJ0KHMgKiBtKSk7XG4gICAgY29uc3Qgd2QgPSB0aGlzLndkID0gemV0YSA8IDEgPyB3MCAqIHNxcnQoMSAtIHpldGEgKiB6ZXRhKSA6IDA7XG4gICAgdGhpcy5iID0gemV0YSA8IDEgPyAoemV0YSAqIHcwICsgLXYpIC8gd2QgOiAtdiArIHcwO1xuICAgIGxldCBzb2x2ZXJUaW1lID0gMDtcbiAgICBsZXQgcmVzdFN0ZXBzID0gMDtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgd2hpbGUgKHJlc3RTdGVwcyA8IG1heFJlc3RTdGVwcyAmJiBpdGVyYXRpb25zIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgaWYgKGFicygxIC0gdGhpcy5zb2x2ZShzb2x2ZXJUaW1lKSkgPCByZXN0VGhyZXNob2xkKSB7XG4gICAgICAgIHJlc3RTdGVwcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdFN0ZXBzID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc29sdmVyRHVyYXRpb24gPSBzb2x2ZXJUaW1lO1xuICAgICAgc29sdmVyVGltZSArPSB0aW1lU3RlcDtcbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICB9XG4gICAgdGhpcy5kdXJhdGlvbiA9IHJvdW5kKHRoaXMuc29sdmVyRHVyYXRpb24gKiBLLCAwKSAqIGdsb2JhbHMudGltZVNjYWxlO1xuICB9XG5cbiAgZ2V0IG1hc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubTtcbiAgfVxuXG4gIHNldCBtYXNzKHYpIHtcbiAgICB0aGlzLm0gPSBjbGFtcChzZXRWYWx1ZSh2LCAxKSwgMCwgbWF4U3ByaW5nUGFyYW1WYWx1ZSk7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gIH1cblxuICBnZXQgc3RpZmZuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnM7XG4gIH1cblxuICBzZXQgc3RpZmZuZXNzKHYpIHtcbiAgICB0aGlzLnMgPSBjbGFtcChzZXRWYWx1ZSh2LCAxMDApLCAxLCBtYXhTcHJpbmdQYXJhbVZhbHVlKTtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgfVxuXG4gIGdldCBkYW1waW5nKCkge1xuICAgIHJldHVybiB0aGlzLmQ7XG4gIH1cblxuICBzZXQgZGFtcGluZyh2KSB7XG4gICAgdGhpcy5kID0gY2xhbXAoc2V0VmFsdWUodiwgMTApLCAuMSwgbWF4U3ByaW5nUGFyYW1WYWx1ZSk7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gIH1cblxuICBnZXQgdmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudjtcbiAgfVxuXG4gIHNldCB2ZWxvY2l0eSh2KSB7XG4gICAgdGhpcy52ID0gY2xhbXAoc2V0VmFsdWUodiwgMCksIC1tYXhTcHJpbmdQYXJhbVZhbHVlLCBtYXhTcHJpbmdQYXJhbVZhbHVlKTtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ByaW5nUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm5zIHtTcHJpbmd9XG4gKi9cbmNvbnN0IGNyZWF0ZVNwcmluZyA9IChwYXJhbWV0ZXJzKSA9PiBuZXcgU3ByaW5nKHBhcmFtZXRlcnMpO1xuXG5cblxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR9IGVcbiAqL1xuY29uc3QgcHJldmVudERlZmF1bHQgPSBlID0+IHtcbiAgaWYgKGUuY2FuY2VsYWJsZSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuY2xhc3MgRE9NUHJveHkge1xuICAvKiogQHBhcmFtIHtPYmplY3R9IGVsICovXG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY2xhc3NMaXN0ID0ge1xuICAgICAgYWRkOiBub29wLFxuICAgICAgcmVtb3ZlOiBub29wLFxuICAgIH07XG4gIH1cblxuICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuZWwueCB8fCAwIH07XG4gIHNldCB4KHYpIHsgdGhpcy5lbC54ID0gdjsgfTtcblxuICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuZWwueSB8fCAwIH07XG4gIHNldCB5KHYpIHsgdGhpcy5lbC55ID0gdjsgfTtcblxuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLmVsLndpZHRoIHx8IDAgfTtcbiAgc2V0IHdpZHRoKHYpIHsgdGhpcy5lbC53aWR0aCA9IHY7IH07XG5cbiAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuZWwuaGVpZ2h0IHx8IDAgfTtcbiAgc2V0IGhlaWdodCh2KSB7IHRoaXMuZWwuaGVpZ2h0ID0gdjsgfTtcblxuICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdGhpcy55LFxuICAgICAgcmlnaHQ6IHRoaXMueCxcbiAgICAgIGJvdHRvbTogdGhpcy55ICsgdGhpcy5oZWlnaHQsXG4gICAgICBsZWZ0OiB0aGlzLnggKyB0aGlzLndpZHRoLFxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBUcmFuc2Zvcm1zIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NVGFyZ2V0fERPTVByb3h5fSAkZWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCRlbCkge1xuICAgIHRoaXMuJGVsID0gJGVsO1xuICAgIHRoaXMuaW5saW5lVHJhbnNmb3JtcyA9IFtdO1xuICAgIHRoaXMucG9pbnQgPSBuZXcgRE9NUG9pbnQoKTtcbiAgICB0aGlzLmludmVyc2VkTWF0cml4ID0gdGhpcy5nZXRNYXRyaXgoKS5pbnZlcnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7RE9NUG9pbnR9XG4gICAqL1xuICBub3JtYWxpemVQb2ludCh4LCB5KSB7XG4gICAgdGhpcy5wb2ludC54ID0geDtcbiAgICB0aGlzLnBvaW50LnkgPSB5O1xuICAgIHJldHVybiB0aGlzLnBvaW50Lm1hdHJpeFRyYW5zZm9ybSh0aGlzLmludmVyc2VkTWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgVHJhdmVyc2VQYXJlbnRzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtET01UYXJnZXR9ICRlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gaVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmF2ZXJzZVBhcmVudHNDYWxsYmFja30gY2JcbiAgICovXG4gIHRyYXZlcnNlVXAoY2IpIHtcbiAgICBsZXQgJGVsID0gLyoqIEB0eXBlIHtET01UYXJnZXR8RG9jdW1lbnR9ICovKHRoaXMuJGVsLnBhcmVudEVsZW1lbnQpLCBpID0gMDtcbiAgICB3aGlsZSAoJGVsICYmICRlbCAhPT0gZG9jKSB7XG4gICAgICBjYigvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oJGVsKSwgaSk7XG4gICAgICAkZWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oJGVsLnBhcmVudEVsZW1lbnQpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGdldE1hdHJpeCgpIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgRE9NTWF0cml4KCk7XG4gICAgdGhpcy50cmF2ZXJzZVVwKCRlbCA9PiB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1WYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUoJGVsKS50cmFuc2Zvcm07XG4gICAgICBpZiAodHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZWxNYXRyaXggPSBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybVZhbHVlKTtcbiAgICAgICAgbWF0cml4LnByZU11bHRpcGx5U2VsZihlbE1hdHJpeCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLnRyYXZlcnNlVXAoKCRlbCwgaSkgPT4ge1xuICAgICAgdGhpcy5pbmxpbmVUcmFuc2Zvcm1zW2ldID0gJGVsLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICRlbC5zdHlsZS50cmFuc2Zvcm0gPSAnbm9uZSc7XG4gICAgfSk7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy50cmF2ZXJzZVVwKCgkZWwsIGkpID0+IHtcbiAgICAgIGNvbnN0IGN0ID0gdGhpcy5pbmxpbmVUcmFuc2Zvcm1zW2ldO1xuICAgICAgaWYgKGN0ID09PSAnJykge1xuICAgICAgICAkZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zZm9ybScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsLnN0eWxlLnRyYW5zZm9ybSA9IGN0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtBcnJheTxOdW1iZXI+fERPTVRhcmdldFNlbGVjdG9yfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXN9IFRcbiAqIEBwYXJhbSB7VCB8ICgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IFQpfSB2YWx1ZVxuICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZVxuICogQHJldHVybiB7VH1cbiAqL1xuY29uc3QgcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlciA9ICh2YWx1ZSwgZHJhZ2dhYmxlKSA9PiB2YWx1ZSAmJiBpc0ZuYyh2YWx1ZSkgPyAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkoZHJhZ2dhYmxlKSA6IHZhbHVlO1xuXG5sZXQgekluZGV4ID0gMDtcblxuY2xhc3MgRHJhZ2dhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRcbiAgICogQHBhcmFtIHtEcmFnZ2FibGVQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIGlmIChzY29wZS5jdXJyZW50KSBzY29wZS5jdXJyZW50LnJlZ2lzdGVyKHRoaXMpO1xuICAgIGNvbnN0IHBhcmFtWCA9IHBhcmFtZXRlcnMueDtcbiAgICBjb25zdCBwYXJhbVkgPSBwYXJhbWV0ZXJzLnk7XG4gICAgY29uc3QgdHJpZ2dlciA9IHBhcmFtZXRlcnMudHJpZ2dlcjtcbiAgICBjb25zdCBtb2RpZmllciA9IHBhcmFtZXRlcnMubW9kaWZpZXI7XG4gICAgY29uc3QgZWFzZSA9IHBhcmFtZXRlcnMucmVsZWFzZUVhc2U7XG4gICAgY29uc3QgY3VzdG9tRWFzZSA9IGVhc2UgJiYgcGFyc2VFYXNpbmdzKGVhc2UpO1xuICAgIGNvbnN0IGhhc1NwcmluZyA9ICFpc1VuZChlYXNlKSAmJiAhaXNVbmQoLyoqIEB0eXBlIHtTcHJpbmd9ICovKGVhc2UpLmVhc2UpO1xuICAgIGNvbnN0IHhQcm9wID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKGlzT2JqKHBhcmFtWCkgJiYgIWlzVW5kKC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhwYXJhbVgpLm1hcFRvKSA/IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhwYXJhbVgpLm1hcFRvIDogJ3RyYW5zbGF0ZVgnKTtcbiAgICBjb25zdCB5UHJvcCA9IC8qKiBAdHlwZSB7U3RyaW5nfSAqLyhpc09iaihwYXJhbVkpICYmICFpc1VuZCgvKiogQHR5cGUge09iamVjdH0gKi8ocGFyYW1ZKS5tYXBUbykgPyAvKiogQHR5cGUge09iamVjdH0gKi8ocGFyYW1ZKS5tYXBUbyA6ICd0cmFuc2xhdGVZJyk7XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbWV0ZXJzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgdGhpcy5jb250YWluZXJBcnJheSA9IGlzQXJyKGNvbnRhaW5lcikgPyBjb250YWluZXIgOiBudWxsO1xuICAgIHRoaXMuJGNvbnRhaW5lciA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGNvbnRhaW5lciAmJiAhdGhpcy5jb250YWluZXJBcnJheSA/IHBhcnNlVGFyZ2V0cygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oY29udGFpbmVyKSlbMF0gOiBkb2MuYm9keSk7XG4gICAgdGhpcy51c2VXaW4gPSB0aGlzLiRjb250YWluZXIgPT09IGRvYy5ib2R5O1xuICAgIC8qKiBAdHlwZSB7V2luZG93IHwgSFRNTEVsZW1lbnR9ICovXG4gICAgdGhpcy4kc2Nyb2xsQ29udGFpbmVyID0gdGhpcy51c2VXaW4gPyB3aW4gOiB0aGlzLiRjb250YWluZXI7XG4gICAgdGhpcy4kdGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oaXNPYmoodGFyZ2V0KSA/IG5ldyBET01Qcm94eSh0YXJnZXQpIDogcGFyc2VUYXJnZXRzKHRhcmdldClbMF0pO1xuICAgIHRoaXMuJHRyaWdnZXIgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhwYXJzZVRhcmdldHModHJpZ2dlciA/IHRyaWdnZXIgOiB0YXJnZXQpWzBdKTtcbiAgICB0aGlzLmZpeGVkID0gZ2V0VGFyZ2V0VmFsdWUodGhpcy4kdGFyZ2V0LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJztcbiAgICAvLyBSZWZyZXNoYWJsZSBwYXJhbWV0ZXJzXG4gICAgdGhpcy5pc0ZpbmVQb2ludGVyID0gdHJ1ZTtcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuY29udGFpbmVyUGFkZGluZyA9IFswLCAwLCAwLCAwXTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmNvbnRhaW5lckZyaWN0aW9uID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnJlbGVhc2VDb250YWluZXJGcmljdGlvbiA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ8QXJyYXk8TnVtYmVyPn0gKi9cbiAgICB0aGlzLnNuYXBYID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcnxBcnJheTxOdW1iZXI+fSAqL1xuICAgIHRoaXMuc25hcFkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsVGhyZXNob2xkID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmRyYWdTcGVlZCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5tYXhWZWxvY2l0eSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5taW5WZWxvY2l0eSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy52ZWxvY2l0eU11bHRpcGxpZXIgPSAwO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXN9ICovXG4gICAgdGhpcy5jdXJzb3IgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge1NwcmluZ30gKi9cbiAgICB0aGlzLnJlbGVhc2VYU3ByaW5nID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGVhc2UpIDogY3JlYXRlU3ByaW5nKHtcbiAgICAgIG1hc3M6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZU1hc3MsIDEpLFxuICAgICAgc3RpZmZuZXNzOiBzZXRWYWx1ZShwYXJhbWV0ZXJzLnJlbGVhc2VTdGlmZm5lc3MsIDgwKSxcbiAgICAgIGRhbXBpbmc6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZURhbXBpbmcsIDIwKSxcbiAgICB9KTtcbiAgICAvKiogQHR5cGUge1NwcmluZ30gKi9cbiAgICB0aGlzLnJlbGVhc2VZU3ByaW5nID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGVhc2UpIDogY3JlYXRlU3ByaW5nKHtcbiAgICAgIG1hc3M6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZU1hc3MsIDEpLFxuICAgICAgc3RpZmZuZXNzOiBzZXRWYWx1ZShwYXJhbWV0ZXJzLnJlbGVhc2VTdGlmZm5lc3MsIDgwKSxcbiAgICAgIGRhbXBpbmc6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZURhbXBpbmcsIDIwKSxcbiAgICB9KTtcbiAgICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMucmVsZWFzZUVhc2UgPSBjdXN0b21FYXNlIHx8IGVhc2VzLm91dFF1aW50O1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmhhc1JlbGVhc2VTcHJpbmcgPSBoYXNTcHJpbmc7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uR3JhYiA9IHBhcmFtZXRlcnMub25HcmFiIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uRHJhZyA9IHBhcmFtZXRlcnMub25EcmFnIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uUmVsZWFzZSA9IHBhcmFtZXRlcnMub25SZWxlYXNlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uVXBkYXRlID0gcGFyYW1ldGVycy5vblVwZGF0ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblNldHRsZSA9IHBhcmFtZXRlcnMub25TZXR0bGUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25TbmFwID0gcGFyYW1ldGVycy5vblNuYXAgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25SZXNpemUgPSBwYXJhbWV0ZXJzLm9uUmVzaXplIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uQWZ0ZXJSZXNpemUgPSBwYXJhbWV0ZXJzLm9uQWZ0ZXJSZXNpemUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5kaXNhYmxlZCA9IFswLCAwXTtcbiAgICAvKiogQHR5cGUge0FuaW1hdGFibGVQYXJhbXN9ICovXG4gICAgY29uc3QgYW5pbWF0YWJsZVBhcmFtcyA9IHt9O1xuICAgIGlmIChtb2RpZmllcikgYW5pbWF0YWJsZVBhcmFtcy5tb2RpZmllciA9IG1vZGlmaWVyO1xuICAgIGlmIChpc1VuZChwYXJhbVgpIHx8IHBhcmFtWCA9PT0gdHJ1ZSkge1xuICAgICAgYW5pbWF0YWJsZVBhcmFtc1t4UHJvcF0gPSAwO1xuICAgIH0gZWxzZSBpZiAoaXNPYmoocGFyYW1YKSkge1xuICAgICAgY29uc3QgcGFyYW1YT2JqZWN0ID0gLyoqIEB0eXBlIHtEcmFnZ2FibGVBeGlzUGFyYW19ICovKHBhcmFtWCk7XG4gICAgICBjb25zdCBhbmltYXRhYmxlWFBhcmFtcyA9IHt9O1xuICAgICAgaWYgKHBhcmFtWE9iamVjdC5tb2RpZmllcikgYW5pbWF0YWJsZVhQYXJhbXMubW9kaWZpZXIgPSBwYXJhbVhPYmplY3QubW9kaWZpZXI7XG4gICAgICBpZiAocGFyYW1YT2JqZWN0LmNvbXBvc2l0aW9uKSBhbmltYXRhYmxlWFBhcmFtcy5jb21wb3NpdGlvbiA9IHBhcmFtWE9iamVjdC5jb21wb3NpdGlvbjtcbiAgICAgIGFuaW1hdGFibGVQYXJhbXNbeFByb3BdID0gYW5pbWF0YWJsZVhQYXJhbXM7XG4gICAgfSBlbHNlIGlmIChwYXJhbVggPT09IGZhbHNlKSB7XG4gICAgICBhbmltYXRhYmxlUGFyYW1zW3hQcm9wXSA9IDA7XG4gICAgICB0aGlzLmRpc2FibGVkWzBdID0gMTtcbiAgICB9XG4gICAgaWYgKGlzVW5kKHBhcmFtWSkgfHwgcGFyYW1ZID09PSB0cnVlKSB7XG4gICAgICBhbmltYXRhYmxlUGFyYW1zW3lQcm9wXSA9IDA7XG4gICAgfSBlbHNlIGlmIChpc09iaihwYXJhbVkpKSB7XG4gICAgICBjb25zdCBwYXJhbVlPYmplY3QgPSAvKiogQHR5cGUge0RyYWdnYWJsZUF4aXNQYXJhbX0gKi8ocGFyYW1ZKTtcbiAgICAgIGNvbnN0IGFuaW1hdGFibGVZUGFyYW1zID0ge307XG4gICAgICBpZiAocGFyYW1ZT2JqZWN0Lm1vZGlmaWVyKSBhbmltYXRhYmxlWVBhcmFtcy5tb2RpZmllciA9IHBhcmFtWU9iamVjdC5tb2RpZmllcjtcbiAgICAgIGlmIChwYXJhbVlPYmplY3QuY29tcG9zaXRpb24pIGFuaW1hdGFibGVZUGFyYW1zLmNvbXBvc2l0aW9uID0gcGFyYW1ZT2JqZWN0LmNvbXBvc2l0aW9uO1xuICAgICAgYW5pbWF0YWJsZVBhcmFtc1t5UHJvcF0gPSBhbmltYXRhYmxlWVBhcmFtcztcbiAgICB9IGVsc2UgaWYgKHBhcmFtWSA9PT0gZmFsc2UpIHtcbiAgICAgIGFuaW1hdGFibGVQYXJhbXNbeVByb3BdID0gMDtcbiAgICAgIHRoaXMuZGlzYWJsZWRbMV0gPSAxO1xuICAgIH1cbiAgICAvKiogQHR5cGUge0FuaW1hdGFibGVPYmplY3R9ICovXG4gICAgdGhpcy5hbmltYXRlID0gLyoqIEB0eXBlIHtBbmltYXRhYmxlT2JqZWN0fSAqLyhuZXcgQW5pbWF0YWJsZSh0aGlzLiR0YXJnZXQsIGFuaW1hdGFibGVQYXJhbXMpKTtcbiAgICAvLyBJbnRlcm5hbCBwcm9wc1xuICAgIHRoaXMueFByb3AgPSB4UHJvcDtcbiAgICB0aGlzLnlQcm9wID0geVByb3A7XG4gICAgdGhpcy5kZXN0WCA9IDA7XG4gICAgdGhpcy5kZXN0WSA9IDA7XG4gICAgdGhpcy5kZWx0YVggPSAwO1xuICAgIHRoaXMuZGVsdGFZID0gMDtcbiAgICB0aGlzLnNjcm9sbCA9IHt4OiAwLCB5OiAwfTtcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuY29vcmRzID0gW3RoaXMueCwgdGhpcy55LCAwLCAwXTsgLy8geCwgeSwgdGVtcCB4LCB0ZW1wIHlcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5zbmFwcGVkID0gWzAsIDBdOyAvLyB4LCB5XG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMucG9pbnRlciA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTsgLy8geDEsIHkxLCB4MiwgeTIsIHRlbXAgeDEsIHRlbXAgeTEsIHRlbXAgeDIsIHRlbXAgeTJcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5zY3JvbGxWaWV3ID0gWzAsIDBdOyAvLyB3LCBoXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLmRyYWdBcmVhID0gWzAsIDAsIDAsIDBdOyAvLyB4LCB5LCB3LCBoXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLmNvbnRhaW5lckJvdW5kcyA9IFstbWF4VmFsdWUsIG1heFZhbHVlLCBtYXhWYWx1ZSwgLW1heFZhbHVlXTsgLy8gdCwgciwgYiwgbFxuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5zY3JvbGxCb3VuZHMgPSBbMCwgMCwgMCwgMF07IC8vIHQsIHIsIGIsIGxcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMudGFyZ2V0Qm91bmRzID0gWzAsIDAsIDAsIDBdOyAvLyB0LCByLCBiLCBsXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMud2luZG93ID0gWzAsIDBdOyAvLyB3LCBoXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrID0gWzAsIDAsIDBdO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnZlbG9jaXR5VGltZSA9IG5vdygpO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy5jdXJzb3JTdHlsZXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL1xuICAgIHRoaXMuYm9keVN0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLnRhcmdldFN0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLnRvdWNoQWN0aW9uU3R5bGVzID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgVHJhbnNmb3Jtcyh0aGlzLiR0YXJnZXQpO1xuICAgIHRoaXMub3ZlcnNob290Q29vcmRzID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5vdmVyc2hvb3RUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgb25VcGRhdGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYW51YWwgPSB0cnVlO1xuICAgICAgICAvLyBVc2UgYSBkdXJhdGlvbiBvZiAxIHRvIHByZXZlbnQgdGhlIGFuaW1hdGFibGUgZnJvbSBjb21wbGV0aW5nIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgaXNzdWVzIHdpdGggb25TZXR0bGUoKVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWFuZ2Fybmllci9hbmltZS9pc3N1ZXMvMTA0NVxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWRbMF0pIHRoaXMuYW5pbWF0ZVt0aGlzLnhQcm9wXSh0aGlzLm92ZXJzaG9vdENvb3Jkcy54LCAxKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkWzFdKSB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0odGhpcy5vdmVyc2hvb3RDb29yZHMueSwgMSk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLm1hbnVhbCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWRbMF0pIHRoaXMuYW5pbWF0ZVt0aGlzLnhQcm9wXSh0aGlzLm92ZXJzaG9vdENvb3Jkcy54LCAwKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkWzFdKSB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0odGhpcy5vdmVyc2hvb3RDb29yZHMueSwgMCk7XG4gICAgICB9LFxuICAgIH0sIG51bGwsIDApLmluaXQoKTtcbiAgICB0aGlzLnVwZGF0ZVRpY2tlciA9IG5ldyBUaW1lcih7IGF1dG9wbGF5OiBmYWxzZSwgb25VcGRhdGU6ICgpID0+IHRoaXMudXBkYXRlKCkgfSwgbnVsbCwwLCkuaW5pdCgpO1xuICAgIHRoaXMuY29udGFpbmVkID0gIWlzVW5kKGNvbnRhaW5lcik7XG4gICAgdGhpcy5tYW51YWwgPSBmYWxzZTtcbiAgICB0aGlzLmdyYWJiZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5hY3RpdmVQcm9wID0gdGhpcy5kaXNhYmxlZFsxXSA/IHhQcm9wIDogeVByb3A7XG4gICAgdGhpcy5hbmltYXRlLmNhbGxiYWNrcy5vblJlbmRlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc1VwZGF0ZWQgPSB0aGlzLnVwZGF0ZWQ7XG4gICAgICBjb25zdCBoYXNNb3ZlZCA9IHRoaXMuZ3JhYmJlZCAmJiBoYXNVcGRhdGVkO1xuICAgICAgY29uc3QgaGFzUmVsZWFzZWQgPSAhaGFzTW92ZWQgJiYgdGhpcy5yZWxlYXNlZDtcbiAgICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgICAgY29uc3QgZHggPSB4IC0gdGhpcy5jb29yZHNbMl07XG4gICAgICBjb25zdCBkeSA9IHkgLSB0aGlzLmNvb3Jkc1szXTtcbiAgICAgIHRoaXMuZGVsdGFYID0gZHg7XG4gICAgICB0aGlzLmRlbHRhWSA9IGR5O1xuICAgICAgdGhpcy5jb29yZHNbMl0gPSB4O1xuICAgICAgdGhpcy5jb29yZHNbM10gPSB5O1xuICAgICAgLy8gQ2hlY2sgaWYgZHggb3IgZHkgYXJlIG5vdCAwIHRvIGNoZWNrIGlmIHRoZSBkcmFnZ2FibGUgaGFzIGFjdHVhbGx5IG1vdmVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWFuZ2Fybmllci9hbmltZS9pc3N1ZXMvMTAzMlxuICAgICAgaWYgKGhhc1VwZGF0ZWQgJiYgKGR4IHx8IGR5KSkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlKHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNSZWxlYXNlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZVZlbG9jaXR5KGR4LCBkeSk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBhdGFuMihkeSwgZHgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hbmltYXRlLmNhbGxiYWNrcy5vbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKCghdGhpcy5ncmFiYmVkICYmIHRoaXMucmVsZWFzZWQpKSB7XG4gICAgICAgIC8vIFNldCByZWxlYXNlZCB0byBmYWxzZSBiZWZvcmUgY2FsbGluZyBvblNldHRsZSB0byBhdm9pZCByZWN1cnNpb25cbiAgICAgICAgdGhpcy5yZWxlYXNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm1hbnVhbCkge1xuICAgICAgICB0aGlzLmRlbHRhWCA9IDA7XG4gICAgICAgIHRoaXMuZGVsdGFZID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlTdGFja1swXSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlTdGFja1sxXSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlTdGFja1syXSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5vblNldHRsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVzaXplVGlja2VyID0gbmV3IFRpbWVyKHtcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgIGR1cmF0aW9uOiAxNTAgKiBnbG9iYWxzLnRpbWVTY2FsZSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIHRoaXMub25BZnRlclJlc2l6ZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgfSkuaW5pdCgpO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZVRpY2tlci5yZXN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVuYWJsZSgpO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRjb250YWluZXIpO1xuICAgIGlmICghaXNPYmoodGFyZ2V0KSkgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuJHRhcmdldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSBkeFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGR5XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGNvbXB1dGVWZWxvY2l0eShkeCwgZHkpIHtcbiAgICBjb25zdCBwcmV2VGltZSA9IHRoaXMudmVsb2NpdHlUaW1lO1xuICAgIGNvbnN0IGN1clRpbWUgPSBub3coKTtcbiAgICBjb25zdCBlbGFwc2VkID0gY3VyVGltZSAtIHByZXZUaW1lO1xuICAgIGlmIChlbGFwc2VkIDwgMTcpIHJldHVybiB0aGlzLnZlbG9jaXR5O1xuICAgIHRoaXMudmVsb2NpdHlUaW1lID0gY3VyVGltZTtcbiAgICBjb25zdCB2ZWxvY2l0eVN0YWNrID0gdGhpcy52ZWxvY2l0eVN0YWNrO1xuICAgIGNvbnN0IHZNdWwgPSB0aGlzLnZlbG9jaXR5TXVsdGlwbGllcjtcbiAgICBjb25zdCBtaW5WID0gdGhpcy5taW5WZWxvY2l0eTtcbiAgICBjb25zdCBtYXhWID0gdGhpcy5tYXhWZWxvY2l0eTtcbiAgICBjb25zdCB2aSA9IHRoaXMudmVsb2NpdHlTdGFja0luZGV4O1xuICAgIHZlbG9jaXR5U3RhY2tbdmldID0gcm91bmQoY2xhbXAoKHNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gZWxhcHNlZCkgKiB2TXVsLCBtaW5WLCBtYXhWKSwgNSk7XG4gICAgY29uc3QgdmVsb2NpdHkgPSBtYXgodmVsb2NpdHlTdGFja1swXSwgdmVsb2NpdHlTdGFja1sxXSwgdmVsb2NpdHlTdGFja1syXSk7XG4gICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gKHZpICsgMSkgJSAzO1xuICAgIHJldHVybiB2ZWxvY2l0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gIHhcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbXV0ZVVwZGF0ZUNhbGxiYWNrXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0WCh4LCBtdXRlVXBkYXRlQ2FsbGJhY2sgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkWzBdKSByZXR1cm47XG4gICAgY29uc3QgdiA9IHJvdW5kKHgsIDUpO1xuICAgIHRoaXMub3ZlcnNob290VGlja2VyLnBhdXNlKCk7XG4gICAgdGhpcy5tYW51YWwgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlZCA9ICFtdXRlVXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5kZXN0WCA9IHY7XG4gICAgdGhpcy5zbmFwcGVkWzBdID0gc25hcCh2LCB0aGlzLnNuYXBYKTtcbiAgICB0aGlzLmFuaW1hdGVbdGhpcy54UHJvcF0odiwgMCk7XG4gICAgdGhpcy5tYW51YWwgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gIHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbXV0ZVVwZGF0ZUNhbGxiYWNrXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0WSh5LCBtdXRlVXBkYXRlQ2FsbGJhY2sgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkWzFdKSByZXR1cm47XG4gICAgY29uc3QgdiA9IHJvdW5kKHksIDUpO1xuICAgIHRoaXMub3ZlcnNob290VGlja2VyLnBhdXNlKCk7XG4gICAgdGhpcy5tYW51YWwgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlZCA9ICFtdXRlVXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5kZXN0WSA9IHY7XG4gICAgdGhpcy5zbmFwcGVkWzFdID0gc25hcCh2LCB0aGlzLnNuYXBZKTtcbiAgICB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0odiwgMCk7XG4gICAgdGhpcy5tYW51YWwgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCB4KCkge1xuICAgIHJldHVybiByb3VuZCgvKiogQHR5cGUge051bWJlcn0gKi8odGhpcy5hbmltYXRlW3RoaXMueFByb3BdKCkpLCBnbG9iYWxzLnByZWNpc2lvbik7XG4gIH1cblxuICBzZXQgeCh4KSB7XG4gICAgdGhpcy5zZXRYKHgsIGZhbHNlKTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiByb3VuZCgvKiogQHR5cGUge051bWJlcn0gKi8odGhpcy5hbmltYXRlW3RoaXMueVByb3BdKCkpLCBnbG9iYWxzLnByZWNpc2lvbik7XG4gIH1cblxuICBzZXQgeSh5KSB7XG4gICAgdGhpcy5zZXRZKHksIGZhbHNlKTtcbiAgfVxuXG4gIGdldCBwcm9ncmVzc1goKSB7XG4gICAgcmV0dXJuIG1hcFJhbmdlKHRoaXMueCwgdGhpcy5jb250YWluZXJCb3VuZHNbM10sIHRoaXMuY29udGFpbmVyQm91bmRzWzFdLCAwLCAxKTtcbiAgfVxuXG4gIHNldCBwcm9ncmVzc1goeCkge1xuICAgIHRoaXMuc2V0WChtYXBSYW5nZSh4LCAwLCAxLCB0aGlzLmNvbnRhaW5lckJvdW5kc1szXSwgdGhpcy5jb250YWluZXJCb3VuZHNbMV0pLCBmYWxzZSk7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3NZKCkge1xuICAgIHJldHVybiBtYXBSYW5nZSh0aGlzLnksIHRoaXMuY29udGFpbmVyQm91bmRzWzBdLCB0aGlzLmNvbnRhaW5lckJvdW5kc1syXSwgMCwgMSk7XG4gIH1cblxuICBzZXQgcHJvZ3Jlc3NZKHkpIHtcbiAgICB0aGlzLnNldFkobWFwUmFuZ2UoeSwgMCwgMSwgdGhpcy5jb250YWluZXJCb3VuZHNbMF0sIHRoaXMuY29udGFpbmVyQm91bmRzWzJdKSwgZmFsc2UpO1xuICB9XG5cbiAgdXBkYXRlU2Nyb2xsQ29vcmRzKCkge1xuICAgIGNvbnN0IHN4ID0gcm91bmQodGhpcy51c2VXaW4gPyB3aW4uc2Nyb2xsWCA6IHRoaXMuJGNvbnRhaW5lci5zY3JvbGxMZWZ0LCAwKTtcbiAgICBjb25zdCBzeSA9IHJvdW5kKHRoaXMudXNlV2luID8gd2luLnNjcm9sbFkgOiB0aGlzLiRjb250YWluZXIuc2Nyb2xsVG9wLCAwKTtcbiAgICBjb25zdCBbIGNwdCwgY3ByLCBjcGIsIGNwbCBdID0gdGhpcy5jb250YWluZXJQYWRkaW5nO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuc2Nyb2xsVGhyZXNob2xkO1xuICAgIHRoaXMuc2Nyb2xsLnggPSBzeDtcbiAgICB0aGlzLnNjcm9sbC55ID0gc3k7XG4gICAgdGhpcy5zY3JvbGxCb3VuZHNbMF0gPSBzeSAtIHRoaXMudGFyZ2V0Qm91bmRzWzBdICsgY3B0IC0gdGhyZXNob2xkO1xuICAgIHRoaXMuc2Nyb2xsQm91bmRzWzFdID0gc3ggLSB0aGlzLnRhcmdldEJvdW5kc1sxXSAtIGNwciArIHRocmVzaG9sZDtcbiAgICB0aGlzLnNjcm9sbEJvdW5kc1syXSA9IHN5IC0gdGhpcy50YXJnZXRCb3VuZHNbMl0gLSBjcGIgKyB0aHJlc2hvbGQ7XG4gICAgdGhpcy5zY3JvbGxCb3VuZHNbM10gPSBzeCAtIHRoaXMudGFyZ2V0Qm91bmRzWzNdICsgY3BsIC0gdGhyZXNob2xkO1xuICB9XG5cbiAgdXBkYXRlQm91bmRpbmdWYWx1ZXMoKSB7XG4gICAgY29uc3QgJGNvbnRhaW5lciA9IHRoaXMuJGNvbnRhaW5lcjtcbiAgICAvLyBSZXR1cm4gZWFybHkgaWYgbm8gJGNvbnRhaW5lciBkZWZpbmVkIHRvIHByZXZlbnRzIGVycm9yIHdoZW4gcmVhZGluZyBzY3JvbGxXaWR0aCAvIHNjcm9sbEhlaWdodFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWxpYW5nYXJuaWVyL2FuaW1lL2lzc3Vlcy8xMDY0XG4gICAgaWYgKCEkY29udGFpbmVyKSByZXR1cm47XG4gICAgY29uc3QgY3ggPSB0aGlzLng7XG4gICAgY29uc3QgY3kgPSB0aGlzLnk7XG4gICAgY29uc3QgY3gyID0gdGhpcy5jb29yZHNbMl07XG4gICAgY29uc3QgY3kyID0gIHRoaXMuY29vcmRzWzNdO1xuICAgIC8vIFByZXZlbnRzIGludGVyZmVyaW5nIHdpdGggdGhlIHNjcm9sbCBhcmVhIGluIGNhc2VzIHRoZSB0YXJnZXQgaXMgb3V0c2lkZSBvZiB0aGUgY29udGFpbmVyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0ZW1wIGNvb3JkcyBhcmUgYWxzbyBhZGp1c2V0IHRvIHByZXZlbnRzIHdyb25nIGRlbHRhIGNhbGN1bGF0aW9uIG9uIHVwZGF0ZXNcbiAgICB0aGlzLmNvb3Jkc1syXSA9IDA7XG4gICAgdGhpcy5jb29yZHNbM10gPSAwO1xuICAgIHRoaXMuc2V0WCgwLCB0cnVlKTtcbiAgICB0aGlzLnNldFkoMCwgdHJ1ZSk7XG4gICAgdGhpcy50cmFuc2Zvcm1zLnJlbW92ZSgpO1xuICAgIGNvbnN0IGl3ID0gdGhpcy53aW5kb3dbMF0gPSB3aW4uaW5uZXJXaWR0aDtcbiAgICBjb25zdCBpaCA9IHRoaXMud2luZG93WzFdID0gd2luLmlubmVySGVpZ2h0O1xuICAgIGNvbnN0IHV3ID0gdGhpcy51c2VXaW47XG4gICAgY29uc3Qgc3cgPSAkY29udGFpbmVyLnNjcm9sbFdpZHRoO1xuICAgIGNvbnN0IHNoID0gJGNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgY29uc3QgZnggPSB0aGlzLmZpeGVkO1xuICAgIGNvbnN0IHRyYW5zZm9ybUNvbnRhaW5lclJlY3QgPSAkY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IFsgY3B0LCBjcHIsIGNwYiwgY3BsIF0gPSB0aGlzLmNvbnRhaW5lclBhZGRpbmc7XG4gICAgdGhpcy5kcmFnQXJlYVswXSA9IHV3ID8gMCA6IHRyYW5zZm9ybUNvbnRhaW5lclJlY3QubGVmdDtcbiAgICB0aGlzLmRyYWdBcmVhWzFdID0gdXcgPyAwIDogdHJhbnNmb3JtQ29udGFpbmVyUmVjdC50b3A7XG4gICAgdGhpcy5zY3JvbGxWaWV3WzBdID0gdXcgPyBjbGFtcChzdywgaXcsIHN3KSA6IHN3O1xuICAgIHRoaXMuc2Nyb2xsVmlld1sxXSA9IHV3ID8gY2xhbXAoc2gsIGloLCBzaCkgOiBzaDtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH0gPSAkY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuZHJhZ0FyZWFbMl0gPSByb3VuZCh1dyA/IGNsYW1wKHdpZHRoLCBpdywgaXcpIDogd2lkdGgsIDApO1xuICAgIHRoaXMuZHJhZ0FyZWFbM10gPSByb3VuZCh1dyA/IGNsYW1wKGhlaWdodCwgaWgsIGloKSA6IGhlaWdodCwgMCk7XG4gICAgY29uc3QgY29udGFpbmVyT3ZlcmZsb3cgPSBnZXRUYXJnZXRWYWx1ZSgkY29udGFpbmVyLCAnb3ZlcmZsb3cnKTtcbiAgICBjb25zdCB2aXNpYmxlT3ZlcmZsb3cgPSBjb250YWluZXJPdmVyZmxvdyA9PT0gJ3Zpc2libGUnO1xuICAgIGNvbnN0IGhpZGRlbk92ZXJmbG93ID0gY29udGFpbmVyT3ZlcmZsb3cgPT09ICdoaWRkZW4nO1xuICAgIHRoaXMuY2FuU2Nyb2xsID0gZnggPyBmYWxzZSA6XG4gICAgICB0aGlzLmNvbnRhaW5lZCAmJlxuICAgICAgKCgkY29udGFpbmVyID09PSBkb2MuYm9keSAmJiB2aXNpYmxlT3ZlcmZsb3cpIHx8ICghaGlkZGVuT3ZlcmZsb3cgJiYgIXZpc2libGVPdmVyZmxvdykpICYmXG4gICAgICAoc3cgPiB0aGlzLmRyYWdBcmVhWzJdICsgY3BsIC0gY3ByIHx8IHNoID4gdGhpcy5kcmFnQXJlYVszXSArIGNwdCAtIGNwYikgJiZcbiAgICAgICghdGhpcy5jb250YWluZXJBcnJheSB8fCAodGhpcy5jb250YWluZXJBcnJheSAmJiAhaXNBcnIodGhpcy5jb250YWluZXJBcnJheSkpKTtcbiAgICBpZiAodGhpcy5jb250YWluZWQpIHtcbiAgICAgIGNvbnN0IHN4ID0gdGhpcy5zY3JvbGwueDtcbiAgICAgIGNvbnN0IHN5ID0gdGhpcy5zY3JvbGwueTtcbiAgICAgIGNvbnN0IGNhblNjcm9sbCA9IHRoaXMuY2FuU2Nyb2xsO1xuICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRoaXMuJHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGhpZGRlbkxlZnQgPSBjYW5TY3JvbGwgPyB1dyA/IDAgOiAkY29udGFpbmVyLnNjcm9sbExlZnQgOiAwO1xuICAgICAgY29uc3QgaGlkZGVuVG9wID0gY2FuU2Nyb2xsID8gdXcgPyAwIDogJGNvbnRhaW5lci5zY3JvbGxUb3AgOiAwO1xuICAgICAgY29uc3QgaGlkZGVuUmlnaHQgPSBjYW5TY3JvbGwgPyB0aGlzLnNjcm9sbFZpZXdbMF0gLSBoaWRkZW5MZWZ0IC0gd2lkdGggOiAwO1xuICAgICAgY29uc3QgaGlkZGVuQm90dG9tID0gY2FuU2Nyb2xsID8gdGhpcy5zY3JvbGxWaWV3WzFdIC0gaGlkZGVuVG9wIC0gaGVpZ2h0IDogMDtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzBdID0gcm91bmQoKHRhcmdldFJlY3QudG9wICsgc3kpIC0gKHV3ID8gMCA6IHRvcCksIDApO1xuICAgICAgdGhpcy50YXJnZXRCb3VuZHNbMV0gPSByb3VuZCgodGFyZ2V0UmVjdC5yaWdodCArIHN4KSAtICh1dyA/IGl3IDogcmlnaHQpLCAwKTtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzJdID0gcm91bmQoKHRhcmdldFJlY3QuYm90dG9tICsgc3kpIC0gKHV3ID8gaWggOiBib3R0b20pLCAwKTtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzNdID0gcm91bmQoKHRhcmdldFJlY3QubGVmdCArIHN4KSAtICh1dyA/IDAgOiBsZWZ0KSwgMCk7XG4gICAgICBpZiAodGhpcy5jb250YWluZXJBcnJheSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSA9IHRoaXMuY29udGFpbmVyQXJyYXlbMF0gKyBjcHQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzFdID0gdGhpcy5jb250YWluZXJBcnJheVsxXSAtIGNwcjtcbiAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZHNbMl0gPSB0aGlzLmNvbnRhaW5lckFycmF5WzJdIC0gY3BiO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1szXSA9IHRoaXMuY29udGFpbmVyQXJyYXlbM10gKyBjcGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSA9IC1yb3VuZCh0YXJnZXRSZWN0LnRvcCAtIChmeCA/IGNsYW1wKHRvcCwgMCwgaWgpIDogdG9wKSArIGhpZGRlblRvcCAtIGNwdCwgMCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzFdID0gLXJvdW5kKHRhcmdldFJlY3QucmlnaHQgLSAoZnggPyBjbGFtcChyaWdodCwgMCwgaXcpIDogcmlnaHQpIC0gaGlkZGVuUmlnaHQgKyBjcHIsIDApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1syXSA9IC1yb3VuZCh0YXJnZXRSZWN0LmJvdHRvbSAtIChmeCA/IGNsYW1wKGJvdHRvbSwgMCwgaWgpIDogYm90dG9tKSAtIGhpZGRlbkJvdHRvbSArIGNwYiwgMCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzNdID0gLXJvdW5kKHRhcmdldFJlY3QubGVmdCAtIChmeCA/IGNsYW1wKGxlZnQsIDAsIGl3KSA6IGxlZnQpICsgaGlkZGVuTGVmdCAtIGNwbCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3Jtcy5yZXZlcnQoKTtcbiAgICAvLyBSZXN0b3JlIGNvb3JkaW5hdGVzXG4gICAgdGhpcy5jb29yZHNbMl0gPSBjeDI7XG4gICAgdGhpcy5jb29yZHNbM10gPSBjeTI7XG4gICAgdGhpcy5zZXRYKGN4LCB0cnVlKTtcbiAgICB0aGlzLnNldFkoY3ksIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0FycmF5fSBib3VuZHNcbiAgICogQHBhcmFtICB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBpc091dE9mQm91bmRzKGJvdW5kcywgeCwgeSkge1xuICAgIC8vIFJldHVybnMgMCBpZiBub3QgT0IsIDEgaWYgeCBpcyBPQiwgMiBpZiB5IGlzIE9CLCAzIGlmIGJvdGggeCBhbmQgeSBhcmUgT0JcbiAgICBpZiAoIXRoaXMuY29udGFpbmVkKSByZXR1cm4gMDtcbiAgICBjb25zdCBbIGJ0LCBiciwgYmIsIGJsIF0gPSBib3VuZHM7XG4gICAgY29uc3QgWyBkeCwgZHkgXSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgY29uc3Qgb2J4ID0gIWR4ICYmIHggPCBibCB8fCAhZHggJiYgeCA+IGJyO1xuICAgIGNvbnN0IG9ieSA9ICFkeSAmJiB5IDwgYnQgfHwgIWR5ICYmIHkgPiBiYjtcbiAgICByZXR1cm4gb2J4ICYmICFvYnkgPyAxIDogIW9ieCAmJiBvYnkgPyAyIDogb2J4ICYmIG9ieSA/IDMgOiAwO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtZXRlcnM7XG4gICAgY29uc3QgcGFyYW1YID0gcGFyYW1zLng7XG4gICAgY29uc3QgcGFyYW1ZID0gcGFyYW1zLnk7XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuY29udGFpbmVyLCB0aGlzKTtcbiAgICBjb25zdCBjcCA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLmNvbnRhaW5lclBhZGRpbmcsIHRoaXMpIHx8IDA7XG4gICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovKGlzQXJyKGNwKSA/IGNwIDogW2NwLCBjcCwgY3AsIGNwXSk7XG4gICAgY29uc3QgY3ggPSB0aGlzLng7XG4gICAgY29uc3QgY3kgPSB0aGlzLnk7XG4gICAgY29uc3QgcGFyc2VkQ3Vyc29yU3R5bGVzID0gcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuY3Vyc29yLCB0aGlzKTtcbiAgICBjb25zdCBjdXJzb3JTdHlsZXMgPSB7IG9uSG92ZXI6ICdncmFiJywgb25HcmFiOiAnZ3JhYmJpbmcnIH07XG4gICAgaWYgKHBhcnNlZEN1cnNvclN0eWxlcykge1xuICAgICAgY29uc3QgeyBvbkhvdmVyLCBvbkdyYWIgfSA9IC8qKiBAdHlwZSB7RHJhZ2dhYmxlQ3Vyc29yUGFyYW1zfSAqLyhwYXJzZWRDdXJzb3JTdHlsZXMpO1xuICAgICAgaWYgKG9uSG92ZXIpIGN1cnNvclN0eWxlcy5vbkhvdmVyID0gb25Ib3ZlcjtcbiAgICAgIGlmIChvbkdyYWIpIGN1cnNvclN0eWxlcy5vbkdyYWIgPSBvbkdyYWI7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyQXJyYXkgPSBpc0Fycihjb250YWluZXIpID8gY29udGFpbmVyIDogbnVsbDtcbiAgICB0aGlzLiRjb250YWluZXIgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhjb250YWluZXIgJiYgIXRoaXMuY29udGFpbmVyQXJyYXkgPyBwYXJzZVRhcmdldHMoLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKGNvbnRhaW5lcikpWzBdIDogZG9jLmJvZHkpO1xuICAgIHRoaXMudXNlV2luID0gdGhpcy4kY29udGFpbmVyID09PSBkb2MuYm9keTtcbiAgICAvKiogQHR5cGUge1dpbmRvdyB8IEhUTUxFbGVtZW50fSAqL1xuICAgIHRoaXMuJHNjcm9sbENvbnRhaW5lciA9IHRoaXMudXNlV2luID8gd2luIDogdGhpcy4kY29udGFpbmVyO1xuICAgIHRoaXMuaXNGaW5lUG9pbnRlciA9IG1hdGNoTWVkaWEoJyhwb2ludGVyOmZpbmUpJykubWF0Y2hlcztcbiAgICB0aGlzLmNvbnRhaW5lclBhZGRpbmcgPSBzZXRWYWx1ZShjb250YWluZXJQYWRkaW5nLCBbMCwgMCwgMCwgMF0pO1xuICAgIHRoaXMuY29udGFpbmVyRnJpY3Rpb24gPSBjbGFtcChzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5jb250YWluZXJGcmljdGlvbiwgdGhpcyksIC44KSwgMCwgMSk7XG4gICAgdGhpcy5yZWxlYXNlQ29udGFpbmVyRnJpY3Rpb24gPSBjbGFtcChzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5yZWxlYXNlQ29udGFpbmVyRnJpY3Rpb24sIHRoaXMpLCB0aGlzLmNvbnRhaW5lckZyaWN0aW9uKSwgMCwgMSk7XG4gICAgdGhpcy5zbmFwWCA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIoaXNPYmoocGFyYW1YKSAmJiAhaXNVbmQocGFyYW1YLnNuYXApID8gcGFyYW1YLnNuYXAgOiBwYXJhbXMuc25hcCwgdGhpcyk7XG4gICAgdGhpcy5zbmFwWSA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIoaXNPYmoocGFyYW1ZKSAmJiAhaXNVbmQocGFyYW1ZLnNuYXApID8gcGFyYW1ZLnNuYXAgOiBwYXJhbXMuc25hcCwgdGhpcyk7XG4gICAgdGhpcy5zY3JvbGxTcGVlZCA9IHNldFZhbHVlKHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnNjcm9sbFNwZWVkLCB0aGlzKSwgMS41KTtcbiAgICB0aGlzLnNjcm9sbFRocmVzaG9sZCA9IHNldFZhbHVlKHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnNjcm9sbFRocmVzaG9sZCwgdGhpcyksIDIwKTtcbiAgICB0aGlzLmRyYWdTcGVlZCA9IHNldFZhbHVlKHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLmRyYWdTcGVlZCwgdGhpcyksIDEpO1xuICAgIHRoaXMubWluVmVsb2NpdHkgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5taW5WZWxvY2l0eSwgdGhpcyksIDApO1xuICAgIHRoaXMubWF4VmVsb2NpdHkgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5tYXhWZWxvY2l0eSwgdGhpcyksIDUwKTtcbiAgICB0aGlzLnZlbG9jaXR5TXVsdGlwbGllciA9IHNldFZhbHVlKHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnZlbG9jaXR5TXVsdGlwbGllciwgdGhpcyksIDEpO1xuICAgIHRoaXMuY3Vyc29yID0gcGFyc2VkQ3Vyc29yU3R5bGVzID09PSBmYWxzZSA/IGZhbHNlIDogY3Vyc29yU3R5bGVzO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdWYWx1ZXMoKTtcblxuICAgIC8vIGNvbnN0IG9iID0gdGhpcy5pc091dE9mQm91bmRzKHRoaXMuY29udGFpbmVyQm91bmRzLCB0aGlzLngsIHRoaXMueSk7XG4gICAgLy8gaWYgKG9iID09PSAxIHx8IG9iID09PSAzKSB0aGlzLnByb2dyZXNzWCA9IHB4O1xuICAgIC8vIGlmIChvYiA9PT0gMiB8fCBvYiA9PT0gMykgdGhpcy5wcm9ncmVzc1kgPSBweTtcblxuICAgIC8vIGlmICh0aGlzLmluaXRpYWxpemVkICYmIHRoaXMuY29udGFpbmVkKSB7XG4gICAgLy8gICBpZiAodGhpcy5wcm9ncmVzc1ggIT09IHB4KSB0aGlzLnByb2dyZXNzWCA9IHB4O1xuICAgIC8vICAgaWYgKHRoaXMucHJvZ3Jlc3NZICE9PSBweSkgdGhpcy5wcm9ncmVzc1kgPSBweTtcbiAgICAvLyB9XG5cbiAgICBjb25zdCBbIGJ0LCBiciwgYmIsIGJsIF0gPSB0aGlzLmNvbnRhaW5lckJvdW5kcztcbiAgICB0aGlzLnNldFgoY2xhbXAoY3gsIGJsLCBiciksIHRydWUpO1xuICAgIHRoaXMuc2V0WShjbGFtcChjeSwgYnQsIGJiKSwgdHJ1ZSk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxDb29yZHMoKTtcbiAgICBpZiAodGhpcy5jYW5TY3JvbGwpIHtcbiAgICAgIGNvbnN0IFsgY3B0LCBjcHIsIGNwYiwgY3BsIF0gPSB0aGlzLmNvbnRhaW5lclBhZGRpbmc7XG4gICAgICBjb25zdCBbIHN3LCBzaCBdID0gdGhpcy5zY3JvbGxWaWV3O1xuICAgICAgY29uc3QgZGF3ID0gdGhpcy5kcmFnQXJlYVsyXTtcbiAgICAgIGNvbnN0IGRhaCA9IHRoaXMuZHJhZ0FyZWFbM107XG4gICAgICBjb25zdCBjc3ggPSB0aGlzLnNjcm9sbC54O1xuICAgICAgY29uc3QgY3N5ID0gdGhpcy5zY3JvbGwueTtcbiAgICAgIGNvbnN0IG5zdyA9IHRoaXMuJGNvbnRhaW5lci5zY3JvbGxXaWR0aDtcbiAgICAgIGNvbnN0IG5zaCA9IHRoaXMuJGNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICBjb25zdCBjc3cgPSB0aGlzLnVzZVdpbiA/IGNsYW1wKG5zdywgdGhpcy53aW5kb3dbMF0sIG5zdykgOiBuc3c7XG4gICAgICBjb25zdCBjc2ggPSB0aGlzLnVzZVdpbiA/IGNsYW1wKG5zaCwgdGhpcy53aW5kb3dbMV0sIG5zaCkgOiBuc2g7XG4gICAgICBjb25zdCBzd2QgPSBzdyAtIGNzdztcbiAgICAgIGNvbnN0IHNoZCA9IHNoIC0gY3NoO1xuICAgICAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBzY3JvbGxhcmVhIGRpbWVuc2lvbnMgY2hhbmdlcyBkdXJpbmcgZHJhZ1xuICAgICAgaWYgKHRoaXMuZHJhZ2dlZCAmJiBzd2QgPiAwKSB7XG4gICAgICAgIHRoaXMuY29vcmRzWzBdIC09IHN3ZDtcbiAgICAgICAgdGhpcy5zY3JvbGxWaWV3WzBdID0gY3N3O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZHJhZ2dlZCAmJiBzaGQgPiAwKSB7XG4gICAgICAgIHRoaXMuY29vcmRzWzFdIC09IHNoZDtcbiAgICAgICAgdGhpcy5zY3JvbGxWaWV3WzFdID0gY3NoO1xuICAgICAgfVxuICAgICAgLy8gSGFuZGxlIGF1dG9zY3JvbGwgd2hlbiB0YXJnZXQgaXMgYXQgdGhlIGVkZ2VzIG9mIHRoZSBzY3JvbGwgYm91bmRzXG4gICAgICBjb25zdCBzID0gdGhpcy5zY3JvbGxTcGVlZCAqIDEwO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5zY3JvbGxUaHJlc2hvbGQ7XG4gICAgICBjb25zdCBbIHgsIHkgXSA9IHRoaXMuY29vcmRzO1xuICAgICAgY29uc3QgWyBzdCwgc3IsIHNiLCBzbCBdID0gdGhpcy5zY3JvbGxCb3VuZHM7XG4gICAgICBjb25zdCB0ID0gcm91bmQoY2xhbXAoKHkgLSBzdCArIGNwdCkgLyB0aHJlc2hvbGQsIC0xLCAwKSAqIHMsIDApO1xuICAgICAgY29uc3QgciA9IHJvdW5kKGNsYW1wKCh4IC0gc3IgLSBjcHIpIC8gdGhyZXNob2xkLCAwLCAxKSAqIHMsIDApO1xuICAgICAgY29uc3QgYiA9IHJvdW5kKGNsYW1wKCh5IC0gc2IgLSBjcGIpIC8gdGhyZXNob2xkLCAwLCAxKSAqIHMsIDApO1xuICAgICAgY29uc3QgbCA9IHJvdW5kKGNsYW1wKCh4IC0gc2wgKyBjcGwpIC8gdGhyZXNob2xkLCAtMSwgMCkgKiBzLCAwKTtcbiAgICAgIGlmICh0IHx8IGIgfHwgbCB8fCByKSB7XG4gICAgICAgIGNvbnN0IFtueCwgbnldID0gdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgbGV0IHNjcm9sbFggPSBjc3g7XG4gICAgICAgIGxldCBzY3JvbGxZID0gY3N5O1xuICAgICAgICBpZiAoIW54KSB7XG4gICAgICAgICAgc2Nyb2xsWCA9IHJvdW5kKGNsYW1wKGNzeCArIChsIHx8IHIpLCAwLCBzdyAtIGRhdyksIDApO1xuICAgICAgICAgIHRoaXMuY29vcmRzWzBdIC09IGNzeCAtIHNjcm9sbFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFueSkge1xuICAgICAgICAgIHNjcm9sbFkgPSByb3VuZChjbGFtcChjc3kgKyAodCB8fCBiKSwgMCwgc2ggLSBkYWgpLCAwKTtcbiAgICAgICAgICB0aGlzLmNvb3Jkc1sxXSAtPSBjc3kgLSBzY3JvbGxZO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IFNhZmFyaSBtb2JpbGUgcmVxdWlyZXMgdG8gdXNlIGRpZmZlcmVudCBzY3JvbGwgbWV0aG9kcyBkZXBlbmRpbmcgaWYgdXNpbmcgdGhlIHdpbmRvdyBvciBub3RcbiAgICAgICAgaWYgKHRoaXMudXNlV2luKSB7XG4gICAgICAgICAgdGhpcy4kc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEJ5KC0oY3N4IC0gc2Nyb2xsWCksIC0oY3N5IC0gc2Nyb2xsWSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJHNjcm9sbENvbnRhaW5lci5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbIGN0LCBjciwgY2IsIGNsIF0gPSB0aGlzLmNvbnRhaW5lckJvdW5kcztcbiAgICBjb25zdCBbIHB4MSwgcHkxLCBweDIsIHB5MiwgcHgzLCBweTMgXSA9IHRoaXMucG9pbnRlcjtcbiAgICB0aGlzLmNvb3Jkc1swXSArPSAocHgxIC0gcHgzKSAqIHRoaXMuZHJhZ1NwZWVkO1xuICAgIHRoaXMuY29vcmRzWzFdICs9IChweTEgLSBweTMpICogdGhpcy5kcmFnU3BlZWQ7XG4gICAgdGhpcy5wb2ludGVyWzRdID0gcHgxO1xuICAgIHRoaXMucG9pbnRlcls1XSA9IHB5MTtcbiAgICBjb25zdCBbIGN4LCBjeSBdID0gdGhpcy5jb29yZHM7XG4gICAgY29uc3QgWyBzeCwgc3kgXSA9IHRoaXMuc25hcHBlZDtcbiAgICBjb25zdCBjZiA9ICgxIC0gdGhpcy5jb250YWluZXJGcmljdGlvbikgKiB0aGlzLmRyYWdTcGVlZDtcbiAgICB0aGlzLnNldFgoY3ggPiBjciA/IGNyICsgKGN4IC0gY3IpICogY2YgOiBjeCA8IGNsID8gY2wgKyAoY3ggLSBjbCkgKiBjZiA6IGN4LCBmYWxzZSk7XG4gICAgdGhpcy5zZXRZKGN5ID4gY2IgPyBjYiArIChjeSAtIGNiKSAqIGNmIDogY3kgPCBjdCA/IGN0ICsgKGN5IC0gY3QpICogY2YgOiBjeSwgZmFsc2UpO1xuICAgIHRoaXMuY29tcHV0ZVZlbG9jaXR5KHB4MSAtIHB4MywgcHkxIC0gcHkzKTtcbiAgICB0aGlzLmFuZ2xlID0gYXRhbjIocHkxIC0gcHkyLCBweDEgLSBweDIpO1xuICAgIGNvbnN0IFsgbnN4LCBuc3kgXSA9IHRoaXMuc25hcHBlZDtcbiAgICBpZiAobnN4ICE9PSBzeCAmJiB0aGlzLnNuYXBYIHx8IG5zeSAhPT0gc3kgJiYgdGhpcy5zbmFwWSkge1xuICAgICAgdGhpcy5vblNuYXAodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnVwZGF0ZVRpY2tlci5wYXVzZSgpO1xuICAgIHRoaXMub3ZlcnNob290VGlja2VyLnBhdXNlKCk7XG4gICAgLy8gUGF1c2VzIHRoZSBpbiBib3VuZHMgb25SZWxlYXNlIGFuaW1hdGlvbnNcbiAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMuYW5pbWF0ZS5hbmltYXRpb25zKSB0aGlzLmFuaW1hdGUuYW5pbWF0aW9uc1twcm9wXS5wYXVzZSgpO1xuICAgIHJlbW92ZSh0aGlzLCBudWxsLCAneCcpO1xuICAgIHJlbW92ZSh0aGlzLCBudWxsLCAneScpO1xuICAgIHJlbW92ZSh0aGlzLCBudWxsLCAncHJvZ3Jlc3NYJyk7XG4gICAgcmVtb3ZlKHRoaXMsIG51bGwsICdwcm9ncmVzc1knKTtcbiAgICByZW1vdmUodGhpcy5zY3JvbGwpOyAvLyBSZW1vdmVzIGFueSBhY3RpdmUgYW5pbWF0aW9ucyBvbiB0aGUgY29udGFpbmVyIHNjcm9sbFxuICAgIHJlbW92ZSh0aGlzLm92ZXJzaG9vdENvb3Jkcyk7IC8vIFJlbW92ZXMgYWN0aXZlIG92ZXJzaG9vdCBhbmltYXRpb25zXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbl1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtnYXBdXG4gICAqIEBwYXJhbSB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2Nyb2xsSW5WaWV3KGR1cmF0aW9uLCBnYXAgPSAwLCBlYXNlID0gZWFzZXMuaW5PdXRRdWFkKSB7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxDb29yZHMoKTtcbiAgICBjb25zdCB4ID0gdGhpcy5kZXN0WDtcbiAgICBjb25zdCB5ID0gdGhpcy5kZXN0WTtcbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLnNjcm9sbDtcbiAgICBjb25zdCBzY3JvbGxCb3VuZHMgPSB0aGlzLnNjcm9sbEJvdW5kcztcbiAgICBjb25zdCBjYW5TY3JvbGwgPSB0aGlzLmNhblNjcm9sbDtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyQXJyYXkgJiYgdGhpcy5pc091dE9mQm91bmRzKHNjcm9sbEJvdW5kcywgeCwgeSkpIHtcbiAgICAgIGNvbnN0IFsgc3QsIHNyLCBzYiwgc2wgXSA9IHNjcm9sbEJvdW5kcztcbiAgICAgIGNvbnN0IHQgPSByb3VuZChjbGFtcCh5IC0gc3QsIC1tYXhWYWx1ZSwgMCksIDApO1xuICAgICAgY29uc3QgciA9IHJvdW5kKGNsYW1wKHggLSBzciwgMCwgbWF4VmFsdWUpLCAwKTtcbiAgICAgIGNvbnN0IGIgPSByb3VuZChjbGFtcCh5IC0gc2IsIDAsIG1heFZhbHVlKSwgMCk7XG4gICAgICBjb25zdCBsID0gcm91bmQoY2xhbXAoeCAtIHNsLCAtbWF4VmFsdWUsIDApLCAwKTtcbiAgICAgIG5ldyBKU0FuaW1hdGlvbihzY3JvbGwsIHtcbiAgICAgICAgeDogcm91bmQoc2Nyb2xsLnggKyAobCA/IGwgLSBnYXAgOiByID8gciArIGdhcCA6IDApLCAwKSxcbiAgICAgICAgeTogcm91bmQoc2Nyb2xsLnkgKyAodCA/IHQgLSBnYXAgOiBiID8gYiArIGdhcCA6IDApLCAwKSxcbiAgICAgICAgZHVyYXRpb246IGlzVW5kKGR1cmF0aW9uKSA/IDM1MCAqIGdsb2JhbHMudGltZVNjYWxlIDogZHVyYXRpb24sXG4gICAgICAgIGVhc2UsXG4gICAgICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLiRzY3JvbGxDb250YWluZXIuc2Nyb2xsVG8oc2Nyb2xsLngsIHNjcm9sbC55KTtcbiAgICAgICAgfVxuICAgICAgfSkuaW5pdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmNhblNjcm9sbCA9IGNhblNjcm9sbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGhhbmRsZUhvdmVyKCkge1xuICAgIGlmICh0aGlzLmlzRmluZVBvaW50ZXIgJiYgdGhpcy5jdXJzb3IgJiYgIXRoaXMuY3Vyc29yU3R5bGVzKSB7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0cmlnZ2VyLCB7XG4gICAgICAgIGN1cnNvcjogLyoqIEB0eXBlIHtEcmFnZ2FibGVDdXJzb3JQYXJhbXN9ICovKHRoaXMuY3Vyc29yKS5vbkhvdmVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbZHVyYXRpb25dXG4gICAqIEBwYXJhbSAge051bWJlcn0gW2dhcF1cbiAgICogQHBhcmFtICB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgYW5pbWF0ZUluVmlldyhkdXJhdGlvbiwgZ2FwID0gMCwgZWFzZSA9IGVhc2VzLmluT3V0UXVhZCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdWYWx1ZXMoKTtcbiAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgY29uc3QgWyBjcHQsIGNwciwgY3BiLCBjcGwgXSA9IHRoaXMuY29udGFpbmVyUGFkZGluZztcbiAgICBjb25zdCBidCA9IHRoaXMuc2Nyb2xsLnkgLSB0aGlzLnRhcmdldEJvdW5kc1swXSArIGNwdCArIGdhcDtcbiAgICBjb25zdCBiciA9IHRoaXMuc2Nyb2xsLnggLSB0aGlzLnRhcmdldEJvdW5kc1sxXSAtIGNwciAtIGdhcDtcbiAgICBjb25zdCBiYiA9IHRoaXMuc2Nyb2xsLnkgLSB0aGlzLnRhcmdldEJvdW5kc1syXSAtIGNwYiAtIGdhcDtcbiAgICBjb25zdCBibCA9IHRoaXMuc2Nyb2xsLnggLSB0aGlzLnRhcmdldEJvdW5kc1szXSArIGNwbCArIGdhcDtcbiAgICBjb25zdCBvYiA9IHRoaXMuaXNPdXRPZkJvdW5kcyhbYnQsIGJyLCBiYiwgYmxdLCB4LCB5KTtcbiAgICBpZiAob2IpIHtcbiAgICAgIGNvbnN0IFsgZGlzYWJsZWRYLCBkaXNhYmxlZFkgXSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICBjb25zdCBkZXN0WCA9IGNsYW1wKHNuYXAoeCwgdGhpcy5zbmFwWCksIGJsLCBicik7XG4gICAgICBjb25zdCBkZXN0WSA9IGNsYW1wKHNuYXAoeSwgdGhpcy5zbmFwWSksIGJ0LCBiYik7XG4gICAgICBjb25zdCBkdXIgPSBpc1VuZChkdXJhdGlvbikgPyAzNTAgKiBnbG9iYWxzLnRpbWVTY2FsZSA6IGR1cmF0aW9uO1xuICAgICAgaWYgKCFkaXNhYmxlZFggJiYgKG9iID09PSAxIHx8IG9iID09PSAzKSkgdGhpcy5hbmltYXRlW3RoaXMueFByb3BdKGRlc3RYLCBkdXIsIGVhc2UpO1xuICAgICAgaWYgKCFkaXNhYmxlZFkgJiYgKG9iID09PSAyIHx8IG9iID09PSAzKSkgdGhpcy5hbmltYXRlW3RoaXMueVByb3BdKGRlc3RZLCBkdXIsIGVhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRG93bihlKSB7XG4gICAgY29uc3QgJGVUYXJnZXQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhlLnRhcmdldCk7XG4gICAgaWYgKHRoaXMuZ3JhYmJlZCB8fCAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICovKCRlVGFyZ2V0KS50eXBlID09PSAncmFuZ2UnKSByZXR1cm47XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5ncmFiYmVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1ZhbHVlcygpO1xuICAgIGNvbnN0IHRvdWNoZXMgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGUpLmNoYW5nZWRUb3VjaGVzO1xuICAgIGNvbnN0IGV2ZW50WCA9IHRvdWNoZXMgPyB0b3VjaGVzWzBdLmNsaWVudFggOiAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovKGUpLmNsaWVudFg7XG4gICAgY29uc3QgZXZlbnRZID0gdG91Y2hlcyA/IHRvdWNoZXNbMF0uY2xpZW50WSA6IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkuY2xpZW50WTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudHJhbnNmb3Jtcy5ub3JtYWxpemVQb2ludChldmVudFgsIGV2ZW50WSk7XG4gICAgY29uc3QgWyBjdCwgY3IsIGNiLCBjbCBdID0gdGhpcy5jb250YWluZXJCb3VuZHM7XG4gICAgY29uc3QgY2YgPSAoMSAtIHRoaXMuY29udGFpbmVyRnJpY3Rpb24pICogdGhpcy5kcmFnU3BlZWQ7XG4gICAgY29uc3QgY3ggPSB0aGlzLng7XG4gICAgY29uc3QgY3kgPSB0aGlzLnk7XG4gICAgdGhpcy5jb29yZHNbMF0gPSB0aGlzLmNvb3Jkc1syXSA9ICFjZiA/IGN4IDogY3ggPiBjciA/IGNyICsgKGN4IC0gY3IpIC8gY2YgOiBjeCA8IGNsID8gY2wgKyAoY3ggLSBjbCkgLyBjZiA6IGN4O1xuICAgIHRoaXMuY29vcmRzWzFdID0gdGhpcy5jb29yZHNbM10gPSAhY2YgPyBjeSA6IGN5ID4gY2IgPyBjYiArIChjeSAtIGNiKSAvIGNmIDogY3kgPCBjdCA/IGN0ICsgKGN5IC0gY3QpIC8gY2YgOiBjeTtcbiAgICB0aGlzLnBvaW50ZXJbMF0gPSB4O1xuICAgIHRoaXMucG9pbnRlclsxXSA9IHk7XG4gICAgdGhpcy5wb2ludGVyWzJdID0geDtcbiAgICB0aGlzLnBvaW50ZXJbM10gPSB5O1xuICAgIHRoaXMucG9pbnRlcls0XSA9IHg7XG4gICAgdGhpcy5wb2ludGVyWzVdID0geTtcbiAgICB0aGlzLnBvaW50ZXJbNl0gPSB4O1xuICAgIHRoaXMucG9pbnRlcls3XSA9IHk7XG4gICAgdGhpcy5kZWx0YVggPSAwO1xuICAgIHRoaXMuZGVsdGFZID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tbMF0gPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja1sxXSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrWzJdID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tJbmRleCA9IDA7XG4gICAgdGhpcy5hbmdsZSA9IDA7XG4gICAgaWYgKHRoaXMudGFyZ2V0U3R5bGVzKSB7XG4gICAgICB0aGlzLnRhcmdldFN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMudGFyZ2V0U3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeiA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhnZXRUYXJnZXRWYWx1ZSh0aGlzLiR0YXJnZXQsICd6SW5kZXgnLCBmYWxzZSkpO1xuICAgIHpJbmRleCA9ICh6ID4gekluZGV4ID8geiA6IHpJbmRleCkgKyAxO1xuICAgIHRoaXMudGFyZ2V0U3R5bGVzID0gc2V0VGFyZ2V0VmFsdWVzKHRoaXMuJHRhcmdldCwgeyB6SW5kZXggfSk7XG4gICAgaWYgKHRoaXMudHJpZ2dlclN0eWxlcykge1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzLnJldmVydCgpO1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3Vyc29yU3R5bGVzKSB7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuY3Vyc29yU3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGaW5lUG9pbnRlciAmJiB0aGlzLmN1cnNvcikge1xuICAgICAgdGhpcy5ib2R5U3R5bGVzID0gc2V0VGFyZ2V0VmFsdWVzKGRvYy5ib2R5LCB7XG4gICAgICAgIGN1cnNvcjogLyoqIEB0eXBlIHtEcmFnZ2FibGVDdXJzb3JQYXJhbXN9ICovKHRoaXMuY3Vyc29yKS5vbkdyYWJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnNjcm9sbEluVmlldygxMDAsIDAsIGVhc2VzLm91dCgzKSk7XG4gICAgdGhpcy5vbkdyYWIodGhpcyk7XG5cbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fFRvdWNoRXZlbnR9IGVcbiAgICovXG4gIGhhbmRsZU1vdmUoZSkge1xuICAgIGlmICghdGhpcy5ncmFiYmVkKSByZXR1cm47XG4gICAgY29uc3QgdG91Y2hlcyA9IC8qKiBAdHlwZSB7VG91Y2hFdmVudH0gKi8oZSkuY2hhbmdlZFRvdWNoZXM7XG4gICAgY29uc3QgZXZlbnRYID0gdG91Y2hlcyA/IHRvdWNoZXNbMF0uY2xpZW50WCA6IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkuY2xpZW50WDtcbiAgICBjb25zdCBldmVudFkgPSB0b3VjaGVzID8gdG91Y2hlc1swXS5jbGllbnRZIDogLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyhlKS5jbGllbnRZO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50cmFuc2Zvcm1zLm5vcm1hbGl6ZVBvaW50KGV2ZW50WCwgZXZlbnRZKTtcbiAgICBjb25zdCBtb3ZlZFggPSB4IC0gdGhpcy5wb2ludGVyWzZdO1xuICAgIGNvbnN0IG1vdmVkWSA9IHkgLSB0aGlzLnBvaW50ZXJbN107XG5cbiAgICBsZXQgJHBhcmVudCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGUudGFyZ2V0KTtcbiAgICBsZXQgaXNBdFRvcCA9IGZhbHNlO1xuICAgIGxldCBpc0F0Qm90dG9tID0gZmFsc2U7XG4gICAgbGV0IGNhblRvdWNoU2Nyb2xsID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodG91Y2hlcyAmJiAkcGFyZW50ICYmICRwYXJlbnQgIT09IHRoaXMuJHRyaWdnZXIpIHtcbiAgICAgIGNvbnN0IG92ZXJmbG93WSA9IGdldFRhcmdldFZhbHVlKCRwYXJlbnQsICdvdmVyZmxvdy15Jyk7XG4gICAgICBpZiAob3ZlcmZsb3dZICE9PSAnaGlkZGVuJyAmJiBvdmVyZmxvd1kgIT09ICd2aXNpYmxlJykge1xuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgfSA9ICRwYXJlbnQ7XG4gICAgICAgIGlmIChzY3JvbGxIZWlnaHQgPiBjbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICBjYW5Ub3VjaFNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgaXNBdFRvcCA9IHNjcm9sbFRvcCA8PSAzO1xuICAgICAgICAgIGlzQXRCb3R0b20gPSBzY3JvbGxUb3AgPj0gKHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodCkgLSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAkcGFyZW50ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oJHBhcmVudC5wYXJlbnROb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoY2FuVG91Y2hTY3JvbGwgJiYgKCghaXNBdFRvcCAmJiAhaXNBdEJvdHRvbSkgfHwgKGlzQXRUb3AgJiYgbW92ZWRZIDwgMCkgfHwgKGlzQXRCb3R0b20gJiYgbW92ZWRZID4gMCkpKSB7XG5cbiAgICAgIHRoaXMucG9pbnRlclswXSA9IHg7XG4gICAgICB0aGlzLnBvaW50ZXJbMV0gPSB5O1xuICAgICAgdGhpcy5wb2ludGVyWzJdID0geDtcbiAgICAgIHRoaXMucG9pbnRlclszXSA9IHk7XG4gICAgICB0aGlzLnBvaW50ZXJbNF0gPSB4O1xuICAgICAgdGhpcy5wb2ludGVyWzVdID0geTtcbiAgICAgIHRoaXMucG9pbnRlcls2XSA9IHg7XG4gICAgICB0aGlzLnBvaW50ZXJbN10gPSB5O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcHJldmVudERlZmF1bHQoZSk7XG5cbiAgICAgIC8vIE5lZWRlZCB0byBwcmV2ZW50cyBjbGljayBvbiBoYW5kbGVVcFxuICAgICAgaWYgKCF0aGlzLnRyaWdnZXJTdHlsZXMpIHRoaXMudHJpZ2dlclN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0cmlnZ2VyLCB7IHBvaW50ZXJFdmVudHM6ICdub25lJyB9KTtcbiAgICAgIC8vIE5lZWRlZCB0byBwcmV2ZW50IHBhZ2Ugc2Nyb2xsIHdoaWxlIGRyYWdnaW5nIG9uIHRvdWNoIGRldnZpY2VcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnREZWZhdWx0LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgdGhpcy4kdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50RGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cblxuICAgICAgaWYgKCghdGhpcy5kaXNhYmxlZFswXSAmJiBhYnMobW92ZWRYKSA+IDMpIHx8ICghdGhpcy5kaXNhYmxlZFsxXSAmJiBhYnMobW92ZWRZKSA+IDMpKSB7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUaWNrZXIucmVzdW1lKCk7XG4gICAgICAgIHRoaXMucG9pbnRlclsyXSA9IHRoaXMucG9pbnRlclswXTtcbiAgICAgICAgdGhpcy5wb2ludGVyWzNdID0gdGhpcy5wb2ludGVyWzFdO1xuICAgICAgICB0aGlzLnBvaW50ZXJbMF0gPSB4O1xuICAgICAgICB0aGlzLnBvaW50ZXJbMV0gPSB5O1xuICAgICAgICB0aGlzLmRyYWdnZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25EcmFnKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVVwKCkge1xuXG4gICAgaWYgKCF0aGlzLmdyYWJiZWQpIHJldHVybjtcblxuICAgIHRoaXMudXBkYXRlVGlja2VyLnBhdXNlKCk7XG5cbiAgICBpZiAodGhpcy50cmlnZ2VyU3R5bGVzKSB7XG4gICAgICB0aGlzLnRyaWdnZXJTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnRyaWdnZXJTdHlsZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJvZHlTdHlsZXMpIHtcbiAgICAgIHRoaXMuYm9keVN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuYm9keVN0eWxlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgWyBkaXNhYmxlZFgsIGRpc2FibGVkWSBdID0gdGhpcy5kaXNhYmxlZDtcbiAgICBjb25zdCBbIHB4MSwgcHkxLCBweDIsIHB5MiwgcHgzLCBweTMgXSA9IHRoaXMucG9pbnRlcjtcbiAgICBjb25zdCBbIGN0LCBjciwgY2IsIGNsIF0gPSB0aGlzLmNvbnRhaW5lckJvdW5kcztcbiAgICBjb25zdCBbIHN4LCBzeSBdID0gdGhpcy5zbmFwcGVkO1xuICAgIGNvbnN0IHNwcmluZ1ggPSB0aGlzLnJlbGVhc2VYU3ByaW5nO1xuICAgIGNvbnN0IHNwcmluZ1kgPSB0aGlzLnJlbGVhc2VZU3ByaW5nO1xuICAgIGNvbnN0IHJlbGVhc2VFYXNlID0gdGhpcy5yZWxlYXNlRWFzZTtcbiAgICBjb25zdCBoYXNSZWxlYXNlU3ByaW5nID0gdGhpcy5oYXNSZWxlYXNlU3ByaW5nO1xuICAgIGNvbnN0IG92ZXJzaG9vdENvb3JkcyA9IHRoaXMub3ZlcnNob290Q29vcmRzO1xuICAgIGNvbnN0IGN4ID0gdGhpcy54O1xuICAgIGNvbnN0IGN5ID0gdGhpcy55O1xuICAgIGNvbnN0IHB2ID0gdGhpcy5jb21wdXRlVmVsb2NpdHkocHgxIC0gcHgzLCBweTEgLSBweTMpO1xuICAgIGNvbnN0IHBhID0gdGhpcy5hbmdsZSA9IGF0YW4yKHB5MSAtIHB5MiwgcHgxIC0gcHgyKTtcbiAgICBjb25zdCBkcyA9IHB2ICogMTUwO1xuICAgIGNvbnN0IGNmID0gKDEgLSB0aGlzLnJlbGVhc2VDb250YWluZXJGcmljdGlvbikgKiB0aGlzLmRyYWdTcGVlZDtcbiAgICBjb25zdCBueCA9IGN4ICsgKGNvcyhwYSkgKiBkcyk7XG4gICAgY29uc3QgbnkgPSBjeSArIChzaW4ocGEpICogZHMpO1xuICAgIGNvbnN0IGJ4ID0gbnggPiBjciA/IGNyICsgKG54IC0gY3IpICogY2YgOiBueCA8IGNsID8gY2wgKyAobnggLSBjbCkgKiBjZiA6IG54O1xuICAgIGNvbnN0IGJ5ID0gbnkgPiBjYiA/IGNiICsgKG55IC0gY2IpICogY2YgOiBueSA8IGN0ID8gY3QgKyAobnkgLSBjdCkgKiBjZiA6IG55O1xuICAgIGNvbnN0IGR4ID0gdGhpcy5kZXN0WCA9IGNsYW1wKHJvdW5kKHNuYXAoYngsIHRoaXMuc25hcFgpLCA1KSwgY2wsIGNyKTtcbiAgICBjb25zdCBkeSA9IHRoaXMuZGVzdFkgPSBjbGFtcChyb3VuZChzbmFwKGJ5LCB0aGlzLnNuYXBZKSwgNSksIGN0LCBjYik7XG4gICAgY29uc3Qgb2IgPSB0aGlzLmlzT3V0T2ZCb3VuZHModGhpcy5jb250YWluZXJCb3VuZHMsIG54LCBueSk7XG5cbiAgICBsZXQgZHVyYXRpb25YID0gMDtcbiAgICBsZXQgZHVyYXRpb25ZID0gMDtcbiAgICBsZXQgZWFzZVggPSByZWxlYXNlRWFzZTtcbiAgICBsZXQgZWFzZVkgPSByZWxlYXNlRWFzZTtcbiAgICBsZXQgbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbiA9IDA7XG5cbiAgICBvdmVyc2hvb3RDb29yZHMueCA9IGN4O1xuICAgIG92ZXJzaG9vdENvb3Jkcy55ID0gY3k7XG5cbiAgICBpZiAoIWRpc2FibGVkWCkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uWCA9IGR4ID09PSBjciA/IGN4ID4gY3IgPyAtMSA6IDEgOiBjeCA8IGNsID8gLTEgOiAxO1xuICAgICAgY29uc3QgZGlzdGFuY2VYID0gcm91bmQoY3ggLSBkeCwgMCk7XG4gICAgICBzcHJpbmdYLnZlbG9jaXR5ID0gZGlzYWJsZWRZICYmIGhhc1JlbGVhc2VTcHJpbmcgPyBkaXN0YW5jZVggPyAoZHMgKiBkaXJlY3Rpb25YKSAvIGFicyhkaXN0YW5jZVgpIDogMCA6IHB2O1xuICAgICAgY29uc3QgeyBlYXNlLCBkdXJhdGlvbiwgcmVzdER1cmF0aW9uIH0gPSBzcHJpbmdYO1xuICAgICAgZHVyYXRpb25YID0gY3ggPT09IGR4ID8gMCA6IGhhc1JlbGVhc2VTcHJpbmcgPyBkdXJhdGlvbiA6IGR1cmF0aW9uIC0gKHJlc3REdXJhdGlvbiAqIGdsb2JhbHMudGltZVNjYWxlKTtcbiAgICAgIGlmIChoYXNSZWxlYXNlU3ByaW5nKSBlYXNlWCA9IGVhc2U7XG4gICAgICBpZiAoZHVyYXRpb25YID4gbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbikgbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbiA9IGR1cmF0aW9uWDtcbiAgICB9XG5cbiAgICBpZiAoIWRpc2FibGVkWSkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uWSA9IGR5ID09PSBjYiA/IGN5ID4gY2IgPyAtMSA6IDEgOiBjeSA8IGN0ID8gLTEgOiAxO1xuICAgICAgY29uc3QgZGlzdGFuY2VZID0gcm91bmQoY3kgLSBkeSwgMCk7XG4gICAgICBzcHJpbmdZLnZlbG9jaXR5ID0gZGlzYWJsZWRYICYmIGhhc1JlbGVhc2VTcHJpbmcgPyBkaXN0YW5jZVkgPyAoZHMgKiBkaXJlY3Rpb25ZKSAvIGFicyhkaXN0YW5jZVkpIDogMCA6IHB2O1xuICAgICAgY29uc3QgeyBlYXNlLCBkdXJhdGlvbiwgcmVzdER1cmF0aW9uIH0gPSBzcHJpbmdZO1xuICAgICAgZHVyYXRpb25ZID0gY3kgPT09IGR5ID8gMCA6IGhhc1JlbGVhc2VTcHJpbmcgPyBkdXJhdGlvbiA6IGR1cmF0aW9uIC0gKHJlc3REdXJhdGlvbiAqIGdsb2JhbHMudGltZVNjYWxlKTtcbiAgICAgIGlmIChoYXNSZWxlYXNlU3ByaW5nKSBlYXNlWSA9IGVhc2U7XG4gICAgICBpZiAoZHVyYXRpb25ZID4gbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbikgbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbiA9IGR1cmF0aW9uWTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1JlbGVhc2VTcHJpbmcgJiYgb2IgJiYgY2YgJiYgKGR1cmF0aW9uWCB8fCBkdXJhdGlvblkpKSB7XG5cbiAgICAgICAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvblR5cGVzLmJsZW5kO1xuXG4gICAgICAgIG5ldyBKU0FuaW1hdGlvbihvdmVyc2hvb3RDb29yZHMsIHtcbiAgICAgICAgICB4OiB7IHRvOiBieCwgZHVyYXRpb246IGR1cmF0aW9uWCAqIC42NSB9LFxuICAgICAgICAgIHk6IHsgdG86IGJ5LCBkdXJhdGlvbjogZHVyYXRpb25ZICogLjY1IH0sXG4gICAgICAgICAgZWFzZTogcmVsZWFzZUVhc2UsXG4gICAgICAgICAgY29tcG9zaXRpb24sXG4gICAgICAgIH0pLmluaXQoKTtcblxuICAgICAgICBuZXcgSlNBbmltYXRpb24ob3ZlcnNob290Q29vcmRzLCB7XG4gICAgICAgICAgeDogeyB0bzogZHgsIGR1cmF0aW9uOiBkdXJhdGlvblggfSxcbiAgICAgICAgICB5OiB7IHRvOiBkeSwgZHVyYXRpb246IGR1cmF0aW9uWSB9LFxuICAgICAgICAgIGVhc2U6IHJlbGVhc2VFYXNlLFxuICAgICAgICAgIGNvbXBvc2l0aW9uLFxuICAgICAgICB9KS5pbml0KCk7XG5cbiAgICAgICAgdGhpcy5vdmVyc2hvb3RUaWNrZXIuc3RyZXRjaChtYXgoZHVyYXRpb25YLCBkdXJhdGlvblkpKS5yZXN0YXJ0KCk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAoIWRpc2FibGVkWCkgdGhpcy5hbmltYXRlW3RoaXMueFByb3BdKGR4LCBkdXJhdGlvblgsIGVhc2VYKTtcbiAgICAgIGlmICghZGlzYWJsZWRZKSB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0oZHksIGR1cmF0aW9uWSwgZWFzZVkpO1xuXG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxJblZpZXcobG9uZ2VzdFJlbGVhc2VEdXJhdGlvbiwgdGhpcy5zY3JvbGxUaHJlc2hvbGQsIHJlbGVhc2VFYXNlKTtcblxuICAgIGxldCBoYXNTbmFwcGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZHggIT09IHN4KSB7XG4gICAgICB0aGlzLnNuYXBwZWRbMF0gPSBkeDtcbiAgICAgIGlmICh0aGlzLnNuYXBYKSBoYXNTbmFwcGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZHkgIT09IHN5ICYmIHRoaXMuc25hcFkpIHtcbiAgICAgIHRoaXMuc25hcHBlZFsxXSA9IGR5O1xuICAgICAgaWYgKHRoaXMuc25hcFkpIGhhc1NuYXBwZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChoYXNTbmFwcGVkKSB0aGlzLm9uU25hcCh0aGlzKTtcblxuICAgIHRoaXMuZ3JhYmJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgdGhpcy5yZWxlYXNlZCA9IHRydWU7XG5cbiAgICAvLyBJdCdzIGltcG9ydGFudCB0byB0cmlnZ2VyIHRoZSBjYWxsYmFjayBhZnRlciB0aGUgcmVsZWFzZSBhbmltYXRpb25zIHRvIGJlIGFibGUgdG8gY2FuY2VsIHRoZW1cbiAgICB0aGlzLm9uUmVsZWFzZSh0aGlzKTtcblxuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbiAgICB0aGlzLiR0cmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnREZWZhdWx0KTtcbiAgICB0aGlzLiR0cmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuXG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5yZXNpemVUaWNrZXIucGF1c2UoKTtcbiAgICB0aGlzLmdyYWJiZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICB0aGlzLnNldFgoMCwgdHJ1ZSk7XG4gICAgdGhpcy5zZXRZKDAsIHRydWUpO1xuICAgIHRoaXMuY29vcmRzWzBdID0gMDtcbiAgICB0aGlzLmNvb3Jkc1sxXSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzBdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbMV0gPSAwO1xuICAgIHRoaXMucG9pbnRlclsyXSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzNdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbNF0gPSAwO1xuICAgIHRoaXMucG9pbnRlcls1XSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzZdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbN10gPSAwO1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja1swXSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrWzFdID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tbMl0gPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gMDtcbiAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuJHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kaXNhYmxlZCcpO1xuICAgICAgdGhpcy50b3VjaEFjdGlvblN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0cmlnZ2VyLCB7XG4gICAgICAgIHRvdWNoQWN0aW9uOiB0aGlzLmRpc2FibGVkWzBdID8gJ3Bhbi14JyA6IHRoaXMuZGlzYWJsZWRbMV0gPyAncGFuLXknIDogJ25vbmUnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgdGhpcy4kdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmdyYWJiZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uU3R5bGVzLnJldmVydCgpO1xuICAgIGlmICh0aGlzLmN1cnNvclN0eWxlcykge1xuICAgICAgdGhpcy5jdXJzb3JTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnRyaWdnZXJTdHlsZXMpIHtcbiAgICAgIHRoaXMudHJpZ2dlclN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMudHJpZ2dlclN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmJvZHlTdHlsZXMpIHtcbiAgICAgIHRoaXMuYm9keVN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuYm9keVN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhcmdldFN0eWxlcykge1xuICAgICAgdGhpcy50YXJnZXRTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnRhcmdldFN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuJHRhcmdldC5jbGFzc0xpc3QuYWRkKCdpcy1kaXNhYmxlZCcpO1xuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMpO1xuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcyk7XG4gICAgdGhpcy4kdHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV2ZXJ0KCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB0aGlzLiR0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtZGlzYWJsZWQnKTtcbiAgICB0aGlzLnVwZGF0ZVRpY2tlci5yZXZlcnQoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFRpY2tlci5yZXZlcnQoKTtcbiAgICB0aGlzLnJlc2l6ZVRpY2tlci5yZXZlcnQoKTtcbiAgICB0aGlzLmFuaW1hdGUucmV2ZXJ0KCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLmhhbmRsZURvd24oLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyhlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICAgIHRoaXMuaGFuZGxlRG93bigvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLmhhbmRsZU1vdmUoLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyhlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKC8qKiBAdHlwZSB7VG91Y2hFdmVudH0gKi8oZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLmhhbmRsZVVwKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICB0aGlzLmhhbmRsZVVwKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG91Y2hjYW5jZWwnOlxuICAgICAgICB0aGlzLmhhbmRsZVVwKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2VlbnRlcic6XG4gICAgICAgIHRoaXMuaGFuZGxlSG92ZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3RzdGFydCc6XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0RyYWdnYWJsZVBhcmFtc30gW3BhcmFtZXRlcnNdXG4gKiBAcmV0dXJuIHtEcmFnZ2FibGV9XG4gKi9cbmNvbnN0IGNyZWF0ZURyYWdnYWJsZSA9ICh0YXJnZXQsIHBhcmFtZXRlcnMpID0+IG5ldyBEcmFnZ2FibGUodGFyZ2V0LCBwYXJhbWV0ZXJzKTtcblxuXG5cblxuY2xhc3MgU2NvcGUge1xuICAvKiogQHBhcmFtIHtTY29wZVBhcmFtc30gW3BhcmFtZXRlcnNdICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIGlmIChzY29wZS5jdXJyZW50KSBzY29wZS5jdXJyZW50LnJlZ2lzdGVyKHRoaXMpO1xuICAgIGNvbnN0IHJvb3RQYXJhbSA9IHBhcmFtZXRlcnMucm9vdDtcbiAgICAvKiogQHR5cGUge0RvY3VtZW50fERPTVRhcmdldH0gKi9cbiAgICBsZXQgcm9vdCA9IGRvYztcbiAgICBpZiAocm9vdFBhcmFtKSB7XG4gICAgICByb290ID0gLyoqIEB0eXBlIHtSZWFjdFJlZn0gKi8ocm9vdFBhcmFtKS5jdXJyZW50IHx8XG4gICAgICAgICAgICAgLyoqIEB0eXBlIHtBbmd1bGFyUmVmfSAqLyhyb290UGFyYW0pLm5hdGl2ZUVsZW1lbnQgfHxcbiAgICAgICAgICAgICBwYXJzZVRhcmdldHMoLyoqIEB0eXBlIHtET01UYXJnZXRTZWxlY3Rvcn0gKi8ocm9vdFBhcmFtKSlbMF0gfHxcbiAgICAgICAgICAgICBkb2M7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlRGVmYXVsdHMgPSBwYXJhbWV0ZXJzLmRlZmF1bHRzO1xuICAgIGNvbnN0IGdsb2JhbERlZmF1bHQgPSBnbG9iYWxzLmRlZmF1bHRzO1xuICAgIGNvbnN0IG1lZGlhUXVlcmllcyA9IHBhcmFtZXRlcnMubWVkaWFRdWVyaWVzO1xuICAgIC8qKiBAdHlwZSB7RGVmYXVsdHNQYXJhbXN9ICovXG4gICAgdGhpcy5kZWZhdWx0cyA9IHNjb3BlRGVmYXVsdHMgPyBtZXJnZU9iamVjdHMoc2NvcGVEZWZhdWx0cywgZ2xvYmFsRGVmYXVsdCkgOiBnbG9iYWxEZWZhdWx0O1xuICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR8RE9NVGFyZ2V0fSAqL1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2s+fSAqL1xuICAgIHRoaXMuY29uc3RydWN0b3JzID0gW107XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTY29wZUNsZWFudXBDYWxsYmFjaz59ICovXG4gICAgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnMgPSBbXTtcbiAgICAvKiogQHR5cGUge0FycmF5PFJldmVydGlibGU+fSAqL1xuICAgIHRoaXMucmV2ZXJ0aWJsZXMgPSBbXTtcbiAgICAvKiogQHR5cGUge0FycmF5PFNjb3BlQ29uc3RydWN0b3JDYWxsYmFjayB8ICgoc2NvcGU6IHRoaXMpID0+IFRpY2thYmxlKT59ICovXG4gICAgdGhpcy5jb25zdHJ1Y3RvcnNPbmNlID0gW107XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTY29wZUNsZWFudXBDYWxsYmFjaz59ICovXG4gICAgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnNPbmNlID0gW107XG4gICAgLyoqIEB0eXBlIHtBcnJheTxSZXZlcnRpYmxlPn0gKi9cbiAgICB0aGlzLnJldmVydGlibGVzT25jZSA9IFtdO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLm9uY2UgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLm9uY2VJbmRleCA9IDA7XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBTY29wZU1ldGhvZD59ICovXG4gICAgdGhpcy5tZXRob2RzID0ge307XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBCb29sZWFuPn0gKi9cbiAgICB0aGlzLm1hdGNoZXMgPSB7fTtcbiAgICAvKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIE1lZGlhUXVlcnlMaXN0Pn0gKi9cbiAgICB0aGlzLm1lZGlhUXVlcnlMaXN0cyA9IHt9O1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgYW55Pn0gKi9cbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICBpZiAobWVkaWFRdWVyaWVzKSB7XG4gICAgICBmb3IgKGxldCBtcSBpbiBtZWRpYVF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgX21xID0gd2luLm1hdGNoTWVkaWEobWVkaWFRdWVyaWVzW21xXSk7XG4gICAgICAgIHRoaXMubWVkaWFRdWVyeUxpc3RzW21xXSA9IF9tcTtcbiAgICAgICAgX21xLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JldmVydGlibGV9IHJldmVydGlibGVcbiAgICovXG4gIHJlZ2lzdGVyKHJldmVydGlibGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHRoaXMub25jZSA/IHRoaXMucmV2ZXJ0aWJsZXNPbmNlIDogdGhpcy5yZXZlcnRpYmxlcztcbiAgICBzdG9yZS5wdXNoKHJldmVydGlibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7U2NvcGVkQ2FsbGJhY2s8VD59IGNiXG4gICAqIEByZXR1cm4ge1R9XG4gICAqL1xuICBleGVjdXRlKGNiKSB7XG4gICAgbGV0IGFjdGl2ZVNjb3BlID0gc2NvcGUuY3VycmVudDtcbiAgICBsZXQgYWN0aXZlUm9vdCA9IHNjb3BlLnJvb3Q7XG4gICAgbGV0IGFjdGl2ZURlZmF1bHRzID0gZ2xvYmFscy5kZWZhdWx0cztcbiAgICBzY29wZS5jdXJyZW50ID0gdGhpcztcbiAgICBzY29wZS5yb290ID0gdGhpcy5yb290O1xuICAgIGdsb2JhbHMuZGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzO1xuICAgIGNvbnN0IG1xcyA9IHRoaXMubWVkaWFRdWVyeUxpc3RzO1xuICAgIGZvciAobGV0IG1xIGluIG1xcykgdGhpcy5tYXRjaGVzW21xXSA9IG1xc1ttcV0ubWF0Y2hlcztcbiAgICBjb25zdCByZXR1cm5lZCA9IGNiKHRoaXMpO1xuICAgIHNjb3BlLmN1cnJlbnQgPSBhY3RpdmVTY29wZTtcbiAgICBzY29wZS5yb290ID0gYWN0aXZlUm9vdDtcbiAgICBnbG9iYWxzLmRlZmF1bHRzID0gYWN0aXZlRGVmYXVsdHM7XG4gICAgcmV0dXJuIHJldHVybmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMub25jZUluZGV4ID0gMDtcbiAgICB0aGlzLmV4ZWN1dGUoKCkgPT4ge1xuICAgICAgbGV0IGkgPSB0aGlzLnJldmVydGlibGVzLmxlbmd0aDtcbiAgICAgIGxldCB5ID0gdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgdGhpcy5yZXZlcnRpYmxlc1tpXS5yZXZlcnQoKTtcbiAgICAgIHdoaWxlICh5LS0pIHRoaXMucmV2ZXJ0Q29uc3RydWN0b3JzW3ldKHRoaXMpO1xuICAgICAgdGhpcy5yZXZlcnRpYmxlcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuY29uc3RydWN0b3JzLmZvckVhY2goKC8qKiBAdHlwZSB7U2NvcGVDb25zdHJ1Y3RvckNhbGxiYWNrfSAqL2NvbnN0cnVjdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHJldmVydENvbnN0cnVjdG9yID0gY29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIGlmIChpc0ZuYyhyZXZlcnRDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICB0aGlzLnJldmVydENvbnN0cnVjdG9ycy5wdXNoKHJldmVydENvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhMVxuICAgKiBAcGFyYW0ge1Njb3BlTWV0aG9kfSBhMlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtTY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2t9IGExXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfFNjb3BlQ29uc3RydWN0b3JDYWxsYmFja30gYTFcbiAgICogQHBhcmFtIHtTY29wZU1ldGhvZH0gW2EyXVxuICAgKi9cbiAgYWRkKGExLCBhMikge1xuICAgIHRoaXMub25jZSA9IGZhbHNlO1xuICAgIGlmIChpc0ZuYyhhMSkpIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gLyoqIEB0eXBlIHtTY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2t9ICovKGExKTtcbiAgICAgIHRoaXMuY29uc3RydWN0b3JzLnB1c2goY29uc3RydWN0b3IpO1xuICAgICAgdGhpcy5leGVjdXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgaWYgKGlzRm5jKHJldmVydENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIHRoaXMucmV2ZXJ0Q29uc3RydWN0b3JzLnB1c2gocmV2ZXJ0Q29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZXRob2RzWy8qKiBAdHlwZSB7U3RyaW5nfSAqLyhhMSldID0gKC8qKiBAdHlwZSB7YW55fSAqLy4uLmFyZ3MpID0+IHRoaXMuZXhlY3V0ZSgoKSA9PiBhMiguLi5hcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2NvcGVDb25zdHJ1Y3RvckNhbGxiYWNrfSBzY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2tcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGFkZE9uY2Uoc2NvcGVDb25zdHJ1Y3RvckNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbmNlID0gdHJ1ZTtcbiAgICBpZiAoaXNGbmMoc2NvcGVDb25zdHJ1Y3RvckNhbGxiYWNrKSkge1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5vbmNlSW5kZXgrKztcbiAgICAgIGNvbnN0IHRyYWNrZWQgPSB0aGlzLmNvbnN0cnVjdG9yc09uY2VbY3VycmVudEluZGV4XTtcbiAgICAgIGlmICh0cmFja2VkKSByZXR1cm4gdGhpcztcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gLyoqIEB0eXBlIHtTY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2t9ICovKHNjb3BlQ29uc3RydWN0b3JDYWxsYmFjayk7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yc09uY2VbY3VycmVudEluZGV4XSA9IGNvbnN0cnVjdG9yO1xuICAgICAgdGhpcy5leGVjdXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgaWYgKGlzRm5jKHJldmVydENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIHRoaXMucmV2ZXJ0Q29uc3RydWN0b3JzT25jZS5wdXNoKHJldmVydENvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAgeyhzY29wZTogdGhpcykgPT4gVGlja2FibGV9IGNiXG4gICAqIEByZXR1cm4ge1RpY2thYmxlfVxuICAgKi9cbiAga2VlcFRpbWUoY2IpIHtcbiAgICB0aGlzLm9uY2UgPSB0cnVlO1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMub25jZUluZGV4Kys7XG4gICAgY29uc3QgdHJhY2tlZCA9IC8qKiBAdHlwZSB7KHNjb3BlOiB0aGlzKSA9PiBUaWNrYWJsZX0gKi8odGhpcy5jb25zdHJ1Y3RvcnNPbmNlW2N1cnJlbnRJbmRleF0pO1xuICAgIGlmIChpc0ZuYyh0cmFja2VkKSkgcmV0dXJuIHRyYWNrZWQodGhpcyk7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSAvKiogQHR5cGUgeyhzY29wZTogdGhpcykgPT4gVGlja2FibGV9ICovKGNyZWF0ZVJlZnJlc2hhYmxlKGNiKSk7XG4gICAgdGhpcy5jb25zdHJ1Y3RvcnNPbmNlW2N1cnJlbnRJbmRleF0gPSBjb25zdHJ1Y3RvcjtcbiAgICBsZXQgdHJhY2tlZFRpY2thYmxlO1xuICAgIHRoaXMuZXhlY3V0ZSgoKSA9PiB7XG4gICAgICB0cmFja2VkVGlja2FibGUgPSBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhY2tlZFRpY2thYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnY2hhbmdlJzpcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldmVydCgpIHtcbiAgICBjb25zdCByZXZlcnRpYmxlcyA9IHRoaXMucmV2ZXJ0aWJsZXM7XG4gICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3JzID0gdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnM7XG4gICAgY29uc3QgcmV2ZXJ0aWJsZXNPbmNlID0gdGhpcy5yZXZlcnRpYmxlc09uY2U7XG4gICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3JzT25jZSA9IHRoaXMucmV2ZXJ0Q29uc3RydWN0b3JzT25jZTtcbiAgICBjb25zdCBtcXMgPSB0aGlzLm1lZGlhUXVlcnlMaXN0cztcbiAgICBsZXQgaSA9IHJldmVydGlibGVzLmxlbmd0aDtcbiAgICBsZXQgaiA9IHJldmVydENvbnN0cnVjdG9ycy5sZW5ndGg7XG4gICAgbGV0IGsgPSByZXZlcnRpYmxlc09uY2UubGVuZ3RoO1xuICAgIGxldCBsID0gcmV2ZXJ0Q29uc3RydWN0b3JzT25jZS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgcmV2ZXJ0aWJsZXNbaV0ucmV2ZXJ0KCk7XG4gICAgd2hpbGUgKGotLSkgcmV2ZXJ0Q29uc3RydWN0b3JzW2pdKHRoaXMpO1xuICAgIHdoaWxlIChrLS0pIHJldmVydGlibGVzT25jZVtrXS5yZXZlcnQoKTtcbiAgICB3aGlsZSAobC0tKSByZXZlcnRDb25zdHJ1Y3RvcnNPbmNlW2xdKHRoaXMpO1xuICAgIGZvciAobGV0IG1xIGluIG1xcykgbXFzW21xXS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzKTtcbiAgICByZXZlcnRpYmxlcy5sZW5ndGggPSAwO1xuICAgIHJldmVydENvbnN0cnVjdG9ycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29uc3RydWN0b3JzLmxlbmd0aCA9IDA7XG4gICAgcmV2ZXJ0aWJsZXNPbmNlLmxlbmd0aCA9IDA7XG4gICAgcmV2ZXJ0Q29uc3RydWN0b3JzT25jZS5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29uc3RydWN0b3JzT25jZS5sZW5ndGggPSAwO1xuICAgIHRoaXMub25jZUluZGV4ID0gMDtcbiAgICB0aGlzLm1hdGNoZXMgPSB7fTtcbiAgICB0aGlzLm1ldGhvZHMgPSB7fTtcbiAgICB0aGlzLm1lZGlhUXVlcnlMaXN0cyA9IHt9O1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTY29wZVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm4ge1Njb3BlfVxuICovXG5jb25zdCBjcmVhdGVTY29wZSA9IHBhcmFtcyA9PiBuZXcgU2NvcGUocGFyYW1zKTtcblxuLyoqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGdldE1heFZpZXdIZWlnaHQgPSAoKSA9PiB7XG4gIGNvbnN0ICRlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoJGVsKTtcbiAgJGVsLnN0eWxlLmhlaWdodCA9ICcxMDBsdmgnO1xuICBjb25zdCBoZWlnaHQgPSAkZWwub2Zmc2V0SGVpZ2h0O1xuICBkb2MuYm9keS5yZW1vdmVDaGlsZCgkZWwpO1xuICByZXR1cm4gaGVpZ2h0O1xufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUge1Njcm9sbFRocmVzaG9sZFZhbHVlfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxPYmplY3R9IFRcbiAqIEBwYXJhbSB7VCB8ICgob2JzZXJ2ZXI6IFNjcm9sbE9ic2VydmVyKSA9PiBUKX0gdmFsdWVcbiAqIEBwYXJhbSB7U2Nyb2xsT2JzZXJ2ZXJ9IHNjcm9sbGVyXG4gKiBAcmV0dXJuIHtUfVxuICovXG5jb25zdCBwYXJzZVNjcm9sbE9ic2VydmVyRnVuY3Rpb25QYXJhbWV0ZXIgPSAodmFsdWUsIHNjcm9sbGVyKSA9PiB2YWx1ZSAmJiBpc0ZuYyh2YWx1ZSkgPyAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkoc2Nyb2xsZXIpIDogdmFsdWU7XG5cbmNvbnN0IHNjcm9sbENvbnRhaW5lcnMgPSBuZXcgTWFwKCk7XG5cbmNsYXNzIFNjcm9sbENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAkZWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCRlbCkge1xuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovXG4gICAgdGhpcy5lbGVtZW50ID0gJGVsO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnVzZVdpbiA9IHRoaXMuZWxlbWVudCA9PT0gZG9jLmJvZHk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy53aW5XaWR0aCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy53aW5IZWlnaHQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudG9wID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxYID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnNjcm9sbFkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMucHJldlNjcm9sbFggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMucHJldlNjcm9sbFkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsV2lkdGggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5iYWNrd2FyZFggPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5iYWNrd2FyZFkgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge1RpbWVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsVGlja2VyID0gbmV3IFRpbWVyKHtcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgIG9uQmVnaW46ICgpID0+IHRoaXMuZGF0YVRpbWVyLnJlc3VtZSgpLFxuICAgICAgb25VcGRhdGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgYmFja3dhcmRzID0gdGhpcy5iYWNrd2FyZFggfHwgdGhpcy5iYWNrd2FyZFk7XG4gICAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9jaGlsZCkgPT4gY2hpbGQuaGFuZGxlU2Nyb2xsKCksIGJhY2t3YXJkcyk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4gdGhpcy5kYXRhVGltZXIucGF1c2UoKVxuICAgIH0pLmluaXQoKTtcbiAgICAvKiogQHR5cGUge1RpbWVyfSAqL1xuICAgIHRoaXMuZGF0YVRpbWVyID0gbmV3IFRpbWVyKHtcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgIGZyYW1lUmF0ZTogMzAsXG4gICAgICBvblVwZGF0ZTogc2VsZiA9PiB7XG4gICAgICAgIGNvbnN0IGR0ID0gc2VsZi5kZWx0YVRpbWU7XG4gICAgICAgIGNvbnN0IHB4ID0gdGhpcy5wcmV2U2Nyb2xsWDtcbiAgICAgICAgY29uc3QgcHkgPSB0aGlzLnByZXZTY3JvbGxZO1xuICAgICAgICBjb25zdCBueCA9IHRoaXMuc2Nyb2xsWDtcbiAgICAgICAgY29uc3QgbnkgPSB0aGlzLnNjcm9sbFk7XG4gICAgICAgIGNvbnN0IGR4ID0gcHggLSBueDtcbiAgICAgICAgY29uc3QgZHkgPSBweSAtIG55O1xuICAgICAgICB0aGlzLnByZXZTY3JvbGxYID0gbng7XG4gICAgICAgIHRoaXMucHJldlNjcm9sbFkgPSBueTtcbiAgICAgICAgaWYgKGR4KSB0aGlzLmJhY2t3YXJkWCA9IHB4ID4gbng7XG4gICAgICAgIGlmIChkeSkgdGhpcy5iYWNrd2FyZFkgPSBweSA+IG55O1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gcm91bmQoZHQgPiAwID8gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAvIGR0IDogMCwgNSk7XG4gICAgICB9XG4gICAgfSkuaW5pdCgpO1xuICAgIC8qKiBAdHlwZSB7VGltZXJ9ICovXG4gICAgdGhpcy5yZXNpemVUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgZHVyYXRpb246IDI1MCAqIGdsb2JhbHMudGltZVNjYWxlLFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVdpbmRvd0JvdW5kcygpO1xuICAgICAgICB0aGlzLnJlZnJlc2hTY3JvbGxPYnNlcnZlcnMoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwoKTtcbiAgICAgIH1cbiAgICB9KS5pbml0KCk7XG4gICAgLyoqIEB0eXBlIHtUaW1lcn0gKi9cbiAgICB0aGlzLndha2VUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgZHVyYXRpb246IDUwMCAqIGdsb2JhbHMudGltZVNjYWxlLFxuICAgICAgb25CZWdpbjogKCkgPT4ge1xuICAgICAgICB0aGlzLnNjcm9sbFRpY2tlci5yZXN1bWUoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGlja2VyLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfSkuaW5pdCgpO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9cbiAgICB0aGlzLl90YWlsID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIHRoaXMudXBkYXRlV2luZG93Qm91bmRzKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcbiAgICB0aGlzLnJlZnJlc2hTY3JvbGxPYnNlcnZlcnMoKTtcbiAgICB0aGlzLmhhbmRsZVNjcm9sbCgpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy5yZXNpemVUaWNrZXIucmVzdGFydCgpKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICAodGhpcy51c2VXaW4gPyB3aW4gOiB0aGlzLmVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMsIGZhbHNlKTtcbiAgfVxuXG4gIHVwZGF0ZVNjcm9sbENvb3JkcygpIHtcbiAgICBjb25zdCB1c2VXaW4gPSB0aGlzLnVzZVdpbjtcbiAgICBjb25zdCAkZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdGhpcy5zY3JvbGxYID0gcm91bmQodXNlV2luID8gd2luLnNjcm9sbFggOiAkZWwuc2Nyb2xsTGVmdCwgMCk7XG4gICAgdGhpcy5zY3JvbGxZID0gcm91bmQodXNlV2luID8gd2luLnNjcm9sbFkgOiAkZWwuc2Nyb2xsVG9wLCAwKTtcbiAgfVxuXG4gIHVwZGF0ZVdpbmRvd0JvdW5kcygpIHtcbiAgICB0aGlzLndpbldpZHRoID0gd2luLmlubmVyV2lkdGg7XG4gICAgdGhpcy53aW5IZWlnaHQgPSBnZXRNYXhWaWV3SGVpZ2h0KCk7XG4gIH1cblxuICB1cGRhdGVCb3VuZHMoKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCk7XG4gICAgY29uc3QgJGVsID0gdGhpcy5lbGVtZW50O1xuICAgIHRoaXMuc2Nyb2xsV2lkdGggPSAkZWwuc2Nyb2xsV2lkdGggKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5SaWdodCk7XG4gICAgdGhpcy5zY3JvbGxIZWlnaHQgPSAkZWwuc2Nyb2xsSGVpZ2h0ICsgcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICAgIHRoaXMudXBkYXRlV2luZG93Qm91bmRzKCk7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHRoaXMudXNlV2luKSB7XG4gICAgICB3aWR0aCA9IHRoaXMud2luV2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLndpbkhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWxSZWN0ID0gJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgd2lkdGggPSAkZWwuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSAkZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSBlbFJlY3QudG9wO1xuICAgICAgdGhpcy5sZWZ0ID0gZWxSZWN0LmxlZnQ7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIHJlZnJlc2hTY3JvbGxPYnNlcnZlcnMoKSB7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqL2NoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQuX2RlYnVnKSB7XG4gICAgICAgIGNoaWxkLnJlbW92ZURlYnVnKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovY2hpbGQpID0+IHtcbiAgICAgIGNoaWxkLnJlZnJlc2goKTtcbiAgICAgIGlmIChjaGlsZC5fZGVidWcpIHtcbiAgICAgICAgY2hpbGQuZGVidWcoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy51cGRhdGVXaW5kb3dCb3VuZHMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIHRoaXMucmVmcmVzaFNjcm9sbE9ic2VydmVycygpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKCk7XG4gIH1cblxuICBoYW5kbGVTY3JvbGwoKSB7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxDb29yZHMoKTtcbiAgICB0aGlzLndha2VUaWNrZXIucmVzdGFydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV2ZXJ0KCkge1xuICAgIHRoaXMuc2Nyb2xsVGlja2VyLmNhbmNlbCgpO1xuICAgIHRoaXMuZGF0YVRpbWVyLmNhbmNlbCgpO1xuICAgIHRoaXMucmVzaXplVGlja2VyLmNhbmNlbCgpO1xuICAgIHRoaXMud2FrZVRpY2tlci5jYW5jZWwoKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAodGhpcy51c2VXaW4gPyB3aW4gOiB0aGlzLmVsZW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMpO1xuICAgIHNjcm9sbENvbnRhaW5lcnMuZGVsZXRlKHRoaXMuZWxlbWVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtTY3JvbGxDb250YWluZXJ9XG4gKi9cbmNvbnN0IHJlZ2lzdGVyQW5kR2V0U2Nyb2xsQ29udGFpbmVyID0gdGFyZ2V0ID0+IHtcbiAgY29uc3QgJGVsID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8odGFyZ2V0ID8gcGFyc2VUYXJnZXRzKHRhcmdldClbMF0gfHwgZG9jLmJvZHkgOiBkb2MuYm9keSk7XG4gIGxldCBzY3JvbGxDb250YWluZXIgPSBzY3JvbGxDb250YWluZXJzLmdldCgkZWwpO1xuICBpZiAoIXNjcm9sbENvbnRhaW5lcikge1xuICAgIHNjcm9sbENvbnRhaW5lciA9IG5ldyBTY3JvbGxDb250YWluZXIoJGVsKTtcbiAgICBzY3JvbGxDb250YWluZXJzLnNldCgkZWwsIHNjcm9sbENvbnRhaW5lcik7XG4gIH1cbiAgcmV0dXJuIHNjcm9sbENvbnRhaW5lcjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKiBAcGFyYW0ge051bWJlcnxzdHJpbmd9IHZcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW3VuZGVyXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvdmVyXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBjb252ZXJ0VmFsdWVUb1B4ID0gKCRlbCwgdiwgc2l6ZSwgdW5kZXIsIG92ZXIpID0+IHtcbiAgY29uc3QgY2xhbXBNaW4gPSB2ID09PSAnbWluJztcbiAgY29uc3QgY2xhbXBNYXggPSB2ID09PSAnbWF4JztcbiAgY29uc3QgdmFsdWUgPSB2ID09PSAndG9wJyB8fCB2ID09PSAnbGVmdCcgfHwgdiA9PT0gJ3N0YXJ0JyB8fCBjbGFtcE1pbiA/IDAgOlxuICAgICAgICAgICAgICAgIHYgPT09ICdib3R0b20nIHx8IHYgPT09ICdyaWdodCcgfHwgdiA9PT0gJ2VuZCcgfHwgY2xhbXBNYXggPyAnMTAwJScgOlxuICAgICAgICAgICAgICAgIHYgPT09ICdjZW50ZXInID8gJzUwJScgOlxuICAgICAgICAgICAgICAgIHY7XG4gIGNvbnN0IHsgbiwgdSB9ID0gZGVjb21wb3NlUmF3VmFsdWUodmFsdWUsIGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlKTtcbiAgbGV0IHB4ID0gbjtcbiAgaWYgKHUgPT09ICclJykge1xuICAgIHB4ID0gKG4gLyAxMDApICogc2l6ZTtcbiAgfSBlbHNlIGlmICh1KSB7XG4gICAgcHggPSBjb252ZXJ0VmFsdWVVbml0KCRlbCwgZGVjb21wb3NlZE9yaWdpbmFsVmFsdWUsICdweCcsIHRydWUpLm47XG4gIH1cbiAgaWYgKGNsYW1wTWF4ICYmIHVuZGVyIDwgMCkgcHggKz0gdW5kZXI7XG4gIGlmIChjbGFtcE1pbiAmJiBvdmVyID4gMCkgcHggKz0gb3ZlcjtcbiAgcmV0dXJuIHB4O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAkZWxcbiAqIEBwYXJhbSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9IHZcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW3VuZGVyXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvdmVyXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBwYXJzZUJvdW5kVmFsdWUgPSAoJGVsLCB2LCBzaXplLCB1bmRlciwgb3ZlcikgPT4ge1xuICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgbGV0IHZhbHVlO1xuICBpZiAoaXNTdHIodikpIHtcbiAgICBjb25zdCBtYXRjaGVkT3BlcmF0b3IgPSByZWxhdGl2ZVZhbHVlc0V4ZWNSZ3guZXhlYygvKiogQHR5cGUge1N0cmluZ30gKi8odikpO1xuICAgIGlmIChtYXRjaGVkT3BlcmF0b3IpIHtcbiAgICAgIGNvbnN0IHNwbGl0dGVyID0gbWF0Y2hlZE9wZXJhdG9yWzBdO1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSBzcGxpdHRlclswXTtcbiAgICAgIGNvbnN0IHNwbGl0dGVkID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHYpLnNwbGl0KHNwbGl0dGVyKTtcbiAgICAgIGNvbnN0IGNsYW1wTWluID0gc3BsaXR0ZWRbMF0gPT09ICdtaW4nO1xuICAgICAgY29uc3QgY2xhbXBNYXggPSBzcGxpdHRlZFswXSA9PT0gJ21heCc7XG4gICAgICBjb25zdCB2YWx1ZUFQeCA9IGNvbnZlcnRWYWx1ZVRvUHgoJGVsLCBzcGxpdHRlZFswXSwgc2l6ZSwgdW5kZXIsIG92ZXIpO1xuICAgICAgY29uc3QgdmFsdWVCUHggPSBjb252ZXJ0VmFsdWVUb1B4KCRlbCwgc3BsaXR0ZWRbMV0sIHNpemUsIHVuZGVyLCBvdmVyKTtcbiAgICAgIGlmIChjbGFtcE1pbikge1xuICAgICAgICBjb25zdCBtaW4gPSBnZXRSZWxhdGl2ZVZhbHVlKGNvbnZlcnRWYWx1ZVRvUHgoJGVsLCAnbWluJywgc2l6ZSksIHZhbHVlQlB4LCBvcGVyYXRvcik7XG4gICAgICAgIHZhbHVlID0gbWluIDwgdmFsdWVBUHggPyB2YWx1ZUFQeCA6IG1pbjtcbiAgICAgIH0gZWxzZSBpZiAoY2xhbXBNYXgpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gZ2V0UmVsYXRpdmVWYWx1ZShjb252ZXJ0VmFsdWVUb1B4KCRlbCwgJ21heCcsIHNpemUpLCB2YWx1ZUJQeCwgb3BlcmF0b3IpO1xuICAgICAgICB2YWx1ZSA9IG1heCA+IHZhbHVlQVB4ID8gdmFsdWVBUHggOiBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGdldFJlbGF0aXZlVmFsdWUodmFsdWVBUHgsIHZhbHVlQlB4LCBvcGVyYXRvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gY29udmVydFZhbHVlVG9QeCgkZWwsIHYsIHNpemUsIHVuZGVyLCBvdmVyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSAvKiogQHR5cGUge051bWJlcn0gKi8odik7XG4gIH1cbiAgcmV0dXJuIHJvdW5kKHZhbHVlLCAwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtKU0FuaW1hdGlvbn0gbGlua2VkXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuY29uc3QgZ2V0QW5pbWF0aW9uRG9tVGFyZ2V0ID0gbGlua2VkID0+IHtcbiAgbGV0ICRsaW5rZWRUYXJnZXQ7XG4gIGNvbnN0IGxpbmtlZFRhcmdldHMgPSBsaW5rZWQudGFyZ2V0cztcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5rZWRUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IGxpbmtlZFRhcmdldHNbaV07XG4gICAgaWYgKHRhcmdldFtpc0RvbVN5bWJvbF0pIHtcbiAgICAgICRsaW5rZWRUYXJnZXQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyh0YXJnZXQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiAkbGlua2VkVGFyZ2V0O1xufTtcblxubGV0IHNjcm9sbGVySW5kZXggPSAwO1xuXG5jb25zdCBkZWJ1Z0NvbG9ycyQxID0gWycjRkY0QjRCJywnI0ZGOTcxQicsJyNGRkM3MzAnLCcjRjlGNjQwJywnIzdBRkY1QScsJyMxOEZGNzQnLCcjMTdFMDlCJywnIzNDRkZFQycsJyMwNURCRTknLCcjMzNCM0YxJywnIzYzOENGOScsJyNDNTYzRkUnLCcjRkY0RkNGJywnI0Y5M0Y4QSddO1xuXG5jbGFzcyBTY3JvbGxPYnNlcnZlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Njcm9sbE9ic2VydmVyUGFyYW1zfSBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBpZiAoc2NvcGUuY3VycmVudCkgc2NvcGUuY3VycmVudC5yZWdpc3Rlcih0aGlzKTtcbiAgICBjb25zdCBzeW5jTW9kZSA9IHNldFZhbHVlKHBhcmFtZXRlcnMuc3luYywgJ3BsYXkgcGF1c2UnKTtcbiAgICBjb25zdCBlYXNlID0gc3luY01vZGUgPyBwYXJzZUVhc2luZ3MoLyoqIEB0eXBlIHtFYXNpbmdQYXJhbX0gKi8oc3luY01vZGUpKSA6IG51bGw7XG4gICAgY29uc3QgaXNMaW5lYXIgPSBzeW5jTW9kZSAmJiAoc3luY01vZGUgPT09ICdsaW5lYXInIHx8IHN5bmNNb2RlID09PSBub25lKTtcbiAgICBjb25zdCBpc0Vhc2UgPSBzeW5jTW9kZSAmJiAhKGVhc2UgPT09IG5vbmUgJiYgIWlzTGluZWFyKTtcbiAgICBjb25zdCBpc1Ntb290aCA9IHN5bmNNb2RlICYmIChpc051bShzeW5jTW9kZSkgfHwgc3luY01vZGUgPT09IHRydWUgfHwgaXNMaW5lYXIpO1xuICAgIGNvbnN0IGlzTWV0aG9kcyA9IHN5bmNNb2RlICYmIChpc1N0cihzeW5jTW9kZSkgJiYgIWlzRWFzZSAmJiAhaXNTbW9vdGgpO1xuICAgIGNvbnN0IHN5bmNNZXRob2RzID0gaXNNZXRob2RzID8gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHN5bmNNb2RlKS5zcGxpdCgnICcpLm1hcChcbiAgICAgICgvKiogQHR5cGUge1N0cmluZ30gKi9tKSA9PiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmtlZCA9IHRoaXMubGlua2VkO1xuICAgICAgICByZXR1cm4gbGlua2VkICYmIGxpbmtlZFttXSA/IGxpbmtlZFttXSgpIDogbnVsbDtcbiAgICAgIH1cbiAgICApIDogbnVsbDtcbiAgICBjb25zdCBiaURpclN5bmMgPSBpc01ldGhvZHMgJiYgc3luY01ldGhvZHMubGVuZ3RoID4gMjtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmluZGV4ID0gc2Nyb2xsZXJJbmRleCsrO1xuICAgIC8qKiBAdHlwZSB7U3RyaW5nfE51bWJlcn0gKi9cbiAgICB0aGlzLmlkID0gIWlzVW5kKHBhcmFtZXRlcnMuaWQpID8gcGFyYW1ldGVycy5pZCA6IHRoaXMuaW5kZXg7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxDb250YWluZXJ9ICovXG4gICAgdGhpcy5jb250YWluZXIgPSByZWdpc3RlckFuZEdldFNjcm9sbENvbnRhaW5lcihwYXJhbWV0ZXJzLmNvbnRhaW5lcik7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtUaWNrYWJsZXxXQUFQSUFuaW1hdGlvbn0gKi9cbiAgICB0aGlzLmxpbmtlZCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMucmVwZWF0ID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5ob3Jpem9udGFsID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFBhcmFtfFNjcm9sbFRocmVzaG9sZFZhbHVlfFNjcm9sbFRocmVzaG9sZENhbGxiYWNrfSAqL1xuICAgIHRoaXMuZW50ZXIgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2t9ICovXG4gICAgdGhpcy5sZWF2ZSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuc3luYyA9IGlzRWFzZSB8fCBpc1Ntb290aCB8fCAhIXN5bmNNZXRob2RzO1xuICAgIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gICAgdGhpcy5zeW5jRWFzZSA9IGlzRWFzZSA/IGVhc2UgOiBudWxsO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc3luY1Ntb290aCA9IGlzU21vb3RoID8gc3luY01vZGUgPT09IHRydWUgfHwgaXNMaW5lYXIgPyAxIDogLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHN5bmNNb2RlKSA6IG51bGw7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNFbnRlciA9IHN5bmNNZXRob2RzICYmICFiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMF0gPyBzeW5jTWV0aG9kc1swXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNMZWF2ZSA9IHN5bmNNZXRob2RzICYmICFiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMV0gPyBzeW5jTWV0aG9kc1sxXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNFbnRlckZvcndhcmQgPSBzeW5jTWV0aG9kcyAmJiBiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMF0gPyBzeW5jTWV0aG9kc1swXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNMZWF2ZUZvcndhcmQgPSBzeW5jTWV0aG9kcyAmJiBiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMV0gPyBzeW5jTWV0aG9kc1sxXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNFbnRlckJhY2t3YXJkID0gc3luY01ldGhvZHMgJiYgYmlEaXJTeW5jICYmIHN5bmNNZXRob2RzWzJdID8gc3luY01ldGhvZHNbMl0gOiBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25TeW5jTGVhdmVCYWNrd2FyZCA9IHN5bmNNZXRob2RzICYmIGJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1szXSA/IHN5bmNNZXRob2RzWzNdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uRW50ZXIgPSBwYXJhbWV0ZXJzLm9uRW50ZXIgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uTGVhdmUgPSBwYXJhbWV0ZXJzLm9uTGVhdmUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uRW50ZXJGb3J3YXJkID0gcGFyYW1ldGVycy5vbkVudGVyRm9yd2FyZCB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25MZWF2ZUZvcndhcmQgPSBwYXJhbWV0ZXJzLm9uTGVhdmVGb3J3YXJkIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vbkVudGVyQmFja3dhcmQgPSBwYXJhbWV0ZXJzLm9uRW50ZXJCYWNrd2FyZCB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25MZWF2ZUJhY2t3YXJkID0gcGFyYW1ldGVycy5vbkxlYXZlQmFja3dhcmQgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uVXBkYXRlID0gcGFyYW1ldGVycy5vblVwZGF0ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25TeW5jQ29tcGxldGUgPSBwYXJhbWV0ZXJzLm9uU3luY0NvbXBsZXRlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMucmV2ZXJ0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5iZWdhbiA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmlzSW5WaWV3ID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuZm9yY2VFbnRlciA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmhhc0VudGVyZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gICAgLy8gLyoqIEB0eXBlIHtBcnJheS48TnVtYmVyPn0gKi9cbiAgICAvLyB0aGlzLm9mZnNldHMgPSBbXTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5vZmZzZXRTdGFydCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5vZmZzZXRFbmQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMucHJldlByb2dyZXNzID0gMDtcbiAgICAvKiogQHR5cGUge0FycmF5fSAqL1xuICAgIHRoaXMudGhyZXNob2xkcyA9IFsnc3RhcnQnLCAnZW5kJywgJ2VuZCcsICdzdGFydCddO1xuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5jb29yZHMgPSBbMCwgMCwgMCwgMF07XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLmRlYnVnU3R5bGVzID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuICAgIHRoaXMuJGRlYnVnID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyUGFyYW1zfSAqL1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtZXRlcnM7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuX2RlYnVnID0gc2V0VmFsdWUocGFyYW1ldGVycy5kZWJ1ZywgZmFsc2UpO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgICBhZGRDaGlsZCh0aGlzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgLy8gV2FpdCBmb3IgdGhlIG5leHQgZnJhbWUgdG8gYWRkIHRvIHRoZSBjb250YWluZXIgaW4gb3JkZXIgdG8gaGFuZGxlIGNhbGxzIHRvIGxpbmsoKVxuICAgIHN5bmMoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucmV2ZXJ0ZWQpIHJldHVybjtcbiAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8ocGFyc2VUYXJnZXRzKHBhcmFtZXRlcnMudGFyZ2V0KVswXSk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0IHx8IGRvYy5ib2R5O1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kZWJ1ZykgdGhpcy5kZWJ1ZygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlja2FibGV8V0FBUElBbmltYXRpb259IGxpbmtlZFxuICAgKi9cbiAgbGluayhsaW5rZWQpIHtcbiAgICBpZiAobGlua2VkKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdG8gcGF1c2UgdGhlIGxpbmtlZCBvYmplY3QgaW4gY2FzZSBpdCdzIGFkZGVkIGxhdGVyXG4gICAgICBsaW5rZWQucGF1c2UoKTtcbiAgICAgIHRoaXMubGlua2VkID0gbGlua2VkO1xuICAgICAgLy8gVHJ5IHRvIHVzZSBhIHRhcmdldCBvZiB0aGUgbGlua2VkIG9iamVjdCBpZiBubyB0YXJnZXQgcGFyYW1ldGVycyBzcGVjaWZpZWRcbiAgICAgIGlmICghdGhpcy5fcGFyYW1zLnRhcmdldCkge1xuICAgICAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuICAgICAgICBsZXQgJGxpbmtlZFRhcmdldDtcbiAgICAgICAgaWYgKCFpc1VuZCgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqLyhsaW5rZWQpLnRhcmdldHMpKSB7XG4gICAgICAgICAgJGxpbmtlZFRhcmdldCA9IGdldEFuaW1hdGlvbkRvbVRhcmdldCgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqLyhsaW5rZWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oLyoqIEB0eXBlIHtUaW1lbGluZX0gKi8obGlua2VkKSwgKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50YXJnZXRzICYmICEkbGlua2VkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICRsaW5rZWRUYXJnZXQgPSBnZXRBbmltYXRpb25Eb21UYXJnZXQoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8oY2hpbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjayB0byBib2R5IGlmIG5vIHRhcmdldCBmb3VuZFxuICAgICAgICB0aGlzLnRhcmdldCA9ICRsaW5rZWRUYXJnZXQgfHwgZG9jLmJvZHk7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCB2ZWxvY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXIudmVsb2NpdHk7XG4gIH1cblxuICBnZXQgYmFja3dhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbCA/IHRoaXMuY29udGFpbmVyLmJhY2t3YXJkWCA6IHRoaXMuY29udGFpbmVyLmJhY2t3YXJkWTtcbiAgfVxuXG4gIGdldCBzY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbCA/IHRoaXMuY29udGFpbmVyLnNjcm9sbFggOiB0aGlzLmNvbnRhaW5lci5zY3JvbGxZO1xuICB9XG5cbiAgZ2V0IHByb2dyZXNzKCkge1xuICAgIGNvbnN0IHAgPSAodGhpcy5zY3JvbGwgLSB0aGlzLm9mZnNldFN0YXJ0KSAvIHRoaXMuZGlzdGFuY2U7XG4gICAgcmV0dXJuIHAgPT09IEluZmluaXR5IHx8IGlzTmFOKHApID8gMCA6IHJvdW5kKGNsYW1wKHAsIDAsIDEpLCA2KTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgLy8gVGhpcyBmbGFnIGlzIHVzZWQgdG8gcHJldmVudCBydW5uaW5nIGhhbmRsZVNjcm9sbCgpIG91dHNpZGUgb2YgdGhpcy5yZWZyZXNoKCkgd2l0aCB2YWx1ZXMgbm90IGNhbGN1bGF0ZWRcbiAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMucmV2ZXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gICAgdGhpcy5yZXBlYXQgPSBzZXRWYWx1ZShwYXJzZVNjcm9sbE9ic2VydmVyRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnJlcGVhdCwgdGhpcyksIHRydWUpO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHNldFZhbHVlKHBhcnNlU2Nyb2xsT2JzZXJ2ZXJGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuYXhpcywgdGhpcyksICd5JykgPT09ICd4JztcbiAgICB0aGlzLmVudGVyID0gc2V0VmFsdWUocGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5lbnRlciwgdGhpcyksICdlbmQgc3RhcnQnKTtcbiAgICB0aGlzLmxlYXZlID0gc2V0VmFsdWUocGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5sZWF2ZSwgdGhpcyksICdzdGFydCBlbmQnKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVEZWJ1ZygpIHtcbiAgICBpZiAodGhpcy4kZGVidWcpIHtcbiAgICAgIHRoaXMuJGRlYnVnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZGVidWcpO1xuICAgICAgdGhpcy4kZGVidWcgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWJ1Z1N0eWxlcykge1xuICAgICAgdGhpcy5kZWJ1Z1N0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuJGRlYnVnID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWJ1ZygpIHtcbiAgICB0aGlzLnJlbW92ZURlYnVnKCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgY29uc3QgaXNIb3JpID0gdGhpcy5ob3Jpem9udGFsO1xuICAgIGNvbnN0ICRleGlzdGluZ0RlYnVnID0gY29udGFpbmVyLmVsZW1lbnQucXVlcnlTZWxlY3RvcignOnNjb3BlID4gLmFuaW1lanMtb25zY3JvbGwtZGVidWcnKTtcbiAgICBjb25zdCAkZGVidWcgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgJHRocmVzaG9sZHMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgJHRyaWdnZXJzID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbG9yID0gZGVidWdDb2xvcnMkMVt0aGlzLmluZGV4ICUgZGVidWdDb2xvcnMkMS5sZW5ndGhdO1xuICAgIGNvbnN0IHVzZVdpbiA9IGNvbnRhaW5lci51c2VXaW47XG4gICAgY29uc3QgY29udGFpbmVyV2lkdGggPSB1c2VXaW4gPyBjb250YWluZXIud2luV2lkdGggOiBjb250YWluZXIud2lkdGg7XG4gICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gdXNlV2luID8gY29udGFpbmVyLndpbkhlaWdodCA6IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgY29uc3Qgc2Nyb2xsV2lkdGggPSBjb250YWluZXIuc2Nyb2xsV2lkdGg7XG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gY29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5jb250YWluZXIud2lkdGggPiAzNjAgPyAzMjAgOiAyNjA7XG4gICAgY29uc3Qgb2ZmTGVmdCA9IGlzSG9yaSA/IDAgOiAxMDtcbiAgICBjb25zdCBvZmZUb3AgPSBpc0hvcmkgPyAxMCA6IDA7XG4gICAgY29uc3QgaGFsZiA9IGlzSG9yaSA/IDI0IDogc2l6ZSAvIDI7XG4gICAgY29uc3QgbGFiZWxIZWlnaHQgPSBpc0hvcmkgPyBoYWxmIDogMTU7XG4gICAgY29uc3QgbGFiZWxXaWR0aCA9IGlzSG9yaSA/IDYwIDogaGFsZjtcbiAgICBjb25zdCBsYWJlbFNpemUgPSBpc0hvcmkgPyBsYWJlbFdpZHRoIDogbGFiZWxIZWlnaHQ7XG4gICAgY29uc3QgcmVwZWF0ID0gaXNIb3JpID8gJ3JlcGVhdC14JyA6ICdyZXBlYXQteSc7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY29uc3QgZ3JhZGllbnRPZmZzZXQgPSB2ID0+IGlzSG9yaSA/ICcwcHggJysodikrJ3B4JyA6ICh2KSsncHgnKycgMnB4JztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjb25zdCBsaW5lQ1NTID0gKGMpID0+IGBsaW5lYXItZ3JhZGllbnQoJHtpc0hvcmkgPyA5MCA6IDB9ZGVnLCAke2N9IDJweCwgdHJhbnNwYXJlbnQgMXB4KWA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjb25zdCBiYXNlQ1NTID0gKHAsIGwsIHQsIHcsIGgpID0+IGBwb3NpdGlvbjoke3B9O2xlZnQ6JHtsfXB4O3RvcDoke3R9cHg7d2lkdGg6JHt3fXB4O2hlaWdodDoke2h9cHg7YDtcbiAgICAkZGVidWcuc3R5bGUuY3NzVGV4dCA9IGAke2Jhc2VDU1MoJ2Fic29sdXRlJywgb2ZmTGVmdCwgb2ZmVG9wLCBpc0hvcmkgPyBzY3JvbGxXaWR0aCA6IHNpemUsIGlzSG9yaSA/IHNpemUgOiBzY3JvbGxIZWlnaHQpfVxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB6LWluZGV4OiAke3RoaXMuY29udGFpbmVyLnpJbmRleCsrfTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBmbGV4LWRpcmVjdGlvbjogJHtpc0hvcmkgPyAnY29sdW1uJyA6ICdyb3cnfTtcbiAgICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMHB4IDFweCAwcHggcmdiYSgwLDAsMCwuNzUpKTtcbiAgICBgO1xuICAgICR0aHJlc2hvbGRzLnN0eWxlLmNzc1RleHQgPSBgJHtiYXNlQ1NTKCdzdGlja3knLCAwLCAwLCBpc0hvcmkgPyBjb250YWluZXJXaWR0aCA6IGhhbGYsIGlzSG9yaSA/IGhhbGYgOiBjb250YWluZXJIZWlnaHQpfWA7XG4gICAgaWYgKCEkZXhpc3RpbmdEZWJ1Zykge1xuICAgICAgJHRocmVzaG9sZHMuc3R5bGUuY3NzVGV4dCArPSBgYmFja2dyb3VuZDpcbiAgICAgICAgJHtsaW5lQ1NTKCcjRkZGRicpfSR7Z3JhZGllbnRPZmZzZXQoaGFsZi0xMCl9IC8gJHtpc0hvcmkgPyAnMTAwcHggMTAwcHgnIDogJzEwMHB4IDEwMHB4J30gJHtyZXBlYXR9LFxuICAgICAgICAke2xpbmVDU1MoJyNGRkY4Jyl9JHtncmFkaWVudE9mZnNldChoYWxmLTEwKX0gLyAke2lzSG9yaSA/ICcxMHB4IDEwcHgnIDogJzEwcHggMTBweCd9ICR7cmVwZWF0fTtcbiAgICAgIGA7XG4gICAgfVxuICAgICR0cmlnZ2Vycy5zdHlsZS5jc3NUZXh0ID0gYCR7YmFzZUNTUygncmVsYXRpdmUnLCAwLCAwLCBpc0hvcmkgPyBzY3JvbGxXaWR0aCA6IGhhbGYsIGlzSG9yaSA/IGhhbGYgOiBzY3JvbGxIZWlnaHQpfWA7XG4gICAgaWYgKCEkZXhpc3RpbmdEZWJ1Zykge1xuICAgICAgJHRyaWdnZXJzLnN0eWxlLmNzc1RleHQgKz0gYGJhY2tncm91bmQ6XG4gICAgICAgICR7bGluZUNTUygnI0ZGRkYnKX0ke2dyYWRpZW50T2Zmc2V0KDApfSAvICR7aXNIb3JpID8gJzEwMHB4IDEwcHgnIDogJzEwcHggMTAwcHgnfSAke3JlcGVhdH0sXG4gICAgICAgICR7bGluZUNTUygnI0ZGRjgnKX0ke2dyYWRpZW50T2Zmc2V0KDApfSAvICR7aXNIb3JpID8gJzEwcHggMHB4JyA6ICcwcHggMTBweCd9ICR7cmVwZWF0fTtcbiAgICAgIGA7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IFsnIGVudGVyOiAnLCAnIGxlYXZlOiAnXTtcbiAgICB0aGlzLmNvb3Jkcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICBjb25zdCBpc1ZpZXcgPSBpID4gMTtcbiAgICAgIGNvbnN0IHZhbHVlID0gKGlzVmlldyA/IDAgOiB0aGlzLm9mZnNldCkgKyB2O1xuICAgICAgY29uc3QgaXNUYWlsID0gaSAlIDI7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gdmFsdWUgPCBsYWJlbFNpemU7XG4gICAgICBjb25zdCBpc092ZXIgPSB2YWx1ZSA+IChpc1ZpZXcgPyBpc0hvcmkgPyBjb250YWluZXJXaWR0aCA6IGNvbnRhaW5lckhlaWdodCA6IGlzSG9yaSA/IHNjcm9sbFdpZHRoIDogc2Nyb2xsSGVpZ2h0KSAtIGxhYmVsU2l6ZTtcbiAgICAgIGNvbnN0IGlzRmxpcCA9IChpc1ZpZXcgPyBpc1RhaWwgJiYgIWlzRmlyc3QgOiAhaXNUYWlsICYmICFpc0ZpcnN0KSB8fCBpc092ZXI7XG4gICAgICBjb25zdCAkbGFiZWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb25zdCAkdGV4dCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IGRpclByb3AgPSBpc0hvcmkgPyBpc0ZsaXAgPyAncmlnaHQnIDogJ2xlZnQnIDogaXNGbGlwID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgIGNvbnN0IGZsaXBPZmZzZXQgPSBpc0ZsaXAgPyAoaXNIb3JpID8gbGFiZWxXaWR0aCA6IGxhYmVsSGVpZ2h0KSArICghaXNWaWV3ID8gaXNIb3JpID8gLTEgOiAtMiA6IGlzSG9yaSA/IC0xIDogaXNPdmVyID8gMCA6IC0yKSA6ICFpc1ZpZXcgPyBpc0hvcmkgPyAxIDogMCA6IGlzSG9yaSA/IDEgOiAwO1xuICAgICAgLy8gJHRleHQuaW5uZXJIVE1MID0gYCR7IWlzVmlldyA/ICcnIDogbGFiZWxzW2lzVGFpbF0gKyAnICd9JHt0aGlzLmlkfTogJHt0aGlzLnRocmVzaG9sZHNbaV19ICR7aXNWaWV3ID8gJycgOiBsYWJlbHNbaXNUYWlsXX1gO1xuICAgICAgJHRleHQuaW5uZXJIVE1MID0gYCR7dGhpcy5pZH0ke2xhYmVsc1tpc1RhaWxdfSR7dGhpcy50aHJlc2hvbGRzW2ldfWA7XG4gICAgICAkbGFiZWwuc3R5bGUuY3NzVGV4dCA9IGAke2Jhc2VDU1MoJ2Fic29sdXRlJywgMCwgMCwgbGFiZWxXaWR0aCwgbGFiZWxIZWlnaHQpfVxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogJHtpc0hvcmkgPyAnY29sdW1uJyA6ICdyb3cnfTtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LSR7aXNWaWV3ID8gJ3N0YXJ0JyA6ICdlbmQnfTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtJHtpc0ZsaXAgPyAnZW5kJyA6ICdzdGFydCd9O1xuICAgICAgICBib3JkZXItJHtkaXJQcm9wfTogMnB4ICR7aXNUYWlsID8gJ3NvbGlkJyA6ICdzb2xpZCd9ICR7Y29sb3J9O1xuICAgICAgYDtcbiAgICAgICR0ZXh0LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIG1heC13aWR0aDogJHsoc2l6ZSAvIDIpIC0gMTB9cHg7XG4gICAgICAgIGhlaWdodDogJHtsYWJlbEhlaWdodH07XG4gICAgICAgIG1hcmdpbi0ke2lzSG9yaSA/IGlzRmxpcCA/ICdyaWdodCcgOiAnbGVmdCcgOiBpc0ZsaXAgPyAnYm90dG9tJyA6ICd0b3AnfTogLTJweDtcbiAgICAgICAgcGFkZGluZzogMXB4O1xuICAgICAgICBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBtb25vc3BhY2U7XG4gICAgICAgIGZvbnQtc2l6ZTogMTBweDtcbiAgICAgICAgbGV0dGVyLXNwYWNpbmc6IC0uMDI1ZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiA5cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIHRleHQtYWxpZ246ICR7aXNIb3JpICYmIGlzRmxpcCB8fCAhaXNIb3JpICYmICFpc1ZpZXcgPyAncmlnaHQnIDogJ2xlZnQnfTtcbiAgICAgICAgd2hpdGUtc3BhY2U6IHByZTtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgIGNvbG9yOiAke2lzVGFpbCA/IGNvbG9yIDogJ3JnYmEoMCwwLDAsLjc1KSd9O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2lzVGFpbCA/ICdyZ2JhKDAsMCwwLC42NSknIDogY29sb3J9O1xuICAgICAgICBib3JkZXI6IDJweCBzb2xpZCAke2lzVGFpbCA/IGNvbG9yIDogJ3RyYW5zcGFyZW50J307XG4gICAgICAgIGJvcmRlci0ke2lzSG9yaSA/IGlzRmxpcCA/ICd0b3AtbGVmdCcgOiAndG9wLXJpZ2h0JyA6IGlzRmxpcCA/ICd0b3AtbGVmdCcgOiAnYm90dG9tLWxlZnQnfS1yYWRpdXM6IDVweDtcbiAgICAgICAgYm9yZGVyLSR7aXNIb3JpID8gaXNGbGlwID8gJ2JvdHRvbS1sZWZ0JyA6ICdib3R0b20tcmlnaHQnIDogaXNGbGlwID8gJ3RvcC1yaWdodCcgOiAnYm90dG9tLXJpZ2h0J30tcmFkaXVzOiA1cHg7XG4gICAgICBgO1xuICAgICAgJGxhYmVsLmFwcGVuZENoaWxkKCR0ZXh0KTtcbiAgICAgIGxldCBwb3NpdGlvbiA9IHZhbHVlIC0gZmxpcE9mZnNldCArIChpc0hvcmkgPyAxIDogMCk7XG4gICAgICAkbGFiZWwuc3R5bGVbaXNIb3JpID8gJ2xlZnQnIDogJ3RvcCddID0gYCR7cG9zaXRpb259cHhgO1xuICAgICAgLy8gJGxhYmVsLnN0eWxlW2lzSG9yaSA/ICdsZWZ0JyA6ICd0b3AnXSA9IHZhbHVlIC0gZmxpcE9mZnNldCArICghaXNGbGlwICYmIGlzRmlyc3QgJiYgIWlzVmlldyA/IDEgOiBpc0ZsaXAgPyAwIDogLTIpICsgJ3B4JztcbiAgICAgIChpc1ZpZXcgPyAkdGhyZXNob2xkcyA6ICR0cmlnZ2VycykuYXBwZW5kQ2hpbGQoJGxhYmVsKTtcbiAgICB9KTtcblxuICAgICRkZWJ1Zy5hcHBlbmRDaGlsZCgkdGhyZXNob2xkcyk7XG4gICAgJGRlYnVnLmFwcGVuZENoaWxkKCR0cmlnZ2Vycyk7XG4gICAgY29udGFpbmVyLmVsZW1lbnQuYXBwZW5kQ2hpbGQoJGRlYnVnKTtcblxuICAgIGlmICghJGV4aXN0aW5nRGVidWcpICRkZWJ1Zy5jbGFzc0xpc3QuYWRkKCdhbmltZWpzLW9uc2Nyb2xsLWRlYnVnJyk7XG4gICAgdGhpcy4kZGVidWcgPSAkZGVidWc7XG4gICAgY29uc3QgY29udGFpbmVyUG9zaXRpb24gPSBnZXRUYXJnZXRWYWx1ZShjb250YWluZXIuZWxlbWVudCwgJ3Bvc2l0aW9uJyk7XG4gICAgaWYgKGNvbnRhaW5lclBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgdGhpcy5kZWJ1Z1N0eWxlcyA9IHNldFRhcmdldFZhbHVlcyhjb250YWluZXIuZWxlbWVudCwgeyBwb3NpdGlvbjogJ3JlbGF0aXZlICd9KTtcbiAgICB9XG5cbiAgfVxuXG4gIHVwZGF0ZUJvdW5kcygpIHtcbiAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgIHRoaXMucmVtb3ZlRGVidWcoKTtcbiAgICB9XG4gICAgbGV0IHN0aWNreXM7XG4gICAgY29uc3QgJHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIGNvbnN0IGlzSG9yaSA9IHRoaXMuaG9yaXpvbnRhbDtcbiAgICBjb25zdCBsaW5rZWQgPSB0aGlzLmxpbmtlZDtcbiAgICBsZXQgbGlua2VkVGltZTtcbiAgICBsZXQgJGVsID0gJHRhcmdldDtcbiAgICAvLyBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgLy8gbGV0IG9mZnNldFkgPSAwO1xuICAgIC8vIGxldCAkb2Zmc2V0UGFyZW50ID0gJGVsO1xuICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gKi9cbiAgICBpZiAobGlua2VkKSB7XG4gICAgICBsaW5rZWRUaW1lID0gbGlua2VkLmN1cnJlbnRUaW1lO1xuICAgICAgbGlua2VkLnNlZWsoMCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qIE9sZCBpbXBsZW1lbnRhdGlvbiB0byBnZXQgb2Zmc2V0IGFuZCB0YXJnZXRTaXplIGJlZm9yZSBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL2p1bGlhbmdhcm5pZXIvYW5pbWUvaXNzdWVzLzEwMjFcbiAgICAvLyBjb25zdCBpc0NvbnRhaW5lclN0YXRpYyA9IGdldFRhcmdldFZhbHVlKGNvbnRhaW5lci5lbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycgPyBzZXRUYXJnZXRWYWx1ZXMoY29udGFpbmVyLmVsZW1lbnQsIHsgcG9zaXRpb246ICdyZWxhdGl2ZSAnfSkgOiBmYWxzZTtcbiAgICAvLyB3aGlsZSAoJGVsICYmICRlbCAhPT0gY29udGFpbmVyLmVsZW1lbnQgJiYgJGVsICE9PSBkb2MuYm9keSkge1xuICAgIC8vICAgY29uc3QgaXNTdGlja3kgPSBnZXRUYXJnZXRWYWx1ZSgkZWwsICdwb3NpdGlvbicpID09PSAnc3RpY2t5JyA/XG4gICAgLy8gICAgICAgICAgICAgICAgICAgIHNldFRhcmdldFZhbHVlcygkZWwsIHsgcG9zaXRpb246ICdzdGF0aWMnIH0pIDpcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgZmFsc2U7XG4gICAgLy8gICBpZiAoJGVsID09PSAkb2Zmc2V0UGFyZW50KSB7XG4gICAgLy8gICAgIG9mZnNldFggKz0gJGVsLm9mZnNldExlZnQgfHwgMDtcbiAgICAvLyAgICAgb2Zmc2V0WSArPSAkZWwub2Zmc2V0VG9wIHx8IDA7XG4gICAgLy8gICAgICRvZmZzZXRQYXJlbnQgPSAkZWwub2Zmc2V0UGFyZW50O1xuICAgIC8vICAgfVxuICAgIC8vICAgJGVsID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oJGVsLnBhcmVudEVsZW1lbnQpO1xuICAgIC8vICAgaWYgKGlzU3RpY2t5KSB7XG4gICAgLy8gICAgIGlmICghc3RpY2t5cykgc3RpY2t5cyA9IFtdO1xuICAgIC8vICAgICBzdGlja3lzLnB1c2goaXNTdGlja3kpO1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICAvLyBpZiAoaXNDb250YWluZXJTdGF0aWMpIGlzQ29udGFpbmVyU3RhdGljLnJldmVydCgpO1xuICAgIC8vIGNvbnN0IG9mZnNldCA9IGlzSG9yaSA/IG9mZnNldFggOiBvZmZzZXRZO1xuICAgIC8vIGNvbnN0IHRhcmdldFNpemUgPSBpc0hvcmkgPyAkdGFyZ2V0Lm9mZnNldFdpZHRoIDogJHRhcmdldC5vZmZzZXRIZWlnaHQ7XG5cbiAgICB3aGlsZSAoJGVsICYmICRlbCAhPT0gY29udGFpbmVyLmVsZW1lbnQgJiYgJGVsICE9PSBkb2MuYm9keSkge1xuICAgICAgY29uc3QgaXNTdGlja3kgPSBnZXRUYXJnZXRWYWx1ZSgkZWwsICdwb3NpdGlvbicpID09PSAnc3RpY2t5JyA/IHNldFRhcmdldFZhbHVlcygkZWwsIHsgcG9zaXRpb246ICdzdGF0aWMnIH0pIDogZmFsc2U7XG4gICAgICAkZWwgPSAkZWwucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChpc1N0aWNreSkge1xuICAgICAgICBpZiAoIXN0aWNreXMpIHN0aWNreXMgPSBbXTtcbiAgICAgICAgc3RpY2t5cy5wdXNoKGlzU3RpY2t5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVjdCA9ICR0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaXNIb3JpID8gcmVjdC5sZWZ0ICsgY29udGFpbmVyLnNjcm9sbFggLSBjb250YWluZXIubGVmdCA6IHJlY3QudG9wICsgY29udGFpbmVyLnNjcm9sbFkgLSBjb250YWluZXIudG9wO1xuICAgIGNvbnN0IHRhcmdldFNpemUgPSBpc0hvcmkgPyByZWN0LndpZHRoIDogcmVjdC5oZWlnaHQ7XG4gICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGlzSG9yaSA/IGNvbnRhaW5lci53aWR0aCA6IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGlzSG9yaSA/IGNvbnRhaW5lci5zY3JvbGxXaWR0aCA6IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgY29uc3QgbWF4U2Nyb2xsID0gc2Nyb2xsU2l6ZSAtIGNvbnRhaW5lclNpemU7XG4gICAgY29uc3QgZW50ZXIgPSB0aGlzLmVudGVyO1xuICAgIGNvbnN0IGxlYXZlID0gdGhpcy5sZWF2ZTtcblxuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9ICovXG4gICAgbGV0IGVudGVyVGFyZ2V0ID0gJ3N0YXJ0JztcbiAgICAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFZhbHVlfSAqL1xuICAgIGxldCBsZWF2ZVRhcmdldCA9ICdlbmQnO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9ICovXG4gICAgbGV0IGVudGVyQ29udGFpbmVyID0gJ2VuZCc7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxUaHJlc2hvbGRWYWx1ZX0gKi9cbiAgICBsZXQgbGVhdmVDb250YWluZXIgPSAnc3RhcnQnO1xuXG4gICAgaWYgKGlzU3RyKGVudGVyKSkge1xuICAgICAgY29uc3Qgc3BsaXR0ZWQgPSAvKiogQHR5cGUge1N0cmluZ30gKi8oZW50ZXIpLnNwbGl0KCcgJyk7XG4gICAgICBlbnRlckNvbnRhaW5lciA9IHNwbGl0dGVkWzBdO1xuICAgICAgZW50ZXJUYXJnZXQgPSBzcGxpdHRlZC5sZW5ndGggPiAxID8gc3BsaXR0ZWRbMV0gOiBlbnRlclRhcmdldDtcbiAgICB9IGVsc2UgaWYgKGlzT2JqKGVudGVyKSkge1xuICAgICAgY29uc3QgZSA9IC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkUGFyYW19ICovKGVudGVyKTtcbiAgICAgIGlmICghaXNVbmQoZS5jb250YWluZXIpKSBlbnRlckNvbnRhaW5lciA9IGUuY29udGFpbmVyO1xuICAgICAgaWYgKCFpc1VuZChlLnRhcmdldCkpIGVudGVyVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgfSBlbHNlIGlmIChpc051bShlbnRlcikpIHtcbiAgICAgIGVudGVyQ29udGFpbmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKGVudGVyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHIobGVhdmUpKSB7XG4gICAgICBjb25zdCBzcGxpdHRlZCA9IC8qKiBAdHlwZSB7U3RyaW5nfSAqLyhsZWF2ZSkuc3BsaXQoJyAnKTtcbiAgICAgIGxlYXZlQ29udGFpbmVyID0gc3BsaXR0ZWRbMF07XG4gICAgICBsZWF2ZVRhcmdldCA9IHNwbGl0dGVkLmxlbmd0aCA+IDEgPyBzcGxpdHRlZFsxXSA6IGxlYXZlVGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAoaXNPYmoobGVhdmUpKSB7XG4gICAgICBjb25zdCB0ID0gLyoqIEB0eXBlIHtTY3JvbGxUaHJlc2hvbGRQYXJhbX0gKi8obGVhdmUpO1xuICAgICAgaWYgKCFpc1VuZCh0LmNvbnRhaW5lcikpIGxlYXZlQ29udGFpbmVyID0gdC5jb250YWluZXI7XG4gICAgICBpZiAoIWlzVW5kKHQudGFyZ2V0KSkgbGVhdmVUYXJnZXQgPSB0LnRhcmdldDtcbiAgICB9IGVsc2UgaWYgKGlzTnVtKGxlYXZlKSkge1xuICAgICAgbGVhdmVDb250YWluZXIgPSAvKiogQHR5cGUge051bWJlcn0gKi8obGVhdmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZEVudGVyVGFyZ2V0ID0gcGFyc2VCb3VuZFZhbHVlKCR0YXJnZXQsIGVudGVyVGFyZ2V0LCB0YXJnZXRTaXplKTtcbiAgICBjb25zdCBwYXJzZWRMZWF2ZVRhcmdldCA9IHBhcnNlQm91bmRWYWx1ZSgkdGFyZ2V0LCBsZWF2ZVRhcmdldCwgdGFyZ2V0U2l6ZSk7XG4gICAgY29uc3QgdW5kZXIgPSAocGFyc2VkRW50ZXJUYXJnZXQgKyBvZmZzZXQpIC0gY29udGFpbmVyU2l6ZTtcbiAgICBjb25zdCBvdmVyID0gKHBhcnNlZExlYXZlVGFyZ2V0ICsgb2Zmc2V0KSAtIG1heFNjcm9sbDtcbiAgICBjb25zdCBwYXJzZWRFbnRlckNvbnRhaW5lciA9IHBhcnNlQm91bmRWYWx1ZSgkdGFyZ2V0LCBlbnRlckNvbnRhaW5lciwgY29udGFpbmVyU2l6ZSwgdW5kZXIsIG92ZXIpO1xuICAgIGNvbnN0IHBhcnNlZExlYXZlQ29udGFpbmVyID0gcGFyc2VCb3VuZFZhbHVlKCR0YXJnZXQsIGxlYXZlQ29udGFpbmVyLCBjb250YWluZXJTaXplLCB1bmRlciwgb3Zlcik7XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSBwYXJzZWRFbnRlclRhcmdldCArIG9mZnNldCAtIHBhcnNlZEVudGVyQ29udGFpbmVyO1xuICAgIGNvbnN0IG9mZnNldEVuZCA9IHBhcnNlZExlYXZlVGFyZ2V0ICsgb2Zmc2V0IC0gcGFyc2VkTGVhdmVDb250YWluZXI7XG4gICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSBvZmZzZXRFbmQgLSBvZmZzZXRTdGFydDtcbiAgICAvLyB0aGlzLm9mZnNldHNbMF0gPSBvZmZzZXRYO1xuICAgIC8vIHRoaXMub2Zmc2V0c1sxXSA9IG9mZnNldFk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5vZmZzZXRTdGFydCA9IG9mZnNldFN0YXJ0O1xuICAgIHRoaXMub2Zmc2V0RW5kID0gb2Zmc2V0RW5kO1xuICAgIHRoaXMuZGlzdGFuY2UgPSBzY3JvbGxEZWx0YSA8PSAwID8gMCA6IHNjcm9sbERlbHRhO1xuICAgIHRoaXMudGhyZXNob2xkcyA9IFtlbnRlclRhcmdldCwgbGVhdmVUYXJnZXQsIGVudGVyQ29udGFpbmVyLCBsZWF2ZUNvbnRhaW5lcl07XG4gICAgdGhpcy5jb29yZHMgPSBbcGFyc2VkRW50ZXJUYXJnZXQsIHBhcnNlZExlYXZlVGFyZ2V0LCBwYXJzZWRFbnRlckNvbnRhaW5lciwgcGFyc2VkTGVhdmVDb250YWluZXJdO1xuICAgIGlmIChzdGlja3lzKSB7XG4gICAgICBzdGlja3lzLmZvckVhY2goc3RpY2t5ID0+IHN0aWNreS5yZXZlcnQoKSk7XG4gICAgfVxuICAgIGlmIChsaW5rZWQpIHtcbiAgICAgIGxpbmtlZC5zZWVrKGxpbmtlZFRpbWUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgIHRoaXMuZGVidWcoKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTY3JvbGwoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVhZHkpIHJldHVybjtcbiAgICBjb25zdCBsaW5rZWQgPSB0aGlzLmxpbmtlZDtcbiAgICBjb25zdCBzeW5jID0gdGhpcy5zeW5jO1xuICAgIGNvbnN0IHN5bmNFYXNlID0gdGhpcy5zeW5jRWFzZTtcbiAgICBjb25zdCBzeW5jU21vb3RoID0gdGhpcy5zeW5jU21vb3RoO1xuICAgIGNvbnN0IHNob3VsZFNlZWsgPSBsaW5rZWQgJiYgKHN5bmNFYXNlIHx8IHN5bmNTbW9vdGgpO1xuICAgIGNvbnN0IGlzSG9yaSA9IHRoaXMuaG9yaXpvbnRhbDtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLnNjcm9sbDtcbiAgICBjb25zdCBpc0JlZm9yZSA9IHNjcm9sbCA8PSB0aGlzLm9mZnNldFN0YXJ0O1xuICAgIGNvbnN0IGlzQWZ0ZXIgPSBzY3JvbGwgPj0gdGhpcy5vZmZzZXRFbmQ7XG4gICAgY29uc3QgaXNJblZpZXcgPSAhaXNCZWZvcmUgJiYgIWlzQWZ0ZXI7XG4gICAgY29uc3QgaXNPblRoZUVkZ2UgPSBzY3JvbGwgPT09IHRoaXMub2Zmc2V0U3RhcnQgfHwgc2Nyb2xsID09PSB0aGlzLm9mZnNldEVuZDtcbiAgICBjb25zdCBmb3JjZUVudGVyID0gIXRoaXMuaGFzRW50ZXJlZCAmJiBpc09uVGhlRWRnZTtcbiAgICBjb25zdCAkZGVidWcgPSB0aGlzLl9kZWJ1ZyAmJiB0aGlzLiRkZWJ1ZztcbiAgICBsZXQgaGFzVXBkYXRlZCA9IGZhbHNlO1xuICAgIGxldCBzeW5jQ29tcGxldGVkID0gZmFsc2U7XG4gICAgbGV0IHAgPSB0aGlzLnByb2dyZXNzO1xuXG4gICAgaWYgKGlzQmVmb3JlICYmIHRoaXMuYmVnYW4pIHtcbiAgICAgIHRoaXMuYmVnYW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocCA+IDAgJiYgIXRoaXMuYmVnYW4pIHtcbiAgICAgIHRoaXMuYmVnYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRTZWVrKSB7XG4gICAgICBjb25zdCBscCA9IGxpbmtlZC5wcm9ncmVzcztcbiAgICAgIGlmIChzeW5jU21vb3RoICYmIGlzTnVtKHN5bmNTbW9vdGgpKSB7XG4gICAgICAgIGlmICgvKiogQHR5cGUge051bWJlcn0gKi8oc3luY1Ntb290aCkgPCAxKSB7XG4gICAgICAgICAgY29uc3Qgc3RlcCA9IDAuMDAwMTtcbiAgICAgICAgICBjb25zdCBzbmFwID0gbHAgPCBwICYmIHAgPT09IDEgPyBzdGVwIDogbHAgPiBwICYmICFwID8gLXN0ZXAgOiAwO1xuICAgICAgICAgIHAgPSByb3VuZChsZXJwKGxwLCBwLCBpbnRlcnBvbGF0ZSguMDEsIC4yLCAvKiogQHR5cGUge051bWJlcn0gKi8oc3luY1Ntb290aCkpLCBmYWxzZSkgKyBzbmFwLCA2KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzeW5jRWFzZSkge1xuICAgICAgICBwID0gc3luY0Vhc2UocCk7XG4gICAgICB9XG4gICAgICBoYXNVcGRhdGVkID0gcCAhPT0gdGhpcy5wcmV2UHJvZ3Jlc3M7XG4gICAgICBzeW5jQ29tcGxldGVkID0gbHAgPT09IDE7XG4gICAgICBpZiAoaGFzVXBkYXRlZCAmJiAhc3luY0NvbXBsZXRlZCAmJiAoc3luY1Ntb290aCAmJiBscCkpIHtcbiAgICAgICAgY29udGFpbmVyLndha2VUaWNrZXIucmVzdGFydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkZGVidWcpIHtcbiAgICAgIGNvbnN0IHN0aWNreSA9IGlzSG9yaSA/IGNvbnRhaW5lci5zY3JvbGxZIDogY29udGFpbmVyLnNjcm9sbFg7XG4gICAgICAkZGVidWcuc3R5bGVbaXNIb3JpID8gJ3RvcCcgOiAnbGVmdCddID0gc3RpY2t5ICsgMTAgKyAncHgnO1xuICAgIH1cblxuICAgIC8vIFRyaWdnZXIgZW50ZXIgY2FsbGJhY2tzIGlmIGFscmVhZHkgaW4gdmlldyBvciB3aGVuIGVudGVyaW5nIHRoZSB2aWV3XG4gICAgaWYgKChpc0luVmlldyAmJiAhdGhpcy5pc0luVmlldykgfHwgKGZvcmNlRW50ZXIgJiYgIXRoaXMuZm9yY2VFbnRlciAmJiAhdGhpcy5oYXNFbnRlcmVkKSkge1xuICAgICAgaWYgKGlzSW5WaWV3KSB0aGlzLmlzSW5WaWV3ID0gdHJ1ZTtcbiAgICAgIGlmICghdGhpcy5mb3JjZUVudGVyIHx8ICF0aGlzLmhhc0VudGVyZWQpIHtcbiAgICAgICAgaWYgKCRkZWJ1ZyAmJiBpc0luVmlldykgJGRlYnVnLnN0eWxlLnpJbmRleCA9IGAke3RoaXMuY29udGFpbmVyLnpJbmRleCsrfWA7XG4gICAgICAgIHRoaXMub25TeW5jRW50ZXIodGhpcyk7XG4gICAgICAgIHRoaXMub25FbnRlcih0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuYmFja3dhcmQpIHtcbiAgICAgICAgICB0aGlzLm9uU3luY0VudGVyQmFja3dhcmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5vbkVudGVyQmFja3dhcmQodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vblN5bmNFbnRlckZvcndhcmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5vbkVudGVyRm9yd2FyZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0VudGVyZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZm9yY2VFbnRlcikgdGhpcy5mb3JjZUVudGVyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJblZpZXcpIHtcbiAgICAgICAgdGhpcy5mb3JjZUVudGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzSW5WaWV3IHx8ICFpc0luVmlldyAmJiB0aGlzLmlzSW5WaWV3KSB7XG4gICAgICBoYXNVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVXBkYXRlZCkge1xuICAgICAgaWYgKHNob3VsZFNlZWspIGxpbmtlZC5zZWVrKGxpbmtlZC5kdXJhdGlvbiAqIHApO1xuICAgICAgdGhpcy5vblVwZGF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzSW5WaWV3ICYmIHRoaXMuaXNJblZpZXcpIHtcbiAgICAgIHRoaXMuaXNJblZpZXcgPSBmYWxzZTtcbiAgICAgIHRoaXMub25TeW5jTGVhdmUodGhpcyk7XG4gICAgICB0aGlzLm9uTGVhdmUodGhpcyk7XG4gICAgICBpZiAodGhpcy5iYWNrd2FyZCkge1xuICAgICAgICB0aGlzLm9uU3luY0xlYXZlQmFja3dhcmQodGhpcyk7XG4gICAgICAgIHRoaXMub25MZWF2ZUJhY2t3YXJkKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vblN5bmNMZWF2ZUZvcndhcmQodGhpcyk7XG4gICAgICAgIHRoaXMub25MZWF2ZUZvcndhcmQodGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoc3luYyAmJiAhc3luY1Ntb290aCkge1xuICAgICAgICBzeW5jQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocCA+PSAxICYmIHRoaXMuYmVnYW4gJiYgIXRoaXMuY29tcGxldGVkICYmIChzeW5jICYmIHN5bmNDb21wbGV0ZWQgfHwgIXN5bmMpKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICB0aGlzLm9uU3luY0NvbXBsZXRlKHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgaWYgKCghdGhpcy5yZXBlYXQgJiYgIWxpbmtlZCkgfHwgKCF0aGlzLnJlcGVhdCAmJiBsaW5rZWQgJiYgbGlua2VkLmNvbXBsZXRlZCkpIHtcbiAgICAgICAgdGhpcy5yZXZlcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocCA8IDEgJiYgdGhpcy5jb21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuY29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2UHJvZ3Jlc3MgPSBwO1xuICB9XG5cbiAgcmV2ZXJ0KCkge1xuICAgIGlmICh0aGlzLnJldmVydGVkKSByZXR1cm47XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgcmVtb3ZlQ2hpbGQoY29udGFpbmVyLCB0aGlzKTtcbiAgICBpZiAoIWNvbnRhaW5lci5faGVhZCkge1xuICAgICAgY29udGFpbmVyLnJldmVydCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgIHRoaXMucmVtb3ZlRGVidWcoKTtcbiAgICB9XG4gICAgdGhpcy5yZXZlcnRlZCA9IHRydWU7XG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuXG4vKipcbiAqIEBwYXJhbSB7U2Nyb2xsT2JzZXJ2ZXJQYXJhbXN9IFtwYXJhbWV0ZXJzPXt9XVxuICogQHJldHVybiB7U2Nyb2xsT2JzZXJ2ZXJ9XG4gKi9cbmNvbnN0IG9uU2Nyb2xsID0gKHBhcmFtZXRlcnMgPSB7fSkgPT4gbmV3IFNjcm9sbE9ic2VydmVyKHBhcmFtZXRlcnMpO1xuXG5cblxuXG5jb25zdCBzZWdtZW50ZXIgPSAodHlwZW9mIEludGwgIT09ICd1bmRlZmluZWQnKSAmJiBJbnRsLlNlZ21lbnRlcjtcbmNvbnN0IHZhbHVlUmd4ID0gL1xce3ZhbHVlXFx9L2c7XG5jb25zdCBpbmRleFJneCA9IC9cXHtpXFx9L2c7XG5jb25zdCB3aGl0ZVNwYWNlR3JvdXBSZ3ggPSAvKFxccyspLztcbmNvbnN0IHdoaXRlU3BhY2VSZ3ggPSAvXlxccyskLztcbmNvbnN0IGxpbmVUeXBlID0gJ2xpbmUnO1xuY29uc3Qgd29yZFR5cGUgPSAnd29yZCc7XG5jb25zdCBjaGFyVHlwZSA9ICdjaGFyJztcbmNvbnN0IGRhdGFMaW5lID0gYGRhdGEtbGluZWA7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VnbWVudFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHNlZ21lbnRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2lzV29yZExpa2VdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZWdtZW50ZXJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oU3RyaW5nKTogSXRlcmFibGU8U2VnbWVudD59IHNlZ21lbnRcbiAqL1xuXG4vKiogQHR5cGUge1NlZ21lbnRlcn0gKi9cbmxldCB3b3JkU2VnbWVudGVyID0gbnVsbDtcbi8qKiBAdHlwZSB7U2VnbWVudGVyfSAqL1xubGV0IGdyYXBoZW1lU2VnbWVudGVyID0gbnVsbDtcbmxldCAkc3BsaXRUZW1wbGF0ZSA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtICB7U2VnbWVudH0gc2VnXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBpc1NlZ21lbnRXb3JkTGlrZSA9IHNlZyA9PiB7XG4gIHJldHVybiBzZWcuaXNXb3JkTGlrZSB8fFxuICAgICAgICAgc2VnLnNlZ21lbnQgPT09ICcgJyB8fCAvLyBDb25zaWRlciBzcGFjZXMgYXMgd29yZHMgZmlyc3QsIHRoZW4gaGFuZGxlIHRoZW0gZGlmZnJlbnRseSBsYXRlclxuICAgICAgICAgaXNOdW0oK3NlZy5zZWdtZW50KTsgLy8gU2FmYXJpIGRvZXNuJ3QgY29uc2lkZXJzIG51bWJlcnMgYXMgd29yZHNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKi9cbmNvbnN0IHNldEFyaWFIaWRkZW4gPSAkZWwgPT4gJGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59XG4gKi9cbmNvbnN0IGdldEFsbFRvcExldmVsRWxlbWVudHMgPSAoJGVsLCB0eXBlKSA9PiBbLi4uLyoqIEB0eXBlIHsqfSAqLygkZWwucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtJHt0eXBlfV06bm90KFtkYXRhLSR7dHlwZX1dIFtkYXRhLSR7dHlwZX1dKWApKV07XG5cbmNvbnN0IGRlYnVnQ29sb3JzID0geyBsaW5lOiAnIzAwRDY3MicsIHdvcmQ6ICcjRkY0QjRCJywgY2hhcjogJyM1QTg3RkYnIH07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKi9cbmNvbnN0IGZpbHRlckVtcHR5RWxlbWVudHMgPSAkZWwgPT4ge1xuICBpZiAoISRlbC5jaGlsZEVsZW1lbnRDb3VudCAmJiAhJGVsLnRleHRDb250ZW50LnRyaW0oKSkge1xuICAgIGNvbnN0ICRwYXJlbnQgPSAkZWwucGFyZW50RWxlbWVudDtcbiAgICAkZWwucmVtb3ZlKCk7XG4gICAgaWYgKCRwYXJlbnQpIGZpbHRlckVtcHR5RWxlbWVudHMoJHBhcmVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gKiBAcGFyYW0ge1NldDxIVE1MRWxlbWVudD59IGJpblxuICogQHJldHVybnMge1NldDxIVE1MRWxlbWVudD59XG4gKi9cbmNvbnN0IGZpbHRlckxpbmVFbGVtZW50cyA9ICgkZWwsIGxpbmVJbmRleCwgYmluKSA9PiB7XG4gIGNvbnN0IGRhdGFMaW5lQXR0ciA9ICRlbC5nZXRBdHRyaWJ1dGUoZGF0YUxpbmUpO1xuICBpZiAoZGF0YUxpbmVBdHRyICE9PSBudWxsICYmICtkYXRhTGluZUF0dHIgIT09IGxpbmVJbmRleCB8fCAkZWwudGFnTmFtZSA9PT0gJ0JSJykgYmluLmFkZCgkZWwpO1xuICBsZXQgaSA9ICRlbC5jaGlsZEVsZW1lbnRDb3VudDtcbiAgd2hpbGUgKGktLSkgZmlsdGVyTGluZUVsZW1lbnRzKC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKCRlbC5jaGlsZHJlbltpXSksIGxpbmVJbmRleCwgYmluKTtcbiAgcmV0dXJuIGJpbjtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7J2xpbmUnfCd3b3JkJ3wnY2hhcid9IHR5cGVcbiAqIEBwYXJhbSAge3NwbGl0VGVtcGxhdGVQYXJhbXN9IHBhcmFtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBnZW5lcmF0ZVRlbXBsYXRlID0gKHR5cGUsIHBhcmFtcyA9IHt9KSA9PiB7XG4gIGxldCB0ZW1wbGF0ZSA9IGBgO1xuICBjb25zdCBjbGFzc1N0cmluZyA9IGlzU3RyKHBhcmFtcy5jbGFzcykgPyBgIGNsYXNzPVwiJHtwYXJhbXMuY2xhc3N9XCJgIDogJyc7XG4gIGNvbnN0IGNsb25lVHlwZSA9IHNldFZhbHVlKHBhcmFtcy5jbG9uZSwgZmFsc2UpO1xuICBjb25zdCB3cmFwVHlwZSA9IHNldFZhbHVlKHBhcmFtcy53cmFwLCBmYWxzZSk7XG4gIGNvbnN0IG92ZXJmbG93ID0gd3JhcFR5cGUgPyB3cmFwVHlwZSA9PT0gdHJ1ZSA/ICdjbGlwJyA6IHdyYXBUeXBlIDogY2xvbmVUeXBlID8gJ2NsaXAnIDogZmFsc2U7XG4gIGlmICh3cmFwVHlwZSkgdGVtcGxhdGUgKz0gYDxzcGFuJHtvdmVyZmxvdyA/IGAgc3R5bGU9XCJvdmVyZmxvdzoke292ZXJmbG93fTtcImAgOiAnJ30+YDtcbiAgdGVtcGxhdGUgKz0gYDxzcGFuJHtjbGFzc1N0cmluZ30ke2Nsb25lVHlwZSA/IGAgc3R5bGU9XCJwb3NpdGlvbjpyZWxhdGl2ZTtcImAgOiAnJ30gZGF0YS0ke3R5cGV9PVwie2l9XCI+YDtcbiAgaWYgKGNsb25lVHlwZSkge1xuICAgIGNvbnN0IGxlZnQgPSBjbG9uZVR5cGUgPT09ICdsZWZ0JyA/ICctMTAwJScgOiBjbG9uZVR5cGUgPT09ICdyaWdodCcgPyAnMTAwJScgOiAnMCc7XG4gICAgY29uc3QgdG9wID0gY2xvbmVUeXBlID09PSAndG9wJyA/ICctMTAwJScgOiBjbG9uZVR5cGUgPT09ICdib3R0b20nID8gJzEwMCUnIDogJzAnO1xuICAgIHRlbXBsYXRlICs9IGA8c3Bhbj57dmFsdWV9PC9zcGFuPmA7XG4gICAgdGVtcGxhdGUgKz0gYDxzcGFuIGluZXJ0IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOiR7dG9wfTtsZWZ0OiR7bGVmdH07d2hpdGUtc3BhY2U6bm93cmFwO1wiPnt2YWx1ZX08L3NwYW4+YDtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSArPSBge3ZhbHVlfWA7XG4gIH1cbiAgdGVtcGxhdGUgKz0gYDwvc3Bhbj5gO1xuICBpZiAod3JhcFR5cGUpIHRlbXBsYXRlICs9IGA8L3NwYW4+YDtcbiAgcmV0dXJuIHRlbXBsYXRlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd8U3BsaXRGdW5jdGlvblZhbHVlfSBodG1sVGVtcGxhdGVcbiAqIEBwYXJhbSAge0FycmF5PEhUTUxFbGVtZW50Pn0gc3RvcmVcbiAqIEBwYXJhbSAge05vZGV8SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSAge0RvY3VtZW50RnJhZ21lbnR9ICRwYXJlbnRGcmFnbWVudFxuICogQHBhcmFtICB7J2xpbmUnfCd3b3JkJ3wnY2hhcid9IHR5cGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlYnVnXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbmVJbmRleFxuICogQHBhcmFtICB7TnVtYmVyfSBbd29yZEluZGV4XVxuICogQHBhcmFtICB7TnVtYmVyfSBbY2hhckluZGV4XVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmNvbnN0IHByb2Nlc3NIVE1MVGVtcGxhdGUgPSAoaHRtbFRlbXBsYXRlLCBzdG9yZSwgbm9kZSwgJHBhcmVudEZyYWdtZW50LCB0eXBlLCBkZWJ1ZywgbGluZUluZGV4LCB3b3JkSW5kZXgsIGNoYXJJbmRleCkgPT4ge1xuICBjb25zdCBpc0xpbmUgPSB0eXBlID09PSBsaW5lVHlwZTtcbiAgY29uc3QgaXNDaGFyID0gdHlwZSA9PT0gY2hhclR5cGU7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGBfJHt0eXBlfV9gO1xuICBjb25zdCB0ZW1wbGF0ZSA9IGlzRm5jKGh0bWxUZW1wbGF0ZSkgPyBodG1sVGVtcGxhdGUobm9kZSkgOiBodG1sVGVtcGxhdGU7XG4gIGNvbnN0IGRpc3BsYXlTdHlsZSA9IGlzTGluZSA/ICdibG9jaycgOiAnaW5saW5lLWJsb2NrJztcbiAgJHNwbGl0VGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVcbiAgICAucmVwbGFjZSh2YWx1ZVJneCwgYDxpIGNsYXNzPVwiJHtjbGFzc05hbWV9XCI+PC9pPmApXG4gICAgLnJlcGxhY2UoaW5kZXhSZ3gsIGAke2lzQ2hhciA/IGNoYXJJbmRleCA6IGlzTGluZSA/IGxpbmVJbmRleCA6IHdvcmRJbmRleH1gKTtcbiAgY29uc3QgJGNvbnRlbnQgPSAkc3BsaXRUZW1wbGF0ZS5jb250ZW50O1xuICBjb25zdCAkaGlnaGVzdFBhcmVudCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKCRjb250ZW50LmZpcnN0RWxlbWVudENoaWxkKTtcbiAgY29uc3QgJHNwbGl0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oJGNvbnRlbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtJHt0eXBlfV1gKSkgfHwgJGhpZ2hlc3RQYXJlbnQ7XG4gIGNvbnN0ICRyZXBsYWNhYmxlcyA9IC8qKiBAdHlwZSB7Tm9kZUxpc3RPZjxIVE1MRWxlbWVudD59ICovKCRjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYGkuJHtjbGFzc05hbWV9YCkpO1xuICBjb25zdCByZXBsYWNhYmxlc0xlbmd0aCA9ICRyZXBsYWNhYmxlcy5sZW5ndGg7XG4gIGlmIChyZXBsYWNhYmxlc0xlbmd0aCkge1xuICAgICRoaWdoZXN0UGFyZW50LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5U3R5bGU7XG4gICAgJHNwbGl0LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5U3R5bGU7XG4gICAgJHNwbGl0LnNldEF0dHJpYnV0ZShkYXRhTGluZSwgYCR7bGluZUluZGV4fWApO1xuICAgIGlmICghaXNMaW5lKSB7XG4gICAgICAkc3BsaXQuc2V0QXR0cmlidXRlKCdkYXRhLXdvcmQnLCBgJHt3b3JkSW5kZXh9YCk7XG4gICAgICBpZiAoaXNDaGFyKSAkc3BsaXQuc2V0QXR0cmlidXRlKCdkYXRhLWNoYXInLCBgJHtjaGFySW5kZXh9YCk7XG4gICAgfVxuICAgIGxldCBpID0gcmVwbGFjYWJsZXNMZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY29uc3QgJHJlcGxhY2UgPSAkcmVwbGFjYWJsZXNbaV07XG4gICAgICBjb25zdCAkY2xvc2VzdFBhcmVudCA9ICRyZXBsYWNlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAkY2xvc2VzdFBhcmVudC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheVN0eWxlO1xuICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAkY2xvc2VzdFBhcmVudC5pbm5lckhUTUwgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhub2RlKS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkY2xvc2VzdFBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSksICRyZXBsYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RvcmUucHVzaCgkc3BsaXQpO1xuICAgICRwYXJlbnRGcmFnbWVudC5hcHBlbmRDaGlsZCgkY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKGBUaGUgZXhwcmVzc2lvbiBcInt2YWx1ZX1cIiBpcyBtaXNzaW5nIGZyb20gdGhlIHByb3ZpZGVkIHRlbXBsYXRlLmApO1xuICB9XG4gIGlmIChkZWJ1ZykgJGhpZ2hlc3RQYXJlbnQuc3R5bGUub3V0bGluZSA9IGAxcHggZG90dGVkICR7ZGVidWdDb2xvcnNbdHlwZV19YDtcbiAgcmV0dXJuICRoaWdoZXN0UGFyZW50O1xufTtcblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgc3BsaXRzIHRleHQgaW50byB3b3JkcyBhbmQgd3JhcHMgdGhlbSBpbiBzcGFuIGVsZW1lbnRzIHdoaWxlIHByZXNlcnZpbmcgdGhlIG9yaWdpbmFsIEhUTUwgc3RydWN0dXJlLlxuICogQGNsYXNzXG4gKi9cbmNsYXNzIFRleHRTcGxpdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudHxOb2RlTGlzdHxTdHJpbmd8QXJyYXk8SFRNTEVsZW1lbnQ+fSB0YXJnZXRcbiAgICogQHBhcmFtICB7VGV4dFNwbGl0dGVyUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgcGFyYW1ldGVycyA9IHt9KSB7XG4gICAgLy8gT25seSBpbml0IHNlZ21lbnRlcnMgd2hlbiBuZWVkZWRcbiAgICBpZiAoIXdvcmRTZWdtZW50ZXIpIHdvcmRTZWdtZW50ZXIgPSBzZWdtZW50ZXIgPyBuZXcgc2VnbWVudGVyKFtdLCB7IGdyYW51bGFyaXR5OiB3b3JkVHlwZSB9KSA6IHtcbiAgICAgIHNlZ21lbnQ6ICh0ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgICAgIGNvbnN0IHdvcmRzID0gdGV4dC5zcGxpdCh3aGl0ZVNwYWNlR3JvdXBSZ3gpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHdvcmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSB3b3Jkc1tpXTtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICBpc1dvcmRMaWtlOiAhd2hpdGVTcGFjZVJneC50ZXN0KHNlZ21lbnQpLCAvLyBDb25zaWRlciBub24td2hpdGVzcGFjZSBhcyB3b3JkLWxpa2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWdyYXBoZW1lU2VnbWVudGVyKSBncmFwaGVtZVNlZ21lbnRlciA9IHNlZ21lbnRlciA/IG5ldyBzZWdtZW50ZXIoW10sIHsgZ3JhbnVsYXJpdHk6ICdncmFwaGVtZScgfSkgOiB7XG4gICAgICBzZWdtZW50OiB0ZXh0ID0+IFsuLi50ZXh0XS5tYXAoY2hhciA9PiAoeyBzZWdtZW50OiBjaGFyIH0pKVxuICAgIH07XG4gICAgaWYgKCEkc3BsaXRUZW1wbGF0ZSAmJiBpc0Jyb3dzZXIpICRzcGxpdFRlbXBsYXRlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKHNjb3BlLmN1cnJlbnQpIHNjb3BlLmN1cnJlbnQucmVnaXN0ZXIodGhpcyk7XG4gICAgY29uc3QgeyB3b3JkcywgY2hhcnMsIGxpbmVzLCBhY2Nlc3NpYmxlLCBpbmNsdWRlU3BhY2VzLCBkZWJ1ZyB9ID0gcGFyYW1ldGVycztcbiAgICBjb25zdCAkdGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oKHRhcmdldCA9IGlzQXJyKHRhcmdldCkgPyB0YXJnZXRbMF0gOiB0YXJnZXQpICYmIC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KS5ub2RlVHlwZSA/IHRhcmdldCA6IChnZXROb2RlTGlzdCh0YXJnZXQpIHx8IFtdKVswXSk7XG4gICAgY29uc3QgbGluZVBhcmFtcyA9IGxpbmVzID09PSB0cnVlID8ge30gOiBsaW5lcztcbiAgICBjb25zdCB3b3JkUGFyYW1zID0gd29yZHMgPT09IHRydWUgfHwgaXNVbmQod29yZHMpID8ge30gOiB3b3JkcztcbiAgICBjb25zdCBjaGFyUGFyYW1zID0gY2hhcnMgPT09IHRydWUgPyB7fSA6IGNoYXJzO1xuICAgIHRoaXMuZGVidWcgPSBzZXRWYWx1ZShkZWJ1ZywgZmFsc2UpO1xuICAgIHRoaXMuaW5jbHVkZVNwYWNlcyA9IHNldFZhbHVlKGluY2x1ZGVTcGFjZXMsIGZhbHNlKTtcbiAgICB0aGlzLmFjY2Vzc2libGUgPSBzZXRWYWx1ZShhY2Nlc3NpYmxlLCB0cnVlKTtcbiAgICB0aGlzLmxpbmVzT25seSA9IGxpbmVQYXJhbXMgJiYgKCF3b3JkUGFyYW1zICYmICFjaGFyUGFyYW1zKTtcbiAgICAvKiogQHR5cGUge1N0cmluZ3xmYWxzZXxTcGxpdEZ1bmN0aW9uVmFsdWV9ICovXG4gICAgdGhpcy5saW5lVGVtcGxhdGUgPSBpc09iaihsaW5lUGFyYW1zKSA/IGdlbmVyYXRlVGVtcGxhdGUobGluZVR5cGUsIC8qKiBAdHlwZSB7c3BsaXRUZW1wbGF0ZVBhcmFtc30gKi8obGluZVBhcmFtcykpIDogbGluZVBhcmFtcztcbiAgICAvKiogQHR5cGUge1N0cmluZ3xmYWxzZXxTcGxpdEZ1bmN0aW9uVmFsdWV9ICovXG4gICAgdGhpcy53b3JkVGVtcGxhdGUgPSBpc09iaih3b3JkUGFyYW1zKSB8fCB0aGlzLmxpbmVzT25seSA/IGdlbmVyYXRlVGVtcGxhdGUod29yZFR5cGUsIC8qKiBAdHlwZSB7c3BsaXRUZW1wbGF0ZVBhcmFtc30gKi8od29yZFBhcmFtcykpIDogd29yZFBhcmFtcztcbiAgICAvKiogQHR5cGUge1N0cmluZ3xmYWxzZXxTcGxpdEZ1bmN0aW9uVmFsdWV9ICovXG4gICAgdGhpcy5jaGFyVGVtcGxhdGUgPSBpc09iaihjaGFyUGFyYW1zKSA/IGdlbmVyYXRlVGVtcGxhdGUoY2hhclR5cGUsIC8qKiBAdHlwZSB7c3BsaXRUZW1wbGF0ZVBhcmFtc30gKi8oY2hhclBhcmFtcykpIDogY2hhclBhcmFtcztcbiAgICB0aGlzLiR0YXJnZXQgPSAkdGFyZ2V0O1xuICAgIHRoaXMuaHRtbCA9ICR0YXJnZXQgJiYgJHRhcmdldC5pbm5lckhUTUw7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMud29yZHMgPSBbXTtcbiAgICB0aGlzLmNoYXJzID0gW107XG4gICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgdGhpcy5lZmZlY3RzQ2xlYW51cHMgPSBbXTtcbiAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gbnVsbDtcbiAgICBjb25zdCBoYW5kbGVTcGxpdCA9ICgpID0+IHRoaXMuaHRtbCAmJiAobGluZVBhcmFtcyB8fCB3b3JkUGFyYW1zIHx8IGNoYXJQYXJhbXMpICYmIHRoaXMuc3BsaXQoKTtcbiAgICAvLyBNYWtlIHN1cmUgdGhpcyBpcyBkZWNsYXJlZCBiZWZvcmUgY2FsbGluZyBoYW5kbGVTcGxpdCgpIGluIGNhc2UgcmV2ZXJ0KCkgaXMgY2FsbGVkIGluc2lkZSBhbiBlZmZlY3QgY2FsbGJhY2tcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIC8vIFVzZSBhIHNldFRpbWVvdXQgaW5zdGVhZCBvZiBhIFRpbWVyIGZvciBiZXR0ZXIgdHJlZSBzaGFraW5nXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50V2lkdGggPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLygkdGFyZ2V0KS5vZmZzZXRXaWR0aDtcbiAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCA9PT0gdGhpcy53aWR0aCkgcmV0dXJuO1xuICAgICAgICB0aGlzLndpZHRoID0gY3VycmVudFdpZHRoO1xuICAgICAgICBoYW5kbGVTcGxpdCgpO1xuICAgICAgfSwgMTUwKTtcbiAgICB9KTtcbiAgICAvLyBPbmx5IGRlY2xhcmUgdGhlIGZvbnQgcmVhZHkgcHJvbWlzZSB3aGVuIHNwbGl0dGluZyBieSBsaW5lcyBhbmQgbm90IGFscmVheSBzcGxpdFxuICAgIGlmICh0aGlzLmxpbmVUZW1wbGF0ZSAmJiAhdGhpcy5yZWFkeSkge1xuICAgICAgZG9jLmZvbnRzLnJlYWR5LnRoZW4oaGFuZGxlU3BsaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTcGxpdCgpO1xuICAgIH1cbiAgICAkdGFyZ2V0ID8gdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKCR0YXJnZXQpIDogY29uc29sZS53YXJuKCdObyBUZXh0IFNwbGl0dGVyIHRhcmdldCBmb3VuZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHsoLi4uYXJnczogYW55W10pID0+IFRpY2thYmxlIHwgKCgpID0+IHZvaWQpfSBlZmZlY3RcbiAgICogQHJldHVybiB0aGlzXG4gICAqL1xuICBhZGRFZmZlY3QoZWZmZWN0KSB7XG4gICAgaWYgKCFpc0ZuYyhlZmZlY3QpKSByZXR1cm4gY29uc29sZS53YXJuKCdFZmZlY3QgbXVzdCByZXR1cm4gYSBmdW5jdGlvbi4nKTtcbiAgICBjb25zdCByZWZyZXNoYWJsZUVmZmVjdCA9IGNyZWF0ZVJlZnJlc2hhYmxlKGVmZmVjdCk7XG4gICAgdGhpcy5lZmZlY3RzLnB1c2gocmVmcmVzaGFibGVFZmZlY3QpO1xuICAgIGlmICh0aGlzLnJlYWR5KSB0aGlzLmVmZmVjdHNDbGVhbnVwc1t0aGlzLmVmZmVjdHMubGVuZ3RoIC0gMV0gPSByZWZyZXNoYWJsZUVmZmVjdCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldmVydCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IHRoaXMud29yZHMubGVuZ3RoID0gdGhpcy5jaGFycy5sZW5ndGggPSAwO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIC8vIE1ha2Ugc3VyZSB0byByZXZlcnQgdGhlIGVmZmVjdHMgYWZ0ZXIgZGlzY29ubmVjdGluZyB0aGUgcmVzaXplT2JzZXJ2ZXIgdG8gYXZvaWQgdHJpZ2dlcmluZyBpdCBpbiB0aGUgcHJvY2Vzc1xuICAgIHRoaXMuZWZmZWN0c0NsZWFudXBzLmZvckVhY2goY2xlYW51cCA9PiBpc0ZuYyhjbGVhbnVwKSA/IGNsZWFudXAodGhpcykgOiBjbGVhbnVwLnJldmVydCAmJiBjbGVhbnVwLnJldmVydCgpKTtcbiAgICB0aGlzLiR0YXJnZXQuaW5uZXJIVE1MID0gdGhpcy5odG1sO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHByb2Nlc3NlcyBhIG5vZGUgYW5kIGl0cyBjaGlsZHJlblxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIHNwbGl0Tm9kZShub2RlKSB7XG4gICAgY29uc3Qgd29yZFRlbXBsYXRlID0gdGhpcy53b3JkVGVtcGxhdGU7XG4gICAgY29uc3QgY2hhclRlbXBsYXRlID0gdGhpcy5jaGFyVGVtcGxhdGU7XG4gICAgY29uc3QgaW5jbHVkZVNwYWNlcyA9IHRoaXMuaW5jbHVkZVNwYWNlcztcbiAgICBjb25zdCBkZWJ1ZyA9IHRoaXMuZGVidWc7XG4gICAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIGlmIChub2RlVHlwZSA9PT0gMykge1xuICAgICAgY29uc3Qgbm9kZVRleHQgPSBub2RlLm5vZGVWYWx1ZTtcbiAgICAgIC8vIElmIHRoZSBub2RlVGV4dCBpcyBvbmx5IHdoaXRlc3BhY2UsIGxlYXZlIGl0IGFzIGlzXG4gICAgICBpZiAobm9kZVRleHQudHJpbSgpKSB7XG4gICAgICAgIGNvbnN0IHRlbXBXb3JkcyA9IFtdO1xuICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMud29yZHM7XG4gICAgICAgIGNvbnN0IGNoYXJzID0gdGhpcy5jaGFycztcbiAgICAgICAgY29uc3Qgd29yZFNlZ21lbnRzID0gd29yZFNlZ21lbnRlci5zZWdtZW50KG5vZGVUZXh0KTtcbiAgICAgICAgY29uc3QgJHdvcmRzRnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgcHJldlNlZyA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgd29yZFNlZ21lbnQgb2Ygd29yZFNlZ21lbnRzKSB7XG4gICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHdvcmRTZWdtZW50LnNlZ21lbnQ7XG4gICAgICAgICAgY29uc3QgaXNXb3JkTGlrZSA9IGlzU2VnbWVudFdvcmRMaWtlKHdvcmRTZWdtZW50KTtcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBzZWdtZW50IHNob3VsZCBiZSBhIG5ldyB3b3JkLCBmaXJzdCBzZWdtZW50IGFsd2F5cyBiZWNvbWVzIGEgbmV3IHdvcmRcbiAgICAgICAgICBpZiAoIXByZXZTZWcgfHwgKGlzV29yZExpa2UgJiYgKHByZXZTZWcgJiYgKGlzU2VnbWVudFdvcmRMaWtlKHByZXZTZWcpKSkpKSB7XG4gICAgICAgICAgICB0ZW1wV29yZHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT25seSBjb25jYXRlbmF0ZSBpZiBib3RoIGN1cnJlbnQgYW5kIHByZXZpb3VzIGFyZSBub24td29yZC1saWtlIGFuZCBkb24ndCBjb250YWluIHNwYWNlc1xuICAgICAgICAgICAgY29uc3QgbGFzdFdvcmRJbmRleCA9IHRlbXBXb3Jkcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgbGFzdFdvcmQgPSB0ZW1wV29yZHNbbGFzdFdvcmRJbmRleF07XG4gICAgICAgICAgICBpZiAoIWxhc3RXb3JkLmluY2x1ZGVzKCcgJykgJiYgIXNlZ21lbnQuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICAgICAgICB0ZW1wV29yZHNbbGFzdFdvcmRJbmRleF0gKz0gc2VnbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRlbXBXb3Jkcy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2U2VnID0gd29yZFNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRlbXBXb3Jkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB3b3JkID0gdGVtcFdvcmRzW2ldO1xuICAgICAgICAgIGlmICghd29yZC50cmltKCkpIHtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHdoaXRlc3BhY2Ugb25seSBpZiBpbmNsdWRlU3BhY2VzIGlzIGZhbHNlIGFuZCBpZiB0aGUgY3VycmVudCBzcGFjZSBpcyBub3QgdGhlIGZpcnN0IG5vZGVcbiAgICAgICAgICAgIGlmIChpICYmIGluY2x1ZGVTcGFjZXMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgJHdvcmRzRnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHdvcmQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV4dFdvcmQgPSB0ZW1wV29yZHNbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgaGFzV29yZEZvbGxvd2luZ1NwYWNlID0gaW5jbHVkZVNwYWNlcyAmJiBuZXh0V29yZCAmJiAhbmV4dFdvcmQudHJpbSgpO1xuICAgICAgICAgICAgY29uc3Qgd29yZFRvUHJvY2VzcyA9IHdvcmQ7XG4gICAgICAgICAgICBjb25zdCBjaGFyU2VnbWVudHMgPSBjaGFyVGVtcGxhdGUgPyBncmFwaGVtZVNlZ21lbnRlci5zZWdtZW50KHdvcmRUb1Byb2Nlc3MpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0ICRjaGFyc0ZyYWdtZW50ID0gY2hhclRlbXBsYXRlID8gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZShoYXNXb3JkRm9sbG93aW5nU3BhY2UgPyB3b3JkICsgJ1xceGEwJyA6IHdvcmQpO1xuICAgICAgICAgICAgaWYgKGNoYXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBjb25zdCBjaGFyU2VnbWVudHNBcnJheSA9IFsuLi5jaGFyU2VnbWVudHNdO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBjaGFyU2VnbWVudHNBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhclNlZ21lbnQgPSBjaGFyU2VnbWVudHNBcnJheVtqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0xhc3RDaGFyID0gaiA9PT0gamwgLSAxO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgY2hhcmFjdGVyIGFuZCBpbmNsdWRlU3BhY2VzIGlzIHRydWUgd2l0aCBhIGZvbGxvd2luZyBzcGFjZSwgYXBwZW5kIHRoZSBzcGFjZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJUZXh0ID0gaXNMYXN0Q2hhciAmJiBoYXNXb3JkRm9sbG93aW5nU3BhY2UgPyBjaGFyU2VnbWVudC5zZWdtZW50ICsgJ1xceGEwJyA6IGNoYXJTZWdtZW50LnNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgJGNoYXJOb2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKGNoYXJUZXh0KTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzSFRNTFRlbXBsYXRlKGNoYXJUZW1wbGF0ZSwgY2hhcnMsICRjaGFyTm9kZSwgLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLygkY2hhcnNGcmFnbWVudCksIGNoYXJUeXBlLCBkZWJ1ZywgLTEsIHdvcmRzLmxlbmd0aCwgY2hhcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdvcmRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBwcm9jZXNzSFRNTFRlbXBsYXRlKHdvcmRUZW1wbGF0ZSwgd29yZHMsICRjaGFyc0ZyYWdtZW50LCAkd29yZHNGcmFnbWVudCwgd29yZFR5cGUsIGRlYnVnLCAtMSwgd29yZHMubGVuZ3RoLCBjaGFycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAvLyBDaGFycyBlbGVtZW50cyBtdXN0IGJlIHJlLXBhcnNlZCBpbiB0aGUgc3BsaXQoKSBtZXRob2QgaWYgYm90aCB3b3JkcyBhbmQgY2hhcnMgYXJlIHBhcnNlZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgJHdvcmRzRnJhZ21lbnQuYXBwZW5kQ2hpbGQoJGNoYXJzRnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHdvcmRzRnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHdvcmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgdGhlIG5leHQgaXRlcmF0aW9uIGlmIHdlIGluY2x1ZGVkIGEgc3BhY2VcbiAgICAgICAgICAgIGlmIChoYXNXb3JkRm9sbG93aW5nU3BhY2UpIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCgkd29yZHNGcmFnbWVudCwgbm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMSkge1xuICAgICAgLy8gQ29udmVydGluZyB0byBhbiBhcnJheSBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgY2hpbGROb2RlcyBwb3R0ZW50aWFsIG11dGF0aW9uXG4gICAgICBjb25zdCBjaGlsZE5vZGVzID0gLyoqIEB0eXBlIHtBcnJheTxOb2RlPn0gKi8oWy4uLi8qKiBAdHlwZSB7Kn0gKi8obm9kZS5jaGlsZE5vZGVzKV0pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykgdGhpcy5zcGxpdE5vZGUoY2hpbGROb2Rlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXJDYWNoZVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc3BsaXQoY2xlYXJDYWNoZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgJGVsID0gdGhpcy4kdGFyZ2V0O1xuICAgIGNvbnN0IGlzQ2FjaGVkID0gISF0aGlzLmNhY2hlICYmICFjbGVhckNhY2hlO1xuICAgIGNvbnN0IGxpbmVUZW1wbGF0ZSA9IHRoaXMubGluZVRlbXBsYXRlO1xuICAgIGNvbnN0IHdvcmRUZW1wbGF0ZSA9IHRoaXMud29yZFRlbXBsYXRlO1xuICAgIGNvbnN0IGNoYXJUZW1wbGF0ZSA9IHRoaXMuY2hhclRlbXBsYXRlO1xuICAgIGNvbnN0IGZvbnRzUmVhZHkgPSBkb2MuZm9udHMuc3RhdHVzICE9PSAnbG9hZGluZyc7XG4gICAgY29uc3QgY2FuU3BsaXRMaW5lcyA9IGxpbmVUZW1wbGF0ZSAmJiBmb250c1JlYWR5O1xuICAgIHRoaXMucmVhZHkgPSAhbGluZVRlbXBsYXRlIHx8IGZvbnRzUmVhZHk7XG4gICAgaWYgKGNhblNwbGl0TGluZXMgfHwgY2xlYXJDYWNoZSkge1xuICAgICAgLy8gTm8gbmVlZCB0byByZXZlcnQgZWZmZWN0cyBhbmltYXRpb25zIGhlcmUgc2luY2UgaXQncyBhbHJlYWR5IHRha2VuIGNhcmUgYnkgdGhlIHJlZnJlc2hhYmxlXG4gICAgICB0aGlzLmVmZmVjdHNDbGVhbnVwcy5mb3JFYWNoKGNsZWFudXAgPT4gaXNGbmMoY2xlYW51cCkgJiYgY2xlYW51cCh0aGlzKSk7XG4gICAgfVxuICAgIGlmICghaXNDYWNoZWQpIHtcbiAgICAgIGlmIChjbGVhckNhY2hlKSB7XG4gICAgICAgICRlbC5pbm5lckhUTUwgPSB0aGlzLmh0bWw7XG4gICAgICAgIHRoaXMud29yZHMubGVuZ3RoID0gdGhpcy5jaGFycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5zcGxpdE5vZGUoJGVsKTtcbiAgICAgIHRoaXMuY2FjaGUgPSAkZWwuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBpZiAoY2FuU3BsaXRMaW5lcykge1xuICAgICAgaWYgKGlzQ2FjaGVkKSAkZWwuaW5uZXJIVE1MID0gdGhpcy5jYWNoZTtcbiAgICAgIHRoaXMubGluZXMubGVuZ3RoID0gMDtcbiAgICAgIGlmICh3b3JkVGVtcGxhdGUpIHRoaXMud29yZHMgPSBnZXRBbGxUb3BMZXZlbEVsZW1lbnRzKCRlbCwgd29yZFR5cGUpO1xuICAgIH1cbiAgICAvLyBBbHdheXMgcmVwYXJzZSBjaGFyYWN0ZXJzIGFmdGVyIGEgbGluZSByZXNldCBvciBpZiBib3RoIHdvcmRzIGFuZCBjaGFycyBhcmUgYWN0aXZhdGVkXG4gICAgaWYgKGNoYXJUZW1wbGF0ZSAmJiAoY2FuU3BsaXRMaW5lcyB8fCB3b3JkVGVtcGxhdGUpKSB7XG4gICAgICB0aGlzLmNoYXJzID0gZ2V0QWxsVG9wTGV2ZWxFbGVtZW50cygkZWwsIGNoYXJUeXBlKTtcbiAgICB9XG4gICAgLy8gV29yZHMgYXJlIHVzZWQgd2hlbiBsaW5lcyBvbmx5IGFuZCBwcmlvcml0aXplZCBvdmVyIGNoYXJzXG4gICAgY29uc3QgZWxlbWVudHNBcnJheSA9IHRoaXMud29yZHMubGVuZ3RoID8gdGhpcy53b3JkcyA6IHRoaXMuY2hhcnM7XG4gICAgbGV0IHksIGxpbmVzQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZWxlbWVudHNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0ICRlbCA9IGVsZW1lbnRzQXJyYXlbaV07XG4gICAgICBjb25zdCB7IHRvcCwgaGVpZ2h0IH0gPSAkZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoeSAmJiB0b3AgLSB5ID4gaGVpZ2h0ICogLjUpIGxpbmVzQ291bnQrKztcbiAgICAgICRlbC5zZXRBdHRyaWJ1dGUoZGF0YUxpbmUsIGAke2xpbmVzQ291bnR9YCk7XG4gICAgICBjb25zdCBuZXN0ZWQgPSAkZWwucXVlcnlTZWxlY3RvckFsbChgWyR7ZGF0YUxpbmV9XWApO1xuICAgICAgbGV0IGMgPSBuZXN0ZWQubGVuZ3RoO1xuICAgICAgd2hpbGUgKGMtLSkgbmVzdGVkW2NdLnNldEF0dHJpYnV0ZShkYXRhTGluZSwgYCR7bGluZXNDb3VudH1gKTtcbiAgICAgIHkgPSB0b3A7XG4gICAgfVxuICAgIGlmIChjYW5TcGxpdExpbmVzKSB7XG4gICAgICBjb25zdCBsaW5lc0ZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBjbG9uZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGxpbmVJbmRleCA9IDA7IGxpbmVJbmRleCA8IGxpbmVzQ291bnQgKyAxOyBsaW5lSW5kZXgrKykge1xuICAgICAgICBjb25zdCAkY2xvbmUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLygkZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgZmlsdGVyTGluZUVsZW1lbnRzKCRjbG9uZSwgbGluZUluZGV4LCBuZXcgU2V0KCkpLmZvckVhY2goJGVsID0+IHtcbiAgICAgICAgICBjb25zdCAkcGFyZW50ID0gJGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgaWYgKCRwYXJlbnQpIHBhcmVudHMuYWRkKCRwYXJlbnQpO1xuICAgICAgICAgICRlbC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsb25lcy5wdXNoKCRjbG9uZSk7XG4gICAgICB9XG4gICAgICBwYXJlbnRzLmZvckVhY2goZmlsdGVyRW1wdHlFbGVtZW50cyk7XG4gICAgICBmb3IgKGxldCBjbG9uZUluZGV4ID0gMCwgY2xvbmVzTGVuZ3RoID0gY2xvbmVzLmxlbmd0aDsgY2xvbmVJbmRleCA8IGNsb25lc0xlbmd0aDsgY2xvbmVJbmRleCsrKSB7XG4gICAgICAgIHByb2Nlc3NIVE1MVGVtcGxhdGUobGluZVRlbXBsYXRlLCB0aGlzLmxpbmVzLCBjbG9uZXNbY2xvbmVJbmRleF0sIGxpbmVzRnJhZ21lbnQsIGxpbmVUeXBlLCB0aGlzLmRlYnVnLCBjbG9uZUluZGV4KTtcbiAgICAgIH1cbiAgICAgICRlbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICRlbC5hcHBlbmRDaGlsZChsaW5lc0ZyYWdtZW50KTtcbiAgICAgIGlmICh3b3JkVGVtcGxhdGUpIHRoaXMud29yZHMgPSBnZXRBbGxUb3BMZXZlbEVsZW1lbnRzKCRlbCwgd29yZFR5cGUpO1xuICAgICAgaWYgKGNoYXJUZW1wbGF0ZSkgdGhpcy5jaGFycyA9IGdldEFsbFRvcExldmVsRWxlbWVudHMoJGVsLCBjaGFyVHlwZSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgd29yZCB3cmFwcGVycyBhbmQgY2xlYXIgdGhlIHdvcmRzIGFycmF5IGlmIGxpbmVzIHNwbGl0IG9ubHlcbiAgICBpZiAodGhpcy5saW5lc09ubHkpIHtcbiAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy53b3JkcztcbiAgICAgIGxldCB3ID0gd29yZHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKHctLSkge1xuICAgICAgICBjb25zdCAkd29yZCA9IHdvcmRzW3ddO1xuICAgICAgICAkd29yZC5yZXBsYWNlV2l0aCgkd29yZC50ZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgICB3b3Jkcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY2Nlc3NpYmxlICYmIChjYW5TcGxpdExpbmVzIHx8ICFpc0NhY2hlZCkpIHtcbiAgICAgIGNvbnN0ICRhY2Nlc3NpYmxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIC8vIE1ha2UgdGhlIGFjY2Vzc2libGUgZWxlbWVudCB2aXN1YWxseS1oaWRkZW4gKGh0dHBzOi8vd3d3LnNjb3R0b2hhcmEubWUvYmxvZy8yMDE3LzA0LzE0L2luY2x1c2l2ZWx5LWhpZGRlbi5odG1sKVxuICAgICAgJGFjY2Vzc2libGUuc3R5bGUuY3NzVGV4dCA9IGBwb3NpdGlvbjphYnNvbHV0ZTtvdmVyZmxvdzpoaWRkZW47Y2xpcDpyZWN0KDAgMCAwIDApO2NsaXAtcGF0aDppbnNldCg1MCUpO3dpZHRoOjFweDtoZWlnaHQ6MXB4O3doaXRlLXNwYWNlOm5vd3JhcDtgO1xuICAgICAgLy8gJGFjY2Vzc2libGUuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgJGFjY2Vzc2libGUuaW5uZXJIVE1MID0gdGhpcy5odG1sO1xuICAgICAgJGVsLmluc2VydEJlZm9yZSgkYWNjZXNzaWJsZSwgJGVsLmZpcnN0Q2hpbGQpO1xuICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKHNldEFyaWFIaWRkZW4pO1xuICAgICAgdGhpcy53b3Jkcy5mb3JFYWNoKHNldEFyaWFIaWRkZW4pO1xuICAgICAgdGhpcy5jaGFycy5mb3JFYWNoKHNldEFyaWFIaWRkZW4pO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oJGVsKS5vZmZzZXRXaWR0aDtcbiAgICBpZiAoY2FuU3BsaXRMaW5lcyB8fCBjbGVhckNhY2hlKSB7XG4gICAgICB0aGlzLmVmZmVjdHMuZm9yRWFjaCgoZWZmZWN0LCBpKSA9PiB0aGlzLmVmZmVjdHNDbGVhbnVwc1tpXSA9IGVmZmVjdCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnNwbGl0KHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR8Tm9kZUxpc3R8U3RyaW5nfEFycmF5PEhUTUxFbGVtZW50Pn0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtUZXh0U3BsaXR0ZXJQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICogQHJldHVybiB7VGV4dFNwbGl0dGVyfVxuICovXG5jb25zdCBzcGxpdCA9ICh0YXJnZXQsIHBhcmFtZXRlcnMpID0+IG5ldyBUZXh0U3BsaXR0ZXIodGFyZ2V0LCBwYXJhbWV0ZXJzKTtcblxuY29uc3QgdGV4dCA9IHtcbiAgc3BsaXQsXG59O1xuXG5cblxuXG4vKipcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtTdGFnZ2VyUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybiB7U3RhZ2dlckZ1bmN0aW9uPE51bWJlcj59XG4gKi9cbi8qKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcGFyYW0ge1N0YWdnZXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb248U3RyaW5nPn1cbiAqL1xuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gdmFsXG4gKiBAcGFyYW0ge1N0YWdnZXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb248TnVtYmVyPn1cbiAqL1xuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7W1N0cmluZywgU3RyaW5nXX0gdmFsXG4gKiBAcGFyYW0ge1N0YWdnZXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb248U3RyaW5nPn1cbiAqL1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8W051bWJlciwgTnVtYmVyXXxbU3RyaW5nLCBTdHJpbmddfSB2YWwgVGhlIHN0YWdnZXJlZCB2YWx1ZSBvciByYW5nZVxuICogQHBhcmFtIHtTdGFnZ2VyUGFyYW1zfSBbcGFyYW1zXSBUaGUgc3RhZ2dlciBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb248TnVtYmVyfFN0cmluZz59XG4gKi9cbmNvbnN0IHN0YWdnZXIgPSAodmFsLCBwYXJhbXMgPSB7fSkgPT4ge1xuICBsZXQgdmFsdWVzID0gW107XG4gIGxldCBtYXhWYWx1ZSA9IDA7XG4gIGNvbnN0IGZyb20gPSBwYXJhbXMuZnJvbTtcbiAgY29uc3QgcmV2ZXJzZWQgPSBwYXJhbXMucmV2ZXJzZWQ7XG4gIGNvbnN0IGVhc2UgPSBwYXJhbXMuZWFzZTtcbiAgY29uc3QgaGFzRWFzaW5nID0gIWlzVW5kKGVhc2UpO1xuICBjb25zdCBoYXNTcHJpbmcgPSBoYXNFYXNpbmcgJiYgIWlzVW5kKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgY29uc3Qgc3RhZ2dlckVhc2UgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSA6IGhhc0Vhc2luZyA/IHBhcnNlRWFzaW5ncyhlYXNlKSA6IG51bGw7XG4gIGNvbnN0IGdyaWQgPSBwYXJhbXMuZ3JpZDtcbiAgY29uc3QgYXhpcyA9IHBhcmFtcy5heGlzO1xuICBjb25zdCBjdXN0b21Ub3RhbCA9IHBhcmFtcy50b3RhbDtcbiAgY29uc3QgZnJvbUZpcnN0ID0gaXNVbmQoZnJvbSkgfHwgZnJvbSA9PT0gMCB8fCBmcm9tID09PSAnZmlyc3QnO1xuICBjb25zdCBmcm9tQ2VudGVyID0gZnJvbSA9PT0gJ2NlbnRlcic7XG4gIGNvbnN0IGZyb21MYXN0ID0gZnJvbSA9PT0gJ2xhc3QnO1xuICBjb25zdCBmcm9tUmFuZG9tID0gZnJvbSA9PT0gJ3JhbmRvbSc7XG4gIGNvbnN0IGlzUmFuZ2UgPSBpc0Fycih2YWwpO1xuICBjb25zdCB1c2VQcm9wID0gcGFyYW1zLnVzZTtcbiAgY29uc3QgdmFsMSA9IGlzUmFuZ2UgPyBwYXJzZU51bWJlcih2YWxbMF0pIDogcGFyc2VOdW1iZXIodmFsKTtcbiAgY29uc3QgdmFsMiA9IGlzUmFuZ2UgPyBwYXJzZU51bWJlcih2YWxbMV0pIDogMDtcbiAgY29uc3QgdW5pdE1hdGNoID0gdW5pdHNFeGVjUmd4LmV4ZWMoKGlzUmFuZ2UgPyB2YWxbMV0gOiB2YWwpICsgZW1wdHlTdHJpbmcpO1xuICBjb25zdCBzdGFydCA9IHBhcmFtcy5zdGFydCB8fCAwICsgKGlzUmFuZ2UgPyB2YWwxIDogMCk7XG4gIGxldCBmcm9tSW5kZXggPSBmcm9tRmlyc3QgPyAwIDogaXNOdW0oZnJvbSkgPyBmcm9tIDogMDtcbiAgcmV0dXJuICh0YXJnZXQsIGksIHQsIHRsKSA9PiB7XG4gICAgY29uc3QgWyByZWdpc3RlcmVkVGFyZ2V0IF0gPSByZWdpc3RlclRhcmdldHModGFyZ2V0KTtcbiAgICBjb25zdCB0b3RhbCA9IGlzVW5kKGN1c3RvbVRvdGFsKSA/IHQgOiBjdXN0b21Ub3RhbDtcbiAgICBjb25zdCBjdXN0b21JbmRleCA9ICFpc1VuZCh1c2VQcm9wKSA/IGlzRm5jKHVzZVByb3ApID8gdXNlUHJvcChyZWdpc3RlcmVkVGFyZ2V0LCBpLCB0b3RhbCkgOiBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZShyZWdpc3RlcmVkVGFyZ2V0LCB1c2VQcm9wKSA6IGZhbHNlO1xuICAgIGNvbnN0IHN0YWdnZXJJbmRleCA9IGlzTnVtKGN1c3RvbUluZGV4KSB8fCBpc1N0cihjdXN0b21JbmRleCkgJiYgaXNOdW0oK2N1c3RvbUluZGV4KSA/ICtjdXN0b21JbmRleCA6IGk7XG4gICAgaWYgKGZyb21DZW50ZXIpIGZyb21JbmRleCA9ICh0b3RhbCAtIDEpIC8gMjtcbiAgICBpZiAoZnJvbUxhc3QpIGZyb21JbmRleCA9IHRvdGFsIC0gMTtcbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0b3RhbDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoIWdyaWQpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChhYnMoZnJvbUluZGV4IC0gaW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmcm9tWCA9ICFmcm9tQ2VudGVyID8gZnJvbUluZGV4ICUgZ3JpZFswXSA6IChncmlkWzBdIC0gMSkgLyAyO1xuICAgICAgICAgIGNvbnN0IGZyb21ZID0gIWZyb21DZW50ZXIgPyBmbG9vcihmcm9tSW5kZXggLyBncmlkWzBdKSA6IChncmlkWzFdIC0gMSkgLyAyO1xuICAgICAgICAgIGNvbnN0IHRvWCA9IGluZGV4ICUgZ3JpZFswXTtcbiAgICAgICAgICBjb25zdCB0b1kgPSBmbG9vcihpbmRleCAvIGdyaWRbMF0pO1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlWSA9IGZyb21ZIC0gdG9ZO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB2YWx1ZSA9IC1kaXN0YW5jZVg7XG4gICAgICAgICAgaWYgKGF4aXMgPT09ICd5JykgdmFsdWUgPSAtZGlzdGFuY2VZO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhWYWx1ZSA9IG1heCguLi52YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWdnZXJFYXNlKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHZhbCA9PiBzdGFnZ2VyRWFzZSh2YWwgLyBtYXhWYWx1ZSkgKiBtYXhWYWx1ZSk7XG4gICAgICBpZiAocmV2ZXJzZWQpIHZhbHVlcyA9IHZhbHVlcy5tYXAodmFsID0+IGF4aXMgPyAodmFsIDwgMCkgPyB2YWwgKiAtMSA6IC12YWwgOiBhYnMobWF4VmFsdWUgLSB2YWwpKTtcbiAgICAgIGlmIChmcm9tUmFuZG9tKSB2YWx1ZXMgPSBzaHVmZmxlKHZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnN0IHNwYWNpbmcgPSBpc1JhbmdlID8gKHZhbDIgLSB2YWwxKSAvIG1heFZhbHVlIDogdmFsMTtcbiAgICBjb25zdCBvZmZzZXQgPSB0bCA/IHBhcnNlVGltZWxpbmVQb3NpdGlvbih0bCwgaXNVbmQocGFyYW1zLnN0YXJ0KSA/IHRsLml0ZXJhdGlvbkR1cmF0aW9uIDogc3RhcnQpIDogLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHN0YXJ0KTtcbiAgICAvKiogQHR5cGUge1N0cmluZ3xOdW1iZXJ9ICovXG4gICAgbGV0IG91dHB1dCA9IG9mZnNldCArICgoc3BhY2luZyAqIHJvdW5kKHZhbHVlc1tzdGFnZ2VySW5kZXhdLCAyKSkgfHwgMCk7XG4gICAgaWYgKHBhcmFtcy5tb2RpZmllcikgb3V0cHV0ID0gcGFyYW1zLm1vZGlmaWVyKG91dHB1dCk7XG4gICAgaWYgKHVuaXRNYXRjaCkgb3V0cHV0ID0gYCR7b3V0cHV0fSR7dW5pdE1hdGNoWzJdfWA7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuZXhwb3J0IHsgQW5pbWF0YWJsZSwgRHJhZ2dhYmxlLCBKU0FuaW1hdGlvbiwgU2NvcGUsIFNjcm9sbE9ic2VydmVyLCBTcHJpbmcsIFRleHRTcGxpdHRlciwgVGltZWxpbmUsIFRpbWVyLCBXQUFQSUFuaW1hdGlvbiwgYW5pbWF0ZSwgY3JlYXRlQW5pbWF0YWJsZSwgY3JlYXRlRHJhZ2dhYmxlLCBjcmVhdGVTY29wZSwgY3JlYXRlU3ByaW5nLCBjcmVhdGVUaW1lbGluZSwgY3JlYXRlVGltZXIsIGVhc2VzLCBlbmdpbmUsIG9uU2Nyb2xsLCBzY3JvbGxDb250YWluZXJzLCBzdGFnZ2VyLCBzdmcsIHRleHQsIHV0aWxzLCB3YWFwaSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/animejs@4.1.4/node_modules/animejs/lib/anime.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ccount: () => (/* binding */ ccount)\n/* harmony export */ });\n/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nfunction ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jY291bnRAMi4wLjEvbm9kZV9tb2R1bGVzL2Njb3VudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vY2NvdW50QDIuMC4xL25vZGVfbW9kdWxlcy9jY291bnQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3VudCBob3cgb2Z0ZW4gYSBjaGFyYWN0ZXIgKG9yIHN1YnN0cmluZykgaXMgdXNlZCBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgVmFsdWUgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxuICogICBDaGFyYWN0ZXIgKG9yIHN1YnN0cmluZykgdG8gbG9vayBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgIE51bWJlciBvZiB0aW1lcyBgY2hhcmFjdGVyYCBvY2N1cnJlZCBpbiBgdmFsdWVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2NvdW50KHZhbHVlLCBjaGFyYWN0ZXIpIHtcbiAgY29uc3Qgc291cmNlID0gU3RyaW5nKHZhbHVlKVxuXG4gIGlmICh0eXBlb2YgY2hhcmFjdGVyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGNoYXJhY3RlcicpXG4gIH1cblxuICBsZXQgY291bnQgPSAwXG4gIGxldCBpbmRleCA9IHNvdXJjZS5pbmRleE9mKGNoYXJhY3RlcilcblxuICB3aGlsZSAoaW5kZXggIT09IC0xKSB7XG4gICAgY291bnQrK1xuICAgIGluZGV4ID0gc291cmNlLmluZGV4T2YoY2hhcmFjdGVyLCBpbmRleCArIGNoYXJhY3Rlci5sZW5ndGgpXG4gIH1cblxuICByZXR1cm4gY291bnRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/character-entities-html4@2.1.0/node_modules/character-entities-html4/index.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/character-entities-html4@2.1.0/node_modules/character-entities-html4/index.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   characterEntitiesHtml4: () => (/* binding */ characterEntitiesHtml4)\n/* harmony export */ });\n/**\n * Map of named character references from HTML 4.\n *\n * @type {Record<string, string>}\n */\nconst characterEntitiesHtml4 = {\n  nbsp: '',\n  iexcl: '',\n  cent: '',\n  pound: '',\n  curren: '',\n  yen: '',\n  brvbar: '',\n  sect: '',\n  uml: '',\n  copy: '',\n  ordf: '',\n  laquo: '',\n  not: '',\n  shy: '',\n  reg: '',\n  macr: '',\n  deg: '',\n  plusmn: '',\n  sup2: '',\n  sup3: '',\n  acute: '',\n  micro: '',\n  para: '',\n  middot: '',\n  cedil: '',\n  sup1: '',\n  ordm: '',\n  raquo: '',\n  frac14: '',\n  frac12: '',\n  frac34: '',\n  iquest: '',\n  Agrave: '',\n  Aacute: '',\n  Acirc: '',\n  Atilde: '',\n  Auml: '',\n  Aring: '',\n  AElig: '',\n  Ccedil: '',\n  Egrave: '',\n  Eacute: '',\n  Ecirc: '',\n  Euml: '',\n  Igrave: '',\n  Iacute: '',\n  Icirc: '',\n  Iuml: '',\n  ETH: '',\n  Ntilde: '',\n  Ograve: '',\n  Oacute: '',\n  Ocirc: '',\n  Otilde: '',\n  Ouml: '',\n  times: '',\n  Oslash: '',\n  Ugrave: '',\n  Uacute: '',\n  Ucirc: '',\n  Uuml: '',\n  Yacute: '',\n  THORN: '',\n  szlig: '',\n  agrave: '',\n  aacute: '',\n  acirc: '',\n  atilde: '',\n  auml: '',\n  aring: '',\n  aelig: '',\n  ccedil: '',\n  egrave: '',\n  eacute: '',\n  ecirc: '',\n  euml: '',\n  igrave: '',\n  iacute: '',\n  icirc: '',\n  iuml: '',\n  eth: '',\n  ntilde: '',\n  ograve: '',\n  oacute: '',\n  ocirc: '',\n  otilde: '',\n  ouml: '',\n  divide: '',\n  oslash: '',\n  ugrave: '',\n  uacute: '',\n  ucirc: '',\n  uuml: '',\n  yacute: '',\n  thorn: '',\n  yuml: '',\n  fnof: '',\n  Alpha: '',\n  Beta: '',\n  Gamma: '',\n  Delta: '',\n  Epsilon: '',\n  Zeta: '',\n  Eta: '',\n  Theta: '',\n  Iota: '',\n  Kappa: '',\n  Lambda: '',\n  Mu: '',\n  Nu: '',\n  Xi: '',\n  Omicron: '',\n  Pi: '',\n  Rho: '',\n  Sigma: '',\n  Tau: '',\n  Upsilon: '',\n  Phi: '',\n  Chi: '',\n  Psi: '',\n  Omega: '',\n  alpha: '',\n  beta: '',\n  gamma: '',\n  delta: '',\n  epsilon: '',\n  zeta: '',\n  eta: '',\n  theta: '',\n  iota: '',\n  kappa: '',\n  lambda: '',\n  mu: '',\n  nu: '',\n  xi: '',\n  omicron: '',\n  pi: '',\n  rho: '',\n  sigmaf: '',\n  sigma: '',\n  tau: '',\n  upsilon: '',\n  phi: '',\n  chi: '',\n  psi: '',\n  omega: '',\n  thetasym: '',\n  upsih: '',\n  piv: '',\n  bull: '',\n  hellip: '',\n  prime: '',\n  Prime: '',\n  oline: '',\n  frasl: '',\n  weierp: '',\n  image: '',\n  real: '',\n  trade: '',\n  alefsym: '',\n  larr: '',\n  uarr: '',\n  rarr: '',\n  darr: '',\n  harr: '',\n  crarr: '',\n  lArr: '',\n  uArr: '',\n  rArr: '',\n  dArr: '',\n  hArr: '',\n  forall: '',\n  part: '',\n  exist: '',\n  empty: '',\n  nabla: '',\n  isin: '',\n  notin: '',\n  ni: '',\n  prod: '',\n  sum: '',\n  minus: '',\n  lowast: '',\n  radic: '',\n  prop: '',\n  infin: '',\n  ang: '',\n  and: '',\n  or: '',\n  cap: '',\n  cup: '',\n  int: '',\n  there4: '',\n  sim: '',\n  cong: '',\n  asymp: '',\n  ne: '',\n  equiv: '',\n  le: '',\n  ge: '',\n  sub: '',\n  sup: '',\n  nsub: '',\n  sube: '',\n  supe: '',\n  oplus: '',\n  otimes: '',\n  perp: '',\n  sdot: '',\n  lceil: '',\n  rceil: '',\n  lfloor: '',\n  rfloor: '',\n  lang: '',\n  rang: '',\n  loz: '',\n  spades: '',\n  clubs: '',\n  hearts: '',\n  diams: '',\n  quot: '\"',\n  amp: '&',\n  lt: '<',\n  gt: '>',\n  OElig: '',\n  oelig: '',\n  Scaron: '',\n  scaron: '',\n  Yuml: '',\n  circ: '',\n  tilde: '',\n  ensp: '',\n  emsp: '',\n  thinsp: '',\n  zwnj: '',\n  zwj: '',\n  lrm: '',\n  rlm: '',\n  ndash: '',\n  mdash: '',\n  lsquo: '',\n  rsquo: '',\n  sbquo: '',\n  ldquo: '',\n  rdquo: '',\n  bdquo: '',\n  dagger: '',\n  Dagger: '',\n  permil: '',\n  lsaquo: '',\n  rsaquo: '',\n  euro: ''\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFyYWN0ZXItZW50aXRpZXMtaHRtbDRAMi4xLjAvbm9kZV9tb2R1bGVzL2NoYXJhY3Rlci1lbnRpdGllcy1odG1sNC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFyYWN0ZXItZW50aXRpZXMtaHRtbDRAMi4xLjAvbm9kZV9tb2R1bGVzL2NoYXJhY3Rlci1lbnRpdGllcy1odG1sNC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1hcCBvZiBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBmcm9tIEhUTUwgNC5cbiAqXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYXJhY3RlckVudGl0aWVzSHRtbDQgPSB7XG4gIG5ic3A6ICfCoCcsXG4gIGlleGNsOiAnwqEnLFxuICBjZW50OiAnwqInLFxuICBwb3VuZDogJ8KjJyxcbiAgY3VycmVuOiAnwqQnLFxuICB5ZW46ICfCpScsXG4gIGJydmJhcjogJ8KmJyxcbiAgc2VjdDogJ8KnJyxcbiAgdW1sOiAnwqgnLFxuICBjb3B5OiAnwqknLFxuICBvcmRmOiAnwqonLFxuICBsYXF1bzogJ8KrJyxcbiAgbm90OiAnwqwnLFxuICBzaHk6ICfCrScsXG4gIHJlZzogJ8KuJyxcbiAgbWFjcjogJ8KvJyxcbiAgZGVnOiAnwrAnLFxuICBwbHVzbW46ICfCsScsXG4gIHN1cDI6ICfCsicsXG4gIHN1cDM6ICfCsycsXG4gIGFjdXRlOiAnwrQnLFxuICBtaWNybzogJ8K1JyxcbiAgcGFyYTogJ8K2JyxcbiAgbWlkZG90OiAnwrcnLFxuICBjZWRpbDogJ8K4JyxcbiAgc3VwMTogJ8K5JyxcbiAgb3JkbTogJ8K6JyxcbiAgcmFxdW86ICfCuycsXG4gIGZyYWMxNDogJ8K8JyxcbiAgZnJhYzEyOiAnwr0nLFxuICBmcmFjMzQ6ICfCvicsXG4gIGlxdWVzdDogJ8K/JyxcbiAgQWdyYXZlOiAnw4AnLFxuICBBYWN1dGU6ICfDgScsXG4gIEFjaXJjOiAnw4InLFxuICBBdGlsZGU6ICfDgycsXG4gIEF1bWw6ICfDhCcsXG4gIEFyaW5nOiAnw4UnLFxuICBBRWxpZzogJ8OGJyxcbiAgQ2NlZGlsOiAnw4cnLFxuICBFZ3JhdmU6ICfDiCcsXG4gIEVhY3V0ZTogJ8OJJyxcbiAgRWNpcmM6ICfDiicsXG4gIEV1bWw6ICfDiycsXG4gIElncmF2ZTogJ8OMJyxcbiAgSWFjdXRlOiAnw40nLFxuICBJY2lyYzogJ8OOJyxcbiAgSXVtbDogJ8OPJyxcbiAgRVRIOiAnw5AnLFxuICBOdGlsZGU6ICfDkScsXG4gIE9ncmF2ZTogJ8OSJyxcbiAgT2FjdXRlOiAnw5MnLFxuICBPY2lyYzogJ8OUJyxcbiAgT3RpbGRlOiAnw5UnLFxuICBPdW1sOiAnw5YnLFxuICB0aW1lczogJ8OXJyxcbiAgT3NsYXNoOiAnw5gnLFxuICBVZ3JhdmU6ICfDmScsXG4gIFVhY3V0ZTogJ8OaJyxcbiAgVWNpcmM6ICfDmycsXG4gIFV1bWw6ICfDnCcsXG4gIFlhY3V0ZTogJ8OdJyxcbiAgVEhPUk46ICfDnicsXG4gIHN6bGlnOiAnw58nLFxuICBhZ3JhdmU6ICfDoCcsXG4gIGFhY3V0ZTogJ8OhJyxcbiAgYWNpcmM6ICfDoicsXG4gIGF0aWxkZTogJ8OjJyxcbiAgYXVtbDogJ8OkJyxcbiAgYXJpbmc6ICfDpScsXG4gIGFlbGlnOiAnw6YnLFxuICBjY2VkaWw6ICfDpycsXG4gIGVncmF2ZTogJ8OoJyxcbiAgZWFjdXRlOiAnw6knLFxuICBlY2lyYzogJ8OqJyxcbiAgZXVtbDogJ8OrJyxcbiAgaWdyYXZlOiAnw6wnLFxuICBpYWN1dGU6ICfDrScsXG4gIGljaXJjOiAnw64nLFxuICBpdW1sOiAnw68nLFxuICBldGg6ICfDsCcsXG4gIG50aWxkZTogJ8OxJyxcbiAgb2dyYXZlOiAnw7InLFxuICBvYWN1dGU6ICfDsycsXG4gIG9jaXJjOiAnw7QnLFxuICBvdGlsZGU6ICfDtScsXG4gIG91bWw6ICfDticsXG4gIGRpdmlkZTogJ8O3JyxcbiAgb3NsYXNoOiAnw7gnLFxuICB1Z3JhdmU6ICfDuScsXG4gIHVhY3V0ZTogJ8O6JyxcbiAgdWNpcmM6ICfDuycsXG4gIHV1bWw6ICfDvCcsXG4gIHlhY3V0ZTogJ8O9JyxcbiAgdGhvcm46ICfDvicsXG4gIHl1bWw6ICfDvycsXG4gIGZub2Y6ICfGkicsXG4gIEFscGhhOiAnzpEnLFxuICBCZXRhOiAnzpInLFxuICBHYW1tYTogJ86TJyxcbiAgRGVsdGE6ICfOlCcsXG4gIEVwc2lsb246ICfOlScsXG4gIFpldGE6ICfOlicsXG4gIEV0YTogJ86XJyxcbiAgVGhldGE6ICfOmCcsXG4gIElvdGE6ICfOmScsXG4gIEthcHBhOiAnzponLFxuICBMYW1iZGE6ICfOmycsXG4gIE11OiAnzpwnLFxuICBOdTogJ86dJyxcbiAgWGk6ICfOnicsXG4gIE9taWNyb246ICfOnycsXG4gIFBpOiAnzqAnLFxuICBSaG86ICfOoScsXG4gIFNpZ21hOiAnzqMnLFxuICBUYXU6ICfOpCcsXG4gIFVwc2lsb246ICfOpScsXG4gIFBoaTogJ86mJyxcbiAgQ2hpOiAnzqcnLFxuICBQc2k6ICfOqCcsXG4gIE9tZWdhOiAnzqknLFxuICBhbHBoYTogJ86xJyxcbiAgYmV0YTogJ86yJyxcbiAgZ2FtbWE6ICfOsycsXG4gIGRlbHRhOiAnzrQnLFxuICBlcHNpbG9uOiAnzrUnLFxuICB6ZXRhOiAnzrYnLFxuICBldGE6ICfOtycsXG4gIHRoZXRhOiAnzrgnLFxuICBpb3RhOiAnzrknLFxuICBrYXBwYTogJ866JyxcbiAgbGFtYmRhOiAnzrsnLFxuICBtdTogJ868JyxcbiAgbnU6ICfOvScsXG4gIHhpOiAnzr4nLFxuICBvbWljcm9uOiAnzr8nLFxuICBwaTogJ8+AJyxcbiAgcmhvOiAnz4EnLFxuICBzaWdtYWY6ICfPgicsXG4gIHNpZ21hOiAnz4MnLFxuICB0YXU6ICfPhCcsXG4gIHVwc2lsb246ICfPhScsXG4gIHBoaTogJ8+GJyxcbiAgY2hpOiAnz4cnLFxuICBwc2k6ICfPiCcsXG4gIG9tZWdhOiAnz4knLFxuICB0aGV0YXN5bTogJ8+RJyxcbiAgdXBzaWg6ICfPkicsXG4gIHBpdjogJ8+WJyxcbiAgYnVsbDogJ+KAoicsXG4gIGhlbGxpcDogJ+KApicsXG4gIHByaW1lOiAn4oCyJyxcbiAgUHJpbWU6ICfigLMnLFxuICBvbGluZTogJ+KAvicsXG4gIGZyYXNsOiAn4oGEJyxcbiAgd2VpZXJwOiAn4oSYJyxcbiAgaW1hZ2U6ICfihJEnLFxuICByZWFsOiAn4oScJyxcbiAgdHJhZGU6ICfihKInLFxuICBhbGVmc3ltOiAn4oS1JyxcbiAgbGFycjogJ+KGkCcsXG4gIHVhcnI6ICfihpEnLFxuICByYXJyOiAn4oaSJyxcbiAgZGFycjogJ+KGkycsXG4gIGhhcnI6ICfihpQnLFxuICBjcmFycjogJ+KGtScsXG4gIGxBcnI6ICfih5AnLFxuICB1QXJyOiAn4oeRJyxcbiAgckFycjogJ+KHkicsXG4gIGRBcnI6ICfih5MnLFxuICBoQXJyOiAn4oeUJyxcbiAgZm9yYWxsOiAn4oiAJyxcbiAgcGFydDogJ+KIgicsXG4gIGV4aXN0OiAn4oiDJyxcbiAgZW1wdHk6ICfiiIUnLFxuICBuYWJsYTogJ+KIhycsXG4gIGlzaW46ICfiiIgnLFxuICBub3RpbjogJ+KIiScsXG4gIG5pOiAn4oiLJyxcbiAgcHJvZDogJ+KIjycsXG4gIHN1bTogJ+KIkScsXG4gIG1pbnVzOiAn4oiSJyxcbiAgbG93YXN0OiAn4oiXJyxcbiAgcmFkaWM6ICfiiJonLFxuICBwcm9wOiAn4oidJyxcbiAgaW5maW46ICfiiJ4nLFxuICBhbmc6ICfiiKAnLFxuICBhbmQ6ICfiiKcnLFxuICBvcjogJ+KIqCcsXG4gIGNhcDogJ+KIqScsXG4gIGN1cDogJ+KIqicsXG4gIGludDogJ+KIqycsXG4gIHRoZXJlNDogJ+KItCcsXG4gIHNpbTogJ+KIvCcsXG4gIGNvbmc6ICfiiYUnLFxuICBhc3ltcDogJ+KJiCcsXG4gIG5lOiAn4omgJyxcbiAgZXF1aXY6ICfiiaEnLFxuICBsZTogJ+KJpCcsXG4gIGdlOiAn4omlJyxcbiAgc3ViOiAn4oqCJyxcbiAgc3VwOiAn4oqDJyxcbiAgbnN1YjogJ+KKhCcsXG4gIHN1YmU6ICfiioYnLFxuICBzdXBlOiAn4oqHJyxcbiAgb3BsdXM6ICfiipUnLFxuICBvdGltZXM6ICfiipcnLFxuICBwZXJwOiAn4oqlJyxcbiAgc2RvdDogJ+KLhScsXG4gIGxjZWlsOiAn4oyIJyxcbiAgcmNlaWw6ICfijIknLFxuICBsZmxvb3I6ICfijIonLFxuICByZmxvb3I6ICfijIsnLFxuICBsYW5nOiAn4oypJyxcbiAgcmFuZzogJ+KMqicsXG4gIGxvejogJ+KXiicsXG4gIHNwYWRlczogJ+KZoCcsXG4gIGNsdWJzOiAn4pmjJyxcbiAgaGVhcnRzOiAn4pmlJyxcbiAgZGlhbXM6ICfimaYnLFxuICBxdW90OiAnXCInLFxuICBhbXA6ICcmJyxcbiAgbHQ6ICc8JyxcbiAgZ3Q6ICc+JyxcbiAgT0VsaWc6ICfFkicsXG4gIG9lbGlnOiAnxZMnLFxuICBTY2Fyb246ICfFoCcsXG4gIHNjYXJvbjogJ8WhJyxcbiAgWXVtbDogJ8W4JyxcbiAgY2lyYzogJ8uGJyxcbiAgdGlsZGU6ICfLnCcsXG4gIGVuc3A6ICfigIInLFxuICBlbXNwOiAn4oCDJyxcbiAgdGhpbnNwOiAn4oCJJyxcbiAgenduajogJ+KAjCcsXG4gIHp3ajogJ+KAjScsXG4gIGxybTogJ+KAjicsXG4gIHJsbTogJ+KAjycsXG4gIG5kYXNoOiAn4oCTJyxcbiAgbWRhc2g6ICfigJQnLFxuICBsc3F1bzogJ+KAmCcsXG4gIHJzcXVvOiAn4oCZJyxcbiAgc2JxdW86ICfigJonLFxuICBsZHF1bzogJ+KAnCcsXG4gIHJkcXVvOiAn4oCdJyxcbiAgYmRxdW86ICfigJ4nLFxuICBkYWdnZXI6ICfigKAnLFxuICBEYWdnZXI6ICfigKEnLFxuICBwZXJtaWw6ICfigLAnLFxuICBsc2FxdW86ICfigLknLFxuICByc2FxdW86ICfigLonLFxuICBldXJvOiAn4oKsJ1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/character-entities-html4@2.1.0/node_modules/character-entities-html4/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   characterEntitiesLegacy: () => (/* binding */ characterEntitiesLegacy)\n/* harmony export */ });\n/**\n * List of legacy HTML named character references that dont need a trailing semicolon.\n *\n * @type {Array<string>}\n */\nconst characterEntitiesLegacy = [\n  'AElig',\n  'AMP',\n  'Aacute',\n  'Acirc',\n  'Agrave',\n  'Aring',\n  'Atilde',\n  'Auml',\n  'COPY',\n  'Ccedil',\n  'ETH',\n  'Eacute',\n  'Ecirc',\n  'Egrave',\n  'Euml',\n  'GT',\n  'Iacute',\n  'Icirc',\n  'Igrave',\n  'Iuml',\n  'LT',\n  'Ntilde',\n  'Oacute',\n  'Ocirc',\n  'Ograve',\n  'Oslash',\n  'Otilde',\n  'Ouml',\n  'QUOT',\n  'REG',\n  'THORN',\n  'Uacute',\n  'Ucirc',\n  'Ugrave',\n  'Uuml',\n  'Yacute',\n  'aacute',\n  'acirc',\n  'acute',\n  'aelig',\n  'agrave',\n  'amp',\n  'aring',\n  'atilde',\n  'auml',\n  'brvbar',\n  'ccedil',\n  'cedil',\n  'cent',\n  'copy',\n  'curren',\n  'deg',\n  'divide',\n  'eacute',\n  'ecirc',\n  'egrave',\n  'eth',\n  'euml',\n  'frac12',\n  'frac14',\n  'frac34',\n  'gt',\n  'iacute',\n  'icirc',\n  'iexcl',\n  'igrave',\n  'iquest',\n  'iuml',\n  'laquo',\n  'lt',\n  'macr',\n  'micro',\n  'middot',\n  'nbsp',\n  'not',\n  'ntilde',\n  'oacute',\n  'ocirc',\n  'ograve',\n  'ordf',\n  'ordm',\n  'oslash',\n  'otilde',\n  'ouml',\n  'para',\n  'plusmn',\n  'pound',\n  'quot',\n  'raquo',\n  'reg',\n  'sect',\n  'shy',\n  'sup1',\n  'sup2',\n  'sup3',\n  'szlig',\n  'thorn',\n  'times',\n  'uacute',\n  'ucirc',\n  'ugrave',\n  'uml',\n  'uuml',\n  'yacute',\n  'yen',\n  'yuml'\n]\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jaGFyYWN0ZXItZW50aXRpZXMtbGVnYWN5QDMuMC4wL25vZGVfbW9kdWxlcy9jaGFyYWN0ZXItZW50aXRpZXMtbGVnYWN5L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vY2hhcmFjdGVyLWVudGl0aWVzLWxlZ2FjeUAzLjAuMC9ub2RlX21vZHVsZXMvY2hhcmFjdGVyLWVudGl0aWVzLWxlZ2FjeS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpc3Qgb2YgbGVnYWN5IEhUTUwgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMgdGhhdCBkb27igJl0IG5lZWQgYSB0cmFpbGluZyBzZW1pY29sb24uXG4gKlxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKi9cbmV4cG9ydCBjb25zdCBjaGFyYWN0ZXJFbnRpdGllc0xlZ2FjeSA9IFtcbiAgJ0FFbGlnJyxcbiAgJ0FNUCcsXG4gICdBYWN1dGUnLFxuICAnQWNpcmMnLFxuICAnQWdyYXZlJyxcbiAgJ0FyaW5nJyxcbiAgJ0F0aWxkZScsXG4gICdBdW1sJyxcbiAgJ0NPUFknLFxuICAnQ2NlZGlsJyxcbiAgJ0VUSCcsXG4gICdFYWN1dGUnLFxuICAnRWNpcmMnLFxuICAnRWdyYXZlJyxcbiAgJ0V1bWwnLFxuICAnR1QnLFxuICAnSWFjdXRlJyxcbiAgJ0ljaXJjJyxcbiAgJ0lncmF2ZScsXG4gICdJdW1sJyxcbiAgJ0xUJyxcbiAgJ050aWxkZScsXG4gICdPYWN1dGUnLFxuICAnT2NpcmMnLFxuICAnT2dyYXZlJyxcbiAgJ09zbGFzaCcsXG4gICdPdGlsZGUnLFxuICAnT3VtbCcsXG4gICdRVU9UJyxcbiAgJ1JFRycsXG4gICdUSE9STicsXG4gICdVYWN1dGUnLFxuICAnVWNpcmMnLFxuICAnVWdyYXZlJyxcbiAgJ1V1bWwnLFxuICAnWWFjdXRlJyxcbiAgJ2FhY3V0ZScsXG4gICdhY2lyYycsXG4gICdhY3V0ZScsXG4gICdhZWxpZycsXG4gICdhZ3JhdmUnLFxuICAnYW1wJyxcbiAgJ2FyaW5nJyxcbiAgJ2F0aWxkZScsXG4gICdhdW1sJyxcbiAgJ2JydmJhcicsXG4gICdjY2VkaWwnLFxuICAnY2VkaWwnLFxuICAnY2VudCcsXG4gICdjb3B5JyxcbiAgJ2N1cnJlbicsXG4gICdkZWcnLFxuICAnZGl2aWRlJyxcbiAgJ2VhY3V0ZScsXG4gICdlY2lyYycsXG4gICdlZ3JhdmUnLFxuICAnZXRoJyxcbiAgJ2V1bWwnLFxuICAnZnJhYzEyJyxcbiAgJ2ZyYWMxNCcsXG4gICdmcmFjMzQnLFxuICAnZ3QnLFxuICAnaWFjdXRlJyxcbiAgJ2ljaXJjJyxcbiAgJ2lleGNsJyxcbiAgJ2lncmF2ZScsXG4gICdpcXVlc3QnLFxuICAnaXVtbCcsXG4gICdsYXF1bycsXG4gICdsdCcsXG4gICdtYWNyJyxcbiAgJ21pY3JvJyxcbiAgJ21pZGRvdCcsXG4gICduYnNwJyxcbiAgJ25vdCcsXG4gICdudGlsZGUnLFxuICAnb2FjdXRlJyxcbiAgJ29jaXJjJyxcbiAgJ29ncmF2ZScsXG4gICdvcmRmJyxcbiAgJ29yZG0nLFxuICAnb3NsYXNoJyxcbiAgJ290aWxkZScsXG4gICdvdW1sJyxcbiAgJ3BhcmEnLFxuICAncGx1c21uJyxcbiAgJ3BvdW5kJyxcbiAgJ3F1b3QnLFxuICAncmFxdW8nLFxuICAncmVnJyxcbiAgJ3NlY3QnLFxuICAnc2h5JyxcbiAgJ3N1cDEnLFxuICAnc3VwMicsXG4gICdzdXAzJyxcbiAgJ3N6bGlnJyxcbiAgJ3Rob3JuJyxcbiAgJ3RpbWVzJyxcbiAgJ3VhY3V0ZScsXG4gICd1Y2lyYycsXG4gICd1Z3JhdmUnLFxuICAndW1sJyxcbiAgJ3V1bWwnLFxuICAneWFjdXRlJyxcbiAgJ3llbicsXG4gICd5dW1sJ1xuXVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/**\n * @typedef Options\n *   Configuration for `stringify`.\n * @property {boolean} [padLeft=true]\n *   Whether to pad a space before a token.\n * @property {boolean} [padRight=false]\n *   Whether to pad a space after a token.\n */\n\n/**\n * @typedef {Options} StringifyOptions\n *   Please use `StringifyOptions` instead.\n */\n\n/**\n * Parse comma-separated tokens to an array.\n *\n * @param {string} value\n *   Comma-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nfunction parse(value) {\n  /** @type {Array<string>} */\n  const tokens = []\n  const input = String(value || '')\n  let index = input.indexOf(',')\n  let start = 0\n  /** @type {boolean} */\n  let end = false\n\n  while (!end) {\n    if (index === -1) {\n      index = input.length\n      end = true\n    }\n\n    const token = input.slice(start, index).trim()\n\n    if (token || !end) {\n      tokens.push(token)\n    }\n\n    start = index + 1\n    index = input.indexOf(',', start)\n  }\n\n  return tokens\n}\n\n/**\n * Serialize an array of strings or numbers to comma-separated tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @param {Options} [options]\n *   Configuration for `stringify` (optional).\n * @returns {string}\n *   Comma-separated tokens.\n */\nfunction stringify(values, options) {\n  const settings = options || {}\n\n  // Ensure the last empty entry is seen.\n  const input = values[values.length - 1] === '' ? [...values, ''] : values\n\n  return input\n    .join(\n      (settings.padRight ? ' ' : '') +\n        ',' +\n        (settings.padLeft === false ? '' : ' ')\n    )\n    .trim()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9jb21tYS1zZXBhcmF0ZWQtdG9rZW5zQDIuMC4zL25vZGVfbW9kdWxlcy9jb21tYS1zZXBhcmF0ZWQtdG9rZW5zL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1AsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9jb21tYS1zZXBhcmF0ZWQtdG9rZW5zQDIuMC4zL25vZGVfbW9kdWxlcy9jb21tYS1zZXBhcmF0ZWQtdG9rZW5zL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciBgc3RyaW5naWZ5YC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BhZExlZnQ9dHJ1ZV1cbiAqICAgV2hldGhlciB0byBwYWQgYSBzcGFjZSBiZWZvcmUgYSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BhZFJpZ2h0PWZhbHNlXVxuICogICBXaGV0aGVyIHRvIHBhZCBhIHNwYWNlIGFmdGVyIGEgdG9rZW4uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T3B0aW9uc30gU3RyaW5naWZ5T3B0aW9uc1xuICogICBQbGVhc2UgdXNlIGBTdHJpbmdpZnlPcHRpb25zYCBpbnN0ZWFkLlxuICovXG5cbi8qKlxuICogUGFyc2UgY29tbWEtc2VwYXJhdGVkIHRva2VucyB0byBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgQ29tbWEtc2VwYXJhdGVkIHRva2Vucy5cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fVxuICogICBMaXN0IG9mIHRva2Vucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHZhbHVlKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgdG9rZW5zID0gW11cbiAgY29uc3QgaW5wdXQgPSBTdHJpbmcodmFsdWUgfHwgJycpXG4gIGxldCBpbmRleCA9IGlucHV0LmluZGV4T2YoJywnKVxuICBsZXQgc3RhcnQgPSAwXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgbGV0IGVuZCA9IGZhbHNlXG5cbiAgd2hpbGUgKCFlbmQpIHtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBpbmRleCA9IGlucHV0Lmxlbmd0aFxuICAgICAgZW5kID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0gaW5wdXQuc2xpY2Uoc3RhcnQsIGluZGV4KS50cmltKClcblxuICAgIGlmICh0b2tlbiB8fCAhZW5kKSB7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbilcbiAgICB9XG5cbiAgICBzdGFydCA9IGluZGV4ICsgMVxuICAgIGluZGV4ID0gaW5wdXQuaW5kZXhPZignLCcsIHN0YXJ0KVxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIG51bWJlcnMgdG8gY29tbWEtc2VwYXJhdGVkIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xudW1iZXI+fSB2YWx1ZXNcbiAqICAgTGlzdCBvZiB0b2tlbnMuXG4gKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIGZvciBgc3RyaW5naWZ5YCAob3B0aW9uYWwpLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgQ29tbWEtc2VwYXJhdGVkIHRva2Vucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBvcHRpb25zIHx8IHt9XG5cbiAgLy8gRW5zdXJlIHRoZSBsYXN0IGVtcHR5IGVudHJ5IGlzIHNlZW4uXG4gIGNvbnN0IGlucHV0ID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9PT0gJycgPyBbLi4udmFsdWVzLCAnJ10gOiB2YWx1ZXNcblxuICByZXR1cm4gaW5wdXRcbiAgICAuam9pbihcbiAgICAgIChzZXR0aW5ncy5wYWRSaWdodCA/ICcgJyA6ICcnKSArXG4gICAgICAgICcsJyArXG4gICAgICAgIChzZXR0aW5ncy5wYWRMZWZ0ID09PSBmYWxzZSA/ICcnIDogJyAnKVxuICAgIClcbiAgICAudHJpbSgpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/emoji-regex-xs@1.0.0/node_modules/emoji-regex-xs/index.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/emoji-regex-xs@1.0.0/node_modules/emoji-regex-xs/index.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst r = String.raw;\nconst seq = r`(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})`;\nconst sTags = r`\\u{E0061}-\\u{E007A}`;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => new RegExp(r`[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[${sTags}]{2}[\\u{E0030}-\\u{E0039}${sTags}]{1,3}\\u{E007F}|${seq}(?:\\u200D${seq})*`, 'gu'));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9lbW9qaS1yZWdleC14c0AxLjAuMC9ub2RlX21vZHVsZXMvZW1vamktcmVnZXgteHMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLG9CQUFvQixNQUFNLGlCQUFpQixvQkFBb0IsR0FBRyxlQUFlLEtBQUssbUJBQW1CO0FBQ3pHLG1CQUFtQixNQUFNLElBQUksTUFBTTtBQUNuQyxpRUFBZSx1QkFBdUIsTUFBTSxJQUFJLE1BQU0sRUFBRSxFQUFFLElBQUksTUFBTSxHQUFHLE1BQU0sRUFBRSxFQUFFLElBQUksTUFBTSxJQUFJLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxHQUFHLE1BQU0sR0FBRyxJQUFJLFdBQVcsSUFBSSxVQUFVLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vZW1vamktcmVnZXgteHNAMS4wLjAvbm9kZV9tb2R1bGVzL2Vtb2ppLXJlZ2V4LXhzL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByID0gU3RyaW5nLnJhdztcbmNvbnN0IHNlcSA9IHJgKD86XFxwe0Vtb2ppfVxcdUZFMEZcXHUyMEUzP3xcXHB7RW1vamlfTW9kaWZpZXJfQmFzZX1cXHB7RW1vamlfTW9kaWZpZXJ9P3xcXHB7RW1vamlfUHJlc2VudGF0aW9ufSlgO1xuY29uc3Qgc1RhZ3MgPSByYFxcdXtFMDA2MX0tXFx1e0UwMDdBfWA7XG5leHBvcnQgZGVmYXVsdCAoKSA9PiBuZXcgUmVnRXhwKHJgW1xcdXsxRjFFNn0tXFx1ezFGMUZGfV17Mn18XFx1ezFGM0Y0fVske3NUYWdzfV17Mn1bXFx1e0UwMDMwfS1cXHV7RTAwMzl9JHtzVGFnc31dezEsM31cXHV7RTAwN0Z9fCR7c2VxfSg/OlxcdTIwMEQke3NlcX0pKmAsICdndScpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/emoji-regex-xs@1.0.0/node_modules/emoji-regex-xs/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/comment.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/comment.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   comment: () => (/* binding */ comment)\n/* harmony export */ });\n/* harmony import */ var stringify_entities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stringify-entities */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js\");\n/**\n * @import {Comment, Parents} from 'hast'\n * @import {State} from '../index.js'\n */\n\n\n\nconst htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g\n\n// Declare arrays as variables so it can be cached by `stringifyEntities`\nconst bogusCommentEntitySubset = ['>']\nconst commentEntitySubset = ['<', '>']\n\n/**\n * Serialize a comment.\n *\n * @param {Comment} node\n *   Node to handle.\n * @param {number | undefined} _1\n *   Index of `node` in `parent.\n * @param {Parents | undefined} _2\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nfunction comment(node, _1, _2, state) {\n  // See: <https://html.spec.whatwg.org/multipage/syntax.html#comments>\n  return state.settings.bogusComments\n    ? '<?' +\n        (0,stringify_entities__WEBPACK_IMPORTED_MODULE_0__.stringifyEntities)(\n          node.value,\n          Object.assign({}, state.settings.characterReferences, {\n            subset: bogusCommentEntitySubset\n          })\n        ) +\n        '>'\n    : '<!--' + node.value.replace(htmlCommentRegex, encode) + '-->'\n\n  /**\n   * @param {string} $0\n   */\n  function encode($0) {\n    return (0,stringify_entities__WEBPACK_IMPORTED_MODULE_0__.stringifyEntities)(\n      $0,\n      Object.assign({}, state.settings.characterReferences, {\n        subset: commentEntitySubset\n      })\n    )\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2hhbmRsZS9jb21tZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QixZQUFZLE9BQU87QUFDbkI7O0FBRW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFFQUFpQjtBQUN6QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLFdBQVcscUVBQWlCO0FBQzVCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2hhbmRsZS9jb21tZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7Q29tbWVudCwgUGFyZW50c30gZnJvbSAnaGFzdCdcbiAqIEBpbXBvcnQge1N0YXRlfSBmcm9tICcuLi9pbmRleC5qcydcbiAqL1xuXG5pbXBvcnQge3N0cmluZ2lmeUVudGl0aWVzfSBmcm9tICdzdHJpbmdpZnktZW50aXRpZXMnXG5cbmNvbnN0IGh0bWxDb21tZW50UmVnZXggPSAvXj58Xi0+fDwhLS18LS0+fC0tIT58PCEtJC9nXG5cbi8vIERlY2xhcmUgYXJyYXlzIGFzIHZhcmlhYmxlcyBzbyBpdCBjYW4gYmUgY2FjaGVkIGJ5IGBzdHJpbmdpZnlFbnRpdGllc2BcbmNvbnN0IGJvZ3VzQ29tbWVudEVudGl0eVN1YnNldCA9IFsnPiddXG5jb25zdCBjb21tZW50RW50aXR5U3Vic2V0ID0gWyc8JywgJz4nXVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBhIGNvbW1lbnQuXG4gKlxuICogQHBhcmFtIHtDb21tZW50fSBub2RlXG4gKiAgIE5vZGUgdG8gaGFuZGxlLlxuICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IF8xXG4gKiAgIEluZGV4IG9mIGBub2RlYCBpbiBgcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfMlxuICogICBQYXJlbnQgb2YgYG5vZGVgLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgU2VyaWFsaXplZCBub2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWVudChub2RlLCBfMSwgXzIsIHN0YXRlKSB7XG4gIC8vIFNlZTogPGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2NvbW1lbnRzPlxuICByZXR1cm4gc3RhdGUuc2V0dGluZ3MuYm9ndXNDb21tZW50c1xuICAgID8gJzw/JyArXG4gICAgICAgIHN0cmluZ2lmeUVudGl0aWVzKFxuICAgICAgICAgIG5vZGUudmFsdWUsXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc2V0dGluZ3MuY2hhcmFjdGVyUmVmZXJlbmNlcywge1xuICAgICAgICAgICAgc3Vic2V0OiBib2d1c0NvbW1lbnRFbnRpdHlTdWJzZXRcbiAgICAgICAgICB9KVxuICAgICAgICApICtcbiAgICAgICAgJz4nXG4gICAgOiAnPCEtLScgKyBub2RlLnZhbHVlLnJlcGxhY2UoaHRtbENvbW1lbnRSZWdleCwgZW5jb2RlKSArICctLT4nXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAkMFxuICAgKi9cbiAgZnVuY3Rpb24gZW5jb2RlKCQwKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUVudGl0aWVzKFxuICAgICAgJDAsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zZXR0aW5ncy5jaGFyYWN0ZXJSZWZlcmVuY2VzLCB7XG4gICAgICAgIHN1YnNldDogY29tbWVudEVudGl0eVN1YnNldFxuICAgICAgfSlcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/comment.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/doctype.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/doctype.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doctype: () => (/* binding */ doctype)\n/* harmony export */ });\n/**\n * @import {Doctype, Parents} from 'hast'\n * @import {State} from '../index.js'\n */\n\n/**\n * Serialize a doctype.\n *\n * @param {Doctype} _1\n *   Node to handle.\n * @param {number | undefined} _2\n *   Index of `node` in `parent.\n * @param {Parents | undefined} _3\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nfunction doctype(_1, _2, _3, state) {\n  return (\n    '<!' +\n    (state.settings.upperDoctype ? 'DOCTYPE' : 'doctype') +\n    (state.settings.tightDoctype ? '' : ' ') +\n    'html>'\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2hhbmRsZS9kb2N0eXBlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL2hhc3QtdXRpbC10by1odG1sQDkuMC40L25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8taHRtbC9saWIvaGFuZGxlL2RvY3R5cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtEb2N0eXBlLCBQYXJlbnRzfSBmcm9tICdoYXN0J1xuICogQGltcG9ydCB7U3RhdGV9IGZyb20gJy4uL2luZGV4LmpzJ1xuICovXG5cbi8qKlxuICogU2VyaWFsaXplIGEgZG9jdHlwZS5cbiAqXG4gKiBAcGFyYW0ge0RvY3R5cGV9IF8xXG4gKiAgIE5vZGUgdG8gaGFuZGxlLlxuICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IF8yXG4gKiAgIEluZGV4IG9mIGBub2RlYCBpbiBgcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfM1xuICogICBQYXJlbnQgb2YgYG5vZGVgLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgU2VyaWFsaXplZCBub2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG9jdHlwZShfMSwgXzIsIF8zLCBzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgICc8IScgK1xuICAgIChzdGF0ZS5zZXR0aW5ncy51cHBlckRvY3R5cGUgPyAnRE9DVFlQRScgOiAnZG9jdHlwZScpICtcbiAgICAoc3RhdGUuc2V0dGluZ3MudGlnaHREb2N0eXBlID8gJycgOiAnICcpICtcbiAgICAnaHRtbD4nXG4gIClcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/doctype.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/element.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/element.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   element: () => (/* binding */ element)\n/* harmony export */ });\n/* harmony import */ var ccount__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ccount */ \"(app-pages-browser)/./node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js\");\n/* harmony import */ var comma_separated_tokens__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! comma-separated-tokens */ \"(app-pages-browser)/./node_modules/.pnpm/comma-separated-tokens@2.0.3/node_modules/comma-separated-tokens/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! property-information */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! property-information */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/find.js\");\n/* harmony import */ var space_separated_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! space-separated-tokens */ \"(app-pages-browser)/./node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js\");\n/* harmony import */ var stringify_entities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! stringify-entities */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js\");\n/* harmony import */ var _omission_closing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../omission/closing.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/closing.js\");\n/* harmony import */ var _omission_opening_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../omission/opening.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/opening.js\");\n/**\n * @import {Element, Parents, Properties} from 'hast'\n * @import {State} from '../index.js'\n */\n\n\n\n\n\n\n\n\n\n/**\n * Maps of subsets.\n *\n * Each value is a matrix of tuples.\n * The value at `0` causes parse errors, the value at `1` is valid.\n * Of both, the value at `0` is unsafe, and the value at `1` is safe.\n *\n * @type {Record<'double' | 'name' | 'single' | 'unquoted', Array<[Array<string>, Array<string>]>>}\n */\nconst constants = {\n  // See: <https://html.spec.whatwg.org/#attribute-name-state>.\n  name: [\n    ['\\t\\n\\f\\r &/=>'.split(''), '\\t\\n\\f\\r \"&\\'/=>`'.split('')],\n    ['\\0\\t\\n\\f\\r \"&\\'/<=>'.split(''), '\\0\\t\\n\\f\\r \"&\\'/<=>`'.split('')]\n  ],\n  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.\n  unquoted: [\n    ['\\t\\n\\f\\r &>'.split(''), '\\0\\t\\n\\f\\r \"&\\'<=>`'.split('')],\n    ['\\0\\t\\n\\f\\r \"&\\'<=>`'.split(''), '\\0\\t\\n\\f\\r \"&\\'<=>`'.split('')]\n  ],\n  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.\n  single: [\n    [\"&'\".split(''), '\"&\\'`'.split('')],\n    [\"\\0&'\".split(''), '\\0\"&\\'`'.split('')]\n  ],\n  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.\n  double: [\n    ['\"&'.split(''), '\"&\\'`'.split('')],\n    ['\\0\"&'.split(''), '\\0\"&\\'`'.split('')]\n  ]\n}\n\n/**\n * Serialize an element node.\n *\n * @param {Element} node\n *   Node to handle.\n * @param {number | undefined} index\n *   Index of `node` in `parent.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nfunction element(node, index, parent, state) {\n  const schema = state.schema\n  const omit = schema.space === 'svg' ? false : state.settings.omitOptionalTags\n  let selfClosing =\n    schema.space === 'svg'\n      ? state.settings.closeEmptyElements\n      : state.settings.voids.includes(node.tagName.toLowerCase())\n  /** @type {Array<string>} */\n  const parts = []\n  /** @type {string} */\n  let last\n\n  if (schema.space === 'html' && node.tagName === 'svg') {\n    state.schema = property_information__WEBPACK_IMPORTED_MODULE_0__.svg\n  }\n\n  const attributes = serializeAttributes(state, node.properties)\n\n  const content = state.all(\n    schema.space === 'html' && node.tagName === 'template' ? node.content : node\n  )\n\n  state.schema = schema\n\n  // If the node is categorised as void, but it has children, remove the\n  // categorisation.\n  // This enables for example `menuitem`s, which are void in W3C HTML but not\n  // void in WHATWG HTML, to be stringified properly.\n  // Note: `menuitem` has since been removed from the HTML spec, and so is no\n  // longer void.\n  if (content) selfClosing = false\n\n  if (attributes || !omit || !(0,_omission_opening_js__WEBPACK_IMPORTED_MODULE_1__.opening)(node, index, parent)) {\n    parts.push('<', node.tagName, attributes ? ' ' + attributes : '')\n\n    if (\n      selfClosing &&\n      (schema.space === 'svg' || state.settings.closeSelfClosing)\n    ) {\n      last = attributes.charAt(attributes.length - 1)\n      if (\n        !state.settings.tightSelfClosing ||\n        last === '/' ||\n        (last && last !== '\"' && last !== \"'\")\n      ) {\n        parts.push(' ')\n      }\n\n      parts.push('/')\n    }\n\n    parts.push('>')\n  }\n\n  parts.push(content)\n\n  if (!selfClosing && (!omit || !(0,_omission_closing_js__WEBPACK_IMPORTED_MODULE_2__.closing)(node, index, parent))) {\n    parts.push('</' + node.tagName + '>')\n  }\n\n  return parts.join('')\n}\n\n/**\n * @param {State} state\n * @param {Properties | null | undefined} properties\n * @returns {string}\n */\nfunction serializeAttributes(state, properties) {\n  /** @type {Array<string>} */\n  const values = []\n  let index = -1\n  /** @type {string} */\n  let key\n\n  if (properties) {\n    for (key in properties) {\n      if (properties[key] !== null && properties[key] !== undefined) {\n        const value = serializeAttribute(state, key, properties[key])\n        if (value) values.push(value)\n      }\n    }\n  }\n\n  while (++index < values.length) {\n    const last = state.settings.tightAttributes\n      ? values[index].charAt(values[index].length - 1)\n      : undefined\n\n    // In tight mode, dont add a space after quoted attributes.\n    if (index !== values.length - 1 && last !== '\"' && last !== \"'\") {\n      values[index] += ' '\n    }\n  }\n\n  return values.join('')\n}\n\n/**\n * @param {State} state\n * @param {string} key\n * @param {Properties[keyof Properties]} value\n * @returns {string}\n */\nfunction serializeAttribute(state, key, value) {\n  const info = (0,property_information__WEBPACK_IMPORTED_MODULE_3__.find)(state.schema, key)\n  const x =\n    state.settings.allowParseErrors && state.schema.space === 'html' ? 0 : 1\n  const y = state.settings.allowDangerousCharacters ? 0 : 1\n  let quote = state.quote\n  /** @type {string | undefined} */\n  let result\n\n  if (info.overloadedBoolean && (value === info.attribute || value === '')) {\n    value = true\n  } else if (\n    (info.boolean || info.overloadedBoolean) &&\n    (typeof value !== 'string' || value === info.attribute || value === '')\n  ) {\n    value = Boolean(value)\n  }\n\n  if (\n    value === null ||\n    value === undefined ||\n    value === false ||\n    (typeof value === 'number' && Number.isNaN(value))\n  ) {\n    return ''\n  }\n\n  const name = (0,stringify_entities__WEBPACK_IMPORTED_MODULE_4__.stringifyEntities)(\n    info.attribute,\n    Object.assign({}, state.settings.characterReferences, {\n      // Always encode without parse errors in non-HTML.\n      subset: constants.name[x][y]\n    })\n  )\n\n  // No value.\n  // There is currently only one boolean property in SVG: `[download]` on\n  // `<a>`.\n  // This property does not seem to work in browsers (Firefox, Safari, Chrome),\n  // so I cant test if dropping the value works.\n  // But I assume that it should:\n  //\n  // ```html\n  // <!doctype html>\n  // <svg viewBox=\"0 0 100 100\">\n  //   <a href=https://example.com download>\n  //     <circle cx=50 cy=40 r=35 />\n  //   </a>\n  // </svg>\n  // ```\n  //\n  // See: <https://github.com/wooorm/property-information/blob/main/lib/svg.js>\n  if (value === true) return name\n\n  // `spaces` doesnt accept a second argument, but its given here just to\n  // keep the code cleaner.\n  value = Array.isArray(value)\n    ? (info.commaSeparated ? comma_separated_tokens__WEBPACK_IMPORTED_MODULE_5__.stringify : space_separated_tokens__WEBPACK_IMPORTED_MODULE_6__.stringify)(value, {\n        padLeft: !state.settings.tightCommaSeparatedLists\n      })\n    : String(value)\n\n  if (state.settings.collapseEmptyAttributes && !value) return name\n\n  // Check unquoted value.\n  if (state.settings.preferUnquoted) {\n    result = (0,stringify_entities__WEBPACK_IMPORTED_MODULE_4__.stringifyEntities)(\n      value,\n      Object.assign({}, state.settings.characterReferences, {\n        attribute: true,\n        subset: constants.unquoted[x][y]\n      })\n    )\n  }\n\n  // If we dont want unquoted, or if `value` contains character references when\n  // unquoted\n  if (result !== value) {\n    // If the alternative is less common than `quote`, switch.\n    if (\n      state.settings.quoteSmart &&\n      (0,ccount__WEBPACK_IMPORTED_MODULE_7__.ccount)(value, quote) > (0,ccount__WEBPACK_IMPORTED_MODULE_7__.ccount)(value, state.alternative)\n    ) {\n      quote = state.alternative\n    }\n\n    result =\n      quote +\n      (0,stringify_entities__WEBPACK_IMPORTED_MODULE_4__.stringifyEntities)(\n        value,\n        Object.assign({}, state.settings.characterReferences, {\n          // Always encode without parse errors in non-HTML.\n          subset: (quote === \"'\" ? constants.single : constants.double)[x][y],\n          attribute: true\n        })\n      ) +\n      quote\n  }\n\n  // Dont add a `=` for unquoted empties.\n  return name + (result ? '=' + result : result)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2hhbmRsZS9lbGVtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUMsWUFBWSxPQUFPO0FBQ25COztBQUU2QjtBQUM2QjtBQUNaO0FBQ1k7QUFDTjtBQUNOO0FBQ0E7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQSxtQkFBbUIscURBQUc7QUFDdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qiw2REFBTztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQyw2REFBTztBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVywrQkFBK0I7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyw4QkFBOEI7QUFDekMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlLDBEQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxxRUFBaUI7QUFDaEM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZEQUFNLEdBQUcsNkRBQU07QUFDNUM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEscUVBQWlCO0FBQzlCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhDQUFNLGlCQUFpQiw4Q0FBTTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0scUVBQWlCO0FBQ3ZCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL2hhc3QtdXRpbC10by1odG1sQDkuMC40L25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8taHRtbC9saWIvaGFuZGxlL2VsZW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtFbGVtZW50LCBQYXJlbnRzLCBQcm9wZXJ0aWVzfSBmcm9tICdoYXN0J1xuICogQGltcG9ydCB7U3RhdGV9IGZyb20gJy4uL2luZGV4LmpzJ1xuICovXG5cbmltcG9ydCB7Y2NvdW50fSBmcm9tICdjY291bnQnXG5pbXBvcnQge3N0cmluZ2lmeSBhcyBjb21tYXN9IGZyb20gJ2NvbW1hLXNlcGFyYXRlZC10b2tlbnMnXG5pbXBvcnQge2ZpbmQsIHN2Z30gZnJvbSAncHJvcGVydHktaW5mb3JtYXRpb24nXG5pbXBvcnQge3N0cmluZ2lmeSBhcyBzcGFjZXN9IGZyb20gJ3NwYWNlLXNlcGFyYXRlZC10b2tlbnMnXG5pbXBvcnQge3N0cmluZ2lmeUVudGl0aWVzfSBmcm9tICdzdHJpbmdpZnktZW50aXRpZXMnXG5pbXBvcnQge2Nsb3Npbmd9IGZyb20gJy4uL29taXNzaW9uL2Nsb3NpbmcuanMnXG5pbXBvcnQge29wZW5pbmd9IGZyb20gJy4uL29taXNzaW9uL29wZW5pbmcuanMnXG5cbi8qKlxuICogTWFwcyBvZiBzdWJzZXRzLlxuICpcbiAqIEVhY2ggdmFsdWUgaXMgYSBtYXRyaXggb2YgdHVwbGVzLlxuICogVGhlIHZhbHVlIGF0IGAwYCBjYXVzZXMgcGFyc2UgZXJyb3JzLCB0aGUgdmFsdWUgYXQgYDFgIGlzIHZhbGlkLlxuICogT2YgYm90aCwgdGhlIHZhbHVlIGF0IGAwYCBpcyB1bnNhZmUsIGFuZCB0aGUgdmFsdWUgYXQgYDFgIGlzIHNhZmUuXG4gKlxuICogQHR5cGUge1JlY29yZDwnZG91YmxlJyB8ICduYW1lJyB8ICdzaW5nbGUnIHwgJ3VucXVvdGVkJywgQXJyYXk8W0FycmF5PHN0cmluZz4sIEFycmF5PHN0cmluZz5dPj59XG4gKi9cbmNvbnN0IGNvbnN0YW50cyA9IHtcbiAgLy8gU2VlOiA8aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0cmlidXRlLW5hbWUtc3RhdGU+LlxuICBuYW1lOiBbXG4gICAgWydcXHRcXG5cXGZcXHIgJi89Picuc3BsaXQoJycpLCAnXFx0XFxuXFxmXFxyIFwiJlxcJy89PmAnLnNwbGl0KCcnKV0sXG4gICAgWydcXDBcXHRcXG5cXGZcXHIgXCImXFwnLzw9Picuc3BsaXQoJycpLCAnXFwwXFx0XFxuXFxmXFxyIFwiJlxcJy88PT5gJy5zcGxpdCgnJyldXG4gIF0sXG4gIC8vIFNlZTogPGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2F0dHJpYnV0ZS12YWx1ZS0odW5xdW90ZWQpLXN0YXRlPi5cbiAgdW5xdW90ZWQ6IFtcbiAgICBbJ1xcdFxcblxcZlxcciAmPicuc3BsaXQoJycpLCAnXFwwXFx0XFxuXFxmXFxyIFwiJlxcJzw9PmAnLnNwbGl0KCcnKV0sXG4gICAgWydcXDBcXHRcXG5cXGZcXHIgXCImXFwnPD0+YCcuc3BsaXQoJycpLCAnXFwwXFx0XFxuXFxmXFxyIFwiJlxcJzw9PmAnLnNwbGl0KCcnKV1cbiAgXSxcbiAgLy8gU2VlOiA8aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0cmlidXRlLXZhbHVlLShzaW5nbGUtcXVvdGVkKS1zdGF0ZT4uXG4gIHNpbmdsZTogW1xuICAgIFtcIiYnXCIuc3BsaXQoJycpLCAnXCImXFwnYCcuc3BsaXQoJycpXSxcbiAgICBbXCJcXDAmJ1wiLnNwbGl0KCcnKSwgJ1xcMFwiJlxcJ2AnLnNwbGl0KCcnKV1cbiAgXSxcbiAgLy8gU2VlOiA8aHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0cmlidXRlLXZhbHVlLShkb3VibGUtcXVvdGVkKS1zdGF0ZT4uXG4gIGRvdWJsZTogW1xuICAgIFsnXCImJy5zcGxpdCgnJyksICdcIiZcXCdgJy5zcGxpdCgnJyldLFxuICAgIFsnXFwwXCImJy5zcGxpdCgnJyksICdcXDBcIiZcXCdgJy5zcGxpdCgnJyldXG4gIF1cbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgYW4gZWxlbWVudCBub2RlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogICBOb2RlIHRvIGhhbmRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBgbm9kZWAgaW4gYHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBgbm9kZWAuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBTZXJpYWxpemVkIG5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50KG5vZGUsIGluZGV4LCBwYXJlbnQsIHN0YXRlKSB7XG4gIGNvbnN0IHNjaGVtYSA9IHN0YXRlLnNjaGVtYVxuICBjb25zdCBvbWl0ID0gc2NoZW1hLnNwYWNlID09PSAnc3ZnJyA/IGZhbHNlIDogc3RhdGUuc2V0dGluZ3Mub21pdE9wdGlvbmFsVGFnc1xuICBsZXQgc2VsZkNsb3NpbmcgPVxuICAgIHNjaGVtYS5zcGFjZSA9PT0gJ3N2ZydcbiAgICAgID8gc3RhdGUuc2V0dGluZ3MuY2xvc2VFbXB0eUVsZW1lbnRzXG4gICAgICA6IHN0YXRlLnNldHRpbmdzLnZvaWRzLmluY2x1ZGVzKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IHBhcnRzID0gW11cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBsYXN0XG5cbiAgaWYgKHNjaGVtYS5zcGFjZSA9PT0gJ2h0bWwnICYmIG5vZGUudGFnTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICBzdGF0ZS5zY2hlbWEgPSBzdmdcbiAgfVxuXG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzZXJpYWxpemVBdHRyaWJ1dGVzKHN0YXRlLCBub2RlLnByb3BlcnRpZXMpXG5cbiAgY29uc3QgY29udGVudCA9IHN0YXRlLmFsbChcbiAgICBzY2hlbWEuc3BhY2UgPT09ICdodG1sJyAmJiBub2RlLnRhZ05hbWUgPT09ICd0ZW1wbGF0ZScgPyBub2RlLmNvbnRlbnQgOiBub2RlXG4gIClcblxuICBzdGF0ZS5zY2hlbWEgPSBzY2hlbWFcblxuICAvLyBJZiB0aGUgbm9kZSBpcyBjYXRlZ29yaXNlZCBhcyB2b2lkLCBidXQgaXQgaGFzIGNoaWxkcmVuLCByZW1vdmUgdGhlXG4gIC8vIGNhdGVnb3Jpc2F0aW9uLlxuICAvLyBUaGlzIGVuYWJsZXMgZm9yIGV4YW1wbGUgYG1lbnVpdGVtYHMsIHdoaWNoIGFyZSB2b2lkIGluIFczQyBIVE1MIGJ1dCBub3RcbiAgLy8gdm9pZCBpbiBXSEFUV0cgSFRNTCwgdG8gYmUgc3RyaW5naWZpZWQgcHJvcGVybHkuXG4gIC8vIE5vdGU6IGBtZW51aXRlbWAgaGFzIHNpbmNlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBIVE1MIHNwZWMsIGFuZCBzbyBpcyBub1xuICAvLyBsb25nZXIgdm9pZC5cbiAgaWYgKGNvbnRlbnQpIHNlbGZDbG9zaW5nID0gZmFsc2VcblxuICBpZiAoYXR0cmlidXRlcyB8fCAhb21pdCB8fCAhb3BlbmluZyhub2RlLCBpbmRleCwgcGFyZW50KSkge1xuICAgIHBhcnRzLnB1c2goJzwnLCBub2RlLnRhZ05hbWUsIGF0dHJpYnV0ZXMgPyAnICcgKyBhdHRyaWJ1dGVzIDogJycpXG5cbiAgICBpZiAoXG4gICAgICBzZWxmQ2xvc2luZyAmJlxuICAgICAgKHNjaGVtYS5zcGFjZSA9PT0gJ3N2ZycgfHwgc3RhdGUuc2V0dGluZ3MuY2xvc2VTZWxmQ2xvc2luZylcbiAgICApIHtcbiAgICAgIGxhc3QgPSBhdHRyaWJ1dGVzLmNoYXJBdChhdHRyaWJ1dGVzLmxlbmd0aCAtIDEpXG4gICAgICBpZiAoXG4gICAgICAgICFzdGF0ZS5zZXR0aW5ncy50aWdodFNlbGZDbG9zaW5nIHx8XG4gICAgICAgIGxhc3QgPT09ICcvJyB8fFxuICAgICAgICAobGFzdCAmJiBsYXN0ICE9PSAnXCInICYmIGxhc3QgIT09IFwiJ1wiKVxuICAgICAgKSB7XG4gICAgICAgIHBhcnRzLnB1c2goJyAnKVxuICAgICAgfVxuXG4gICAgICBwYXJ0cy5wdXNoKCcvJylcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKCc+JylcbiAgfVxuXG4gIHBhcnRzLnB1c2goY29udGVudClcblxuICBpZiAoIXNlbGZDbG9zaW5nICYmICghb21pdCB8fCAhY2xvc2luZyhub2RlLCBpbmRleCwgcGFyZW50KSkpIHtcbiAgICBwYXJ0cy5wdXNoKCc8LycgKyBub2RlLnRhZ05hbWUgKyAnPicpXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtQcm9wZXJ0aWVzIHwgbnVsbCB8IHVuZGVmaW5lZH0gcHJvcGVydGllc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQXR0cmlidXRlcyhzdGF0ZSwgcHJvcGVydGllcykge1xuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IHZhbHVlcyA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQga2V5XG5cbiAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllc1trZXldICE9PSBudWxsICYmIHByb3BlcnRpZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2VyaWFsaXplQXR0cmlidXRlKHN0YXRlLCBrZXksIHByb3BlcnRpZXNba2V5XSlcbiAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3aGlsZSAoKytpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBsYXN0ID0gc3RhdGUuc2V0dGluZ3MudGlnaHRBdHRyaWJ1dGVzXG4gICAgICA/IHZhbHVlc1tpbmRleF0uY2hhckF0KHZhbHVlc1tpbmRleF0ubGVuZ3RoIC0gMSlcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAvLyBJbiB0aWdodCBtb2RlLCBkb27igJl0IGFkZCBhIHNwYWNlIGFmdGVyIHF1b3RlZCBhdHRyaWJ1dGVzLlxuICAgIGlmIChpbmRleCAhPT0gdmFsdWVzLmxlbmd0aCAtIDEgJiYgbGFzdCAhPT0gJ1wiJyAmJiBsYXN0ICE9PSBcIidcIikge1xuICAgICAgdmFsdWVzW2luZGV4XSArPSAnICdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzLmpvaW4oJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7UHJvcGVydGllc1trZXlvZiBQcm9wZXJ0aWVzXX0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUF0dHJpYnV0ZShzdGF0ZSwga2V5LCB2YWx1ZSkge1xuICBjb25zdCBpbmZvID0gZmluZChzdGF0ZS5zY2hlbWEsIGtleSlcbiAgY29uc3QgeCA9XG4gICAgc3RhdGUuc2V0dGluZ3MuYWxsb3dQYXJzZUVycm9ycyAmJiBzdGF0ZS5zY2hlbWEuc3BhY2UgPT09ICdodG1sJyA/IDAgOiAxXG4gIGNvbnN0IHkgPSBzdGF0ZS5zZXR0aW5ncy5hbGxvd0Rhbmdlcm91c0NoYXJhY3RlcnMgPyAwIDogMVxuICBsZXQgcXVvdGUgPSBzdGF0ZS5xdW90ZVxuICAvKiogQHR5cGUge3N0cmluZyB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHJlc3VsdFxuXG4gIGlmIChpbmZvLm92ZXJsb2FkZWRCb29sZWFuICYmICh2YWx1ZSA9PT0gaW5mby5hdHRyaWJ1dGUgfHwgdmFsdWUgPT09ICcnKSkge1xuICAgIHZhbHVlID0gdHJ1ZVxuICB9IGVsc2UgaWYgKFxuICAgIChpbmZvLmJvb2xlYW4gfHwgaW5mby5vdmVybG9hZGVkQm9vbGVhbikgJiZcbiAgICAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PT0gaW5mby5hdHRyaWJ1dGUgfHwgdmFsdWUgPT09ICcnKVxuICApIHtcbiAgICB2YWx1ZSA9IEJvb2xlYW4odmFsdWUpXG4gIH1cblxuICBpZiAoXG4gICAgdmFsdWUgPT09IG51bGwgfHxcbiAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzTmFOKHZhbHVlKSlcbiAgKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBjb25zdCBuYW1lID0gc3RyaW5naWZ5RW50aXRpZXMoXG4gICAgaW5mby5hdHRyaWJ1dGUsXG4gICAgT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc2V0dGluZ3MuY2hhcmFjdGVyUmVmZXJlbmNlcywge1xuICAgICAgLy8gQWx3YXlzIGVuY29kZSB3aXRob3V0IHBhcnNlIGVycm9ycyBpbiBub24tSFRNTC5cbiAgICAgIHN1YnNldDogY29uc3RhbnRzLm5hbWVbeF1beV1cbiAgICB9KVxuICApXG5cbiAgLy8gTm8gdmFsdWUuXG4gIC8vIFRoZXJlIGlzIGN1cnJlbnRseSBvbmx5IG9uZSBib29sZWFuIHByb3BlcnR5IGluIFNWRzogYFtkb3dubG9hZF1gIG9uXG4gIC8vIGA8YT5gLlxuICAvLyBUaGlzIHByb3BlcnR5IGRvZXMgbm90IHNlZW0gdG8gd29yayBpbiBicm93c2VycyAoRmlyZWZveCwgU2FmYXJpLCBDaHJvbWUpLFxuICAvLyBzbyBJIGNhbuKAmXQgdGVzdCBpZiBkcm9wcGluZyB0aGUgdmFsdWUgd29ya3MuXG4gIC8vIEJ1dCBJIGFzc3VtZSB0aGF0IGl0IHNob3VsZDpcbiAgLy9cbiAgLy8gYGBgaHRtbFxuICAvLyA8IWRvY3R5cGUgaHRtbD5cbiAgLy8gPHN2ZyB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cbiAgLy8gICA8YSBocmVmPWh0dHBzOi8vZXhhbXBsZS5jb20gZG93bmxvYWQ+XG4gIC8vICAgICA8Y2lyY2xlIGN4PTUwIGN5PTQwIHI9MzUgLz5cbiAgLy8gICA8L2E+XG4gIC8vIDwvc3ZnPlxuICAvLyBgYGBcbiAgLy9cbiAgLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9wcm9wZXJ0eS1pbmZvcm1hdGlvbi9ibG9iL21haW4vbGliL3N2Zy5qcz5cbiAgaWYgKHZhbHVlID09PSB0cnVlKSByZXR1cm4gbmFtZVxuXG4gIC8vIGBzcGFjZXNgIGRvZXNu4oCZdCBhY2NlcHQgYSBzZWNvbmQgYXJndW1lbnQsIGJ1dCBpdOKAmXMgZ2l2ZW4gaGVyZSBqdXN0IHRvXG4gIC8vIGtlZXAgdGhlIGNvZGUgY2xlYW5lci5cbiAgdmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgID8gKGluZm8uY29tbWFTZXBhcmF0ZWQgPyBjb21tYXMgOiBzcGFjZXMpKHZhbHVlLCB7XG4gICAgICAgIHBhZExlZnQ6ICFzdGF0ZS5zZXR0aW5ncy50aWdodENvbW1hU2VwYXJhdGVkTGlzdHNcbiAgICAgIH0pXG4gICAgOiBTdHJpbmcodmFsdWUpXG5cbiAgaWYgKHN0YXRlLnNldHRpbmdzLmNvbGxhcHNlRW1wdHlBdHRyaWJ1dGVzICYmICF2YWx1ZSkgcmV0dXJuIG5hbWVcblxuICAvLyBDaGVjayB1bnF1b3RlZCB2YWx1ZS5cbiAgaWYgKHN0YXRlLnNldHRpbmdzLnByZWZlclVucXVvdGVkKSB7XG4gICAgcmVzdWx0ID0gc3RyaW5naWZ5RW50aXRpZXMoXG4gICAgICB2YWx1ZSxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnNldHRpbmdzLmNoYXJhY3RlclJlZmVyZW5jZXMsIHtcbiAgICAgICAgYXR0cmlidXRlOiB0cnVlLFxuICAgICAgICBzdWJzZXQ6IGNvbnN0YW50cy51bnF1b3RlZFt4XVt5XVxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICAvLyBJZiB3ZSBkb27igJl0IHdhbnQgdW5xdW90ZWQsIG9yIGlmIGB2YWx1ZWAgY29udGFpbnMgY2hhcmFjdGVyIHJlZmVyZW5jZXMgd2hlblxuICAvLyB1bnF1b3RlZOKAplxuICBpZiAocmVzdWx0ICE9PSB2YWx1ZSkge1xuICAgIC8vIElmIHRoZSBhbHRlcm5hdGl2ZSBpcyBsZXNzIGNvbW1vbiB0aGFuIGBxdW90ZWAsIHN3aXRjaC5cbiAgICBpZiAoXG4gICAgICBzdGF0ZS5zZXR0aW5ncy5xdW90ZVNtYXJ0ICYmXG4gICAgICBjY291bnQodmFsdWUsIHF1b3RlKSA+IGNjb3VudCh2YWx1ZSwgc3RhdGUuYWx0ZXJuYXRpdmUpXG4gICAgKSB7XG4gICAgICBxdW90ZSA9IHN0YXRlLmFsdGVybmF0aXZlXG4gICAgfVxuXG4gICAgcmVzdWx0ID1cbiAgICAgIHF1b3RlICtcbiAgICAgIHN0cmluZ2lmeUVudGl0aWVzKFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc2V0dGluZ3MuY2hhcmFjdGVyUmVmZXJlbmNlcywge1xuICAgICAgICAgIC8vIEFsd2F5cyBlbmNvZGUgd2l0aG91dCBwYXJzZSBlcnJvcnMgaW4gbm9uLUhUTUwuXG4gICAgICAgICAgc3Vic2V0OiAocXVvdGUgPT09IFwiJ1wiID8gY29uc3RhbnRzLnNpbmdsZSA6IGNvbnN0YW50cy5kb3VibGUpW3hdW3ldLFxuICAgICAgICAgIGF0dHJpYnV0ZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgKSArXG4gICAgICBxdW90ZVxuICB9XG5cbiAgLy8gRG9u4oCZdCBhZGQgYSBgPWAgZm9yIHVucXVvdGVkIGVtcHRpZXMuXG4gIHJldHVybiBuYW1lICsgKHJlc3VsdCA/ICc9JyArIHJlc3VsdCA6IHJlc3VsdClcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/element.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/index.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/index.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handle: () => (/* binding */ handle)\n/* harmony export */ });\n/* harmony import */ var zwitch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zwitch */ \"(app-pages-browser)/./node_modules/.pnpm/zwitch@2.0.4/node_modules/zwitch/index.js\");\n/* harmony import */ var _comment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./comment.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/comment.js\");\n/* harmony import */ var _doctype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./doctype.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/doctype.js\");\n/* harmony import */ var _element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./element.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/element.js\");\n/* harmony import */ var _raw_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./raw.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/raw.js\");\n/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./root.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/root.js\");\n/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./text.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/text.js\");\n/**\n * @import {Nodes, Parents} from 'hast'\n * @import {State} from '../index.js'\n */\n\n\n\n\n\n\n\n\n\n/**\n * @type {(node: Nodes, index: number | undefined, parent: Parents | undefined, state: State) => string}\n */\nconst handle = (0,zwitch__WEBPACK_IMPORTED_MODULE_0__.zwitch)('type', {\n  invalid,\n  unknown,\n  handlers: {comment: _comment_js__WEBPACK_IMPORTED_MODULE_1__.comment, doctype: _doctype_js__WEBPACK_IMPORTED_MODULE_2__.doctype, element: _element_js__WEBPACK_IMPORTED_MODULE_3__.element, raw: _raw_js__WEBPACK_IMPORTED_MODULE_4__.raw, root: _root_js__WEBPACK_IMPORTED_MODULE_5__.root, text: _text_js__WEBPACK_IMPORTED_MODULE_6__.text}\n})\n\n/**\n * Fail when a non-node is found in the tree.\n *\n * @param {unknown} node\n *   Unknown value.\n * @returns {never}\n *   Never.\n */\nfunction invalid(node) {\n  throw new Error('Expected node, not `' + node + '`')\n}\n\n/**\n * Fail when a node with an unknown type is found in the tree.\n *\n * @param {unknown} node_\n *  Unknown node.\n * @returns {never}\n *   Never.\n */\nfunction unknown(node_) {\n  // `type` is guaranteed by runtime JS.\n  const node = /** @type {Nodes} */ (node_)\n  throw new Error('Cannot compile unknown node `' + node.type + '`')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2hhbmRsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxPQUFPO0FBQ25COztBQUU2QjtBQUNPO0FBQ0E7QUFDQTtBQUNSO0FBQ0U7QUFDQTs7QUFFOUI7QUFDQSxVQUFVO0FBQ1Y7QUFDTyxlQUFlLDhDQUFNO0FBQzVCO0FBQ0E7QUFDQSxhQUFhLE9BQU8sMkRBQVMsMkRBQVMsdURBQUssZ0RBQU0sa0RBQU07QUFDdkQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL2hhc3QtdXRpbC10by1odG1sQDkuMC40L25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8taHRtbC9saWIvaGFuZGxlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7Tm9kZXMsIFBhcmVudHN9IGZyb20gJ2hhc3QnXG4gKiBAaW1wb3J0IHtTdGF0ZX0gZnJvbSAnLi4vaW5kZXguanMnXG4gKi9cblxuaW1wb3J0IHt6d2l0Y2h9IGZyb20gJ3p3aXRjaCdcbmltcG9ydCB7Y29tbWVudH0gZnJvbSAnLi9jb21tZW50LmpzJ1xuaW1wb3J0IHtkb2N0eXBlfSBmcm9tICcuL2RvY3R5cGUuanMnXG5pbXBvcnQge2VsZW1lbnR9IGZyb20gJy4vZWxlbWVudC5qcydcbmltcG9ydCB7cmF3fSBmcm9tICcuL3Jhdy5qcydcbmltcG9ydCB7cm9vdH0gZnJvbSAnLi9yb290LmpzJ1xuaW1wb3J0IHt0ZXh0fSBmcm9tICcuL3RleHQuanMnXG5cbi8qKlxuICogQHR5cGUgeyhub2RlOiBOb2RlcywgaW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZCwgcGFyZW50OiBQYXJlbnRzIHwgdW5kZWZpbmVkLCBzdGF0ZTogU3RhdGUpID0+IHN0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGhhbmRsZSA9IHp3aXRjaCgndHlwZScsIHtcbiAgaW52YWxpZCxcbiAgdW5rbm93bixcbiAgaGFuZGxlcnM6IHtjb21tZW50LCBkb2N0eXBlLCBlbGVtZW50LCByYXcsIHJvb3QsIHRleHR9XG59KVxuXG4vKipcbiAqIEZhaWwgd2hlbiBhIG5vbi1ub2RlIGlzIGZvdW5kIGluIHRoZSB0cmVlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gbm9kZVxuICogICBVbmtub3duIHZhbHVlLlxuICogQHJldHVybnMge25ldmVyfVxuICogICBOZXZlci5cbiAqL1xuZnVuY3Rpb24gaW52YWxpZChub2RlKSB7XG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9kZSwgbm90IGAnICsgbm9kZSArICdgJylcbn1cblxuLyoqXG4gKiBGYWlsIHdoZW4gYSBub2RlIHdpdGggYW4gdW5rbm93biB0eXBlIGlzIGZvdW5kIGluIHRoZSB0cmVlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gbm9kZV9cbiAqICBVbmtub3duIG5vZGUuXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKiAgIE5ldmVyLlxuICovXG5mdW5jdGlvbiB1bmtub3duKG5vZGVfKSB7XG4gIC8vIGB0eXBlYCBpcyBndWFyYW50ZWVkIGJ5IHJ1bnRpbWUgSlMuXG4gIGNvbnN0IG5vZGUgPSAvKiogQHR5cGUge05vZGVzfSAqLyAobm9kZV8pXG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBpbGUgdW5rbm93biBub2RlIGAnICsgbm9kZS50eXBlICsgJ2AnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/raw.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/raw.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raw: () => (/* binding */ raw)\n/* harmony export */ });\n/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/text.js\");\n/**\n * @import {Parents} from 'hast'\n * @import {Raw} from 'mdast-util-to-hast'\n * @import {State} from '../index.js'\n */\n\n\n\n/**\n * Serialize a raw node.\n *\n * @param {Raw} node\n *   Node to handle.\n * @param {number | undefined} index\n *   Index of `node` in `parent.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nfunction raw(node, index, parent, state) {\n  return state.settings.allowDangerousHtml\n    ? node.value\n    : (0,_text_js__WEBPACK_IMPORTED_MODULE_0__.text)(node, index, parent, state)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2hhbmRsZS9yYXcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLEtBQUs7QUFDakIsWUFBWSxPQUFPO0FBQ25COztBQUU4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsTUFBTSw4Q0FBSTtBQUNWIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL2hhc3QtdXRpbC10by1odG1sQDkuMC40L25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8taHRtbC9saWIvaGFuZGxlL3Jhdy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge1BhcmVudHN9IGZyb20gJ2hhc3QnXG4gKiBAaW1wb3J0IHtSYXd9IGZyb20gJ21kYXN0LXV0aWwtdG8taGFzdCdcbiAqIEBpbXBvcnQge1N0YXRlfSBmcm9tICcuLi9pbmRleC5qcydcbiAqL1xuXG5pbXBvcnQge3RleHR9IGZyb20gJy4vdGV4dC5qcydcblxuLyoqXG4gKiBTZXJpYWxpemUgYSByYXcgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1Jhd30gbm9kZVxuICogICBOb2RlIHRvIGhhbmRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBgbm9kZWAgaW4gYHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBgbm9kZWAuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBTZXJpYWxpemVkIG5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYXcobm9kZSwgaW5kZXgsIHBhcmVudCwgc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnNldHRpbmdzLmFsbG93RGFuZ2Vyb3VzSHRtbFxuICAgID8gbm9kZS52YWx1ZVxuICAgIDogdGV4dChub2RlLCBpbmRleCwgcGFyZW50LCBzdGF0ZSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/raw.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/root.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/root.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   root: () => (/* binding */ root)\n/* harmony export */ });\n/**\n * @import {Parents, Root} from 'hast'\n * @import {State} from '../index.js'\n */\n\n/**\n * Serialize a root.\n *\n * @param {Root} node\n *   Node to handle.\n * @param {number | undefined} _1\n *   Index of `node` in `parent.\n * @param {Parents | undefined} _2\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nfunction root(node, _1, _2, state) {\n  return state.all(node)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2hhbmRsZS9yb290LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL2hhc3QtdXRpbC10by1odG1sQDkuMC40L25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8taHRtbC9saWIvaGFuZGxlL3Jvb3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtQYXJlbnRzLCBSb290fSBmcm9tICdoYXN0J1xuICogQGltcG9ydCB7U3RhdGV9IGZyb20gJy4uL2luZGV4LmpzJ1xuICovXG5cbi8qKlxuICogU2VyaWFsaXplIGEgcm9vdC5cbiAqXG4gKiBAcGFyYW0ge1Jvb3R9IG5vZGVcbiAqICAgTm9kZSB0byBoYW5kbGUuXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gXzFcbiAqICAgSW5kZXggb2YgYG5vZGVgIGluIGBwYXJlbnQuXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IF8yXG4gKiAgIFBhcmVudCBvZiBgbm9kZWAuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBTZXJpYWxpemVkIG5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb290KG5vZGUsIF8xLCBfMiwgc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmFsbChub2RlKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/root.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/text.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/text.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   text: () => (/* binding */ text)\n/* harmony export */ });\n/* harmony import */ var stringify_entities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stringify-entities */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js\");\n/**\n * @import {Parents, Text} from 'hast'\n * @import {Raw} from 'mdast-util-to-hast'\n * @import {State} from '../index.js'\n */\n\n\n\n// Declare array as variable so it can be cached by `stringifyEntities`\nconst textEntitySubset = ['<', '&']\n\n/**\n * Serialize a text node.\n *\n * @param {Raw | Text} node\n *   Node to handle.\n * @param {number | undefined} _\n *   Index of `node` in `parent.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized node.\n */\nfunction text(node, _, parent, state) {\n  // Check if content of `node` should be escaped.\n  return parent &&\n    parent.type === 'element' &&\n    (parent.tagName === 'script' || parent.tagName === 'style')\n    ? node.value\n    : (0,stringify_entities__WEBPACK_IMPORTED_MODULE_0__.stringifyEntities)(\n        node.value,\n        Object.assign({}, state.settings.characterReferences, {\n          subset: textEntitySubset\n        })\n      )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2hhbmRsZS90ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxLQUFLO0FBQ2pCLFlBQVksT0FBTztBQUNuQjs7QUFFb0Q7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxRUFBaUI7QUFDdkI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2hhbmRsZS90ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7UGFyZW50cywgVGV4dH0gZnJvbSAnaGFzdCdcbiAqIEBpbXBvcnQge1Jhd30gZnJvbSAnbWRhc3QtdXRpbC10by1oYXN0J1xuICogQGltcG9ydCB7U3RhdGV9IGZyb20gJy4uL2luZGV4LmpzJ1xuICovXG5cbmltcG9ydCB7c3RyaW5naWZ5RW50aXRpZXN9IGZyb20gJ3N0cmluZ2lmeS1lbnRpdGllcydcblxuLy8gRGVjbGFyZSBhcnJheSBhcyB2YXJpYWJsZSBzbyBpdCBjYW4gYmUgY2FjaGVkIGJ5IGBzdHJpbmdpZnlFbnRpdGllc2BcbmNvbnN0IHRleHRFbnRpdHlTdWJzZXQgPSBbJzwnLCAnJiddXG5cbi8qKlxuICogU2VyaWFsaXplIGEgdGV4dCBub2RlLlxuICpcbiAqIEBwYXJhbSB7UmF3IHwgVGV4dH0gbm9kZVxuICogICBOb2RlIHRvIGhhbmRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBfXG4gKiAgIEluZGV4IG9mIGBub2RlYCBpbiBgcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBwYXJlbnRcbiAqICAgUGFyZW50IG9mIGBub2RlYC5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIFNlcmlhbGl6ZWQgbm9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQobm9kZSwgXywgcGFyZW50LCBzdGF0ZSkge1xuICAvLyBDaGVjayBpZiBjb250ZW50IG9mIGBub2RlYCBzaG91bGQgYmUgZXNjYXBlZC5cbiAgcmV0dXJuIHBhcmVudCAmJlxuICAgIHBhcmVudC50eXBlID09PSAnZWxlbWVudCcgJiZcbiAgICAocGFyZW50LnRhZ05hbWUgPT09ICdzY3JpcHQnIHx8IHBhcmVudC50YWdOYW1lID09PSAnc3R5bGUnKVxuICAgID8gbm9kZS52YWx1ZVxuICAgIDogc3RyaW5naWZ5RW50aXRpZXMoXG4gICAgICAgIG5vZGUudmFsdWUsXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnNldHRpbmdzLmNoYXJhY3RlclJlZmVyZW5jZXMsIHtcbiAgICAgICAgICBzdWJzZXQ6IHRleHRFbnRpdHlTdWJzZXRcbiAgICAgICAgfSlcbiAgICAgIClcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/text.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   all: () => (/* binding */ all),\n/* harmony export */   toHtml: () => (/* binding */ toHtml)\n/* harmony export */ });\n/* harmony import */ var html_void_elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! html-void-elements */ \"(app-pages-browser)/./node_modules/.pnpm/html-void-elements@3.0.0/node_modules/html-void-elements/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! property-information */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/index.js\");\n/* harmony import */ var _handle_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./handle/index.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/handle/index.js\");\n/**\n * @import {Nodes, Parents, RootContent} from 'hast'\n * @import {Schema} from 'property-information'\n * @import {Options as StringifyEntitiesOptions} from 'stringify-entities'\n */\n\n/**\n * @typedef {Omit<StringifyEntitiesOptions, 'attribute' | 'escapeOnly' | 'subset'>} CharacterReferences\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [allowDangerousCharacters=false]\n *   Do not encode some characters which cause XSS vulnerabilities in older\n *   browsers (default: `false`).\n *\n *   >  **Danger**: only set this if you completely trust the content.\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Allow `raw` nodes and insert them as raw HTML (default: `false`).\n *\n *   When `false`, `Raw` nodes are encoded.\n *\n *   >  **Danger**: only set this if you completely trust the content.\n * @property {boolean | null | undefined} [allowParseErrors=false]\n *   Do not encode characters which cause parse errors (even though they work),\n *   to save bytes (default: `false`).\n *\n *   Not used in the SVG space.\n *\n *   >  **Note**: intentionally creates parse errors in markup (how parse\n *   > errors are handled is well defined, so this works but isnt pretty).\n * @property {boolean | null | undefined} [bogusComments=false]\n *   Use bogus comments instead of comments to save byes: `<?charlie>`\n *   instead of `<!--charlie-->` (default: `false`).\n *\n *   >  **Note**: intentionally creates parse errors in markup (how parse\n *   > errors are handled is well defined, so this works but isnt pretty).\n * @property {CharacterReferences | null | undefined} [characterReferences]\n *   Configure how to serialize character references (optional).\n * @property {boolean | null | undefined} [closeEmptyElements=false]\n *   Close SVG elements without any content with slash (`/`) on the opening tag\n *   instead of an end tag: `<circle />` instead of `<circle></circle>`\n *   (default: `false`).\n *\n *   See `tightSelfClosing` to control whether a space is used before the\n *   slash.\n *\n *   Not used in the HTML space.\n * @property {boolean | null | undefined} [closeSelfClosing=false]\n *   Close self-closing nodes with an extra slash (`/`): `<img />` instead of\n *   `<img>` (default: `false`).\n *\n *   See `tightSelfClosing` to control whether a space is used before the\n *   slash.\n *\n *   Not used in the SVG space.\n * @property {boolean | null | undefined} [collapseEmptyAttributes=false]\n *   Collapse empty attributes: get `class` instead of `class=\"\"` (default:\n *   `false`).\n *\n *   Not used in the SVG space.\n *\n *   >  **Note**: boolean attributes (such as `hidden`) are always collapsed.\n * @property {boolean | null | undefined} [omitOptionalTags=false]\n *   Omit optional opening and closing tags (default: `false`).\n *\n *   For example, in `<ol><li>one</li><li>two</li></ol>`, both `</li>` closing\n *   tags can be omitted.\n *   The first because its followed by another `li`, the last because its\n *   followed by nothing.\n *\n *   Not used in the SVG space.\n * @property {boolean | null | undefined} [preferUnquoted=false]\n *   Leave attributes unquoted if that results in less bytes (default: `false`).\n *\n *   Not used in the SVG space.\n * @property {boolean | null | undefined} [quoteSmart=false]\n *   Use the other quote if that results in less bytes (default: `false`).\n * @property {Quote | null | undefined} [quote='\"']\n *   Preferred quote to use (default: `'\"'`).\n * @property {Space | null | undefined} [space='html']\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it (default: `'html'`).\n *\n *   >  **Note**: hast is not XML.\n *   > It supports SVG as embedded in HTML.\n *   > It does not support the features available in XML.\n *   > Passing SVG might break but fragments of modern SVG should be fine.\n *   > Use [`xast`][xast] if you need to support SVG as XML.\n * @property {boolean | null | undefined} [tightAttributes=false]\n *   Join attributes together, without whitespace, if possible: get\n *   `class=\"a b\"title=\"c d\"` instead of `class=\"a b\" title=\"c d\"` to save\n *   bytes (default: `false`).\n *\n *   Not used in the SVG space.\n *\n *   >  **Note**: intentionally creates parse errors in markup (how parse\n *   > errors are handled is well defined, so this works but isnt pretty).\n * @property {boolean | null | undefined} [tightCommaSeparatedLists=false]\n *   Join known comma-separated attribute values with just a comma (`,`),\n *   instead of padding them on the right as well (`,`, where `` represents a\n *   space) (default: `false`).\n * @property {boolean | null | undefined} [tightDoctype=false]\n *   Drop unneeded spaces in doctypes: `<!doctypehtml>` instead of\n *   `<!doctype html>` to save bytes (default: `false`).\n *\n *   >  **Note**: intentionally creates parse errors in markup (how parse\n *   > errors are handled is well defined, so this works but isnt pretty).\n * @property {boolean | null | undefined} [tightSelfClosing=false]\n *   Do not use an extra space when closing self-closing elements: `<img/>`\n *   instead of `<img />` (default: `false`).\n *\n *   >  **Note**: only used if `closeSelfClosing: true` or\n *   > `closeEmptyElements: true`.\n * @property {boolean | null | undefined} [upperDoctype=false]\n *   Use a `<!DOCTYPE` instead of `<!doctype` (default: `false`).\n *\n *   Useless except for XHTML.\n * @property {ReadonlyArray<string> | null | undefined} [voids]\n *   Tag names of elements to serialize without closing tag (default: `html-void-elements`).\n *\n *   Not used in the SVG space.\n *\n *   >  **Note**: Its highly unlikely that you want to pass this, because\n *   > hast is not for XML, and HTML will not add more void elements.\n *\n * @typedef {'\"' | \"'\"} Quote\n *   HTML quotes for attribute values.\n *\n * @typedef {Omit<Required<{[key in keyof Options]: Exclude<Options[key], null | undefined>}>, 'space' | 'quote'>} Settings\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {(node: Parents | undefined) => string} all\n *   Serialize the children of a parent node.\n * @property {Quote} alternative\n *   Alternative quote.\n * @property {(node: Nodes, index: number | undefined, parent: Parents | undefined) => string} one\n *   Serialize one node.\n * @property {Quote} quote\n *   Preferred quote.\n * @property {Schema} schema\n *   Current schema.\n * @property {Settings} settings\n *   User configuration.\n */\n\n\n\n\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/** @type {CharacterReferences} */\nconst emptyCharacterReferences = {}\n\n/** @type {Array<never>} */\nconst emptyChildren = []\n\n/**\n * Serialize hast as HTML.\n *\n * @param {Array<RootContent> | Nodes} tree\n *   Tree to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized HTML.\n */\nfunction toHtml(tree, options) {\n  const options_ = options || emptyOptions\n  const quote = options_.quote || '\"'\n  const alternative = quote === '\"' ? \"'\" : '\"'\n\n  if (quote !== '\"' && quote !== \"'\") {\n    throw new Error('Invalid quote `' + quote + '`, expected `\\'` or `\"`')\n  }\n\n  /** @type {State} */\n  const state = {\n    one,\n    all,\n    settings: {\n      omitOptionalTags: options_.omitOptionalTags || false,\n      allowParseErrors: options_.allowParseErrors || false,\n      allowDangerousCharacters: options_.allowDangerousCharacters || false,\n      quoteSmart: options_.quoteSmart || false,\n      preferUnquoted: options_.preferUnquoted || false,\n      tightAttributes: options_.tightAttributes || false,\n      upperDoctype: options_.upperDoctype || false,\n      tightDoctype: options_.tightDoctype || false,\n      bogusComments: options_.bogusComments || false,\n      tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,\n      tightSelfClosing: options_.tightSelfClosing || false,\n      collapseEmptyAttributes: options_.collapseEmptyAttributes || false,\n      allowDangerousHtml: options_.allowDangerousHtml || false,\n      voids: options_.voids || html_void_elements__WEBPACK_IMPORTED_MODULE_0__.htmlVoidElements,\n      characterReferences:\n        options_.characterReferences || emptyCharacterReferences,\n      closeSelfClosing: options_.closeSelfClosing || false,\n      closeEmptyElements: options_.closeEmptyElements || false\n    },\n    schema: options_.space === 'svg' ? property_information__WEBPACK_IMPORTED_MODULE_1__.svg : property_information__WEBPACK_IMPORTED_MODULE_1__.html,\n    quote,\n    alternative\n  }\n\n  return state.one(\n    Array.isArray(tree) ? {type: 'root', children: tree} : tree,\n    undefined,\n    undefined\n  )\n}\n\n/**\n * Serialize a node.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   Node to handle.\n * @param {number | undefined} index\n *   Index of `node` in `parent.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(node, index, parent) {\n  return (0,_handle_index_js__WEBPACK_IMPORTED_MODULE_2__.handle)(node, index, parent, this)\n}\n\n/**\n * Serialize all children of `parent`.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parents | undefined} parent\n *   Parent whose children to serialize.\n * @returns {string}\n */\nfunction all(parent) {\n  /** @type {Array<string>} */\n  const results = []\n  const children = (parent && parent.children) || emptyChildren\n  let index = -1\n\n  while (++index < children.length) {\n    results[index] = this.one(children[index], index, parent)\n  }\n\n  return results.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QyxZQUFZLFFBQVE7QUFDcEIsWUFBWSxxQ0FBcUM7QUFDakQ7O0FBRUE7QUFDQSxhQUFhLHVFQUF1RTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdDQUF3QztBQUN0RDtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQ0FBMEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBLGFBQWEsZUFBZSxnRUFBZ0UsdUJBQXVCO0FBQ25IO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVDQUF1QztBQUNyRDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsaUZBQWlGO0FBQy9GO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7O0FBRW1EO0FBQ0w7QUFDTjs7QUFFeEMsV0FBVyxTQUFTO0FBQ3BCOztBQUVBLFdBQVcscUJBQXFCO0FBQ2hDOztBQUVBLFdBQVcsY0FBYztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0VBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVDQUF1QyxxREFBRyxHQUFHLHNEQUFJO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vaGFzdC11dGlsLXRvLWh0bWxAOS4wLjQvbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1odG1sL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge05vZGVzLCBQYXJlbnRzLCBSb290Q29udGVudH0gZnJvbSAnaGFzdCdcbiAqIEBpbXBvcnQge1NjaGVtYX0gZnJvbSAncHJvcGVydHktaW5mb3JtYXRpb24nXG4gKiBAaW1wb3J0IHtPcHRpb25zIGFzIFN0cmluZ2lmeUVudGl0aWVzT3B0aW9uc30gZnJvbSAnc3RyaW5naWZ5LWVudGl0aWVzJ1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09taXQ8U3RyaW5naWZ5RW50aXRpZXNPcHRpb25zLCAnYXR0cmlidXRlJyB8ICdlc2NhcGVPbmx5JyB8ICdzdWJzZXQnPn0gQ2hhcmFjdGVyUmVmZXJlbmNlc1xuICpcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFthbGxvd0Rhbmdlcm91c0NoYXJhY3RlcnM9ZmFsc2VdXG4gKiAgIERvIG5vdCBlbmNvZGUgc29tZSBjaGFyYWN0ZXJzIHdoaWNoIGNhdXNlIFhTUyB2dWxuZXJhYmlsaXRpZXMgaW4gb2xkZXJcbiAqICAgYnJvd3NlcnMgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqICAgPiDimqDvuI8gKipEYW5nZXIqKjogb25seSBzZXQgdGhpcyBpZiB5b3UgY29tcGxldGVseSB0cnVzdCB0aGUgY29udGVudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFthbGxvd0Rhbmdlcm91c0h0bWw9ZmFsc2VdXG4gKiAgIEFsbG93IGByYXdgIG5vZGVzIGFuZCBpbnNlcnQgdGhlbSBhcyByYXcgSFRNTCAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKlxuICogICBXaGVuIGBmYWxzZWAsIGBSYXdgIG5vZGVzIGFyZSBlbmNvZGVkLlxuICpcbiAqICAgPiDimqDvuI8gKipEYW5nZXIqKjogb25seSBzZXQgdGhpcyBpZiB5b3UgY29tcGxldGVseSB0cnVzdCB0aGUgY29udGVudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFthbGxvd1BhcnNlRXJyb3JzPWZhbHNlXVxuICogICBEbyBub3QgZW5jb2RlIGNoYXJhY3RlcnMgd2hpY2ggY2F1c2UgcGFyc2UgZXJyb3JzIChldmVuIHRob3VnaCB0aGV5IHdvcmspLFxuICogICB0byBzYXZlIGJ5dGVzIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqXG4gKiAgIE5vdCB1c2VkIGluIHRoZSBTVkcgc3BhY2UuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IGludGVudGlvbmFsbHkgY3JlYXRlcyBwYXJzZSBlcnJvcnMgaW4gbWFya3VwIChob3cgcGFyc2VcbiAqICAgPiBlcnJvcnMgYXJlIGhhbmRsZWQgaXMgd2VsbCBkZWZpbmVkLCBzbyB0aGlzIHdvcmtzIGJ1dCBpc27igJl0IHByZXR0eSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbYm9ndXNDb21tZW50cz1mYWxzZV1cbiAqICAgVXNlIOKAnGJvZ3VzIGNvbW1lbnRz4oCdIGluc3RlYWQgb2YgY29tbWVudHMgdG8gc2F2ZSBieWVzOiBgPD9jaGFybGllPmBcbiAqICAgaW5zdGVhZCBvZiBgPCEtLWNoYXJsaWUtLT5gIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogaW50ZW50aW9uYWxseSBjcmVhdGVzIHBhcnNlIGVycm9ycyBpbiBtYXJrdXAgKGhvdyBwYXJzZVxuICogICA+IGVycm9ycyBhcmUgaGFuZGxlZCBpcyB3ZWxsIGRlZmluZWQsIHNvIHRoaXMgd29ya3MgYnV0IGlzbuKAmXQgcHJldHR5KS5cbiAqIEBwcm9wZXJ0eSB7Q2hhcmFjdGVyUmVmZXJlbmNlcyB8IG51bGwgfCB1bmRlZmluZWR9IFtjaGFyYWN0ZXJSZWZlcmVuY2VzXVxuICogICBDb25maWd1cmUgaG93IHRvIHNlcmlhbGl6ZSBjaGFyYWN0ZXIgcmVmZXJlbmNlcyAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Nsb3NlRW1wdHlFbGVtZW50cz1mYWxzZV1cbiAqICAgQ2xvc2UgU1ZHIGVsZW1lbnRzIHdpdGhvdXQgYW55IGNvbnRlbnQgd2l0aCBzbGFzaCAoYC9gKSBvbiB0aGUgb3BlbmluZyB0YWdcbiAqICAgaW5zdGVhZCBvZiBhbiBlbmQgdGFnOiBgPGNpcmNsZSAvPmAgaW5zdGVhZCBvZiBgPGNpcmNsZT48L2NpcmNsZT5gXG4gKiAgIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqXG4gKiAgIFNlZSBgdGlnaHRTZWxmQ2xvc2luZ2AgdG8gY29udHJvbCB3aGV0aGVyIGEgc3BhY2UgaXMgdXNlZCBiZWZvcmUgdGhlXG4gKiAgIHNsYXNoLlxuICpcbiAqICAgTm90IHVzZWQgaW4gdGhlIEhUTUwgc3BhY2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbY2xvc2VTZWxmQ2xvc2luZz1mYWxzZV1cbiAqICAgQ2xvc2Ugc2VsZi1jbG9zaW5nIG5vZGVzIHdpdGggYW4gZXh0cmEgc2xhc2ggKGAvYCk6IGA8aW1nIC8+YCBpbnN0ZWFkIG9mXG4gKiAgIGA8aW1nPmAgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqICAgU2VlIGB0aWdodFNlbGZDbG9zaW5nYCB0byBjb250cm9sIHdoZXRoZXIgYSBzcGFjZSBpcyB1c2VkIGJlZm9yZSB0aGVcbiAqICAgc2xhc2guXG4gKlxuICogICBOb3QgdXNlZCBpbiB0aGUgU1ZHIHNwYWNlLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2NvbGxhcHNlRW1wdHlBdHRyaWJ1dGVzPWZhbHNlXVxuICogICBDb2xsYXBzZSBlbXB0eSBhdHRyaWJ1dGVzOiBnZXQgYGNsYXNzYCBpbnN0ZWFkIG9mIGBjbGFzcz1cIlwiYCAoZGVmYXVsdDpcbiAqICAgYGZhbHNlYCkuXG4gKlxuICogICBOb3QgdXNlZCBpbiB0aGUgU1ZHIHNwYWNlLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBib29sZWFuIGF0dHJpYnV0ZXMgKHN1Y2ggYXMgYGhpZGRlbmApIGFyZSBhbHdheXMgY29sbGFwc2VkLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29taXRPcHRpb25hbFRhZ3M9ZmFsc2VdXG4gKiAgIE9taXQgb3B0aW9uYWwgb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqXG4gKiAgIEZvciBleGFtcGxlLCBpbiBgPG9sPjxsaT5vbmU8L2xpPjxsaT50d288L2xpPjwvb2w+YCwgYm90aCBgPC9saT5gIGNsb3NpbmdcbiAqICAgdGFncyBjYW4gYmUgb21pdHRlZC5cbiAqICAgVGhlIGZpcnN0IGJlY2F1c2UgaXTigJlzIGZvbGxvd2VkIGJ5IGFub3RoZXIgYGxpYCwgdGhlIGxhc3QgYmVjYXVzZSBpdOKAmXNcbiAqICAgZm9sbG93ZWQgYnkgbm90aGluZy5cbiAqXG4gKiAgIE5vdCB1c2VkIGluIHRoZSBTVkcgc3BhY2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJlZmVyVW5xdW90ZWQ9ZmFsc2VdXG4gKiAgIExlYXZlIGF0dHJpYnV0ZXMgdW5xdW90ZWQgaWYgdGhhdCByZXN1bHRzIGluIGxlc3MgYnl0ZXMgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqICAgTm90IHVzZWQgaW4gdGhlIFNWRyBzcGFjZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtxdW90ZVNtYXJ0PWZhbHNlXVxuICogICBVc2UgdGhlIG90aGVyIHF1b3RlIGlmIHRoYXQgcmVzdWx0cyBpbiBsZXNzIGJ5dGVzIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqIEBwcm9wZXJ0eSB7UXVvdGUgfCBudWxsIHwgdW5kZWZpbmVkfSBbcXVvdGU9J1wiJ11cbiAqICAgUHJlZmVycmVkIHF1b3RlIHRvIHVzZSAoZGVmYXVsdDogYCdcIidgKS5cbiAqIEBwcm9wZXJ0eSB7U3BhY2UgfCBudWxsIHwgdW5kZWZpbmVkfSBbc3BhY2U9J2h0bWwnXVxuICogICBXaGVuIGFuIGA8c3ZnPmAgZWxlbWVudCBpcyBmb3VuZCBpbiB0aGUgSFRNTCBzcGFjZSwgdGhpcyBwYWNrYWdlIGFscmVhZHlcbiAqICAgYXV0b21hdGljYWxseSBzd2l0Y2hlcyB0byBhbmQgZnJvbSB0aGUgU1ZHIHNwYWNlIHdoZW4gZW50ZXJpbmcgYW5kIGV4aXRpbmdcbiAqICAgaXQgKGRlZmF1bHQ6IGAnaHRtbCdgKS5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogaGFzdCBpcyBub3QgWE1MLlxuICogICA+IEl0IHN1cHBvcnRzIFNWRyBhcyBlbWJlZGRlZCBpbiBIVE1MLlxuICogICA+IEl0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGZlYXR1cmVzIGF2YWlsYWJsZSBpbiBYTUwuXG4gKiAgID4gUGFzc2luZyBTVkcgbWlnaHQgYnJlYWsgYnV0IGZyYWdtZW50cyBvZiBtb2Rlcm4gU1ZHIHNob3VsZCBiZSBmaW5lLlxuICogICA+IFVzZSBbYHhhc3RgXVt4YXN0XSBpZiB5b3UgbmVlZCB0byBzdXBwb3J0IFNWRyBhcyBYTUwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbdGlnaHRBdHRyaWJ1dGVzPWZhbHNlXVxuICogICBKb2luIGF0dHJpYnV0ZXMgdG9nZXRoZXIsIHdpdGhvdXQgd2hpdGVzcGFjZSwgaWYgcG9zc2libGU6IGdldFxuICogICBgY2xhc3M9XCJhIGJcInRpdGxlPVwiYyBkXCJgIGluc3RlYWQgb2YgYGNsYXNzPVwiYSBiXCIgdGl0bGU9XCJjIGRcImAgdG8gc2F2ZVxuICogICBieXRlcyAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKlxuICogICBOb3QgdXNlZCBpbiB0aGUgU1ZHIHNwYWNlLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBpbnRlbnRpb25hbGx5IGNyZWF0ZXMgcGFyc2UgZXJyb3JzIGluIG1hcmt1cCAoaG93IHBhcnNlXG4gKiAgID4gZXJyb3JzIGFyZSBoYW5kbGVkIGlzIHdlbGwgZGVmaW5lZCwgc28gdGhpcyB3b3JrcyBidXQgaXNu4oCZdCBwcmV0dHkpLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3RpZ2h0Q29tbWFTZXBhcmF0ZWRMaXN0cz1mYWxzZV1cbiAqICAgSm9pbiBrbm93biBjb21tYS1zZXBhcmF0ZWQgYXR0cmlidXRlIHZhbHVlcyB3aXRoIGp1c3QgYSBjb21tYSAoYCxgKSxcbiAqICAgaW5zdGVhZCBvZiBwYWRkaW5nIHRoZW0gb24gdGhlIHJpZ2h0IGFzIHdlbGwgKGAs4pCgYCwgd2hlcmUgYOKQoGAgcmVwcmVzZW50cyBhXG4gKiAgIHNwYWNlKSAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbdGlnaHREb2N0eXBlPWZhbHNlXVxuICogICBEcm9wIHVubmVlZGVkIHNwYWNlcyBpbiBkb2N0eXBlczogYDwhZG9jdHlwZWh0bWw+YCBpbnN0ZWFkIG9mXG4gKiAgIGA8IWRvY3R5cGUgaHRtbD5gIHRvIHNhdmUgYnl0ZXMgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBpbnRlbnRpb25hbGx5IGNyZWF0ZXMgcGFyc2UgZXJyb3JzIGluIG1hcmt1cCAoaG93IHBhcnNlXG4gKiAgID4gZXJyb3JzIGFyZSBoYW5kbGVkIGlzIHdlbGwgZGVmaW5lZCwgc28gdGhpcyB3b3JrcyBidXQgaXNu4oCZdCBwcmV0dHkpLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3RpZ2h0U2VsZkNsb3Npbmc9ZmFsc2VdXG4gKiAgIERvIG5vdCB1c2UgYW4gZXh0cmEgc3BhY2Ugd2hlbiBjbG9zaW5nIHNlbGYtY2xvc2luZyBlbGVtZW50czogYDxpbWcvPmBcbiAqICAgaW5zdGVhZCBvZiBgPGltZyAvPmAgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBvbmx5IHVzZWQgaWYgYGNsb3NlU2VsZkNsb3Npbmc6IHRydWVgIG9yXG4gKiAgID4gYGNsb3NlRW1wdHlFbGVtZW50czogdHJ1ZWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbdXBwZXJEb2N0eXBlPWZhbHNlXVxuICogICBVc2UgYSBgPCFET0NUWVBF4oCmYCBpbnN0ZWFkIG9mIGA8IWRvY3R5cGXigKZgIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqXG4gKiAgIFVzZWxlc3MgZXhjZXB0IGZvciBYSFRNTC5cbiAqIEBwcm9wZXJ0eSB7UmVhZG9ubHlBcnJheTxzdHJpbmc+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ZvaWRzXVxuICogICBUYWcgbmFtZXMgb2YgZWxlbWVudHMgdG8gc2VyaWFsaXplIHdpdGhvdXQgY2xvc2luZyB0YWcgKGRlZmF1bHQ6IGBodG1sLXZvaWQtZWxlbWVudHNgKS5cbiAqXG4gKiAgIE5vdCB1c2VkIGluIHRoZSBTVkcgc3BhY2UuXG4gKlxuICogICA+IPCfkYkgKipOb3RlKio6IEl04oCZcyBoaWdobHkgdW5saWtlbHkgdGhhdCB5b3Ugd2FudCB0byBwYXNzIHRoaXMsIGJlY2F1c2VcbiAqICAgPiBoYXN0IGlzIG5vdCBmb3IgWE1MLCBhbmQgSFRNTCB3aWxsIG5vdCBhZGQgbW9yZSB2b2lkIGVsZW1lbnRzLlxuICpcbiAqIEB0eXBlZGVmIHsnXCInIHwgXCInXCJ9IFF1b3RlXG4gKiAgIEhUTUwgcXVvdGVzIGZvciBhdHRyaWJ1dGUgdmFsdWVzLlxuICpcbiAqIEB0eXBlZGVmIHtPbWl0PFJlcXVpcmVkPHtba2V5IGluIGtleW9mIE9wdGlvbnNdOiBFeGNsdWRlPE9wdGlvbnNba2V5XSwgbnVsbCB8IHVuZGVmaW5lZD59PiwgJ3NwYWNlJyB8ICdxdW90ZSc+fSBTZXR0aW5nc1xuICpcbiAqIEB0eXBlZGVmIHsnaHRtbCcgfCAnc3ZnJ30gU3BhY2VcbiAqICAgTmFtZXNwYWNlLlxuICpcbiAqIEB0eXBlZGVmIFN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7KG5vZGU6IFBhcmVudHMgfCB1bmRlZmluZWQpID0+IHN0cmluZ30gYWxsXG4gKiAgIFNlcmlhbGl6ZSB0aGUgY2hpbGRyZW4gb2YgYSBwYXJlbnQgbm9kZS5cbiAqIEBwcm9wZXJ0eSB7UXVvdGV9IGFsdGVybmF0aXZlXG4gKiAgIEFsdGVybmF0aXZlIHF1b3RlLlxuICogQHByb3BlcnR5IHsobm9kZTogTm9kZXMsIGluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQsIHBhcmVudDogUGFyZW50cyB8IHVuZGVmaW5lZCkgPT4gc3RyaW5nfSBvbmVcbiAqICAgU2VyaWFsaXplIG9uZSBub2RlLlxuICogQHByb3BlcnR5IHtRdW90ZX0gcXVvdGVcbiAqICAgUHJlZmVycmVkIHF1b3RlLlxuICogQHByb3BlcnR5IHtTY2hlbWF9IHNjaGVtYVxuICogICBDdXJyZW50IHNjaGVtYS5cbiAqIEBwcm9wZXJ0eSB7U2V0dGluZ3N9IHNldHRpbmdzXG4gKiAgIFVzZXIgY29uZmlndXJhdGlvbi5cbiAqL1xuXG5pbXBvcnQge2h0bWxWb2lkRWxlbWVudHN9IGZyb20gJ2h0bWwtdm9pZC1lbGVtZW50cydcbmltcG9ydCB7aHRtbCwgc3ZnfSBmcm9tICdwcm9wZXJ0eS1pbmZvcm1hdGlvbidcbmltcG9ydCB7aGFuZGxlfSBmcm9tICcuL2hhbmRsZS9pbmRleC5qcydcblxuLyoqIEB0eXBlIHtPcHRpb25zfSAqL1xuY29uc3QgZW1wdHlPcHRpb25zID0ge31cblxuLyoqIEB0eXBlIHtDaGFyYWN0ZXJSZWZlcmVuY2VzfSAqL1xuY29uc3QgZW1wdHlDaGFyYWN0ZXJSZWZlcmVuY2VzID0ge31cblxuLyoqIEB0eXBlIHtBcnJheTxuZXZlcj59ICovXG5jb25zdCBlbXB0eUNoaWxkcmVuID0gW11cblxuLyoqXG4gKiBTZXJpYWxpemUgaGFzdCBhcyBIVE1MLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Um9vdENvbnRlbnQ+IHwgTm9kZXN9IHRyZWVcbiAqICAgVHJlZSB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgU2VyaWFsaXplZCBIVE1MLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IdG1sKHRyZWUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9uc18gPSBvcHRpb25zIHx8IGVtcHR5T3B0aW9uc1xuICBjb25zdCBxdW90ZSA9IG9wdGlvbnNfLnF1b3RlIHx8ICdcIidcbiAgY29uc3QgYWx0ZXJuYXRpdmUgPSBxdW90ZSA9PT0gJ1wiJyA/IFwiJ1wiIDogJ1wiJ1xuXG4gIGlmIChxdW90ZSAhPT0gJ1wiJyAmJiBxdW90ZSAhPT0gXCInXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcXVvdGUgYCcgKyBxdW90ZSArICdgLCBleHBlY3RlZCBgXFwnYCBvciBgXCJgJylcbiAgfVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIG9uZSxcbiAgICBhbGwsXG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIG9taXRPcHRpb25hbFRhZ3M6IG9wdGlvbnNfLm9taXRPcHRpb25hbFRhZ3MgfHwgZmFsc2UsXG4gICAgICBhbGxvd1BhcnNlRXJyb3JzOiBvcHRpb25zXy5hbGxvd1BhcnNlRXJyb3JzIHx8IGZhbHNlLFxuICAgICAgYWxsb3dEYW5nZXJvdXNDaGFyYWN0ZXJzOiBvcHRpb25zXy5hbGxvd0Rhbmdlcm91c0NoYXJhY3RlcnMgfHwgZmFsc2UsXG4gICAgICBxdW90ZVNtYXJ0OiBvcHRpb25zXy5xdW90ZVNtYXJ0IHx8IGZhbHNlLFxuICAgICAgcHJlZmVyVW5xdW90ZWQ6IG9wdGlvbnNfLnByZWZlclVucXVvdGVkIHx8IGZhbHNlLFxuICAgICAgdGlnaHRBdHRyaWJ1dGVzOiBvcHRpb25zXy50aWdodEF0dHJpYnV0ZXMgfHwgZmFsc2UsXG4gICAgICB1cHBlckRvY3R5cGU6IG9wdGlvbnNfLnVwcGVyRG9jdHlwZSB8fCBmYWxzZSxcbiAgICAgIHRpZ2h0RG9jdHlwZTogb3B0aW9uc18udGlnaHREb2N0eXBlIHx8IGZhbHNlLFxuICAgICAgYm9ndXNDb21tZW50czogb3B0aW9uc18uYm9ndXNDb21tZW50cyB8fCBmYWxzZSxcbiAgICAgIHRpZ2h0Q29tbWFTZXBhcmF0ZWRMaXN0czogb3B0aW9uc18udGlnaHRDb21tYVNlcGFyYXRlZExpc3RzIHx8IGZhbHNlLFxuICAgICAgdGlnaHRTZWxmQ2xvc2luZzogb3B0aW9uc18udGlnaHRTZWxmQ2xvc2luZyB8fCBmYWxzZSxcbiAgICAgIGNvbGxhcHNlRW1wdHlBdHRyaWJ1dGVzOiBvcHRpb25zXy5jb2xsYXBzZUVtcHR5QXR0cmlidXRlcyB8fCBmYWxzZSxcbiAgICAgIGFsbG93RGFuZ2Vyb3VzSHRtbDogb3B0aW9uc18uYWxsb3dEYW5nZXJvdXNIdG1sIHx8IGZhbHNlLFxuICAgICAgdm9pZHM6IG9wdGlvbnNfLnZvaWRzIHx8IGh0bWxWb2lkRWxlbWVudHMsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VzOlxuICAgICAgICBvcHRpb25zXy5jaGFyYWN0ZXJSZWZlcmVuY2VzIHx8IGVtcHR5Q2hhcmFjdGVyUmVmZXJlbmNlcyxcbiAgICAgIGNsb3NlU2VsZkNsb3Npbmc6IG9wdGlvbnNfLmNsb3NlU2VsZkNsb3NpbmcgfHwgZmFsc2UsXG4gICAgICBjbG9zZUVtcHR5RWxlbWVudHM6IG9wdGlvbnNfLmNsb3NlRW1wdHlFbGVtZW50cyB8fCBmYWxzZVxuICAgIH0sXG4gICAgc2NoZW1hOiBvcHRpb25zXy5zcGFjZSA9PT0gJ3N2ZycgPyBzdmcgOiBodG1sLFxuICAgIHF1b3RlLFxuICAgIGFsdGVybmF0aXZlXG4gIH1cblxuICByZXR1cm4gc3RhdGUub25lKFxuICAgIEFycmF5LmlzQXJyYXkodHJlZSkgPyB7dHlwZTogJ3Jvb3QnLCBjaGlsZHJlbjogdHJlZX0gOiB0cmVlLFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWRcbiAgKVxufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBhIG5vZGUuXG4gKlxuICogQHRoaXMge1N0YXRlfVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0ge05vZGVzfSBub2RlXG4gKiAgIE5vZGUgdG8gaGFuZGxlLlxuICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGluZGV4XG4gKiAgIEluZGV4IG9mIGBub2RlYCBpbiBgcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBwYXJlbnRcbiAqICAgUGFyZW50IG9mIGBub2RlYC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIFNlcmlhbGl6ZWQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gb25lKG5vZGUsIGluZGV4LCBwYXJlbnQpIHtcbiAgcmV0dXJuIGhhbmRsZShub2RlLCBpbmRleCwgcGFyZW50LCB0aGlzKVxufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBhbGwgY2hpbGRyZW4gb2YgYHBhcmVudGAuXG4gKlxuICogQHRoaXMge1N0YXRlfVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IHBhcmVudFxuICogICBQYXJlbnQgd2hvc2UgY2hpbGRyZW4gdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsbChwYXJlbnQpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCByZXN1bHRzID0gW11cbiAgY29uc3QgY2hpbGRyZW4gPSAocGFyZW50ICYmIHBhcmVudC5jaGlsZHJlbikgfHwgZW1wdHlDaGlsZHJlblxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmVzdWx0c1tpbmRleF0gPSB0aGlzLm9uZShjaGlsZHJlbltpbmRleF0sIGluZGV4LCBwYXJlbnQpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0cy5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/closing.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/closing.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closing: () => (/* binding */ closing)\n/* harmony export */ });\n/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-whitespace */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js\");\n/* harmony import */ var _util_siblings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/siblings.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/util/siblings.js\");\n/* harmony import */ var _omission_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./omission.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/omission.js\");\n/**\n * @import {Element, Parents} from 'hast'\n */\n\n\n\n\n\nconst closing = (0,_omission_js__WEBPACK_IMPORTED_MODULE_0__.omission)({\n  body,\n  caption: headOrColgroupOrCaption,\n  colgroup: headOrColgroupOrCaption,\n  dd,\n  dt,\n  head: headOrColgroupOrCaption,\n  html,\n  li,\n  optgroup,\n  option,\n  p,\n  rp: rubyElement,\n  rt: rubyElement,\n  tbody,\n  td: cells,\n  tfoot,\n  th: cells,\n  thead,\n  tr\n})\n\n/**\n * Macro for `</head>`, `</colgroup>`, and `</caption>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction headOrColgroupOrCaption(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index, true)\n  return (\n    !next ||\n    (next.type !== 'comment' &&\n      !(next.type === 'text' && (0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__.whitespace)(next.value.charAt(0))))\n  )\n}\n\n/**\n * Whether to omit `</html>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction html(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return !next || next.type !== 'comment'\n}\n\n/**\n * Whether to omit `</body>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction body(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return !next || next.type !== 'comment'\n}\n\n/**\n * Whether to omit `</p>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction p(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return next\n    ? next.type === 'element' &&\n        (next.tagName === 'address' ||\n          next.tagName === 'article' ||\n          next.tagName === 'aside' ||\n          next.tagName === 'blockquote' ||\n          next.tagName === 'details' ||\n          next.tagName === 'div' ||\n          next.tagName === 'dl' ||\n          next.tagName === 'fieldset' ||\n          next.tagName === 'figcaption' ||\n          next.tagName === 'figure' ||\n          next.tagName === 'footer' ||\n          next.tagName === 'form' ||\n          next.tagName === 'h1' ||\n          next.tagName === 'h2' ||\n          next.tagName === 'h3' ||\n          next.tagName === 'h4' ||\n          next.tagName === 'h5' ||\n          next.tagName === 'h6' ||\n          next.tagName === 'header' ||\n          next.tagName === 'hgroup' ||\n          next.tagName === 'hr' ||\n          next.tagName === 'main' ||\n          next.tagName === 'menu' ||\n          next.tagName === 'nav' ||\n          next.tagName === 'ol' ||\n          next.tagName === 'p' ||\n          next.tagName === 'pre' ||\n          next.tagName === 'section' ||\n          next.tagName === 'table' ||\n          next.tagName === 'ul')\n    : !parent ||\n        // Confusing parent.\n        !(\n          parent.type === 'element' &&\n          (parent.tagName === 'a' ||\n            parent.tagName === 'audio' ||\n            parent.tagName === 'del' ||\n            parent.tagName === 'ins' ||\n            parent.tagName === 'map' ||\n            parent.tagName === 'noscript' ||\n            parent.tagName === 'video')\n        )\n}\n\n/**\n * Whether to omit `</li>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction li(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return !next || (next.type === 'element' && next.tagName === 'li')\n}\n\n/**\n * Whether to omit `</dt>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction dt(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return Boolean(\n    next &&\n      next.type === 'element' &&\n      (next.tagName === 'dt' || next.tagName === 'dd')\n  )\n}\n\n/**\n * Whether to omit `</dd>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction dd(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'dt' || next.tagName === 'dd'))\n  )\n}\n\n/**\n * Whether to omit `</rt>` or `</rp>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction rubyElement(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'rp' || next.tagName === 'rt'))\n  )\n}\n\n/**\n * Whether to omit `</optgroup>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction optgroup(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return !next || (next.type === 'element' && next.tagName === 'optgroup')\n}\n\n/**\n * Whether to omit `</option>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction option(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'option' || next.tagName === 'optgroup'))\n  )\n}\n\n/**\n * Whether to omit `</thead>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction thead(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return Boolean(\n    next &&\n      next.type === 'element' &&\n      (next.tagName === 'tbody' || next.tagName === 'tfoot')\n  )\n}\n\n/**\n * Whether to omit `</tbody>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction tbody(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'tbody' || next.tagName === 'tfoot'))\n  )\n}\n\n/**\n * Whether to omit `</tfoot>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction tfoot(_, index, parent) {\n  return !(0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n}\n\n/**\n * Whether to omit `</tr>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction tr(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return !next || (next.type === 'element' && next.tagName === 'tr')\n}\n\n/**\n * Whether to omit `</td>` or `</th>`.\n *\n * @param {Element} _\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the closing tag can be omitted.\n */\nfunction cells(_, index, parent) {\n  const next = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(parent, index)\n  return (\n    !next ||\n    (next.type === 'element' &&\n      (next.tagName === 'td' || next.tagName === 'th'))\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL29taXNzaW9uL2Nsb3NpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7O0FBRStDO0FBQ0E7QUFDVDs7QUFFL0IsZ0JBQWdCLHNEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFVO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFZO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFZO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFZO0FBQzNC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QUFlLCtEQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL29taXNzaW9uL2Nsb3NpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtFbGVtZW50LCBQYXJlbnRzfSBmcm9tICdoYXN0J1xuICovXG5cbmltcG9ydCB7d2hpdGVzcGFjZX0gZnJvbSAnaGFzdC11dGlsLXdoaXRlc3BhY2UnXG5pbXBvcnQge3NpYmxpbmdBZnRlcn0gZnJvbSAnLi91dGlsL3NpYmxpbmdzLmpzJ1xuaW1wb3J0IHtvbWlzc2lvbn0gZnJvbSAnLi9vbWlzc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IGNsb3NpbmcgPSBvbWlzc2lvbih7XG4gIGJvZHksXG4gIGNhcHRpb246IGhlYWRPckNvbGdyb3VwT3JDYXB0aW9uLFxuICBjb2xncm91cDogaGVhZE9yQ29sZ3JvdXBPckNhcHRpb24sXG4gIGRkLFxuICBkdCxcbiAgaGVhZDogaGVhZE9yQ29sZ3JvdXBPckNhcHRpb24sXG4gIGh0bWwsXG4gIGxpLFxuICBvcHRncm91cCxcbiAgb3B0aW9uLFxuICBwLFxuICBycDogcnVieUVsZW1lbnQsXG4gIHJ0OiBydWJ5RWxlbWVudCxcbiAgdGJvZHksXG4gIHRkOiBjZWxscyxcbiAgdGZvb3QsXG4gIHRoOiBjZWxscyxcbiAgdGhlYWQsXG4gIHRyXG59KVxuXG4vKipcbiAqIE1hY3JvIGZvciBgPC9oZWFkPmAsIGA8L2NvbGdyb3VwPmAsIGFuZCBgPC9jYXB0aW9uPmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBfXG4gKiAgIEVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gaW5kZXhcbiAqICAgSW5kZXggb2YgZWxlbWVudCBpbiBwYXJlbnQuXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IHBhcmVudFxuICogICBQYXJlbnQgb2YgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoZSBjbG9zaW5nIHRhZyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuZnVuY3Rpb24gaGVhZE9yQ29sZ3JvdXBPckNhcHRpb24oXywgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCBuZXh0ID0gc2libGluZ0FmdGVyKHBhcmVudCwgaW5kZXgsIHRydWUpXG4gIHJldHVybiAoXG4gICAgIW5leHQgfHxcbiAgICAobmV4dC50eXBlICE9PSAnY29tbWVudCcgJiZcbiAgICAgICEobmV4dC50eXBlID09PSAndGV4dCcgJiYgd2hpdGVzcGFjZShuZXh0LnZhbHVlLmNoYXJBdCgwKSkpKVxuICApXG59XG5cbi8qKlxuICogV2hldGhlciB0byBvbWl0IGA8L2h0bWw+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IF9cbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBlbGVtZW50IGluIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhlIGNsb3NpbmcgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiBodG1sKF8sIGluZGV4LCBwYXJlbnQpIHtcbiAgY29uc3QgbmV4dCA9IHNpYmxpbmdBZnRlcihwYXJlbnQsIGluZGV4KVxuICByZXR1cm4gIW5leHQgfHwgbmV4dC50eXBlICE9PSAnY29tbWVudCdcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRvIG9taXQgYDwvYm9keT5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gX1xuICogICBFbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGluZGV4XG4gKiAgIEluZGV4IG9mIGVsZW1lbnQgaW4gcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBwYXJlbnRcbiAqICAgUGFyZW50IG9mIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqICAgV2hldGhlciB0aGUgY2xvc2luZyB0YWcgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbmZ1bmN0aW9uIGJvZHkoXywgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCBuZXh0ID0gc2libGluZ0FmdGVyKHBhcmVudCwgaW5kZXgpXG4gIHJldHVybiAhbmV4dCB8fCBuZXh0LnR5cGUgIT09ICdjb21tZW50J1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdG8gb21pdCBgPC9wPmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBfXG4gKiAgIEVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gaW5kZXhcbiAqICAgSW5kZXggb2YgZWxlbWVudCBpbiBwYXJlbnQuXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IHBhcmVudFxuICogICBQYXJlbnQgb2YgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoZSBjbG9zaW5nIHRhZyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuZnVuY3Rpb24gcChfLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IG5leHQgPSBzaWJsaW5nQWZ0ZXIocGFyZW50LCBpbmRleClcbiAgcmV0dXJuIG5leHRcbiAgICA/IG5leHQudHlwZSA9PT0gJ2VsZW1lbnQnICYmXG4gICAgICAgIChuZXh0LnRhZ05hbWUgPT09ICdhZGRyZXNzJyB8fFxuICAgICAgICAgIG5leHQudGFnTmFtZSA9PT0gJ2FydGljbGUnIHx8XG4gICAgICAgICAgbmV4dC50YWdOYW1lID09PSAnYXNpZGUnIHx8XG4gICAgICAgICAgbmV4dC50YWdOYW1lID09PSAnYmxvY2txdW90ZScgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdkZXRhaWxzJyB8fFxuICAgICAgICAgIG5leHQudGFnTmFtZSA9PT0gJ2RpdicgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdkbCcgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdmaWVsZHNldCcgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdmaWdjYXB0aW9uJyB8fFxuICAgICAgICAgIG5leHQudGFnTmFtZSA9PT0gJ2ZpZ3VyZScgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdmb290ZXInIHx8XG4gICAgICAgICAgbmV4dC50YWdOYW1lID09PSAnZm9ybScgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdoMScgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdoMicgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdoMycgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdoNCcgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdoNScgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdoNicgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdoZWFkZXInIHx8XG4gICAgICAgICAgbmV4dC50YWdOYW1lID09PSAnaGdyb3VwJyB8fFxuICAgICAgICAgIG5leHQudGFnTmFtZSA9PT0gJ2hyJyB8fFxuICAgICAgICAgIG5leHQudGFnTmFtZSA9PT0gJ21haW4nIHx8XG4gICAgICAgICAgbmV4dC50YWdOYW1lID09PSAnbWVudScgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICduYXYnIHx8XG4gICAgICAgICAgbmV4dC50YWdOYW1lID09PSAnb2wnIHx8XG4gICAgICAgICAgbmV4dC50YWdOYW1lID09PSAncCcgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICdwcmUnIHx8XG4gICAgICAgICAgbmV4dC50YWdOYW1lID09PSAnc2VjdGlvbicgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICd0YWJsZScgfHxcbiAgICAgICAgICBuZXh0LnRhZ05hbWUgPT09ICd1bCcpXG4gICAgOiAhcGFyZW50IHx8XG4gICAgICAgIC8vIENvbmZ1c2luZyBwYXJlbnQuXG4gICAgICAgICEoXG4gICAgICAgICAgcGFyZW50LnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgICAgICAgIChwYXJlbnQudGFnTmFtZSA9PT0gJ2EnIHx8XG4gICAgICAgICAgICBwYXJlbnQudGFnTmFtZSA9PT0gJ2F1ZGlvJyB8fFxuICAgICAgICAgICAgcGFyZW50LnRhZ05hbWUgPT09ICdkZWwnIHx8XG4gICAgICAgICAgICBwYXJlbnQudGFnTmFtZSA9PT0gJ2lucycgfHxcbiAgICAgICAgICAgIHBhcmVudC50YWdOYW1lID09PSAnbWFwJyB8fFxuICAgICAgICAgICAgcGFyZW50LnRhZ05hbWUgPT09ICdub3NjcmlwdCcgfHxcbiAgICAgICAgICAgIHBhcmVudC50YWdOYW1lID09PSAndmlkZW8nKVxuICAgICAgICApXG59XG5cbi8qKlxuICogV2hldGhlciB0byBvbWl0IGA8L2xpPmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBfXG4gKiAgIEVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gaW5kZXhcbiAqICAgSW5kZXggb2YgZWxlbWVudCBpbiBwYXJlbnQuXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IHBhcmVudFxuICogICBQYXJlbnQgb2YgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoZSBjbG9zaW5nIHRhZyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuZnVuY3Rpb24gbGkoXywgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCBuZXh0ID0gc2libGluZ0FmdGVyKHBhcmVudCwgaW5kZXgpXG4gIHJldHVybiAhbmV4dCB8fCAobmV4dC50eXBlID09PSAnZWxlbWVudCcgJiYgbmV4dC50YWdOYW1lID09PSAnbGknKVxufVxuXG4vKipcbiAqIFdoZXRoZXIgdG8gb21pdCBgPC9kdD5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gX1xuICogICBFbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGluZGV4XG4gKiAgIEluZGV4IG9mIGVsZW1lbnQgaW4gcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBwYXJlbnRcbiAqICAgUGFyZW50IG9mIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqICAgV2hldGhlciB0aGUgY2xvc2luZyB0YWcgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbmZ1bmN0aW9uIGR0KF8sIGluZGV4LCBwYXJlbnQpIHtcbiAgY29uc3QgbmV4dCA9IHNpYmxpbmdBZnRlcihwYXJlbnQsIGluZGV4KVxuICByZXR1cm4gQm9vbGVhbihcbiAgICBuZXh0ICYmXG4gICAgICBuZXh0LnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgICAgKG5leHQudGFnTmFtZSA9PT0gJ2R0JyB8fCBuZXh0LnRhZ05hbWUgPT09ICdkZCcpXG4gIClcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRvIG9taXQgYDwvZGQ+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IF9cbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBlbGVtZW50IGluIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhlIGNsb3NpbmcgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiBkZChfLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IG5leHQgPSBzaWJsaW5nQWZ0ZXIocGFyZW50LCBpbmRleClcbiAgcmV0dXJuIChcbiAgICAhbmV4dCB8fFxuICAgIChuZXh0LnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgICAgKG5leHQudGFnTmFtZSA9PT0gJ2R0JyB8fCBuZXh0LnRhZ05hbWUgPT09ICdkZCcpKVxuICApXG59XG5cbi8qKlxuICogV2hldGhlciB0byBvbWl0IGA8L3J0PmAgb3IgYDwvcnA+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IF9cbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBlbGVtZW50IGluIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhlIGNsb3NpbmcgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiBydWJ5RWxlbWVudChfLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IG5leHQgPSBzaWJsaW5nQWZ0ZXIocGFyZW50LCBpbmRleClcbiAgcmV0dXJuIChcbiAgICAhbmV4dCB8fFxuICAgIChuZXh0LnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgICAgKG5leHQudGFnTmFtZSA9PT0gJ3JwJyB8fCBuZXh0LnRhZ05hbWUgPT09ICdydCcpKVxuICApXG59XG5cbi8qKlxuICogV2hldGhlciB0byBvbWl0IGA8L29wdGdyb3VwPmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBfXG4gKiAgIEVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gaW5kZXhcbiAqICAgSW5kZXggb2YgZWxlbWVudCBpbiBwYXJlbnQuXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IHBhcmVudFxuICogICBQYXJlbnQgb2YgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoZSBjbG9zaW5nIHRhZyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuZnVuY3Rpb24gb3B0Z3JvdXAoXywgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCBuZXh0ID0gc2libGluZ0FmdGVyKHBhcmVudCwgaW5kZXgpXG4gIHJldHVybiAhbmV4dCB8fCAobmV4dC50eXBlID09PSAnZWxlbWVudCcgJiYgbmV4dC50YWdOYW1lID09PSAnb3B0Z3JvdXAnKVxufVxuXG4vKipcbiAqIFdoZXRoZXIgdG8gb21pdCBgPC9vcHRpb24+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IF9cbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBlbGVtZW50IGluIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhlIGNsb3NpbmcgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiBvcHRpb24oXywgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCBuZXh0ID0gc2libGluZ0FmdGVyKHBhcmVudCwgaW5kZXgpXG4gIHJldHVybiAoXG4gICAgIW5leHQgfHxcbiAgICAobmV4dC50eXBlID09PSAnZWxlbWVudCcgJiZcbiAgICAgIChuZXh0LnRhZ05hbWUgPT09ICdvcHRpb24nIHx8IG5leHQudGFnTmFtZSA9PT0gJ29wdGdyb3VwJykpXG4gIClcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRvIG9taXQgYDwvdGhlYWQ+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IF9cbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBlbGVtZW50IGluIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhlIGNsb3NpbmcgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiB0aGVhZChfLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IG5leHQgPSBzaWJsaW5nQWZ0ZXIocGFyZW50LCBpbmRleClcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgbmV4dCAmJlxuICAgICAgbmV4dC50eXBlID09PSAnZWxlbWVudCcgJiZcbiAgICAgIChuZXh0LnRhZ05hbWUgPT09ICd0Ym9keScgfHwgbmV4dC50YWdOYW1lID09PSAndGZvb3QnKVxuICApXG59XG5cbi8qKlxuICogV2hldGhlciB0byBvbWl0IGA8L3Rib2R5PmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBfXG4gKiAgIEVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gaW5kZXhcbiAqICAgSW5kZXggb2YgZWxlbWVudCBpbiBwYXJlbnQuXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IHBhcmVudFxuICogICBQYXJlbnQgb2YgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoZSBjbG9zaW5nIHRhZyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuZnVuY3Rpb24gdGJvZHkoXywgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCBuZXh0ID0gc2libGluZ0FmdGVyKHBhcmVudCwgaW5kZXgpXG4gIHJldHVybiAoXG4gICAgIW5leHQgfHxcbiAgICAobmV4dC50eXBlID09PSAnZWxlbWVudCcgJiZcbiAgICAgIChuZXh0LnRhZ05hbWUgPT09ICd0Ym9keScgfHwgbmV4dC50YWdOYW1lID09PSAndGZvb3QnKSlcbiAgKVxufVxuXG4vKipcbiAqIFdoZXRoZXIgdG8gb21pdCBgPC90Zm9vdD5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gX1xuICogICBFbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGluZGV4XG4gKiAgIEluZGV4IG9mIGVsZW1lbnQgaW4gcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBwYXJlbnRcbiAqICAgUGFyZW50IG9mIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqICAgV2hldGhlciB0aGUgY2xvc2luZyB0YWcgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRmb290KF8sIGluZGV4LCBwYXJlbnQpIHtcbiAgcmV0dXJuICFzaWJsaW5nQWZ0ZXIocGFyZW50LCBpbmRleClcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRvIG9taXQgYDwvdHI+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IF9cbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBlbGVtZW50IGluIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhlIGNsb3NpbmcgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiB0cihfLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IG5leHQgPSBzaWJsaW5nQWZ0ZXIocGFyZW50LCBpbmRleClcbiAgcmV0dXJuICFuZXh0IHx8IChuZXh0LnR5cGUgPT09ICdlbGVtZW50JyAmJiBuZXh0LnRhZ05hbWUgPT09ICd0cicpXG59XG5cbi8qKlxuICogV2hldGhlciB0byBvbWl0IGA8L3RkPmAgb3IgYDwvdGg+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IF9cbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBlbGVtZW50IGluIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhlIGNsb3NpbmcgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiBjZWxscyhfLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IG5leHQgPSBzaWJsaW5nQWZ0ZXIocGFyZW50LCBpbmRleClcbiAgcmV0dXJuIChcbiAgICAhbmV4dCB8fFxuICAgIChuZXh0LnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgICAgKG5leHQudGFnTmFtZSA9PT0gJ3RkJyB8fCBuZXh0LnRhZ05hbWUgPT09ICd0aCcpKVxuICApXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/closing.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/omission.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/omission.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   omission: () => (/* binding */ omission)\n/* harmony export */ });\n/**\n * @import {Element, Parents} from 'hast'\n */\n\n/**\n * @callback OmitHandle\n *   Check if a tag can be omitted.\n * @param {Element} element\n *   Element to check.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether to omit a tag.\n *\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Factory to check if a given node can have a tag omitted.\n *\n * @param {Record<string, OmitHandle>} handlers\n *   Omission handlers, where each key is a tag name, and each value is the\n *   corresponding handler.\n * @returns {OmitHandle}\n *   Whether to omit a tag of an element.\n */\nfunction omission(handlers) {\n  return omit\n\n  /**\n   * Check if a given node can have a tag omitted.\n   *\n   * @type {OmitHandle}\n   */\n  function omit(node, index, parent) {\n    return (\n      own.call(handlers, node.tagName) &&\n      handlers[node.tagName](node, index, parent)\n    )\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL29taXNzaW9uL29taXNzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL29taXNzaW9uL29taXNzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7RWxlbWVudCwgUGFyZW50c30gZnJvbSAnaGFzdCdcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBPbWl0SGFuZGxlXG4gKiAgIENoZWNrIGlmIGEgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgIEVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gaW5kZXhcbiAqICAgSW5kZXggb2YgZWxlbWVudCBpbiBwYXJlbnQuXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IHBhcmVudFxuICogICBQYXJlbnQgb2YgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRvIG9taXQgYSB0YWcuXG4gKlxuICovXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKlxuICogRmFjdG9yeSB0byBjaGVjayBpZiBhIGdpdmVuIG5vZGUgY2FuIGhhdmUgYSB0YWcgb21pdHRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIE9taXRIYW5kbGU+fSBoYW5kbGVyc1xuICogICBPbWlzc2lvbiBoYW5kbGVycywgd2hlcmUgZWFjaCBrZXkgaXMgYSB0YWcgbmFtZSwgYW5kIGVhY2ggdmFsdWUgaXMgdGhlXG4gKiAgIGNvcnJlc3BvbmRpbmcgaGFuZGxlci5cbiAqIEByZXR1cm5zIHtPbWl0SGFuZGxlfVxuICogICBXaGV0aGVyIHRvIG9taXQgYSB0YWcgb2YgYW4gZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9taXNzaW9uKGhhbmRsZXJzKSB7XG4gIHJldHVybiBvbWl0XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgZ2l2ZW4gbm9kZSBjYW4gaGF2ZSBhIHRhZyBvbWl0dGVkLlxuICAgKlxuICAgKiBAdHlwZSB7T21pdEhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG9taXQobm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICAgIHJldHVybiAoXG4gICAgICBvd24uY2FsbChoYW5kbGVycywgbm9kZS50YWdOYW1lKSAmJlxuICAgICAgaGFuZGxlcnNbbm9kZS50YWdOYW1lXShub2RlLCBpbmRleCwgcGFyZW50KVxuICAgIClcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/omission.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/opening.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/opening.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   opening: () => (/* binding */ opening)\n/* harmony export */ });\n/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-whitespace */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js\");\n/* harmony import */ var _util_siblings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/siblings.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/util/siblings.js\");\n/* harmony import */ var _closing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./closing.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/closing.js\");\n/* harmony import */ var _omission_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./omission.js */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/omission.js\");\n/**\n * @import {Element, Parents} from 'hast'\n */\n\n\n\n\n\n\nconst opening = (0,_omission_js__WEBPACK_IMPORTED_MODULE_0__.omission)({\n  body,\n  colgroup,\n  head,\n  html,\n  tbody\n})\n\n/**\n * Whether to omit `<html>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction html(node) {\n  const head = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(node, -1)\n  return !head || head.type !== 'comment'\n}\n\n/**\n * Whether to omit `<head>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction head(node) {\n  /** @type {Set<string>} */\n  const seen = new Set()\n\n  // Whether `srcdoc` or not,\n  // make sure the content model at least doesnt have too many `base`s/`title`s.\n  for (const child of node.children) {\n    if (\n      child.type === 'element' &&\n      (child.tagName === 'base' || child.tagName === 'title')\n    ) {\n      if (seen.has(child.tagName)) return false\n      seen.add(child.tagName)\n    }\n  }\n\n  // May be omitted if the element is empty,\n  // or if the first thing inside the head element is an element.\n  const child = node.children[0]\n  return !child || child.type === 'element'\n}\n\n/**\n * Whether to omit `<body>`.\n *\n * @param {Element} node\n *   Element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction body(node) {\n  const head = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(node, -1, true)\n\n  return (\n    !head ||\n    (head.type !== 'comment' &&\n      !(head.type === 'text' && (0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__.whitespace)(head.value.charAt(0))) &&\n      !(\n        head.type === 'element' &&\n        (head.tagName === 'meta' ||\n          head.tagName === 'link' ||\n          head.tagName === 'script' ||\n          head.tagName === 'style' ||\n          head.tagName === 'template')\n      ))\n  )\n}\n\n/**\n * Whether to omit `<colgroup>`.\n * The spec describes some logic for the opening tag, but its easier to\n * implement in the closing tag, to the same effect, so we handle it there\n * instead.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction colgroup(node, index, parent) {\n  const previous = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingBefore)(parent, index)\n  const head = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(node, -1, true)\n\n  // Previous colgroup was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    previous.tagName === 'colgroup' &&\n    (0,_closing_js__WEBPACK_IMPORTED_MODULE_3__.closing)(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return Boolean(head && head.type === 'element' && head.tagName === 'col')\n}\n\n/**\n * Whether to omit `<tbody>`.\n *\n * @param {Element} node\n *   Element.\n * @param {number | undefined} index\n *   Index of element in parent.\n * @param {Parents | undefined} parent\n *   Parent of element.\n * @returns {boolean}\n *   Whether the opening tag can be omitted.\n */\nfunction tbody(node, index, parent) {\n  const previous = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingBefore)(parent, index)\n  const head = (0,_util_siblings_js__WEBPACK_IMPORTED_MODULE_1__.siblingAfter)(node, -1)\n\n  // Previous table section was already omitted.\n  if (\n    parent &&\n    previous &&\n    previous.type === 'element' &&\n    (previous.tagName === 'thead' || previous.tagName === 'tbody') &&\n    (0,_closing_js__WEBPACK_IMPORTED_MODULE_3__.closing)(previous, parent.children.indexOf(previous), parent)\n  ) {\n    return false\n  }\n\n  return Boolean(head && head.type === 'element' && head.tagName === 'tr')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL29taXNzaW9uL29wZW5pbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCOztBQUUrQztBQUNlO0FBQzFCO0FBQ0U7O0FBRS9CLGdCQUFnQixzREFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBWTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFZOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0VBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQWE7QUFDaEMsZUFBZSwrREFBWTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvREFBTztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFhO0FBQ2hDLGVBQWUsK0RBQVk7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0RBQU87QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL29taXNzaW9uL29wZW5pbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtFbGVtZW50LCBQYXJlbnRzfSBmcm9tICdoYXN0J1xuICovXG5cbmltcG9ydCB7d2hpdGVzcGFjZX0gZnJvbSAnaGFzdC11dGlsLXdoaXRlc3BhY2UnXG5pbXBvcnQge3NpYmxpbmdBZnRlciwgc2libGluZ0JlZm9yZX0gZnJvbSAnLi91dGlsL3NpYmxpbmdzLmpzJ1xuaW1wb3J0IHtjbG9zaW5nfSBmcm9tICcuL2Nsb3NpbmcuanMnXG5pbXBvcnQge29taXNzaW9ufSBmcm9tICcuL29taXNzaW9uLmpzJ1xuXG5leHBvcnQgY29uc3Qgb3BlbmluZyA9IG9taXNzaW9uKHtcbiAgYm9keSxcbiAgY29sZ3JvdXAsXG4gIGhlYWQsXG4gIGh0bWwsXG4gIHRib2R5XG59KVxuXG4vKipcbiAqIFdoZXRoZXIgdG8gb21pdCBgPGh0bWw+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgRWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoZSBvcGVuaW5nIHRhZyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuZnVuY3Rpb24gaHRtbChub2RlKSB7XG4gIGNvbnN0IGhlYWQgPSBzaWJsaW5nQWZ0ZXIobm9kZSwgLTEpXG4gIHJldHVybiAhaGVhZCB8fCBoZWFkLnR5cGUgIT09ICdjb21tZW50J1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdG8gb21pdCBgPGhlYWQ+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgRWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoZSBvcGVuaW5nIHRhZyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuZnVuY3Rpb24gaGVhZChub2RlKSB7XG4gIC8qKiBAdHlwZSB7U2V0PHN0cmluZz59ICovXG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0KClcblxuICAvLyBXaGV0aGVyIGBzcmNkb2NgIG9yIG5vdCxcbiAgLy8gbWFrZSBzdXJlIHRoZSBjb250ZW50IG1vZGVsIGF0IGxlYXN0IGRvZXNu4oCZdCBoYXZlIHRvbyBtYW55IGBiYXNlYHMvYHRpdGxlYHMuXG4gIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgIGlmIChcbiAgICAgIGNoaWxkLnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgICAgKGNoaWxkLnRhZ05hbWUgPT09ICdiYXNlJyB8fCBjaGlsZC50YWdOYW1lID09PSAndGl0bGUnKVxuICAgICkge1xuICAgICAgaWYgKHNlZW4uaGFzKGNoaWxkLnRhZ05hbWUpKSByZXR1cm4gZmFsc2VcbiAgICAgIHNlZW4uYWRkKGNoaWxkLnRhZ05hbWUpXG4gICAgfVxuICB9XG5cbiAgLy8g4oCcTWF5IGJlIG9taXR0ZWQgaWYgdGhlIGVsZW1lbnQgaXMgZW1wdHksXG4gIC8vIG9yIGlmIHRoZSBmaXJzdCB0aGluZyBpbnNpZGUgdGhlIGhlYWQgZWxlbWVudCBpcyBhbiBlbGVtZW50LuKAnVxuICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF1cbiAgcmV0dXJuICFjaGlsZCB8fCBjaGlsZC50eXBlID09PSAnZWxlbWVudCdcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRvIG9taXQgYDxib2R5PmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiAgIEVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqICAgV2hldGhlciB0aGUgb3BlbmluZyB0YWcgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbmZ1bmN0aW9uIGJvZHkobm9kZSkge1xuICBjb25zdCBoZWFkID0gc2libGluZ0FmdGVyKG5vZGUsIC0xLCB0cnVlKVxuXG4gIHJldHVybiAoXG4gICAgIWhlYWQgfHxcbiAgICAoaGVhZC50eXBlICE9PSAnY29tbWVudCcgJiZcbiAgICAgICEoaGVhZC50eXBlID09PSAndGV4dCcgJiYgd2hpdGVzcGFjZShoZWFkLnZhbHVlLmNoYXJBdCgwKSkpICYmXG4gICAgICAhKFxuICAgICAgICBoZWFkLnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgICAgICAoaGVhZC50YWdOYW1lID09PSAnbWV0YScgfHxcbiAgICAgICAgICBoZWFkLnRhZ05hbWUgPT09ICdsaW5rJyB8fFxuICAgICAgICAgIGhlYWQudGFnTmFtZSA9PT0gJ3NjcmlwdCcgfHxcbiAgICAgICAgICBoZWFkLnRhZ05hbWUgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBoZWFkLnRhZ05hbWUgPT09ICd0ZW1wbGF0ZScpXG4gICAgICApKVxuICApXG59XG5cbi8qKlxuICogV2hldGhlciB0byBvbWl0IGA8Y29sZ3JvdXA+YC5cbiAqIFRoZSBzcGVjIGRlc2NyaWJlcyBzb21lIGxvZ2ljIGZvciB0aGUgb3BlbmluZyB0YWcsIGJ1dCBpdOKAmXMgZWFzaWVyIHRvXG4gKiBpbXBsZW1lbnQgaW4gdGhlIGNsb3NpbmcgdGFnLCB0byB0aGUgc2FtZSBlZmZlY3QsIHNvIHdlIGhhbmRsZSBpdCB0aGVyZVxuICogaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBlbGVtZW50IGluIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhlIG9wZW5pbmcgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiBjb2xncm91cChub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IHByZXZpb3VzID0gc2libGluZ0JlZm9yZShwYXJlbnQsIGluZGV4KVxuICBjb25zdCBoZWFkID0gc2libGluZ0FmdGVyKG5vZGUsIC0xLCB0cnVlKVxuXG4gIC8vIFByZXZpb3VzIGNvbGdyb3VwIHdhcyBhbHJlYWR5IG9taXR0ZWQuXG4gIGlmIChcbiAgICBwYXJlbnQgJiZcbiAgICBwcmV2aW91cyAmJlxuICAgIHByZXZpb3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgIHByZXZpb3VzLnRhZ05hbWUgPT09ICdjb2xncm91cCcgJiZcbiAgICBjbG9zaW5nKHByZXZpb3VzLCBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihwcmV2aW91cyksIHBhcmVudClcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gQm9vbGVhbihoZWFkICYmIGhlYWQudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGhlYWQudGFnTmFtZSA9PT0gJ2NvbCcpXG59XG5cbi8qKlxuICogV2hldGhlciB0byBvbWl0IGA8dGJvZHk+YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBpbmRleFxuICogICBJbmRleCBvZiBlbGVtZW50IGluIHBhcmVudC5cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhlIG9wZW5pbmcgdGFnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5mdW5jdGlvbiB0Ym9keShub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IHByZXZpb3VzID0gc2libGluZ0JlZm9yZShwYXJlbnQsIGluZGV4KVxuICBjb25zdCBoZWFkID0gc2libGluZ0FmdGVyKG5vZGUsIC0xKVxuXG4gIC8vIFByZXZpb3VzIHRhYmxlIHNlY3Rpb24gd2FzIGFscmVhZHkgb21pdHRlZC5cbiAgaWYgKFxuICAgIHBhcmVudCAmJlxuICAgIHByZXZpb3VzICYmXG4gICAgcHJldmlvdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmXG4gICAgKHByZXZpb3VzLnRhZ05hbWUgPT09ICd0aGVhZCcgfHwgcHJldmlvdXMudGFnTmFtZSA9PT0gJ3Rib2R5JykgJiZcbiAgICBjbG9zaW5nKHByZXZpb3VzLCBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihwcmV2aW91cyksIHBhcmVudClcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gQm9vbGVhbihoZWFkICYmIGhlYWQudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGhlYWQudGFnTmFtZSA9PT0gJ3RyJylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/opening.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/util/siblings.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/util/siblings.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   siblingAfter: () => (/* binding */ siblingAfter),\n/* harmony export */   siblingBefore: () => (/* binding */ siblingBefore)\n/* harmony export */ });\n/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-whitespace */ \"(app-pages-browser)/./node_modules/.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js\");\n/**\n * @import {Parents, RootContent} from 'hast'\n */\n\n\n\nconst siblingAfter = siblings(1)\nconst siblingBefore = siblings(-1)\n\n/** @type {Array<RootContent>} */\nconst emptyChildren = []\n\n/**\n * Factory to check siblings in a direction.\n *\n * @param {number} increment\n */\nfunction siblings(increment) {\n  return sibling\n\n  /**\n   * Find applicable siblings in a direction.\n   *\n   * @template {Parents} Parent\n   *   Parent type.\n   * @param {Parent | undefined} parent\n   *   Parent.\n   * @param {number | undefined} index\n   *   Index of child in `parent`.\n   * @param {boolean | undefined} [includeWhitespace=false]\n   *   Whether to include whitespace (default: `false`).\n   * @returns {Parent extends {children: Array<infer Child>} ? Child | undefined : never}\n   *   Child of parent.\n   */\n  function sibling(parent, index, includeWhitespace) {\n    const siblings = parent ? parent.children : emptyChildren\n    let offset = (index || 0) + increment\n    let next = siblings[offset]\n\n    if (!includeWhitespace) {\n      while (next && (0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_0__.whitespace)(next)) {\n        offset += increment\n        next = siblings[offset]\n      }\n    }\n\n    // @ts-expect-error: its a correct child.\n    return next\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtdG8taHRtbEA5LjAuNC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWh0bWwvbGliL29taXNzaW9uL3V0aWwvc2libGluZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQzs7QUFFK0M7O0FBRXhDO0FBQ0E7O0FBRVAsV0FBVyxvQkFBb0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLGVBQWUsZ0JBQWdCLDhCQUE4QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0VBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vaGFzdC11dGlsLXRvLWh0bWxAOS4wLjQvbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1odG1sL2xpYi9vbWlzc2lvbi91dGlsL3NpYmxpbmdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7UGFyZW50cywgUm9vdENvbnRlbnR9IGZyb20gJ2hhc3QnXG4gKi9cblxuaW1wb3J0IHt3aGl0ZXNwYWNlfSBmcm9tICdoYXN0LXV0aWwtd2hpdGVzcGFjZSdcblxuZXhwb3J0IGNvbnN0IHNpYmxpbmdBZnRlciA9IHNpYmxpbmdzKDEpXG5leHBvcnQgY29uc3Qgc2libGluZ0JlZm9yZSA9IHNpYmxpbmdzKC0xKVxuXG4vKiogQHR5cGUge0FycmF5PFJvb3RDb250ZW50Pn0gKi9cbmNvbnN0IGVtcHR5Q2hpbGRyZW4gPSBbXVxuXG4vKipcbiAqIEZhY3RvcnkgdG8gY2hlY2sgc2libGluZ3MgaW4gYSBkaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluY3JlbWVudFxuICovXG5mdW5jdGlvbiBzaWJsaW5ncyhpbmNyZW1lbnQpIHtcbiAgcmV0dXJuIHNpYmxpbmdcblxuICAvKipcbiAgICogRmluZCBhcHBsaWNhYmxlIHNpYmxpbmdzIGluIGEgZGlyZWN0aW9uLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge1BhcmVudHN9IFBhcmVudFxuICAgKiAgIFBhcmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge1BhcmVudCB8IHVuZGVmaW5lZH0gcGFyZW50XG4gICAqICAgUGFyZW50LlxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gaW5kZXhcbiAgICogICBJbmRleCBvZiBjaGlsZCBpbiBgcGFyZW50YC5cbiAgICogQHBhcmFtIHtib29sZWFuIHwgdW5kZWZpbmVkfSBbaW5jbHVkZVdoaXRlc3BhY2U9ZmFsc2VdXG4gICAqICAgV2hldGhlciB0byBpbmNsdWRlIHdoaXRlc3BhY2UgKGRlZmF1bHQ6IGBmYWxzZWApLlxuICAgKiBAcmV0dXJucyB7UGFyZW50IGV4dGVuZHMge2NoaWxkcmVuOiBBcnJheTxpbmZlciBDaGlsZD59ID8gQ2hpbGQgfCB1bmRlZmluZWQgOiBuZXZlcn1cbiAgICogICBDaGlsZCBvZiBwYXJlbnQuXG4gICAqL1xuICBmdW5jdGlvbiBzaWJsaW5nKHBhcmVudCwgaW5kZXgsIGluY2x1ZGVXaGl0ZXNwYWNlKSB7XG4gICAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQgPyBwYXJlbnQuY2hpbGRyZW4gOiBlbXB0eUNoaWxkcmVuXG4gICAgbGV0IG9mZnNldCA9IChpbmRleCB8fCAwKSArIGluY3JlbWVudFxuICAgIGxldCBuZXh0ID0gc2libGluZ3Nbb2Zmc2V0XVxuXG4gICAgaWYgKCFpbmNsdWRlV2hpdGVzcGFjZSkge1xuICAgICAgd2hpbGUgKG5leHQgJiYgd2hpdGVzcGFjZShuZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gaW5jcmVtZW50XG4gICAgICAgIG5leHQgPSBzaWJsaW5nc1tvZmZzZXRdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaXTigJlzIGEgY29ycmVjdCBjaGlsZC5cbiAgICByZXR1cm4gbmV4dFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-to-html@9.0.4/node_modules/hast-util-to-html/lib/omission/util/siblings.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   whitespace: () => (/* binding */ whitespace)\n/* harmony export */ });\n/**\n * @typedef {import('hast').Nodes} Nodes\n */\n\n// HTML whitespace expression.\n// See <https://infra.spec.whatwg.org/#ascii-whitespace>.\nconst re = /[ \\t\\n\\f\\r]/g\n\n/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {Nodes | string} thing\n *   Thing to check (`Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`); if a node is passed it must be a `Text` node,\n *   whose `value` field is checked.\n */\nfunction whitespace(thing) {\n  return typeof thing === 'object'\n    ? thing.type === 'text'\n      ? empty(thing.value)\n      : false\n    : empty(thing)\n}\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction empty(value) {\n  return value.replace(re, '') === ''\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9oYXN0LXV0aWwtd2hpdGVzcGFjZUAzLjAuMC9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXdoaXRlc3BhY2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vaGFzdC11dGlsLXdoaXRlc3BhY2VAMy4wLjAvbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC13aGl0ZXNwYWNlL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Ob2Rlc30gTm9kZXNcbiAqL1xuXG4vLyBIVE1MIHdoaXRlc3BhY2UgZXhwcmVzc2lvbi5cbi8vIFNlZSA8aHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXdoaXRlc3BhY2U+LlxuY29uc3QgcmUgPSAvWyBcXHRcXG5cXGZcXHJdL2dcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgKmludGVyLWVsZW1lbnQgd2hpdGVzcGFjZSouXG4gKlxuICogQHBhcmFtIHtOb2RlcyB8IHN0cmluZ30gdGhpbmdcbiAqICAgVGhpbmcgdG8gY2hlY2sgKGBOb2RlYCBvciBgc3RyaW5nYCkuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqICAgV2hldGhlciB0aGUgYHZhbHVlYCBpcyBpbnRlci1lbGVtZW50IHdoaXRlc3BhY2UgKGBib29sZWFuYCk6IGNvbnNpc3Rpbmcgb2ZcbiAqICAgemVybyBvciBtb3JlIG9mIHNwYWNlLCB0YWIgKGBcXHRgKSwgbGluZSBmZWVkIChgXFxuYCksIGNhcnJpYWdlIHJldHVyblxuICogICAoYFxccmApLCBvciBmb3JtIGZlZWQgKGBcXGZgKTsgaWYgYSBub2RlIGlzIHBhc3NlZCBpdCBtdXN0IGJlIGEgYFRleHRgIG5vZGUsXG4gKiAgIHdob3NlIGB2YWx1ZWAgZmllbGQgaXMgY2hlY2tlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdoaXRlc3BhY2UodGhpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCdcbiAgICA/IHRoaW5nLnR5cGUgPT09ICd0ZXh0J1xuICAgICAgPyBlbXB0eSh0aGluZy52YWx1ZSlcbiAgICAgIDogZmFsc2VcbiAgICA6IGVtcHR5KHRoaW5nKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCAnJykgPT09ICcnXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/hast-util-whitespace@3.0.0/node_modules/hast-util-whitespace/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/html-void-elements@3.0.0/node_modules/html-void-elements/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/html-void-elements@3.0.0/node_modules/html-void-elements/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   htmlVoidElements: () => (/* binding */ htmlVoidElements)\n/* harmony export */ });\n/**\n * List of HTML void tag names.\n *\n * @type {Array<string>}\n */\nconst htmlVoidElements = [\n  'area',\n  'base',\n  'basefont',\n  'bgsound',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'frame',\n  'hr',\n  'image',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr'\n]\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9odG1sLXZvaWQtZWxlbWVudHNAMy4wLjAvbm9kZV9tb2R1bGVzL2h0bWwtdm9pZC1lbGVtZW50cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vaHRtbC12b2lkLWVsZW1lbnRzQDMuMC4wL25vZGVfbW9kdWxlcy9odG1sLXZvaWQtZWxlbWVudHMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaXN0IG9mIEhUTUwgdm9pZCB0YWcgbmFtZXMuXG4gKlxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKi9cbmV4cG9ydCBjb25zdCBodG1sVm9pZEVsZW1lbnRzID0gW1xuICAnYXJlYScsXG4gICdiYXNlJyxcbiAgJ2Jhc2Vmb250JyxcbiAgJ2Jnc291bmQnLFxuICAnYnInLFxuICAnY29sJyxcbiAgJ2NvbW1hbmQnLFxuICAnZW1iZWQnLFxuICAnZnJhbWUnLFxuICAnaHInLFxuICAnaW1hZ2UnLFxuICAnaW1nJyxcbiAgJ2lucHV0JyxcbiAgJ2tleWdlbicsXG4gICdsaW5rJyxcbiAgJ21ldGEnLFxuICAncGFyYW0nLFxuICAnc291cmNlJyxcbiAgJ3RyYWNrJyxcbiAgJ3dicidcbl1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/html-void-elements@3.0.0/node_modules/html-void-elements/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/oniguruma-to-es@1.0.0/node_modules/oniguruma-to-es/dist/index.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/oniguruma-to-es@1.0.0/node_modules/oniguruma-to-es/dist/index.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmulatedRegExp: () => (/* binding */ EmulatedRegExp),\n/* harmony export */   toDetails: () => (/* binding */ toDetails),\n/* harmony export */   toOnigurumaAst: () => (/* binding */ toOnigurumaAst),\n/* harmony export */   toRegExp: () => (/* binding */ toRegExp)\n/* harmony export */ });\n/* harmony import */ var regex_internals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regex/internals */ \"(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/internals.js\");\n/* harmony import */ var emoji_regex_xs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! emoji-regex-xs */ \"(app-pages-browser)/./node_modules/.pnpm/emoji-regex-xs@1.0.0/node_modules/emoji-regex-xs/index.mjs\");\n/* harmony import */ var regex_recursion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! regex-recursion */ \"(app-pages-browser)/./node_modules/.pnpm/regex-recursion@5.1.1/node_modules/regex-recursion/src/index.js\");\n// src/utils.js\nvar cp = String.fromCodePoint;\nvar r = String.raw;\nvar envSupportsFlagGroups = (() => {\n  try {\n    new RegExp(\"(?i:)\");\n  } catch {\n    return false;\n  }\n  return true;\n})();\nvar envSupportsFlagV = (() => {\n  try {\n    new RegExp(\"\", \"v\");\n  } catch {\n    return false;\n  }\n  return true;\n})();\nfunction getNewCurrentFlags(current, { enable, disable }) {\n  return {\n    dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),\n    ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase)\n  };\n}\nfunction getOrCreate(map, key, defaultValue) {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key);\n}\nfunction isMinTarget(target, min) {\n  return EsVersion[target] >= EsVersion[min];\n}\nfunction throwIfNot(value, msg) {\n  if (!value) {\n    throw new Error(msg ?? \"Value expected\");\n  }\n  return value;\n}\n\n// src/options.js\nvar EsVersion = {\n  ES2025: 2025,\n  ES2024: 2024,\n  ES2018: 2018\n};\nvar Target = (\n  /** @type {const} */\n  {\n    auto: \"auto\",\n    ES2025: \"ES2025\",\n    ES2024: \"ES2024\",\n    ES2018: \"ES2018\"\n  }\n);\nfunction getOptions(options) {\n  if (options?.target !== void 0 && !Target[options.target]) {\n    throw new Error(`Unexpected target \"${options.target}\"`);\n  }\n  const opts = {\n    // Sets the level of emulation rigor/strictness.\n    accuracy: \"default\",\n    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in\n    // certain patterns not being emulatable.\n    avoidSubclass: false,\n    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W` in any order (all optional).\n    // Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).\n    flags: \"\",\n    // Include JavaScript flag `g` (`global`) in the result.\n    global: false,\n    // Include JavaScript flag `d` (`hasIndices`) in the result.\n    hasIndices: false,\n    // JavaScript version used for generated regexes. Using `auto` detects the best value based on\n    // your environment. Later targets allow faster processing, simpler generated source, and\n    // support for additional features.\n    target: \"auto\",\n    // Disables optimizations that simplify the pattern when it doesn't change the meaning.\n    verbose: false,\n    ...options,\n    // Advanced options that override standard behavior, error checking, and flags when enabled.\n    rules: {\n      // Useful with TextMate grammars that merge backreferences across patterns.\n      allowOrphanBackrefs: false,\n      // Use ASCII-based `\\b` and `\\B`, which increases search performance of generated regexes.\n      asciiWordBoundaries: false,\n      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using\n      // named capture.\n      // - Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`.\n      // - On by default in `vscode-oniguruma`.\n      captureGroup: false,\n      // Remove unsupported uses of `\\G`, rather than erroring.\n      ignoreUnsupportedGAnchors: false,\n      // Change the recursion depth limit from Oniguruma's default of `20` to an integer `2``20`.\n      recursionLimit: 20,\n      ...options?.rules\n    }\n  };\n  if (opts.target === \"auto\") {\n    opts.target = envSupportsFlagGroups ? \"ES2025\" : envSupportsFlagV ? \"ES2024\" : \"ES2018\";\n  }\n  return opts;\n}\n\n// src/unicode.js\nvar CharsWithoutIgnoreCaseExpansion = /* @__PURE__ */ new Set([\n  cp(304),\n  // \n  cp(305)\n  // \n]);\nfunction getIgnoreCaseMatchChars(char) {\n  if (CharsWithoutIgnoreCaseExpansion.has(char)) {\n    return [char];\n  }\n  const set = /* @__PURE__ */ new Set();\n  const lower = char.toLowerCase();\n  const upper = lower.toUpperCase();\n  const title = LowerToTitleCaseMap.get(lower);\n  const altLower = LowerToAlternativeLowerCaseMap.get(lower);\n  const altUpper = LowerToAlternativeUpperCaseMap.get(lower);\n  if ([...upper].length === 1) {\n    set.add(upper);\n  }\n  altUpper && set.add(altUpper);\n  title && set.add(title);\n  set.add(lower);\n  altLower && set.add(altLower);\n  return [...set];\n}\nvar JsUnicodeProperties = new Set(\n  `C Other\nCc Control cntrl\nCf Format\nCn Unassigned\nCo Private_Use\nCs Surrogate\nL Letter\nLC Cased_Letter\nLl Lowercase_Letter\nLm Modifier_Letter\nLo Other_Letter\nLt Titlecase_Letter\nLu Uppercase_Letter\nM Mark Combining_Mark\nMc Spacing_Mark\nMe Enclosing_Mark\nMn Nonspacing_Mark\nN Number\nNd Decimal_Number digit\nNl Letter_Number\nNo Other_Number\nP Punctuation punct\nPc Connector_Punctuation\nPd Dash_Punctuation\nPe Close_Punctuation\nPf Final_Punctuation\nPi Initial_Punctuation\nPo Other_Punctuation\nPs Open_Punctuation\nS Symbol\nSc Currency_Symbol\nSk Modifier_Symbol\nSm Math_Symbol\nSo Other_Symbol\nZ Separator\nZl Line_Separator\nZp Paragraph_Separator\nZs Space_Separator\nASCII\nASCII_Hex_Digit AHex\nAlphabetic Alpha\nAny\nAssigned\nBidi_Control Bidi_C\nBidi_Mirrored Bidi_M\nCase_Ignorable CI\nCased\nChanges_When_Casefolded CWCF\nChanges_When_Casemapped CWCM\nChanges_When_Lowercased CWL\nChanges_When_NFKC_Casefolded CWKCF\nChanges_When_Titlecased CWT\nChanges_When_Uppercased CWU\nDash\nDefault_Ignorable_Code_Point DI\nDeprecated Dep\nDiacritic Dia\nEmoji\nEmoji_Component EComp\nEmoji_Modifier EMod\nEmoji_Modifier_Base EBase\nEmoji_Presentation EPres\nExtended_Pictographic ExtPict\nExtender Ext\nGrapheme_Base Gr_Base\nGrapheme_Extend Gr_Ext\nHex_Digit Hex\nIDS_Binary_Operator IDSB\nIDS_Trinary_Operator IDST\nID_Continue IDC\nID_Start IDS\nIdeographic Ideo\nJoin_Control Join_C\nLogical_Order_Exception LOE\nLowercase Lower\nMath\nNoncharacter_Code_Point NChar\nPattern_Syntax Pat_Syn\nPattern_White_Space Pat_WS\nQuotation_Mark QMark\nRadical\nRegional_Indicator RI\nSentence_Terminal STerm\nSoft_Dotted SD\nTerminal_Punctuation Term\nUnified_Ideograph UIdeo\nUppercase Upper\nVariation_Selector VS\nWhite_Space space\nXID_Continue XIDC\nXID_Start XIDS`.split(/\\s/)\n);\nvar JsUnicodePropertiesMap = /* @__PURE__ */ new Map();\nfor (const p of JsUnicodeProperties) {\n  JsUnicodePropertiesMap.set(slug(p), p);\n}\nvar JsUnicodePropertiesOfStrings = /* @__PURE__ */ new Set([\n  // ES2024 properties of strings; none are supported by Oniguruma\n  \"Basic_Emoji\",\n  \"Emoji_Keycap_Sequence\",\n  \"RGI_Emoji\",\n  \"RGI_Emoji_Flag_Sequence\",\n  \"RGI_Emoji_Modifier_Sequence\",\n  \"RGI_Emoji_Tag_Sequence\",\n  \"RGI_Emoji_ZWJ_Sequence\"\n]);\nvar JsUnicodePropertiesOfStringsMap = /* @__PURE__ */ new Map();\nfor (const p of JsUnicodePropertiesOfStrings) {\n  JsUnicodePropertiesOfStringsMap.set(slug(p), p);\n}\nvar LowerToAlternativeLowerCaseMap = /* @__PURE__ */ new Map([\n  [\"s\", cp(383)],\n  // s, \n  [cp(383), \"s\"]\n  // , s\n]);\nvar LowerToAlternativeUpperCaseMap = /* @__PURE__ */ new Map([\n  [cp(223), cp(7838)],\n  // , \n  [cp(107), cp(8490)],\n  // k,  (Kelvin)\n  [cp(229), cp(8491)],\n  // ,  (Angstrom)\n  [cp(969), cp(8486)]\n  // ,  (Ohm)\n]);\nvar LowerToTitleCaseMap = new Map([\n  titleEntry(453),\n  titleEntry(456),\n  titleEntry(459),\n  titleEntry(498),\n  ...titleRange(8072, 8079),\n  ...titleRange(8088, 8095),\n  ...titleRange(8104, 8111),\n  titleEntry(8124),\n  titleEntry(8140),\n  titleEntry(8188)\n]);\nvar PosixClassesMap = /* @__PURE__ */ new Map([\n  [\"alnum\", r`[\\p{Alpha}\\p{Nd}]`],\n  [\"alpha\", r`\\p{Alpha}`],\n  [\"ascii\", r`\\p{ASCII}`],\n  [\"blank\", r`[\\p{Zs}\\t]`],\n  [\"cntrl\", r`\\p{cntrl}`],\n  [\"digit\", r`\\p{Nd}`],\n  [\"graph\", r`[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]`],\n  [\"lower\", r`\\p{Lower}`],\n  [\"print\", r`[[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]`],\n  [\"punct\", r`[\\p{P}\\p{S}]`],\n  // New value from Oniguruma 6.9.9\n  [\"space\", r`\\p{space}`],\n  [\"upper\", r`\\p{Upper}`],\n  [\"word\", r`[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]`],\n  [\"xdigit\", r`\\p{AHex}`]\n]);\nvar PosixProperties = /* @__PURE__ */ new Set([\n  \"alnum\",\n  \"blank\",\n  \"graph\",\n  \"print\",\n  \"word\",\n  \"xdigit\"\n  // The following are available with the same name in JS (see `JsUnicodeProperties`), so can be\n  // handled as standard Unicode properties\n  // 'alpha', // (JS: Alpha)\n  // 'ascii', // (JS: ASCII)\n  // 'cntrl', // (JS: cntrl)\n  // 'digit', // (JS: digit)\n  // 'lower', // (JS: Lower)\n  // 'punct', // (JS: punct)\n  // 'space', // (JS: space)\n  // 'upper', // (JS: Upper)\n]);\nfunction range(start, end) {\n  const range2 = [];\n  for (let i = start; i <= end; i++) {\n    range2.push(i);\n  }\n  return range2;\n}\nfunction slug(name) {\n  return name.replace(/[- _]+/g, \"\").toLowerCase();\n}\nfunction titleEntry(codePoint) {\n  const char = cp(codePoint);\n  return [char.toLowerCase(), char];\n}\nfunction titleRange(start, end) {\n  return range(start, end).map((codePoint) => titleEntry(codePoint));\n}\nvar UnicodePropertiesWithSpecificCase = /* @__PURE__ */ new Set([\n  \"Lower\",\n  \"Lowercase\",\n  \"Upper\",\n  \"Uppercase\",\n  \"Ll\",\n  \"Lowercase_Letter\",\n  \"Lt\",\n  \"Titlecase_Letter\",\n  \"Lu\",\n  \"Uppercase_Letter\"\n  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.\n  // Some other properties include a handful of chars with specific cases only, but these chars are\n  // generally extreme edge cases and using such properties case insensitively generally produces\n  // undesired behavior anyway\n]);\n\n// src/tokenize.js\nvar TokenTypes = (\n  /** @type {const} */\n  {\n    Alternator: \"Alternator\",\n    Assertion: \"Assertion\",\n    Backreference: \"Backreference\",\n    Character: \"Character\",\n    CharacterClassClose: \"CharacterClassClose\",\n    CharacterClassHyphen: \"CharacterClassHyphen\",\n    CharacterClassIntersector: \"CharacterClassIntersector\",\n    CharacterClassOpen: \"CharacterClassOpen\",\n    CharacterSet: \"CharacterSet\",\n    Directive: \"Directive\",\n    GroupClose: \"GroupClose\",\n    GroupOpen: \"GroupOpen\",\n    Subroutine: \"Subroutine\",\n    Quantifier: \"Quantifier\",\n    // These aren't allowed in char classes, so they aren't equivalent to JS `[\\q{}]`\n    VariableLengthCharacterSet: \"VariableLengthCharacterSet\",\n    // Intermediate representation not included in results\n    EscapedNumber: \"EscapedNumber\"\n  }\n);\nvar TokenCharacterSetKinds = {\n  any: \"any\",\n  digit: \"digit\",\n  dot: \"dot\",\n  hex: \"hex\",\n  non_newline: \"non_newline\",\n  posix: \"posix\",\n  property: \"property\",\n  space: \"space\",\n  word: \"word\"\n};\nvar TokenDirectiveKinds = {\n  flags: \"flags\",\n  keep: \"keep\"\n};\nvar TokenGroupKinds = {\n  atomic: \"atomic\",\n  capturing: \"capturing\",\n  group: \"group\",\n  lookahead: \"lookahead\",\n  lookbehind: \"lookbehind\"\n};\nvar EscapeCharCodes = /* @__PURE__ */ new Map([\n  [\"a\", 7],\n  // alert/bell (Not available in JS)\n  [\"b\", 8],\n  // backspace (only in char classes)\n  [\"e\", 27],\n  // escape (Not available in JS)\n  [\"f\", 12],\n  // form feed\n  [\"n\", 10],\n  // line feed\n  [\"r\", 13],\n  // carriage return\n  [\"t\", 9],\n  // horizontal tab\n  [\"v\", 11]\n  // vertical tab\n]);\nvar charClassOpenPattern = r`\\[\\^?`;\nvar sharedEscapesPattern = `${// Control char\n\"c.? | C(?:-.?)?\"}|${// Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n// `\\p{gc=L}` are invalid\nr`[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?`}|${// Hex encoded byte sequence; attempt match before other `\\xNN` hex char\nr`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`}|${// Hex char\nr`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`}|${// Enclosed octal code point\nr`o\\{[^\\}]*\\}?`}|${// Escaped number\nr`\\d{1,3}`}`;\nvar quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nvar tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?: \\? (?:\n    [:=!>(~]\n    | <[=!]\n    | <[^>]*>\n    | '[^']*'\n    | # (?:[^)\\\\] | \\\\.?)*\n    | [imx\\-]+[:)]\n  )?)?\n  | ${quantifierRe.source}\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, \"\"), \"gsu\");\nvar charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:[^:]*:\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, \"\"), \"gsu\");\nfunction tokenize(pattern, flags = \"\", rules) {\n  rules = {\n    // `ONIG_OPTION_CAPTURE_GROUP`\n    captureGroup: false,\n    ...rules\n  };\n  if (typeof pattern !== \"string\") {\n    throw new Error(\"String expected as pattern\");\n  }\n  if (!/^[imxDSW]*$/.test(flags)) {\n    throw new Error(`Flags \"${flags}\" includes unsupported value`);\n  }\n  const extended = flags.includes(\"x\");\n  const xStack = [extended];\n  const context = {\n    captureGroup: rules.captureGroup,\n    getCurrentModX: () => xStack.at(-1),\n    numOpenGroups: 0,\n    popModX() {\n      xStack.pop();\n    },\n    pushModX(isXOn) {\n      xStack.push(isXOn);\n    },\n    replaceCurrentModX(isXOn) {\n      xStack[xStack.length - 1] = isXOn;\n    }\n  };\n  let tokens = [];\n  let match;\n  tokenRe.lastIndex = 0;\n  while (match = tokenRe.exec(pattern)) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== void 0) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n  const potentialUnnamedCaptureTokens = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.forEach((t) => {\n    if (t.type === TokenTypes.GroupOpen) {\n      if (t.kind === TokenGroupKinds.capturing) {\n        t.number = ++numNamedAndOptInUnnamedCaptures;\n      } else if (t.raw === \"(\") {\n        potentialUnnamedCaptureTokens.push(t);\n      }\n    }\n  });\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = TokenGroupKinds.capturing;\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  tokens = tokens.map(\n    (t) => t.type === TokenTypes.EscapedNumber ? splitEscapedNumToken(t, numCaptures) : t\n  ).flat();\n  return {\n    tokens,\n    flags: {\n      ignoreCase: flags.includes(\"i\"),\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      dotAll: flags.includes(\"m\"),\n      // Flag x is fully handled during tokenization\n      extended,\n      // Flags D, S, W are currently only supported as top-level flags\n      digitIsAscii: flags.includes(\"D\"),\n      spaceIsAscii: flags.includes(\"S\"),\n      wordIsAscii: flags.includes(\"W\")\n    },\n    rules\n  };\n}\nfunction getTokenWithDetails(context, pattern, m, lastIndex) {\n  const [m0, m1, m2] = m;\n  if (m0 === \"[\") {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex\n    };\n  }\n  if (m0 === \"\\\\\") {\n    if (\"AbBGzZ\".includes(m1)) {\n      return {\n        token: createToken(TokenTypes.Assertion, m, {\n          kind: m\n        })\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Subroutine, m)\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Backreference, m)\n      };\n    }\n    if (m1 === \"K\") {\n      return {\n        token: createToken(TokenTypes.Directive, m, {\n          kind: TokenDirectiveKinds.keep\n        })\n      };\n    }\n    if (m1 === \"N\") {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.non_newline\n        })\n      };\n    }\n    if (m1 === \"O\") {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.any\n        })\n      };\n    }\n    if (\"RX\".includes(m1)) {\n      return {\n        token: createToken(TokenTypes.VariableLengthCharacterSet, m, {\n          kind: m\n        })\n      };\n    }\n    if (\"yY\".includes(m1)) {\n      throw new Error(`Unsupported grapheme boundary \"${m}\"`);\n    }\n    const result = createTokenForSharedEscape(m, { inCharClass: false });\n    return Array.isArray(result) ? { tokens: result } : { token: result };\n  }\n  if (m0 === \"(\") {\n    if (m2 === \"#\") {\n      if (pattern[lastIndex] !== \")\") {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        lastIndex: lastIndex + 1\n      };\n    }\n    if (\"-imx\".includes(m2)) {\n      return {\n        token: createTokenForFlagMod(m, context)\n      };\n    }\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      m === \"(\" && !context.captureGroup || // Noncapturing group\n      m === \"(?:\"\n    ) {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          // For `(`, will later change to `capturing` and add `number` prop if no named captures\n          kind: TokenGroupKinds.group\n        })\n      };\n    }\n    if (m === \"(?>\") {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.atomic\n        })\n      };\n    }\n    if (m === \"(?=\" || m === \"(?!\" || m === \"(?<=\" || m === \"(?<!\") {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: m2 === \"<\" ? TokenGroupKinds.lookbehind : TokenGroupKinds.lookahead,\n          negate: m.endsWith(\"!\")\n        })\n      };\n    }\n    if (m2 === \"<\" || m2 === \"'\" || m === \"(\" && context.captureGroup) {\n      const token = createToken(TokenTypes.GroupOpen, m, {\n        kind: TokenGroupKinds.capturing\n        // Will add `number` in a second pass\n      });\n      if (m !== \"(\") {\n        token.name = m.slice(3, -1);\n      }\n      return {\n        token\n      };\n    }\n    if (m2 === \"(\") {\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    if (m2 === \"~\") {\n      throw new Error(`Unsupported absence operator \"${m}\"`);\n    }\n    if (m === \"(?\") {\n      throw new Error(\"Invalid group\");\n    }\n    throw new Error(`Unexpected group \"${m}\"`);\n  }\n  if (m === \")\") {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createToken(TokenTypes.GroupClose, m)\n    };\n  }\n  if (m === \"#\" && context.getCurrentModX()) {\n    const end = pattern.indexOf(\"\\n\", lastIndex);\n    return {\n      // Jump forward to the end of the comment\n      lastIndex: end === -1 ? pattern.length : end\n    };\n  }\n  if (/^\\s$/.test(m) && context.getCurrentModX()) {\n    const re = /\\s+/y;\n    re.lastIndex = lastIndex;\n    const rest = re.exec(pattern);\n    return {\n      // Jump forward to the end of the whitespace\n      lastIndex: rest ? re.lastIndex : lastIndex\n    };\n  }\n  if (m === \".\") {\n    return {\n      token: createToken(TokenTypes.CharacterSet, m, {\n        kind: TokenCharacterSetKinds.dot\n      })\n    };\n  }\n  if (m === \"^\" || m === \"$\") {\n    return {\n      token: createToken(TokenTypes.Assertion, m, {\n        kind: m\n      })\n    };\n  }\n  if (m === \"|\") {\n    return {\n      token: createToken(TokenTypes.Alternator, m)\n    };\n  }\n  if (quantifierRe.test(m)) {\n    return {\n      token: createTokenForQuantifier(m)\n    };\n  }\n  assertSingleCodePoint(m);\n  return {\n    token: createToken(TokenTypes.Character, m, {\n      value: m.codePointAt(0)\n    })\n  };\n}\nfunction getAllTokensForCharClass(pattern, opener, lastIndex) {\n  const tokens = [createToken(TokenTypes.CharacterClassOpen, opener, {\n    negate: opener[1] === \"^\"\n  })];\n  let numCharClassesOpen = 1;\n  let match;\n  charClassTokenRe.lastIndex = lastIndex;\n  while (match = charClassTokenRe.exec(pattern)) {\n    const m = match[0];\n    if (m[0] === \"[\" && m[1] !== \":\") {\n      numCharClassesOpen++;\n      tokens.push(createToken(TokenTypes.CharacterClassOpen, m, {\n        negate: m[1] === \"^\"\n      }));\n    } else if (m === \"]\") {\n      if (tokens.at(-1).type === TokenTypes.CharacterClassOpen) {\n        tokens.push(createToken(TokenTypes.Character, m, {\n          value: 93\n        }));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createToken(TokenTypes.CharacterClassClose, m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = createTokenForAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length\n  };\n}\nfunction createTokenForAnyTokenWithinCharClass(raw) {\n  if (raw[0] === \"\\\\\") {\n    return createTokenForSharedEscape(raw, { inCharClass: true });\n  }\n  if (raw[0] === \"[\") {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassesMap.get(posix.groups.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createToken(TokenTypes.CharacterSet, raw, {\n      kind: TokenCharacterSetKinds.posix,\n      negate: !!posix.groups.negate,\n      value: posix.groups.name\n    });\n  }\n  if (raw === \"-\") {\n    return createToken(TokenTypes.CharacterClassHyphen, raw);\n  }\n  if (raw === \"&&\") {\n    return createToken(TokenTypes.CharacterClassIntersector, raw);\n  }\n  assertSingleCodePoint(raw);\n  return createToken(TokenTypes.Character, raw, {\n    value: raw.codePointAt(0)\n  });\n}\nfunction createTokenForSharedEscape(raw, { inCharClass }) {\n  const char1 = raw[1];\n  if (char1 === \"c\" || char1 === \"C\") {\n    return createTokenForControlChar(raw);\n  }\n  if (\"dDhHsSwW\".includes(char1)) {\n    return createTokenForShorthandCharClass(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(`Incomplete or invalid Unicode property \"${raw}\"`);\n    }\n    return createTokenForUnicodeProperty(raw);\n  }\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map((hex) => parseInt(hex, 16));\n      const decoded = new TextDecoder(\"utf-8\", {\n        ignoreBOM: true,\n        fatal: true\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map((char) => {\n        const raw2 = [...encoder.encode(char)].map((byte) => `\\\\x${byte.toString(16)}`).join(\"\");\n        return createToken(TokenTypes.Character, raw2, {\n          value: char.codePointAt(0)\n        });\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === \"u\" || char1 === \"x\") {\n    return createToken(TokenTypes.Character, raw, {\n      value: getValidatedHexCharCode(raw)\n    });\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createToken(TokenTypes.Character, raw, {\n      value: EscapeCharCodes.get(char1)\n    });\n  }\n  if (/\\d/.test(char1)) {\n    return createToken(TokenTypes.EscapedNumber, raw, {\n      inCharClass\n    });\n  }\n  if (raw === \"\\\\\") {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  if (char1 === \"M\") {\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  if ([...raw].length === 2) {\n    return createToken(TokenTypes.Character, raw, {\n      value: raw.codePointAt(1)\n    });\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\nfunction createToken(type, raw, data) {\n  return {\n    type,\n    raw,\n    ...data\n  };\n}\nfunction createTokenForControlChar(raw) {\n  const char = raw[1] === \"c\" ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createToken(TokenTypes.Character, raw, {\n    value: char.toUpperCase().codePointAt(0) - 64\n  });\n}\nfunction createTokenForFlagMod(raw, context) {\n  let { on, off } = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[imx\\-]*))?/.exec(raw).groups;\n  off ??= \"\";\n  const isXOn = (context.getCurrentModX() || on.includes(\"x\")) && !off.includes(\"x\");\n  const enabledFlags = getFlagPropsForToken(on);\n  const disabledFlags = getFlagPropsForToken(off);\n  const flagChanges = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  if (raw.endsWith(\")\")) {\n    context.replaceCurrentModX(isXOn);\n    return createToken(TokenTypes.Directive, raw, {\n      kind: TokenDirectiveKinds.flags,\n      flags: flagChanges\n    });\n  }\n  if (raw.endsWith(\":\")) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    const token = createToken(TokenTypes.GroupOpen, raw, {\n      kind: TokenGroupKinds.group\n    });\n    if (enabledFlags || disabledFlags) {\n      token.flags = flagChanges;\n    }\n    return token;\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\nfunction createTokenForQuantifier(raw) {\n  const data = {};\n  if (raw[0] === \"{\") {\n    const { min, max } = /^\\{(?<min>\\d*)(?:,(?<max>\\d*))?/.exec(raw).groups;\n    const limit = 1e5;\n    if (+min > limit || +max > limit) {\n      throw new Error(\"Quantifier value unsupported in Oniguruma\");\n    }\n    data.min = +min;\n    data.max = max === void 0 ? +min : max === \"\" ? Infinity : +max;\n    data.greedy = !raw.endsWith(\"?\");\n    data.possessive = false;\n  } else {\n    data.min = raw[0] === \"+\" ? 1 : 0;\n    data.max = raw[0] === \"?\" ? 1 : Infinity;\n    data.greedy = raw[1] !== \"?\";\n    data.possessive = raw[1] === \"+\";\n  }\n  return createToken(TokenTypes.Quantifier, raw, data);\n}\nfunction createTokenForShorthandCharClass(raw) {\n  const lower = raw[1].toLowerCase();\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: {\n      \"d\": TokenCharacterSetKinds.digit,\n      \"h\": TokenCharacterSetKinds.hex,\n      // Not available in JS\n      \"s\": TokenCharacterSetKinds.space,\n      // Different than JS\n      \"w\": TokenCharacterSetKinds.word\n    }[lower],\n    negate: raw[1] !== lower\n  });\n}\nfunction createTokenForUnicodeProperty(raw) {\n  const { p, neg, value } = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)/.exec(raw).groups;\n  const negate = p === \"P\" && !neg || p === \"p\" && !!neg;\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: TokenCharacterSetKinds.property,\n    negate,\n    value\n  });\n}\nfunction getFlagPropsForToken(flags) {\n  const obj = {};\n  if (flags.includes(\"i\")) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes(\"m\")) {\n    obj.dotAll = true;\n  }\n  if (flags.includes(\"x\")) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\nfunction getValidatedHexCharCode(raw) {\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  const hex = raw[2] === \"{\" ? /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw).groups.hex : raw.slice(2);\n  const dec = parseInt(hex, 16);\n  return dec;\n}\nfunction splitEscapedNumToken(token, numCaptures) {\n  const { raw, inCharClass } = token;\n  const value = raw.slice(1);\n  if (!inCharClass && // Single digit 1-9 outside a char class is always treated as a backref\n  (value !== \"0\" && value.length === 1 || // Leading 0 makes it octal; backrefs can't include following literal digits\n  value[0] !== \"0\" && +value <= numCaptures)) {\n    return [createToken(TokenTypes.Backreference, raw)];\n  }\n  const tokens = [];\n  const matches = value.match(/^[0-7]+|\\d/g);\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value2;\n    if (i === 0 && m !== \"8\" && m !== \"9\") {\n      value2 = parseInt(m, 8);\n      if (value2 > 127) {\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value2 = m.codePointAt(0);\n    }\n    tokens.push(createToken(TokenTypes.Character, (i === 0 ? \"\\\\\" : \"\") + m, {\n      value: value2\n    }));\n  }\n  return tokens;\n}\nfunction assertSingleCodePoint(raw) {\n  if ([...raw].length !== 1) {\n    throw new Error(`Expected \"${raw}\" to be a single code point`);\n  }\n}\n\n// src/utils-ast.js\nfunction hasOnlyChild({ alternatives }, kidFn) {\n  return alternatives.length === 1 && alternatives[0].elements.length === 1 && (!kidFn || kidFn(alternatives[0].elements[0]));\n}\nfunction isLookaround({ type, kind }) {\n  return type === AstTypes.Assertion && (kind === AstAssertionKinds.lookahead || kind === AstAssertionKinds.lookbehind);\n}\nfunction isZeroLengthNode({ type, min }) {\n  return type === AstTypes.Assertion || type === AstTypes.Directive || type === AstTypes.Quantifier && !min;\n}\n\n// src/traverse.js\nfunction traverse(path, state, visitor) {\n  let ast = path.node;\n  while (ast.parent) {\n    ast = ast.parent;\n  }\n  function traverseArray(array, parent) {\n    for (let i = 0; i < array.length; i++) {\n      const keyShift = traverseNode(array[i], parent, i, array);\n      i = Math.max(-1, i + keyShift);\n    }\n  }\n  function traverseNode(node, parent = null, key = null, container = null) {\n    let keyShift = 0;\n    let skipTraversingKidsOfPath = false;\n    const path2 = {\n      node,\n      parent,\n      key,\n      container,\n      ast,\n      remove() {\n        throwIfNot(container, \"Container expected\").splice(Math.max(0, key + keyShift), 1);\n        keyShift -= 1;\n      },\n      removeAllNextSiblings() {\n        return throwIfNot(container, \"Container expected\").splice(key + 1);\n      },\n      removeAllPrevSiblings() {\n        const shifted = key + keyShift;\n        keyShift -= shifted;\n        return throwIfNot(container, \"Container expected\").splice(0, Math.max(0, shifted));\n      },\n      replaceWith(newNode) {\n        setParent(newNode, parent);\n        if (container) {\n          container[Math.max(0, key + keyShift)] = newNode;\n        } else {\n          parent[key] = newNode;\n        }\n      },\n      skip() {\n        skipTraversingKidsOfPath = true;\n      }\n    };\n    const visitorKey = getAstTypeAliases(node).find((key2) => !!visitor[key2]);\n    const methods = visitorKey && visitor[visitorKey];\n    const enterFn = typeof methods === \"function\" ? methods : methods?.enter;\n    const exitFn = methods?.exit;\n    enterFn?.(path2, state);\n    if (!skipTraversingKidsOfPath) {\n      switch (node.type) {\n        case AstTypes.Regex:\n          traverseNode(node.pattern, node, \"pattern\");\n          traverseNode(node.flags, node, \"flags\");\n          break;\n        case AstTypes.Alternative:\n        case AstTypes.CharacterClass:\n          traverseArray(node.elements, node);\n          break;\n        case AstTypes.Assertion:\n          if (isLookaround(node)) {\n            traverseArray(node.alternatives, node);\n          }\n          break;\n        case AstTypes.Backreference:\n        case AstTypes.Character:\n        case AstTypes.CharacterSet:\n        case AstTypes.Directive:\n        case AstTypes.Flags:\n        case AstTypes.Recursion:\n        case AstTypes.Subroutine:\n        case AstTypes.VariableLengthCharacterSet:\n          break;\n        case AstTypes.CapturingGroup:\n        case AstTypes.Group:\n        case AstTypes.Pattern:\n          traverseArray(node.alternatives, node);\n          break;\n        case AstTypes.CharacterClassIntersection:\n          traverseArray(node.classes, node);\n          break;\n        case AstTypes.CharacterClassRange:\n          traverseNode(node.min, node, \"min\");\n          traverseNode(node.max, node, \"max\");\n          break;\n        case AstTypes.Quantifier:\n          traverseNode(node.element, node, \"element\");\n          break;\n        default:\n          throw new Error(`Unexpected node type \"${node.type}\"`);\n      }\n    }\n    exitFn?.(path2, state);\n    return keyShift;\n  }\n  traverseNode(path.node, path.parent, path.key, path.container);\n}\nvar AstTypeAliases = {\n  AnyGroup: \"AnyGroup\",\n  AnyNode: \"AnyNode\"\n};\nfunction getAstTypeAliases(node) {\n  const { type } = node;\n  const types = [AstTypeAliases.AnyNode];\n  if (type === AstTypes.CapturingGroup || type === AstTypes.Group || isLookaround(node)) {\n    types.push(AstTypeAliases.AnyGroup);\n  }\n  types.push(type);\n  return types;\n}\nfunction setParent(node, parent) {\n  if (\"parent\" in parent) {\n    node.parent = parent;\n  }\n}\n\n// src/parse.js\nvar AstTypes = {\n  Alternative: \"Alternative\",\n  Assertion: \"Assertion\",\n  Backreference: \"Backreference\",\n  CapturingGroup: \"CapturingGroup\",\n  Character: \"Character\",\n  CharacterClass: \"CharacterClass\",\n  CharacterClassIntersection: \"CharacterClassIntersection\",\n  CharacterClassRange: \"CharacterClassRange\",\n  CharacterSet: \"CharacterSet\",\n  Directive: \"Directive\",\n  Flags: \"Flags\",\n  Group: \"Group\",\n  Pattern: \"Pattern\",\n  Quantifier: \"Quantifier\",\n  Regex: \"Regex\",\n  Subroutine: \"Subroutine\",\n  VariableLengthCharacterSet: \"VariableLengthCharacterSet\",\n  // Used only by the transformer for Regex+ ASTs\n  Recursion: \"Recursion\"\n};\nvar AstAssertionKinds = {\n  line_end: \"line_end\",\n  line_start: \"line_start\",\n  lookahead: \"lookahead\",\n  lookbehind: \"lookbehind\",\n  search_start: \"search_start\",\n  string_end: \"string_end\",\n  string_end_newline: \"string_end_newline\",\n  string_start: \"string_start\",\n  word_boundary: \"word_boundary\"\n};\nvar AstCharacterSetKinds = TokenCharacterSetKinds;\nvar AstDirectiveKinds = TokenDirectiveKinds;\nvar AstVariableLengthCharacterSetKinds = {\n  grapheme: \"grapheme\",\n  newline: \"newline\"\n};\nfunction parse({ tokens, flags, rules }, options) {\n  const opts = {\n    skipBackrefValidation: false,\n    skipLookbehindValidation: false,\n    skipPropertyNameValidation: false,\n    verbose: false,\n    ...options\n  };\n  const context = {\n    capturingGroups: [],\n    current: 0,\n    hasNumberedRef: false,\n    namedGroupsByName: /* @__PURE__ */ new Map(),\n    parent: null,\n    skipBackrefValidation: opts.skipBackrefValidation,\n    skipLookbehindValidation: opts.skipLookbehindValidation,\n    skipPropertyNameValidation: opts.skipPropertyNameValidation,\n    subroutines: [],\n    token: null,\n    tokens,\n    verbose: opts.verbose,\n    walk\n  };\n  function walk(parent, state) {\n    const token = tokens[context.current];\n    context.parent = parent;\n    context.token = token;\n    context.current++;\n    switch (token.type) {\n      case TokenTypes.Alternator:\n        return createAlternative();\n      case TokenTypes.Assertion:\n        return createAssertionFromToken(token);\n      case TokenTypes.Backreference:\n        return parseBackreference(context);\n      case TokenTypes.Character:\n        return createCharacter(token.value, { useLastValid: !!state.isCheckingRangeEnd });\n      case TokenTypes.CharacterClassHyphen:\n        return parseCharacterClassHyphen(context, state);\n      case TokenTypes.CharacterClassOpen:\n        return parseCharacterClassOpen(context, state);\n      case TokenTypes.CharacterSet:\n        return parseCharacterSet(context);\n      case TokenTypes.Directive:\n        return createDirectiveFromToken(token);\n      case TokenTypes.GroupOpen:\n        return parseGroupOpen(context, state);\n      case TokenTypes.Quantifier:\n        return parseQuantifier(context);\n      case TokenTypes.Subroutine:\n        return parseSubroutine(context);\n      case TokenTypes.VariableLengthCharacterSet:\n        return createVariableLengthCharacterSet(token.kind);\n      default:\n        throw new Error(`Unexpected token type \"${token.type}\"`);\n    }\n  }\n  const ast = createRegex(createPattern(), createFlags(flags));\n  let top = ast.pattern.alternatives[0];\n  while (context.current < tokens.length) {\n    const node = walk(top, {});\n    if (node.type === AstTypes.Alternative) {\n      ast.pattern.alternatives.push(node);\n      top = node;\n    } else {\n      top.elements.push(node);\n    }\n  }\n  const { capturingGroups, hasNumberedRef, namedGroupsByName, subroutines } = context;\n  if (hasNumberedRef && namedGroupsByName.size && !rules.captureGroup) {\n    throw new Error(\"Numbered backref/subroutine not allowed when using named capture\");\n  }\n  for (const { ref } of subroutines) {\n    if (typeof ref === \"number\") {\n      if (ref > capturingGroups.length) {\n        throw new Error(`Subroutine uses a group number that's not defined`);\n      }\n    } else if (!namedGroupsByName.has(ref)) {\n      throw new Error(r`Subroutine uses a group name that's not defined \"\\g<${ref}>\"`);\n    } else if (namedGroupsByName.get(ref).length > 1) {\n      throw new Error(r`Subroutine uses a duplicate group name \"\\g<${ref}>\"`);\n    }\n  }\n  traverse({ node: ast }, null, {\n    AnyNode({ node, parent }) {\n      node.parent = parent;\n    }\n  });\n  return ast;\n}\nfunction parseBackreference(context) {\n  const { raw } = context.token;\n  const hasKWrapper = /^\\\\k[<']/.test(raw);\n  const ref = hasKWrapper ? raw.slice(3, -1) : raw.slice(1);\n  const fromNum = (num, isRelative = false) => {\n    const numCapturesToLeft = context.capturingGroups.length;\n    let orphan = false;\n    if (num > numCapturesToLeft) {\n      if (context.skipBackrefValidation) {\n        orphan = true;\n      } else {\n        throw new Error(`Not enough capturing groups defined to the left \"${raw}\"`);\n      }\n    }\n    context.hasNumberedRef = true;\n    return createBackreference(isRelative ? numCapturesToLeft + 1 - num : num, { orphan });\n  };\n  if (hasKWrapper) {\n    const numberedRef = /^(?<sign>-?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n    if (numberedRef) {\n      return fromNum(+numberedRef.groups.num, !!numberedRef.groups.sign);\n    }\n    if (/[-+]/.test(ref)) {\n      throw new Error(`Invalid backref name \"${raw}\"`);\n    }\n    if (!context.namedGroupsByName.has(ref)) {\n      throw new Error(`Group name not defined to the left \"${raw}\"`);\n    }\n    return createBackreference(ref);\n  }\n  return fromNum(+ref);\n}\nfunction parseCharacterClassHyphen(context, state) {\n  const { parent, tokens, walk } = context;\n  const prevSiblingNode = parent.elements.at(-1);\n  const nextToken = tokens[context.current];\n  if (!state.isCheckingRangeEnd && prevSiblingNode && prevSiblingNode.type !== AstTypes.CharacterClass && prevSiblingNode.type !== AstTypes.CharacterClassRange && nextToken && nextToken.type !== TokenTypes.CharacterClassOpen && nextToken.type !== TokenTypes.CharacterClassClose && nextToken.type !== TokenTypes.CharacterClassIntersector) {\n    const nextNode = walk(parent, {\n      ...state,\n      isCheckingRangeEnd: true\n    });\n    if (prevSiblingNode.type === AstTypes.Character && nextNode.type === AstTypes.Character) {\n      parent.elements.pop();\n      return createCharacterClassRange(prevSiblingNode, nextNode);\n    }\n    throw new Error(\"Invalid character class range\");\n  }\n  return createCharacter(45);\n}\nfunction parseCharacterClassOpen(context, state) {\n  const { token, tokens, verbose, walk } = context;\n  const firstClassToken = tokens[context.current];\n  let node = createCharacterClass({ negate: token.negate });\n  const intersection = node.elements[0];\n  let nextToken = throwIfUnclosedCharacterClass(firstClassToken);\n  while (nextToken.type !== TokenTypes.CharacterClassClose) {\n    if (nextToken.type === TokenTypes.CharacterClassIntersector) {\n      intersection.classes.push(createCharacterClass({ negate: false, baseOnly: true }));\n      context.current++;\n    } else {\n      const cc = intersection.classes.at(-1);\n      cc.elements.push(walk(cc, state));\n    }\n    nextToken = throwIfUnclosedCharacterClass(tokens[context.current], firstClassToken);\n  }\n  if (!verbose) {\n    optimizeCharacterClassIntersection(intersection);\n  }\n  if (intersection.classes.length === 1) {\n    const cc = intersection.classes[0];\n    cc.negate = node.negate !== cc.negate;\n    node = cc;\n  }\n  context.current++;\n  return node;\n}\nfunction parseCharacterSet({ token, skipPropertyNameValidation }) {\n  let { kind, negate, value } = token;\n  if (kind === TokenCharacterSetKinds.property) {\n    const normalized = slug(value);\n    if (PosixProperties.has(normalized)) {\n      kind = TokenCharacterSetKinds.posix;\n      value = normalized;\n    } else {\n      return createUnicodeProperty(value, {\n        negate,\n        skipPropertyNameValidation\n      });\n    }\n  }\n  if (kind === TokenCharacterSetKinds.posix) {\n    return {\n      type: AstTypes.CharacterSet,\n      kind: AstCharacterSetKinds.posix,\n      negate,\n      value\n    };\n  }\n  return createCharacterSet(kind, { negate });\n}\nfunction parseGroupOpen(context, state) {\n  const { token, tokens, capturingGroups, namedGroupsByName, skipLookbehindValidation, verbose, walk } = context;\n  let node = createByGroupKind(token);\n  if (node.type === AstTypes.CapturingGroup) {\n    capturingGroups.push(node);\n    if (node.name) {\n      getOrCreate(namedGroupsByName, node.name, []).push(node);\n    }\n  }\n  let nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  while (nextToken.type !== TokenTypes.GroupClose) {\n    if (nextToken.type === TokenTypes.Alternator) {\n      node.alternatives.push(createAlternative());\n      context.current++;\n    } else {\n      const alt = node.alternatives.at(-1);\n      const isLookbehind = node.kind === AstAssertionKinds.lookbehind;\n      const isNegLookbehind = isLookbehind && node.negate;\n      const child = walk(alt, {\n        ...state,\n        isInLookbehind: state.isInLookbehind || isLookbehind,\n        isInNegLookbehind: state.isInNegLookbehind || isNegLookbehind\n      });\n      alt.elements.push(child);\n      if ((isLookbehind || state.isInLookbehind) && !skipLookbehindValidation) {\n        const msg = \"Lookbehind includes a pattern not allowed by Oniguruma\";\n        if (isNegLookbehind || state.isInNegLookbehind) {\n          if (child.kind === AstAssertionKinds.lookahead || child.type === AstTypes.CapturingGroup) {\n            throw new Error(msg);\n          }\n        } else {\n          if (child.kind === AstAssertionKinds.lookahead || child.kind === AstAssertionKinds.lookbehind && child.negate) {\n            throw new Error(msg);\n          }\n        }\n      }\n    }\n    nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  }\n  if (!verbose) {\n    node = getOptimizedGroup(node);\n  }\n  context.current++;\n  return node;\n}\nfunction parseQuantifier({ token, parent }) {\n  const { min, max, greedy, possessive: possessive2 } = token;\n  const quantifiedNode = parent.elements.at(-1);\n  if (!quantifiedNode || quantifiedNode.type === AstTypes.Assertion || quantifiedNode.type === AstTypes.Directive) {\n    throw new Error(`Quantifier requires a repeatable token`);\n  }\n  const node = createQuantifier(quantifiedNode, min, max, greedy, possessive2);\n  parent.elements.pop();\n  return node;\n}\nfunction parseSubroutine(context) {\n  const { token, capturingGroups, subroutines } = context;\n  let ref = token.raw.slice(3, -1);\n  const numberedRef = /^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n  if (numberedRef) {\n    const num = +numberedRef.groups.num;\n    const numCapturesToLeft = capturingGroups.length;\n    context.hasNumberedRef = true;\n    ref = {\n      \"\": num,\n      \"+\": numCapturesToLeft + num,\n      \"-\": numCapturesToLeft + 1 - num\n    }[numberedRef.groups.sign];\n    if (ref < 1) {\n      throw new Error(\"Invalid subroutine number\");\n    }\n  } else if (ref === \"0\") {\n    ref = 0;\n  }\n  const node = createSubroutine(ref);\n  subroutines.push(node);\n  return node;\n}\nfunction createAlternative() {\n  return {\n    type: AstTypes.Alternative,\n    elements: []\n  };\n}\nfunction createAssertionFromToken({ type, kind, negate }) {\n  if (type === TokenTypes.GroupOpen) {\n    return createLookaround({\n      behind: kind === TokenGroupKinds.lookbehind,\n      negate\n    });\n  }\n  const nodeKind = throwIfNot({\n    \"^\": AstAssertionKinds.line_start,\n    \"$\": AstAssertionKinds.line_end,\n    \"\\\\A\": AstAssertionKinds.string_start,\n    \"\\\\b\": AstAssertionKinds.word_boundary,\n    \"\\\\B\": AstAssertionKinds.word_boundary,\n    \"\\\\G\": AstAssertionKinds.search_start,\n    \"\\\\z\": AstAssertionKinds.string_end,\n    \"\\\\Z\": AstAssertionKinds.string_end_newline\n  }[kind], `Unexpected assertion kind \"${kind}\"`);\n  const node = {\n    type: AstTypes.Assertion,\n    kind: nodeKind\n  };\n  if (nodeKind === AstAssertionKinds.word_boundary) {\n    node.negate = kind === r`\\B`;\n  }\n  return node;\n}\nfunction createBackreference(ref, options) {\n  const orphan = !!options?.orphan;\n  return {\n    type: AstTypes.Backreference,\n    ...orphan && { orphan },\n    ref\n  };\n}\nfunction createByGroupKind(token) {\n  const { kind, number, name, flags } = token;\n  switch (kind) {\n    case TokenGroupKinds.atomic:\n      return createGroup({ atomic: true });\n    case TokenGroupKinds.capturing:\n      return createCapturingGroup(number, name);\n    case TokenGroupKinds.group:\n      return createGroup({ flags });\n    case TokenGroupKinds.lookahead:\n    case TokenGroupKinds.lookbehind:\n      return createAssertionFromToken(token);\n    default:\n      throw new Error(`Unexpected group kind \"${kind}\"`);\n  }\n}\nfunction createCapturingGroup(number, name) {\n  const hasName = name !== void 0;\n  if (hasName && !isValidGroupNameOniguruma(name)) {\n    throw new Error(`Group name \"${name}\" invalid in Oniguruma`);\n  }\n  return {\n    type: AstTypes.CapturingGroup,\n    number,\n    ...hasName && { name },\n    alternatives: [createAlternative()]\n  };\n}\nfunction createCharacter(charCode, options) {\n  const opts = {\n    useLastValid: false,\n    ...options\n  };\n  if (charCode > 1114111) {\n    const hex = charCode.toString(16);\n    if (opts.useLastValid) {\n      charCode = 1114111;\n    } else if (charCode > 1310719) {\n      throw new Error(`Invalid code point out of range \"\\\\x{${hex}}\"`);\n    } else {\n      throw new Error(`Invalid code point out of range in JS \"\\\\x{${hex}}\"`);\n    }\n  }\n  return {\n    type: AstTypes.Character,\n    value: charCode\n  };\n}\nfunction createCharacterClass(options) {\n  const opts = {\n    baseOnly: false,\n    negate: false,\n    ...options\n  };\n  return {\n    type: AstTypes.CharacterClass,\n    negate: opts.negate,\n    elements: opts.baseOnly ? [] : [createCharacterClassIntersection()]\n  };\n}\nfunction createCharacterClassIntersection() {\n  return {\n    type: AstTypes.CharacterClassIntersection,\n    classes: [createCharacterClass({ negate: false, baseOnly: true })]\n  };\n}\nfunction createCharacterClassRange(min, max) {\n  if (max.value < min.value) {\n    throw new Error(\"Character class range out of order\");\n  }\n  return {\n    type: AstTypes.CharacterClassRange,\n    min,\n    max\n  };\n}\nfunction createCharacterSet(kind, { negate }) {\n  const node = {\n    type: AstTypes.CharacterSet,\n    kind: throwIfNot(AstCharacterSetKinds[kind], `Unexpected character set kind \"${kind}\"`)\n  };\n  if (kind === TokenCharacterSetKinds.digit || kind === TokenCharacterSetKinds.hex || kind === TokenCharacterSetKinds.space || kind === TokenCharacterSetKinds.word) {\n    node.negate = negate;\n  }\n  return node;\n}\nfunction createDirectiveFromToken({ kind, flags }) {\n  const node = {\n    type: AstTypes.Directive,\n    kind: throwIfNot(AstDirectiveKinds[kind], `Unexpected directive kind \"${kind}\"`)\n  };\n  if (kind === TokenDirectiveKinds.flags) {\n    node.flags = flags;\n  }\n  return node;\n}\nfunction createFlags({ ignoreCase, dotAll, extended, digitIsAscii, spaceIsAscii, wordIsAscii }) {\n  return {\n    type: AstTypes.Flags,\n    ignoreCase,\n    dotAll,\n    extended,\n    digitIsAscii,\n    spaceIsAscii,\n    wordIsAscii\n  };\n}\nfunction createGroup(options) {\n  const atomic2 = options?.atomic;\n  const flags = options?.flags;\n  return {\n    type: AstTypes.Group,\n    ...atomic2 && { atomic: atomic2 },\n    ...flags && { flags },\n    alternatives: [createAlternative()]\n  };\n}\nfunction createLookaround(options) {\n  const opts = {\n    behind: false,\n    negate: false,\n    ...options\n  };\n  return {\n    type: AstTypes.Assertion,\n    kind: opts.behind ? AstAssertionKinds.lookbehind : AstAssertionKinds.lookahead,\n    negate: opts.negate,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createPattern() {\n  return {\n    type: AstTypes.Pattern,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createQuantifier(element, min, max, greedy, possessive2) {\n  const node = {\n    type: AstTypes.Quantifier,\n    min,\n    max,\n    greedy,\n    possessive: possessive2,\n    element\n  };\n  if (max < min) {\n    return {\n      ...node,\n      min: max,\n      max: min,\n      possessive: true\n    };\n  }\n  return node;\n}\nfunction createRegex(pattern, flags) {\n  return {\n    type: AstTypes.Regex,\n    pattern,\n    flags\n  };\n}\nfunction createSubroutine(ref) {\n  return {\n    type: AstTypes.Subroutine,\n    ref\n  };\n}\nfunction createUnicodeProperty(value, options) {\n  const opts = {\n    negate: false,\n    skipPropertyNameValidation: false,\n    ...options\n  };\n  return {\n    type: AstTypes.CharacterSet,\n    kind: AstCharacterSetKinds.property,\n    value: opts.skipPropertyNameValidation ? value : getJsUnicodePropertyName(value),\n    negate: opts.negate\n  };\n}\nfunction createVariableLengthCharacterSet(kind) {\n  return {\n    type: AstTypes.VariableLengthCharacterSet,\n    kind: throwIfNot({\n      \"\\\\R\": AstVariableLengthCharacterSetKinds.newline,\n      \"\\\\X\": AstVariableLengthCharacterSetKinds.grapheme\n    }[kind], `Unexpected varcharset kind \"${kind}\"`)\n  };\n}\nfunction getJsUnicodePropertyName(value) {\n  const slugged = slug(value);\n  if (JsUnicodePropertiesOfStringsMap.has(slugged)) {\n    throw new Error(r`Unicode property \"\\p{${value}}\" unsupported in Oniguruma`);\n  }\n  const jsName = JsUnicodePropertiesMap.get(slugged);\n  if (jsName) {\n    return jsName;\n  }\n  return value.trim().replace(/[- _]+/g, \"_\").replace(/[A-Z][a-z]+(?=[A-Z])/g, \"$&_\").replace(/[A-Za-z]+/g, (m) => m[0].toUpperCase() + m.slice(1).toLowerCase());\n}\nfunction getOptimizedGroup(node) {\n  const firstAltFirstEl = node.alternatives[0].elements[0];\n  if (node.type === AstTypes.Group && hasOnlyChild(node, (kid) => kid.type === AstTypes.Group) && !(node.atomic && firstAltFirstEl.flags) && !(node.flags && (firstAltFirstEl.atomic || firstAltFirstEl.flags))) {\n    if (node.atomic) {\n      firstAltFirstEl.atomic = true;\n    } else if (node.flags) {\n      firstAltFirstEl.flags = node.flags;\n    }\n    return firstAltFirstEl;\n  }\n  return node;\n}\nfunction isValidGroupNameOniguruma(name) {\n  return !/^(?:[-\\d]|$)/.test(name);\n}\nfunction optimizeCharacterClassIntersection(intersection) {\n  for (let i = 0; i < intersection.classes.length; i++) {\n    const cc = intersection.classes[i];\n    const firstChild = cc.elements[0];\n    if (cc.elements.length === 1 && firstChild.type === AstTypes.CharacterClass) {\n      intersection.classes[i] = firstChild;\n      firstChild.negate = cc.negate !== firstChild.negate;\n    }\n  }\n}\nfunction throwIfUnclosedCharacterClass(token, firstClassToken) {\n  return throwIfNot(\n    token,\n    // Easier to understand error when applicable\n    `${firstClassToken?.value === 93 ? \"Empty\" : \"Unclosed\"} character class`\n  );\n}\nfunction throwIfUnclosedGroup(token) {\n  return throwIfNot(token, \"Unclosed group\");\n}\n\n// src/subclass.js\n\nvar EmulatedRegExp = class _EmulatedRegExp extends regex_internals__WEBPACK_IMPORTED_MODULE_0__.RegExpSubclass {\n  /**\n  @private\n  @type {string | null}\n  */\n  #strategy;\n  /**\n  Can be used to serialize the arguments used to create the instance.\n  @type {{\n    pattern: string;\n    flags: string;\n    options: EmulatedRegExpOptions;\n  }}\n  */\n  rawArgs;\n  /**\n  @overload\n  @param {string} pattern\n  @param {string} [flags]\n  @param {EmulatedRegExpOptions} [options]\n  */\n  /**\n  @overload\n  @param {EmulatedRegExp} pattern\n  @param {string} [flags]\n  */\n  constructor(pattern, flags, options) {\n    if (pattern instanceof RegExp) {\n      if (options) {\n        throw new Error(\"Cannot provide options when copying a regexp\");\n      }\n      super(pattern, flags);\n      if (pattern instanceof _EmulatedRegExp) {\n        this.#strategy = pattern.#strategy;\n        this.rawArgs = pattern.rawArgs;\n      } else {\n        this.#strategy = null;\n        this.rawArgs = {\n          pattern: pattern.source,\n          flags: pattern.flags,\n          options: {}\n        };\n      }\n      if (flags !== void 0) {\n        this.rawArgs.flags = flags;\n      }\n    } else {\n      const opts = {\n        strategy: null,\n        useEmulationGroups: false,\n        ...options\n      };\n      super(pattern, flags, { useEmulationGroups: opts.useEmulationGroups });\n      this.#strategy = opts.strategy;\n      this.rawArgs = {\n        pattern,\n        flags: flags ?? \"\",\n        options: {\n          ...opts.strategy ? { strategy: opts.strategy } : null,\n          ...opts.useEmulationGroups ? { useEmulationGroups: true } : null\n        }\n      };\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const exec = super.exec;\n    const useLastIndex = this.global || this.sticky;\n    const pos = this.lastIndex;\n    const strategy = this.#strategy;\n    if (strategy === \"line_or_search_start\" && useLastIndex && this.lastIndex) {\n      this.lastIndex = 0;\n      const match = exec.call(this, str.slice(pos));\n      if (match) {\n        adjustMatchDetails(str, this, match, pos);\n      }\n      return match;\n    }\n    if (strategy === \"not_search_start\") {\n      let match = exec.call(this, str);\n      if (match?.index === pos) {\n        const globalRe = useLastIndex ? this : new RegExp(this.source, `g${this.flags}`);\n        globalRe.lastIndex = match.index + 1;\n        match = exec.call(globalRe, str);\n      }\n      return match;\n    }\n    return exec.call(this, str);\n  }\n};\nfunction adjustMatchDetails(str, re, match, offset) {\n  match.input = str;\n  match.index += offset;\n  re.lastIndex += offset;\n  if (re.hasIndices) {\n    const matchIndices = match.indices;\n    for (let i = 0; i < matchIndices.length; i++) {\n      const arr = matchIndices[i];\n      matchIndices[i] = [arr[0] + offset, arr[1] + offset];\n    }\n    const groupIndices = matchIndices.groups;\n    if (groupIndices) {\n      Object.keys(groupIndices).forEach((key) => {\n        const arr = groupIndices[key];\n        groupIndices[key] = [arr[0] + offset, arr[1] + offset];\n      });\n    }\n  }\n}\nfunction applySubclassStrategies(ast) {\n  const alts = ast.pattern.alternatives;\n  const firstEl = alts[0].elements[0];\n  if (alts.length > 1 || !firstEl) {\n    return null;\n  }\n  const hasWrapperGroup = hasOnlyChild(ast.pattern, (kid) => kid.type === AstTypes.CapturingGroup || kid.type === AstTypes.Group) && firstEl.alternatives.length === 1;\n  const singleAltIn = hasWrapperGroup ? firstEl.alternatives[0] : alts[0];\n  const firstElIn = hasWrapperGroup ? singleAltIn.elements[0] : firstEl;\n  if (!firstElIn) {\n    return null;\n  }\n  if ((firstElIn.type === AstTypes.CapturingGroup || firstElIn.type === AstTypes.Group) && firstElIn.alternatives.length === 2 && firstElIn.alternatives[0].elements.length === 1 && firstElIn.alternatives[1].elements.length === 1) {\n    const el1 = firstElIn.alternatives[0].elements[0];\n    const el2 = firstElIn.alternatives[1].elements[0];\n    if (el1.kind === AstAssertionKinds.line_start && el2.kind === AstAssertionKinds.search_start || el1.kind === AstAssertionKinds.search_start && el2.kind === AstAssertionKinds.line_start) {\n      if (el1.kind === AstAssertionKinds.line_start) {\n        firstElIn.alternatives.pop();\n      } else {\n        firstElIn.alternatives.shift();\n      }\n      return \"line_or_search_start\";\n    }\n  }\n  if (isLoneGLookaround(firstElIn, { negate: true })) {\n    firstElIn.parent.elements.shift();\n    return \"not_search_start\";\n  }\n  for (let i = 0; i < singleAltIn.elements.length; i++) {\n    const el = singleAltIn.elements[i];\n    if (!isZeroLengthNode(el)) {\n      break;\n    }\n    if (isLoneGLookaround(el, { negate: true })) {\n      singleAltIn.elements.splice(i, 1);\n      return \"not_search_start\";\n    }\n  }\n  return null;\n}\nfunction isLoneGLookaround(node, options) {\n  return isLookaround(node) && node.negate === options.negate && hasOnlyChild(node, (kid) => kid.kind === AstAssertionKinds.search_start);\n}\n\n// src/transform.js\n\nfunction transform(ast, options) {\n  const opts = {\n    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:\n    // - `VariableLengthCharacterSet` kind `grapheme` (`\\X`): An exact representation would require\n    //   heavy Unicode data; a best-effort approximation requires knowing the target.\n    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode-based\n    //   representations would be hard to change to ASCII-based after the fact in the generator\n    //   based on `target`/`accuracy`, so produce the appropriate structure here.\n    accuracy: \"default\",\n    asciiWordBoundaries: false,\n    avoidSubclass: false,\n    bestEffortTarget: \"ES2025\",\n    ignoreUnsupportedGAnchors: false,\n    ...options\n  };\n  const strategy = opts.avoidSubclass ? null : applySubclassStrategies(ast);\n  const firstPassState = {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.asciiWordBoundaries,\n    flagDirectivesByAlt: /* @__PURE__ */ new Map(),\n    ignoreUnsupportedGAnchors: opts.ignoreUnsupportedGAnchors,\n    minTargetEs2024: isMinTarget(opts.bestEffortTarget, \"ES2024\"),\n    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass \n    subroutineRefMap: /* @__PURE__ */ new Map(),\n    supportedGNodes: /* @__PURE__ */ new Set(),\n    digitIsAscii: ast.flags.digitIsAscii,\n    spaceIsAscii: ast.flags.spaceIsAscii,\n    wordIsAscii: ast.flags.wordIsAscii\n  };\n  traverse({ node: ast }, firstPassState, FirstPassVisitor);\n  const globalFlags = {\n    dotAll: ast.flags.dotAll,\n    ignoreCase: ast.flags.ignoreCase\n  };\n  const secondPassState = {\n    currentFlags: globalFlags,\n    prevFlags: null,\n    globalFlags,\n    groupOriginByCopy: /* @__PURE__ */ new Map(),\n    groupsByName: /* @__PURE__ */ new Map(),\n    multiplexCapturesToLeftByRef: /* @__PURE__ */ new Map(),\n    openRefs: /* @__PURE__ */ new Map(),\n    reffedNodesByReferencer: /* @__PURE__ */ new Map(),\n    subroutineRefMap: firstPassState.subroutineRefMap\n  };\n  traverse({ node: ast }, secondPassState, SecondPassVisitor);\n  const thirdPassState = {\n    groupsByName: secondPassState.groupsByName,\n    highestOrphanBackref: 0,\n    numCapturesToLeft: 0,\n    reffedNodesByReferencer: secondPassState.reffedNodesByReferencer\n  };\n  traverse({ node: ast }, thirdPassState, ThirdPassVisitor);\n  if (strategy) {\n    ast._strategy = strategy;\n  }\n  return ast;\n}\nvar FirstPassVisitor = {\n  Alternative: {\n    enter({ node, parent, key }, { flagDirectivesByAlt }) {\n      const flagDirectives = node.elements.filter((el) => el.kind === AstDirectiveKinds.flags);\n      for (let i = key + 1; i < parent.alternatives.length; i++) {\n        const forwardSiblingAlt = parent.alternatives[i];\n        getOrCreate(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);\n      }\n    },\n    exit({ node }, { flagDirectivesByAlt }) {\n      if (flagDirectivesByAlt.get(node)?.length) {\n        const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));\n        if (flags) {\n          const flagGroup = prepContainer(createGroup({ flags }), node.elements);\n          flagGroup.parent = node;\n          node.elements = [flagGroup];\n        }\n      }\n    }\n  },\n  Assertion({ node, ast, remove, replaceWith }, { asciiWordBoundaries, ignoreUnsupportedGAnchors, supportedGNodes, wordIsAscii }) {\n    const { kind, negate } = node;\n    if (kind === AstAssertionKinds.line_end) {\n      replaceWith(parseFragment(r`(?=\\z|\\n)`));\n    } else if (kind === AstAssertionKinds.line_start) {\n      replaceWith(parseFragment(r`(?<=\\A|\\n(?!\\z))`, { skipLookbehindValidation: true }));\n    } else if (kind === AstAssertionKinds.search_start) {\n      if (supportedGNodes.has(node)) {\n        ast.flags.sticky = true;\n      } else if (!ignoreUnsupportedGAnchors) {\n        throw new Error(r`Uses \"\\G\" in a way that's unsupported`);\n      }\n      remove();\n    } else if (kind === AstAssertionKinds.string_end_newline) {\n      replaceWith(parseFragment(r`(?=\\n?\\z)`));\n    } else if (kind === AstAssertionKinds.word_boundary && !wordIsAscii && !asciiWordBoundaries) {\n      const b = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;\n      const B = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;\n      replaceWith(parseFragment(negate ? B : b));\n    }\n  },\n  CapturingGroup({ node }, { subroutineRefMap }) {\n    const { name, number } = node;\n    if (name && !isValidGroupNameJs(name)) {\n      throw new Error(`Group name \"${name}\" invalid in JS`);\n    }\n    subroutineRefMap.set(number, node);\n    if (name) {\n      subroutineRefMap.set(name, node);\n    }\n  },\n  CharacterSet({ node, replaceWith }, { accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii }) {\n    const { kind, negate, value } = node;\n    if (digitIsAscii && (kind === AstCharacterSetKinds.digit || value === \"digit\")) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.digit, { negate }));\n      return;\n    }\n    if (spaceIsAscii && (kind === AstCharacterSetKinds.space || value === \"space\")) {\n      replaceWith(setNegate(parseFragment(asciiSpaceChar), negate));\n      return;\n    }\n    if (wordIsAscii && (kind === AstCharacterSetKinds.word || value === \"word\")) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.word, { negate }));\n      return;\n    }\n    if (kind === AstCharacterSetKinds.any) {\n      replaceWith(createUnicodeProperty(\"Any\"));\n    } else if (kind === AstCharacterSetKinds.digit) {\n      replaceWith(createUnicodeProperty(\"Nd\", { negate }));\n    } else if (kind === AstCharacterSetKinds.hex) {\n      replaceWith(createUnicodeProperty(\"AHex\", { negate }));\n    } else if (kind === AstCharacterSetKinds.non_newline) {\n      replaceWith(parseFragment(r`[^\\n]`));\n    } else if (kind === AstCharacterSetKinds.space) {\n      replaceWith(createUnicodeProperty(\"space\", { negate }));\n    } else if (kind === AstCharacterSetKinds.word) {\n      replaceWith(setNegate(parseFragment(defaultWordChar), negate));\n    } else if (kind === AstCharacterSetKinds.property) {\n      if (!JsUnicodeProperties.has(value)) {\n        node.key = \"sc\";\n      }\n    } else if (kind === AstCharacterSetKinds.posix) {\n      if (!minTargetEs2024 && (value === \"graph\" || value === \"print\")) {\n        if (accuracy === \"strict\") {\n          throw new Error(`POSIX class \"${value}\" requires min target ES2024 or non-strict accuracy`);\n        }\n        let ascii = {\n          graph: \"!-~\",\n          print: \" -~\"\n        }[value];\n        if (negate) {\n          ascii = `\\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\\u{10FFFF}`;\n        }\n        replaceWith(parseFragment(`[${ascii}]`));\n      } else {\n        replaceWith(setNegate(parseFragment(PosixClassesMap.get(value)), negate));\n      }\n    }\n  },\n  Directive(path, state) {\n    const { node, parent, ast, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings } = path;\n    const { kind, flags } = node;\n    if (kind === AstDirectiveKinds.flags) {\n      if (!flags.enable && !flags.disable) {\n        remove();\n      } else {\n        const flagGroup = prepContainer(createGroup({ flags }), removeAllNextSiblings());\n        replaceWith(flagGroup);\n        traverseReplacement(flagGroup, path, state, FirstPassVisitor);\n      }\n    } else if (kind === AstDirectiveKinds.keep) {\n      if (parent.parent !== ast.pattern || ast.pattern.alternatives.length > 1) {\n        throw new Error(r`Uses \"\\K\" in a way that's unsupported`);\n      }\n      replaceWith(prepContainer(createLookaround({ behind: true }), removeAllPrevSiblings()));\n    }\n  },\n  Flags({ node, parent }) {\n    [\n      \"digitIsAscii\",\n      // Flag D\n      \"extended\",\n      // Flag x\n      \"spaceIsAscii\",\n      // Flag S\n      \"wordIsAscii\"\n      // Flag W\n    ].forEach((f) => delete node[f]);\n    Object.assign(node, {\n      // JS flag g; no Onig equiv\n      global: false,\n      // JS flag d; no Onig equiv\n      hasIndices: false,\n      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break\n      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate\n      // results (also allows `^` and `$` to be used in the generator for string start and end)\n      multiline: false,\n      // JS flag y; no Onig equiv, but used for `\\G` emulation\n      sticky: node.sticky ?? false\n      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out\n      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values\n      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)\n    });\n    parent.options = {\n      disable: {\n        // Onig uses different rules for flag x than Regex+, so disable the implicit flag\n        x: true,\n        // Onig has no flag to control \"named capture only\" mode but contextually applies its\n        // behavior when named capturing is used, so disable Regex+'s implicit flag for it\n        n: true\n      },\n      force: {\n        // Always add flag v because we're generating an AST that relies on it (it enables JS\n        // support for Onig features nested classes, set intersection, Unicode properties, etc.).\n        // However, the generator might disable flag v based on its `target` option\n        v: true\n      }\n    };\n  },\n  Group({ node }) {\n    if (!node.flags) {\n      return;\n    }\n    const { enable, disable } = node.flags;\n    enable?.extended && delete enable.extended;\n    disable?.extended && delete disable.extended;\n    enable?.dotAll && disable?.dotAll && delete enable.dotAll;\n    enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;\n    enable && !Object.keys(enable).length && delete node.flags.enable;\n    disable && !Object.keys(disable).length && delete node.flags.disable;\n    !node.flags.enable && !node.flags.disable && delete node.flags;\n  },\n  Pattern({ node }, { ignoreUnsupportedGAnchors, supportedGNodes }) {\n    const leadingGs = [];\n    let hasAltWithLeadG = false;\n    let hasAltWithoutLeadG = false;\n    for (const alt of node.alternatives) {\n      if (alt.elements.length === 1 && alt.elements[0].kind === AstAssertionKinds.search_start) {\n        alt.elements.pop();\n      } else {\n        const leadingG = getLeadingG(alt.elements);\n        if (leadingG) {\n          hasAltWithLeadG = true;\n          Array.isArray(leadingG) ? leadingGs.push(...leadingG) : leadingGs.push(leadingG);\n        } else {\n          hasAltWithoutLeadG = true;\n        }\n      }\n    }\n    if (hasAltWithLeadG) {\n      if (!hasAltWithoutLeadG) {\n        leadingGs.forEach((g) => supportedGNodes.add(g));\n      } else if (!ignoreUnsupportedGAnchors) {\n        throw new Error(r`Uses \"\\G\" in a way that's unsupported`);\n      }\n    }\n  },\n  Quantifier({ node }) {\n    if (node.element.type === AstTypes.Quantifier) {\n      const group = prepContainer(createGroup(), [node.element]);\n      group.parent = node;\n      node.element = group;\n    }\n  },\n  VariableLengthCharacterSet({ node, replaceWith }, { accuracy, minTargetEs2024 }) {\n    const { kind } = node;\n    if (kind === AstVariableLengthCharacterSetKinds.newline) {\n      replaceWith(parseFragment(\"(?>\\r\\n?|[\\n\\v\\f\\x85\\u2028\\u2029])\"));\n    } else if (kind === AstVariableLengthCharacterSetKinds.grapheme) {\n      if (accuracy === \"strict\") {\n        throw new Error(r`Use of \"\\X\" requires non-strict accuracy`);\n      }\n      const emoji = minTargetEs2024 ? r`\\p{RGI_Emoji}` : (0,emoji_regex_xs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().source.replace(/\\\\u\\{/g, `\\\\x{`);\n      replaceWith(parseFragment(r`(?>\\r\\n|${emoji}|\\P{M}\\p{M}*)`, { skipPropertyNameValidation: true }));\n    } else {\n      throw new Error(`Unexpected varcharset kind \"${kind}\"`);\n    }\n  }\n};\nvar SecondPassVisitor = {\n  Backreference({ node }, { multiplexCapturesToLeftByRef, reffedNodesByReferencer }) {\n    const { orphan, ref } = node;\n    if (!orphan) {\n      reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({ node: node2 }) => node2)]);\n    }\n  },\n  CapturingGroup: {\n    enter({\n      node,\n      replaceWith,\n      skip\n    }, {\n      groupOriginByCopy,\n      groupsByName,\n      multiplexCapturesToLeftByRef,\n      openRefs,\n      reffedNodesByReferencer\n    }) {\n      const origin = groupOriginByCopy.get(node);\n      if (origin && openRefs.has(node.number)) {\n        const recursion2 = createRecursion(node.number);\n        reffedNodesByReferencer.set(recursion2, openRefs.get(node.number));\n        replaceWith(recursion2);\n        skip();\n        return;\n      }\n      openRefs.set(node.number, node);\n      multiplexCapturesToLeftByRef.set(node.number, []);\n      if (node.name) {\n        getOrCreate(multiplexCapturesToLeftByRef, node.name, []);\n      }\n      const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);\n      for (let i = 0; i < multiplexNodes.length; i++) {\n        const multiplex = multiplexNodes[i];\n        if (\n          // This group is from subroutine expansion, and there's a multiplex value from either the\n          // origin node or a prior subroutine expansion group with the same origin\n          origin === multiplex.node || origin && origin === multiplex.origin || // This group is not from subroutine expansion, and it comes after a subroutine expansion\n          // group that refers to this group\n          node === multiplex.origin\n        ) {\n          multiplexNodes.splice(i, 1);\n          break;\n        }\n      }\n      multiplexCapturesToLeftByRef.get(node.number).push({ node, origin });\n      if (node.name) {\n        multiplexCapturesToLeftByRef.get(node.name).push({ node, origin });\n      }\n      if (node.name) {\n        const groupsWithSameName = getOrCreate(groupsByName, node.name, /* @__PURE__ */ new Map());\n        let hasDuplicateNameToRemove = false;\n        if (origin) {\n          hasDuplicateNameToRemove = true;\n        } else {\n          for (const groupInfo of groupsWithSameName.values()) {\n            if (!groupInfo.hasDuplicateNameToRemove) {\n              hasDuplicateNameToRemove = true;\n              break;\n            }\n          }\n        }\n        groupsByName.get(node.name).set(node, { node, hasDuplicateNameToRemove });\n      }\n      if (origin) {\n        node._originNumber = origin.number;\n      }\n    },\n    exit({ node }, { openRefs }) {\n      openRefs.delete(node.number);\n    }\n  },\n  Group: {\n    enter({ node }, state) {\n      state.prevFlags = state.currentFlags;\n      if (node.flags) {\n        state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);\n      }\n    },\n    exit(_, state) {\n      state.currentFlags = state.prevFlags;\n    }\n  },\n  Recursion({ node, parent }, { reffedNodesByReferencer }) {\n    const { ref } = node;\n    let reffed = parent;\n    while (reffed = reffed.parent) {\n      if (reffed.type === AstTypes.CapturingGroup && (reffed.name === ref || reffed.number === ref)) {\n        break;\n      }\n    }\n    reffedNodesByReferencer.set(node, reffed);\n  },\n  Subroutine(path, state) {\n    const { node, replaceWith } = path;\n    const { ref } = node;\n    const reffedGroupNode = state.subroutineRefMap.get(ref);\n    const isGlobalRecursion = ref === 0;\n    const expandedSubroutine = isGlobalRecursion ? createRecursion(0) : (\n      // The reffed group might itself contain subroutines, which are expanded during sub-traversal\n      cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null)\n    );\n    let replacement = expandedSubroutine;\n    if (!isGlobalRecursion) {\n      const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, (node2) => {\n        return node2.type === AstTypes.Group && !!node2.flags;\n      }));\n      const reffedGroupFlags = reffedGroupFlagMods ? getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) : state.globalFlags;\n      if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {\n        replacement = prepContainer(createGroup({\n          flags: getFlagModsFromFlags(reffedGroupFlags)\n        }), [expandedSubroutine]);\n      }\n    }\n    replaceWith(replacement);\n    if (!isGlobalRecursion) {\n      traverseReplacement(replacement, path, state, SecondPassVisitor);\n    }\n  }\n};\nvar ThirdPassVisitor = {\n  Backreference({ node, replaceWith }, state) {\n    if (node.orphan) {\n      state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);\n      return;\n    }\n    const reffedNodes = state.reffedNodesByReferencer.get(node);\n    const participants = reffedNodes.filter((reffed) => canParticipateWithNode(reffed, node));\n    if (!participants.length) {\n      replaceWith(createLookaround({ negate: true }));\n    } else if (participants.length > 1) {\n      const alts = participants.map((reffed) => adoptAndSwapKids(\n        createAlternative(),\n        [createBackreference(reffed.number)]\n      ));\n      replaceWith(adoptAndSwapKids(createGroup(), alts));\n    } else {\n      node.ref = participants[0].number;\n    }\n  },\n  CapturingGroup({ node }, state) {\n    node.number = ++state.numCapturesToLeft;\n    if (node.name) {\n      if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {\n        delete node.name;\n      }\n    }\n  },\n  Recursion({ node }, state) {\n    if (node.ref === 0) {\n      return;\n    }\n    node.ref = state.reffedNodesByReferencer.get(node).number;\n  },\n  Regex: {\n    exit({ node }, state) {\n      const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);\n      for (let i = 0; i < numCapsNeeded; i++) {\n        const emptyCapture = createCapturingGroup();\n        node.pattern.alternatives.at(-1).elements.push(emptyCapture);\n      }\n    }\n  }\n};\nvar asciiSpaceChar = \"[\t-\\r ]\";\nvar defaultWordChar = r`[\\p{L}\\p{M}\\p{N}\\p{Pc}]`;\nfunction adoptAndSwapKids(parent, kids) {\n  kids.forEach((kid) => kid.parent = parent);\n  parent[getContainerAccessor(parent)] = kids;\n  return parent;\n}\nfunction areFlagsEqual(a, b) {\n  return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;\n}\nfunction canParticipateWithNode(capture, node) {\n  let rightmostPoint = node;\n  do {\n    if (rightmostPoint.type === AstTypes.Pattern) {\n      return false;\n    }\n    if (rightmostPoint.type === AstTypes.Alternative) {\n      continue;\n    }\n    if (rightmostPoint === capture) {\n      return false;\n    }\n    const kidsOfParent = getKids(rightmostPoint.parent);\n    for (const kid of kidsOfParent) {\n      if (kid === rightmostPoint) {\n        break;\n      }\n      if (kid === capture) {\n        return true;\n      }\n      if (hasDescendant(kid, capture)) {\n        return true;\n      }\n    }\n  } while (rightmostPoint = rightmostPoint.parent);\n  throw new Error(\"Unexpected path\");\n}\nfunction cloneCapturingGroup(obj, originMap, up, up2) {\n  const store = Array.isArray(obj) ? [] : {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key === \"parent\") {\n      store.parent = Array.isArray(up) ? up2 : up;\n    } else if (value && typeof value === \"object\") {\n      store[key] = cloneCapturingGroup(value, originMap, store, up);\n    } else {\n      if (key === \"type\" && value === AstTypes.CapturingGroup) {\n        originMap.set(store, originMap.get(obj) ?? obj);\n      }\n      store[key] = value;\n    }\n  }\n  return store;\n}\nfunction createRecursion(ref) {\n  return {\n    type: AstTypes.Recursion,\n    ref\n  };\n}\nfunction getAllParents(node, filterFn) {\n  const results = [];\n  while (node = node.parent) {\n    if (!filterFn || filterFn(node)) {\n      results.push(node);\n    }\n  }\n  return results;\n}\nfunction getContainerAccessor(node) {\n  for (const accessor of [\"alternatives\", \"classes\", \"elements\"]) {\n    if (node[accessor]) {\n      return accessor;\n    }\n  }\n  return null;\n}\nfunction getCombinedFlagModsFromFlagNodes(flagNodes) {\n  const flagProps = [\"dotAll\", \"ignoreCase\"];\n  const combinedFlags = { enable: {}, disable: {} };\n  flagNodes.forEach(({ flags }) => {\n    flagProps.forEach((prop) => {\n      if (flags.enable?.[prop]) {\n        delete combinedFlags.disable[prop];\n        combinedFlags.enable[prop] = true;\n      }\n      if (flags.disable?.[prop]) {\n        combinedFlags.disable[prop] = true;\n      }\n    });\n  });\n  if (!Object.keys(combinedFlags.enable).length) {\n    delete combinedFlags.enable;\n  }\n  if (!Object.keys(combinedFlags.disable).length) {\n    delete combinedFlags.disable;\n  }\n  if (combinedFlags.enable || combinedFlags.disable) {\n    return combinedFlags;\n  }\n  return null;\n}\nfunction getFlagModsFromFlags({ dotAll, ignoreCase }) {\n  const mods = {};\n  if (dotAll || ignoreCase) {\n    mods.enable = {};\n    dotAll && (mods.enable.dotAll = true);\n    ignoreCase && (mods.enable.ignoreCase = true);\n  }\n  if (!dotAll || !ignoreCase) {\n    mods.disable = {};\n    !dotAll && (mods.disable.dotAll = true);\n    !ignoreCase && (mods.disable.ignoreCase = true);\n  }\n  return mods;\n}\nfunction getKids(node) {\n  if (!node) {\n    throw new Error(\"Node expected\");\n  }\n  if (node.type === AstTypes.Quantifier) {\n    return [node.element];\n  }\n  const accessor = getContainerAccessor(node);\n  return accessor && node[accessor];\n}\nfunction getLeadingG(els) {\n  const firstToConsider = els.find((el) => el.kind === AstAssertionKinds.search_start || isLoneGLookaround(el, { negate: false }) || !isZeroLengthNode(el));\n  if (!firstToConsider) {\n    return null;\n  }\n  if (firstToConsider.kind === AstAssertionKinds.search_start) {\n    return firstToConsider;\n  }\n  if (isLookaround(firstToConsider)) {\n    return firstToConsider.alternatives[0].elements[0];\n  }\n  if (firstToConsider.type === AstTypes.Group || firstToConsider.type === AstTypes.CapturingGroup) {\n    const gNodesForGroup = [];\n    for (const alt of firstToConsider.alternatives) {\n      const leadingG = getLeadingG(alt.elements);\n      if (!leadingG) {\n        return null;\n      }\n      Array.isArray(leadingG) ? gNodesForGroup.push(...leadingG) : gNodesForGroup.push(leadingG);\n    }\n    return gNodesForGroup;\n  }\n  return null;\n}\nfunction hasDescendant(node, descendant) {\n  const kids = getKids(node) ?? [];\n  for (const kid of kids) {\n    if (kid === descendant || hasDescendant(kid, descendant)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isValidGroupNameJs(name) {\n  return /^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$/u.test(name);\n}\nfunction parseFragment(pattern, options) {\n  const ast = parse(tokenize(pattern), options);\n  const alts = ast.pattern.alternatives;\n  if (alts.length > 1 || alts[0].elements.length > 1) {\n    return adoptAndSwapKids(createGroup(), alts);\n  }\n  return alts[0].elements[0];\n}\nfunction prepContainer(node, kids) {\n  const accessor = getContainerAccessor(node);\n  node[accessor][0].parent = node;\n  if (kids) {\n    adoptAndSwapKids(node[accessor][0], kids);\n  }\n  return node;\n}\nfunction setNegate(node, negate) {\n  node.negate = negate;\n  return node;\n}\nfunction traverseReplacement(replacement, { parent, key, container }, state, visitor) {\n  traverse({\n    // Don't use the `node` from `path`\n    node: replacement,\n    parent,\n    key,\n    container\n  }, state, visitor);\n}\n\n// src/generate.js\n\nfunction generate(ast, options) {\n  const opts = getOptions(options);\n  const minTargetEs2024 = isMinTarget(opts.target, \"ES2024\");\n  const minTargetEs2025 = isMinTarget(opts.target, \"ES2025\");\n  const recursionLimit = opts.rules.recursionLimit;\n  if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {\n    throw new Error(\"Invalid recursionLimit; use 2-20\");\n  }\n  let hasCaseInsensitiveNode = null;\n  let hasCaseSensitiveNode = null;\n  if (!minTargetEs2025) {\n    const iStack = [ast.flags.ignoreCase];\n    traverse({ node: ast }, {\n      getCurrentModI: () => iStack.at(-1),\n      popModI() {\n        iStack.pop();\n      },\n      pushModI(isIOn) {\n        iStack.push(isIOn);\n      },\n      setHasCasedChar() {\n        if (iStack.at(-1)) {\n          hasCaseInsensitiveNode = true;\n        } else {\n          hasCaseSensitiveNode = true;\n        }\n      }\n    }, FlagModifierVisitor);\n  }\n  const appliedGlobalFlags = {\n    dotAll: ast.flags.dotAll,\n    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were\n    //   used (to avoid unnecessary node expansion).\n    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be\n    //   forced without the use of ES2025 flag groups)\n    ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode)\n  };\n  let lastNode = null;\n  const state = {\n    accuracy: opts.accuracy,\n    appliedGlobalFlags,\n    avoidSubclass: opts.avoidSubclass,\n    captureMap: /* @__PURE__ */ new Map(),\n    currentFlags: {\n      dotAll: ast.flags.dotAll,\n      ignoreCase: ast.flags.ignoreCase\n    },\n    inCharClass: false,\n    lastNode,\n    recursionLimit,\n    useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),\n    useFlagMods: minTargetEs2025,\n    useFlagV: minTargetEs2024,\n    verbose: opts.verbose\n  };\n  function gen(node) {\n    state.lastNode = lastNode;\n    lastNode = node;\n    switch (node.type) {\n      case AstTypes.Regex:\n        return {\n          pattern: gen(node.pattern),\n          flags: gen(node.flags),\n          options: { ...node.options }\n        };\n      case AstTypes.Alternative:\n        return node.elements.map(gen).join(\"\");\n      case AstTypes.Assertion:\n        return genAssertion(node, state, gen);\n      case AstTypes.Backreference:\n        return genBackreference(node, state);\n      case AstTypes.CapturingGroup:\n        return genCapturingGroup(node, state, gen);\n      case AstTypes.Character:\n        return genCharacter(node, state);\n      case AstTypes.CharacterClass:\n        return genCharacterClass(node, state, gen);\n      case AstTypes.CharacterClassIntersection:\n        if (!state.useFlagV) {\n          throw new Error(\"Use of class intersection requires min target ES2024\");\n        }\n        return node.classes.map(gen).join(\"&&\");\n      case AstTypes.CharacterClassRange:\n        return genCharacterClassRange(node, state);\n      case AstTypes.CharacterSet:\n        return genCharacterSet(node, state);\n      case AstTypes.Flags:\n        return genFlags(node, state);\n      case AstTypes.Group:\n        return genGroup(node, state, gen);\n      case AstTypes.Pattern:\n        return node.alternatives.map(gen).join(\"|\");\n      case AstTypes.Quantifier:\n        return gen(node.element) + getQuantifierStr(node);\n      case AstTypes.Recursion:\n        return genRecursion(node, state);\n      default:\n        throw new Error(`Unexpected node type \"${node.type}\"`);\n    }\n  }\n  const result = gen(ast);\n  if (!minTargetEs2024) {\n    delete result.options.force.v;\n    result.options.disable.v = true;\n    result.options.unicodeSetsPlugin = null;\n  }\n  return result;\n}\nvar FlagModifierVisitor = {\n  AnyGroup: {\n    enter({ node }, state) {\n      const currentModI = state.getCurrentModI();\n      state.pushModI(\n        node.flags ? getNewCurrentFlags({ ignoreCase: currentModI }, node.flags).ignoreCase : currentModI\n      );\n    },\n    exit(_, state) {\n      state.popModI();\n    }\n  },\n  Backreference(_, state) {\n    state.setHasCasedChar();\n  },\n  Character({ node }, state) {\n    if (charHasCase(cp(node.value))) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterClassRange({ node, skip }, state) {\n    skip();\n    if (getCasesOutsideCharClassRange(node, { firstOnly: true }).length) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterSet({ node }, state) {\n    if (node.kind === AstCharacterSetKinds.property && UnicodePropertiesWithSpecificCase.has(node.value)) {\n      state.setHasCasedChar();\n    }\n  }\n};\nvar BaseEscapeChars = /* @__PURE__ */ new Set([\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  \"{\",\n  \"|\",\n  \"}\"\n]);\nvar CharClassEscapeChars = /* @__PURE__ */ new Set([\n  \"-\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source\n  // linters and regex syntax processors that expect unescaped `[` to create a nested class\n  \"[\"\n]);\nvar CharClassEscapeCharsFlagV = /* @__PURE__ */ new Set([\n  \"(\",\n  \")\",\n  \"-\",\n  \"/\",\n  \"[\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  \"{\",\n  \"|\",\n  \"}\",\n  // Double punctuators; also includes already-listed `-` and `^`\n  \"!\",\n  \"#\",\n  \"$\",\n  \"%\",\n  \"&\",\n  \"*\",\n  \"+\",\n  \",\",\n  \".\",\n  \":\",\n  \";\",\n  \"<\",\n  \"=\",\n  \">\",\n  \"?\",\n  \"@\",\n  \"`\",\n  \"~\"\n]);\nvar CharCodeEscapeMap = /* @__PURE__ */ new Map([\n  [9, r`\\t`],\n  // horizontal tab\n  [10, r`\\n`],\n  // line feed\n  [11, r`\\v`],\n  // vertical tab\n  [12, r`\\f`],\n  // form feed\n  [13, r`\\r`],\n  // carriage return\n  [8232, r`\\u2028`],\n  // line separator\n  [8233, r`\\u2029`],\n  // paragraph separator\n  [65279, r`\\uFEFF`]\n  // ZWNBSP/BOM\n]);\nvar casedRe = /^\\p{Cased}$/u;\nfunction charHasCase(char) {\n  return casedRe.test(char);\n}\nfunction genAssertion(node, _, gen) {\n  const { kind, negate, alternatives } = node;\n  if (isLookaround(node)) {\n    const prefix = `${kind === AstAssertionKinds.lookahead ? \"\" : \"<\"}${negate ? \"!\" : \"=\"}`;\n    return `(?${prefix}${alternatives.map(gen).join(\"|\")})`;\n  }\n  if (kind === AstAssertionKinds.string_end) {\n    return \"$\";\n  }\n  if (kind === AstAssertionKinds.string_start) {\n    return \"^\";\n  }\n  if (kind === AstAssertionKinds.word_boundary) {\n    return negate ? r`\\B` : r`\\b`;\n  }\n  throw new Error(`Unexpected assertion kind \"${kind}\"`);\n}\nfunction genBackreference({ ref }, state) {\n  if (typeof ref !== \"number\") {\n    throw new Error(\"Unexpected named backref in transformed AST\");\n  }\n  if (!state.useFlagMods && state.accuracy === \"strict\" && state.currentFlags.ignoreCase && !state.captureMap.get(ref).ignoreCase) {\n    throw new Error(\"Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy\");\n  }\n  return \"\\\\\" + ref;\n}\nfunction genCapturingGroup({ name, number, alternatives, _originNumber }, state, gen) {\n  state.captureMap.set(number, { ignoreCase: state.currentFlags.ignoreCase });\n  return `(${name ? `?<${name}>` : \"\"}${!state.avoidSubclass && _originNumber ? (\n    // All captures from/within expanded subroutines are marked as emulation groups, and some are\n    // specially marked as emulation groups with transfer. `number` is based on the pattern after\n    // subroutine expansion, whereas `_originNumber` points to the origin capture of an expanded\n    // subroutine (or child capture) *prior* to subroutine expansion. `_originNumber` is\n    // `undefined` if the current capture isn't from an expanded subroutine\n    `${_originNumber < number ? `$${_originNumber}` : \"\"}${regex_internals__WEBPACK_IMPORTED_MODULE_0__.emulationGroupMarker}`\n  ) : \"\"}${alternatives.map(gen).join(\"|\")})`;\n}\nfunction genCharacter({ value }, state) {\n  const char = cp(value);\n  const escaped = getCharEscape(value, {\n    isAfterBackref: state.lastNode.type === AstTypes.Backreference,\n    inCharClass: state.inCharClass,\n    useFlagV: state.useFlagV\n  });\n  if (escaped !== char) {\n    return escaped;\n  }\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {\n    const cases = getIgnoreCaseMatchChars(char);\n    return state.inCharClass ? cases.join(\"\") : cases.length > 1 ? `[${cases.join(\"\")}]` : cases[0];\n  }\n  return char;\n}\nfunction genCharacterClass({ negate, parent, elements }, state, gen) {\n  const genClass = () => `[${negate ? \"^\" : \"\"}${elements.map(gen).join(\"\")}]`;\n  if (!state.inCharClass) {\n    state.inCharClass = true;\n    const result = genClass();\n    state.inCharClass = false;\n    return result;\n  }\n  const firstType = elements[0]?.type;\n  if (!negate && firstType && // Allows many nested classes to work with `target` ES2018 which doesn't support nesting\n  ((!state.useFlagV || !state.verbose) && parent.type === AstTypes.CharacterClass && firstType !== AstTypes.CharacterClassIntersection || !state.verbose && parent.type === AstTypes.CharacterClassIntersection && // JS doesn't allow intersection with union or ranges\n  elements.length === 1 && firstType !== AstTypes.CharacterClass && firstType !== AstTypes.CharacterClassRange)) {\n    return elements.map(gen).join(\"\");\n  }\n  if (!state.useFlagV && parent.type === AstTypes.CharacterClass) {\n    throw new Error(\"Use of nested character class requires min target ES2024\");\n  }\n  return genClass();\n}\nfunction genCharacterClassRange(node, state) {\n  const min = node.min.value;\n  const max = node.max.value;\n  const escOpts = {\n    isAfterBackref: false,\n    inCharClass: true,\n    useFlagV: state.useFlagV\n  };\n  const minStr = getCharEscape(min, escOpts);\n  const maxStr = getCharEscape(max, escOpts);\n  const extraChars = /* @__PURE__ */ new Set();\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {\n    const charsOutsideRange = getCasesOutsideCharClassRange(node);\n    const ranges = getCodePointRangesFromChars(charsOutsideRange);\n    ranges.forEach((value) => {\n      extraChars.add(\n        Array.isArray(value) ? `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` : getCharEscape(value, escOpts)\n      );\n    });\n  }\n  return `${minStr}-${maxStr}${[...extraChars].join(\"\")}`;\n}\nfunction genCharacterSet({ kind, negate, value, key }, state) {\n  if (kind === AstCharacterSetKinds.dot) {\n    return state.currentFlags.dotAll ? state.appliedGlobalFlags.dotAll || state.useFlagMods ? \".\" : \"[^]\" : (\n      // Onig's only line break char is line feed, unlike JS\n      r`[^\\n]`\n    );\n  }\n  if (kind === AstCharacterSetKinds.digit) {\n    return negate ? r`\\D` : r`\\d`;\n  }\n  if (kind === AstCharacterSetKinds.property) {\n    if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && UnicodePropertiesWithSpecificCase.has(value)) {\n      throw new Error(`Unicode property \"${value}\" can't be case-insensitive when other chars have specific case`);\n    }\n    return `${negate ? r`\\P` : r`\\p`}{${key ? `${key}=` : \"\"}${value}}`;\n  }\n  if (kind === AstCharacterSetKinds.word) {\n    return negate ? r`\\W` : r`\\w`;\n  }\n  throw new Error(`Unexpected character set kind \"${kind}\"`);\n}\nfunction genFlags(node, state) {\n  return (\n    // The transformer should never turn on the properties for flags d, g, and m since Onig doesn't\n    // have equivs. Flag m is never relied on since Onig uses different line break chars than JS\n    // (node.hasIndices ? 'd' : '') +\n    // (node.global ? 'g' : '') +\n    // (node.multiline ? 'm' : '') +\n    (state.appliedGlobalFlags.ignoreCase ? \"i\" : \"\") + (node.dotAll ? \"s\" : \"\") + (node.sticky ? \"y\" : \"\")\n  );\n}\nfunction genGroup({ atomic: atomic2, flags, parent, alternatives }, state, gen) {\n  const currentFlags = state.currentFlags;\n  if (flags) {\n    state.currentFlags = getNewCurrentFlags(currentFlags, flags);\n  }\n  const contents = alternatives.map(gen).join(\"|\");\n  const result = !state.verbose && alternatives.length === 1 && parent.type !== AstTypes.Quantifier && !atomic2 && (!state.useFlagMods || !flags) ? contents : `(?${getGroupPrefix(atomic2, flags, state.useFlagMods)}${contents})`;\n  state.currentFlags = currentFlags;\n  return result;\n}\nfunction genRecursion({ ref }, state) {\n  const limit = state.recursionLimit;\n  return ref === 0 ? `(?R=${limit})` : r`\\g<${ref}&R=${limit}>`;\n}\nfunction getCasesOutsideCharClassRange(node, options) {\n  const firstOnly = !!options?.firstOnly;\n  const min = node.min.value;\n  const max = node.max.value;\n  const found = [];\n  if (min < 65 && (max === 65535 || max >= 131071) || min === 65536 && max >= 131071) {\n    return found;\n  }\n  for (let i = min; i <= max; i++) {\n    const char = cp(i);\n    if (!charHasCase(char)) {\n      continue;\n    }\n    const charsOutsideRange = getIgnoreCaseMatchChars(char).filter((caseOfChar) => {\n      const num = caseOfChar.codePointAt(0);\n      return num < min || num > max;\n    });\n    if (charsOutsideRange.length) {\n      found.push(...charsOutsideRange);\n      if (firstOnly) {\n        break;\n      }\n    }\n  }\n  return found;\n}\nfunction getCharEscape(codePoint, { isAfterBackref, inCharClass, useFlagV }) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || codePoint > 126 && codePoint < 160 || // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 262143 || // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    isAfterBackref && isDigitCharCode(codePoint)\n  ) {\n    return codePoint > 255 ? `\\\\u{${codePoint.toString(16).toUpperCase()}}` : `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, \"0\")}`;\n  }\n  const escapeChars = inCharClass ? useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars : BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? \"\\\\\" : \"\") + char;\n}\nfunction getCodePointRangesFromChars(chars) {\n  const codePoints = chars.map((char) => char.codePointAt(0)).sort((a, b) => a - b);\n  const values = [];\n  let start = null;\n  for (let i = 0; i < codePoints.length; i++) {\n    if (codePoints[i + 1] === codePoints[i] + 1) {\n      start ??= codePoints[i];\n    } else if (start === null) {\n      values.push(codePoints[i]);\n    } else {\n      values.push([start, codePoints[i]]);\n      start = null;\n    }\n  }\n  return values;\n}\nfunction getGroupPrefix(atomic2, flagMods, useFlagMods) {\n  if (atomic2) {\n    return \">\";\n  }\n  let mods = \"\";\n  if (flagMods && useFlagMods) {\n    const { enable, disable } = flagMods;\n    mods = (enable?.ignoreCase ? \"i\" : \"\") + (enable?.dotAll ? \"s\" : \"\") + (disable ? \"-\" : \"\") + (disable?.ignoreCase ? \"i\" : \"\") + (disable?.dotAll ? \"s\" : \"\");\n  }\n  return `${mods}:`;\n}\nfunction getQuantifierStr({ min, max, greedy, possessive: possessive2 }) {\n  let base;\n  if (!min && max === 1) {\n    base = \"?\";\n  } else if (!min && max === Infinity) {\n    base = \"*\";\n  } else if (min === 1 && max === Infinity) {\n    base = \"+\";\n  } else if (min === max) {\n    base = `{${min}}`;\n  } else {\n    base = `{${min},${max === Infinity ? \"\" : max}}`;\n  }\n  return base + (possessive2 ? \"+\" : greedy ? \"\" : \"?\");\n}\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\n\n// src/index.js\n\n\nfunction toDetails(pattern, options) {\n  const opts = getOptions(options);\n  const avoidSubclass = opts.avoidSubclass;\n  const tokenized = tokenize(pattern, opts.flags, { captureGroup: opts.rules.captureGroup });\n  const onigurumaAst = parse(tokenized, {\n    skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n    verbose: opts.verbose\n  });\n  const regexAst = transform(onigurumaAst, {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.rules.asciiWordBoundaries,\n    avoidSubclass,\n    bestEffortTarget: opts.target,\n    ignoreUnsupportedGAnchors: opts.rules.ignoreUnsupportedGAnchors\n  });\n  const generated = generate(regexAst, opts);\n  const pluginData = { useEmulationGroups: !avoidSubclass };\n  const result = {\n    pattern: (0,regex_internals__WEBPACK_IMPORTED_MODULE_0__.atomic)((0,regex_internals__WEBPACK_IMPORTED_MODULE_0__.possessive)((0,regex_recursion__WEBPACK_IMPORTED_MODULE_2__.recursion)(generated.pattern, pluginData)), pluginData),\n    flags: `${opts.hasIndices ? \"d\" : \"\"}${opts.global ? \"g\" : \"\"}${generated.flags}${generated.options.disable.v ? \"u\" : \"v\"}`\n  };\n  const useEmulationGroups = !avoidSubclass && result.pattern.includes(regex_internals__WEBPACK_IMPORTED_MODULE_0__.emulationGroupMarker);\n  const strategy = regexAst._strategy;\n  if (useEmulationGroups || strategy) {\n    result.options = {\n      ...strategy ? { strategy } : null,\n      ...useEmulationGroups ? { useEmulationGroups } : null\n    };\n  }\n  return result;\n}\nfunction toOnigurumaAst(pattern, options) {\n  const flags = options?.flags ?? \"\";\n  const captureGroup = options?.rules?.captureGroup ?? false;\n  return parse(tokenize(pattern, flags, { captureGroup }));\n}\nfunction toRegExp(pattern, options) {\n  const result = toDetails(pattern, options);\n  if (result.options) {\n    return new EmulatedRegExp(result.pattern, result.flags, result.options);\n  }\n  return new RegExp(result.pattern, result.flags);\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9vbmlndXJ1bWEtdG8tZXNAMS4wLjAvbm9kZV9tb2R1bGVzL29uaWd1cnVtYS10by1lcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNLEdBQUcsR0FBRztBQUM5QixpQkFBaUIsTUFBTTtBQUN2QixpQkFBaUIsTUFBTTtBQUN2QixrQkFBa0IsR0FBRztBQUNyQixpQkFBaUIsTUFBTTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQixrQkFBa0IsTUFBTSxLQUFLLE1BQU0sS0FBSyxHQUFHLEtBQUssR0FBRztBQUNuRCxpQkFBaUIsTUFBTTtBQUN2QixtQkFBbUIsTUFBTSxLQUFLLE1BQU0sS0FBSyxHQUFHLEtBQUssR0FBRyxJ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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUksa0JBQWtCLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlE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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYSx1REFBTSxDQUFDLDJEQUFVLENBQUMsMERBQVM7QUFDeEMsY0FBYywyQkFBMkIsRUFBRSx1QkFBdUIsRUFBRSxnQkFBZ0IsRUFBRSx3Q0FBd0M7QUFDOUg7QUFDQSx1RUFBdUUsaUVBQXFCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9vbmlndXJ1bWEtdG8tZXNAMS4wLjAvbm9kZV9tb2R1bGVzL29uaWd1cnVtYS10by1lcy9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMuanNcbnZhciBjcCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xudmFyIHIgPSBTdHJpbmcucmF3O1xudmFyIGVudlN1cHBvcnRzRmxhZ0dyb3VwcyA9ICgoKSA9PiB7XG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cChcIig/aTopXCIpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KSgpO1xudmFyIGVudlN1cHBvcnRzRmxhZ1YgPSAoKCkgPT4ge1xuICB0cnkge1xuICAgIG5ldyBSZWdFeHAoXCJcIiwgXCJ2XCIpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KSgpO1xuZnVuY3Rpb24gZ2V0TmV3Q3VycmVudEZsYWdzKGN1cnJlbnQsIHsgZW5hYmxlLCBkaXNhYmxlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICBkb3RBbGw6ICFkaXNhYmxlPy5kb3RBbGwgJiYgISEoZW5hYmxlPy5kb3RBbGwgfHwgY3VycmVudC5kb3RBbGwpLFxuICAgIGlnbm9yZUNhc2U6ICFkaXNhYmxlPy5pZ25vcmVDYXNlICYmICEhKGVuYWJsZT8uaWdub3JlQ2FzZSB8fCBjdXJyZW50Lmlnbm9yZUNhc2UpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPckNyZWF0ZShtYXAsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgbWFwLnNldChrZXksIGRlZmF1bHRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG1hcC5nZXQoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzTWluVGFyZ2V0KHRhcmdldCwgbWluKSB7XG4gIHJldHVybiBFc1ZlcnNpb25bdGFyZ2V0XSA+PSBFc1ZlcnNpb25bbWluXTtcbn1cbmZ1bmN0aW9uIHRocm93SWZOb3QodmFsdWUsIG1zZykge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyA/PyBcIlZhbHVlIGV4cGVjdGVkXCIpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL29wdGlvbnMuanNcbnZhciBFc1ZlcnNpb24gPSB7XG4gIEVTMjAyNTogMjAyNSxcbiAgRVMyMDI0OiAyMDI0LFxuICBFUzIwMTg6IDIwMThcbn07XG52YXIgVGFyZ2V0ID0gKFxuICAvKiogQHR5cGUge2NvbnN0fSAqL1xuICB7XG4gICAgYXV0bzogXCJhdXRvXCIsXG4gICAgRVMyMDI1OiBcIkVTMjAyNVwiLFxuICAgIEVTMjAyNDogXCJFUzIwMjRcIixcbiAgICBFUzIwMTg6IFwiRVMyMDE4XCJcbiAgfVxuKTtcbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucz8udGFyZ2V0ICE9PSB2b2lkIDAgJiYgIVRhcmdldFtvcHRpb25zLnRhcmdldF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdGFyZ2V0IFwiJHtvcHRpb25zLnRhcmdldH1cImApO1xuICB9XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgLy8gU2V0cyB0aGUgbGV2ZWwgb2YgZW11bGF0aW9uIHJpZ29yL3N0cmljdG5lc3MuXG4gICAgYWNjdXJhY3k6IFwiZGVmYXVsdFwiLFxuICAgIC8vIERpc2FibGVzIGFkdmFuY2VkIGVtdWxhdGlvbiB0aGF0IHJlbGllcyBvbiByZXR1cm5pbmcgYSBgUmVnRXhwYCBzdWJjbGFzcywgcmVzdWx0aW5nIGluXG4gICAgLy8gY2VydGFpbiBwYXR0ZXJucyBub3QgYmVpbmcgZW11bGF0YWJsZS5cbiAgICBhdm9pZFN1YmNsYXNzOiBmYWxzZSxcbiAgICAvLyBPbmlndXJ1bWEgZmxhZ3M7IGEgc3RyaW5nIHdpdGggYGlgLCBgbWAsIGB4YCwgYERgLCBgU2AsIGBXYCBpbiBhbnkgb3JkZXIgKGFsbCBvcHRpb25hbCkuXG4gICAgLy8gT25pZ3VydW1hJ3MgYG1gIGlzIGVxdWl2YWxlbnQgdG8gSmF2YVNjcmlwdCdzIGBzYCAoYGRvdEFsbGApLlxuICAgIGZsYWdzOiBcIlwiLFxuICAgIC8vIEluY2x1ZGUgSmF2YVNjcmlwdCBmbGFnIGBnYCAoYGdsb2JhbGApIGluIHRoZSByZXN1bHQuXG4gICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAvLyBJbmNsdWRlIEphdmFTY3JpcHQgZmxhZyBgZGAgKGBoYXNJbmRpY2VzYCkgaW4gdGhlIHJlc3VsdC5cbiAgICBoYXNJbmRpY2VzOiBmYWxzZSxcbiAgICAvLyBKYXZhU2NyaXB0IHZlcnNpb24gdXNlZCBmb3IgZ2VuZXJhdGVkIHJlZ2V4ZXMuIFVzaW5nIGBhdXRvYCBkZXRlY3RzIHRoZSBiZXN0IHZhbHVlIGJhc2VkIG9uXG4gICAgLy8geW91ciBlbnZpcm9ubWVudC4gTGF0ZXIgdGFyZ2V0cyBhbGxvdyBmYXN0ZXIgcHJvY2Vzc2luZywgc2ltcGxlciBnZW5lcmF0ZWQgc291cmNlLCBhbmRcbiAgICAvLyBzdXBwb3J0IGZvciBhZGRpdGlvbmFsIGZlYXR1cmVzLlxuICAgIHRhcmdldDogXCJhdXRvXCIsXG4gICAgLy8gRGlzYWJsZXMgb3B0aW1pemF0aW9ucyB0aGF0IHNpbXBsaWZ5IHRoZSBwYXR0ZXJuIHdoZW4gaXQgZG9lc24ndCBjaGFuZ2UgdGhlIG1lYW5pbmcuXG4gICAgdmVyYm9zZTogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgICAvLyBBZHZhbmNlZCBvcHRpb25zIHRoYXQgb3ZlcnJpZGUgc3RhbmRhcmQgYmVoYXZpb3IsIGVycm9yIGNoZWNraW5nLCBhbmQgZmxhZ3Mgd2hlbiBlbmFibGVkLlxuICAgIHJ1bGVzOiB7XG4gICAgICAvLyBVc2VmdWwgd2l0aCBUZXh0TWF0ZSBncmFtbWFycyB0aGF0IG1lcmdlIGJhY2tyZWZlcmVuY2VzIGFjcm9zcyBwYXR0ZXJucy5cbiAgICAgIGFsbG93T3JwaGFuQmFja3JlZnM6IGZhbHNlLFxuICAgICAgLy8gVXNlIEFTQ0lJLWJhc2VkIGBcXGJgIGFuZCBgXFxCYCwgd2hpY2ggaW5jcmVhc2VzIHNlYXJjaCBwZXJmb3JtYW5jZSBvZiBnZW5lcmF0ZWQgcmVnZXhlcy5cbiAgICAgIGFzY2lpV29yZEJvdW5kYXJpZXM6IGZhbHNlLFxuICAgICAgLy8gQWxsb3cgdW5uYW1lZCBjYXB0dXJlcyBhbmQgbnVtYmVyZWQgY2FsbHMgKGJhY2tyZWZlcmVuY2VzIGFuZCBzdWJyb3V0aW5lcykgd2hlbiB1c2luZ1xuICAgICAgLy8gbmFtZWQgY2FwdHVyZS5cbiAgICAgIC8vIC0gT25pZ3VydW1hIG9wdGlvbiBgT05JR19PUFRJT05fQ0FQVFVSRV9HUk9VUGAuXG4gICAgICAvLyAtIE9uIGJ5IGRlZmF1bHQgaW4gYHZzY29kZS1vbmlndXJ1bWFgLlxuICAgICAgY2FwdHVyZUdyb3VwOiBmYWxzZSxcbiAgICAgIC8vIFJlbW92ZSB1bnN1cHBvcnRlZCB1c2VzIG9mIGBcXEdgLCByYXRoZXIgdGhhbiBlcnJvcmluZy5cbiAgICAgIGlnbm9yZVVuc3VwcG9ydGVkR0FuY2hvcnM6IGZhbHNlLFxuICAgICAgLy8gQ2hhbmdlIHRoZSByZWN1cnNpb24gZGVwdGggbGltaXQgZnJvbSBPbmlndXJ1bWEncyBkZWZhdWx0IG9mIGAyMGAgdG8gYW4gaW50ZWdlciBgMmDigJNgMjBgLlxuICAgICAgcmVjdXJzaW9uTGltaXQ6IDIwLFxuICAgICAgLi4ub3B0aW9ucz8ucnVsZXNcbiAgICB9XG4gIH07XG4gIGlmIChvcHRzLnRhcmdldCA9PT0gXCJhdXRvXCIpIHtcbiAgICBvcHRzLnRhcmdldCA9IGVudlN1cHBvcnRzRmxhZ0dyb3VwcyA/IFwiRVMyMDI1XCIgOiBlbnZTdXBwb3J0c0ZsYWdWID8gXCJFUzIwMjRcIiA6IFwiRVMyMDE4XCI7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59XG5cbi8vIHNyYy91bmljb2RlLmpzXG52YXIgQ2hhcnNXaXRob3V0SWdub3JlQ2FzZUV4cGFuc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgY3AoMzA0KSxcbiAgLy8gxLBcbiAgY3AoMzA1KVxuICAvLyDEsVxuXSk7XG5mdW5jdGlvbiBnZXRJZ25vcmVDYXNlTWF0Y2hDaGFycyhjaGFyKSB7XG4gIGlmIChDaGFyc1dpdGhvdXRJZ25vcmVDYXNlRXhwYW5zaW9uLmhhcyhjaGFyKSkge1xuICAgIHJldHVybiBbY2hhcl07XG4gIH1cbiAgY29uc3Qgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgbG93ZXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHVwcGVyID0gbG93ZXIudG9VcHBlckNhc2UoKTtcbiAgY29uc3QgdGl0bGUgPSBMb3dlclRvVGl0bGVDYXNlTWFwLmdldChsb3dlcik7XG4gIGNvbnN0IGFsdExvd2VyID0gTG93ZXJUb0FsdGVybmF0aXZlTG93ZXJDYXNlTWFwLmdldChsb3dlcik7XG4gIGNvbnN0IGFsdFVwcGVyID0gTG93ZXJUb0FsdGVybmF0aXZlVXBwZXJDYXNlTWFwLmdldChsb3dlcik7XG4gIGlmIChbLi4udXBwZXJdLmxlbmd0aCA9PT0gMSkge1xuICAgIHNldC5hZGQodXBwZXIpO1xuICB9XG4gIGFsdFVwcGVyICYmIHNldC5hZGQoYWx0VXBwZXIpO1xuICB0aXRsZSAmJiBzZXQuYWRkKHRpdGxlKTtcbiAgc2V0LmFkZChsb3dlcik7XG4gIGFsdExvd2VyICYmIHNldC5hZGQoYWx0TG93ZXIpO1xuICByZXR1cm4gWy4uLnNldF07XG59XG52YXIgSnNVbmljb2RlUHJvcGVydGllcyA9IG5ldyBTZXQoXG4gIGBDIE90aGVyXG5DYyBDb250cm9sIGNudHJsXG5DZiBGb3JtYXRcbkNuIFVuYXNzaWduZWRcbkNvIFByaXZhdGVfVXNlXG5DcyBTdXJyb2dhdGVcbkwgTGV0dGVyXG5MQyBDYXNlZF9MZXR0ZXJcbkxsIExvd2VyY2FzZV9MZXR0ZXJcbkxtIE1vZGlmaWVyX0xldHRlclxuTG8gT3RoZXJfTGV0dGVyXG5MdCBUaXRsZWNhc2VfTGV0dGVyXG5MdSBVcHBlcmNhc2VfTGV0dGVyXG5NIE1hcmsgQ29tYmluaW5nX01hcmtcbk1jIFNwYWNpbmdfTWFya1xuTWUgRW5jbG9zaW5nX01hcmtcbk1uIE5vbnNwYWNpbmdfTWFya1xuTiBOdW1iZXJcbk5kIERlY2ltYWxfTnVtYmVyIGRpZ2l0XG5ObCBMZXR0ZXJfTnVtYmVyXG5ObyBPdGhlcl9OdW1iZXJcblAgUHVuY3R1YXRpb24gcHVuY3RcblBjIENvbm5lY3Rvcl9QdW5jdHVhdGlvblxuUGQgRGFzaF9QdW5jdHVhdGlvblxuUGUgQ2xvc2VfUHVuY3R1YXRpb25cblBmIEZpbmFsX1B1bmN0dWF0aW9uXG5QaSBJbml0aWFsX1B1bmN0dWF0aW9uXG5QbyBPdGhlcl9QdW5jdHVhdGlvblxuUHMgT3Blbl9QdW5jdHVhdGlvblxuUyBTeW1ib2xcblNjIEN1cnJlbmN5X1N5bWJvbFxuU2sgTW9kaWZpZXJfU3ltYm9sXG5TbSBNYXRoX1N5bWJvbFxuU28gT3RoZXJfU3ltYm9sXG5aIFNlcGFyYXRvclxuWmwgTGluZV9TZXBhcmF0b3JcblpwIFBhcmFncmFwaF9TZXBhcmF0b3JcblpzIFNwYWNlX1NlcGFyYXRvclxuQVNDSUlcbkFTQ0lJX0hleF9EaWdpdCBBSGV4XG5BbHBoYWJldGljIEFscGhhXG5BbnlcbkFzc2lnbmVkXG5CaWRpX0NvbnRyb2wgQmlkaV9DXG5CaWRpX01pcnJvcmVkIEJpZGlfTVxuQ2FzZV9JZ25vcmFibGUgQ0lcbkNhc2VkXG5DaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGXG5DaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNXG5DaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCBDV0xcbkNoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0ZcbkNoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVFxuQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQgQ1dVXG5EYXNoXG5EZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJXG5EZXByZWNhdGVkIERlcFxuRGlhY3JpdGljIERpYVxuRW1vamlcbkVtb2ppX0NvbXBvbmVudCBFQ29tcFxuRW1vamlfTW9kaWZpZXIgRU1vZFxuRW1vamlfTW9kaWZpZXJfQmFzZSBFQmFzZVxuRW1vamlfUHJlc2VudGF0aW9uIEVQcmVzXG5FeHRlbmRlZF9QaWN0b2dyYXBoaWMgRXh0UGljdFxuRXh0ZW5kZXIgRXh0XG5HcmFwaGVtZV9CYXNlIEdyX0Jhc2VcbkdyYXBoZW1lX0V4dGVuZCBHcl9FeHRcbkhleF9EaWdpdCBIZXhcbklEU19CaW5hcnlfT3BlcmF0b3IgSURTQlxuSURTX1RyaW5hcnlfT3BlcmF0b3IgSURTVFxuSURfQ29udGludWUgSURDXG5JRF9TdGFydCBJRFNcbklkZW9ncmFwaGljIElkZW9cbkpvaW5fQ29udHJvbCBKb2luX0NcbkxvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRVxuTG93ZXJjYXNlIExvd2VyXG5NYXRoXG5Ob25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhclxuUGF0dGVybl9TeW50YXggUGF0X1N5blxuUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1NcblF1b3RhdGlvbl9NYXJrIFFNYXJrXG5SYWRpY2FsXG5SZWdpb25hbF9JbmRpY2F0b3IgUklcblNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtXG5Tb2Z0X0RvdHRlZCBTRFxuVGVybWluYWxfUHVuY3R1YXRpb24gVGVybVxuVW5pZmllZF9JZGVvZ3JhcGggVUlkZW9cblVwcGVyY2FzZSBVcHBlclxuVmFyaWF0aW9uX1NlbGVjdG9yIFZTXG5XaGl0ZV9TcGFjZSBzcGFjZVxuWElEX0NvbnRpbnVlIFhJRENcblhJRF9TdGFydCBYSURTYC5zcGxpdCgvXFxzLylcbik7XG52YXIgSnNVbmljb2RlUHJvcGVydGllc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mb3IgKGNvbnN0IHAgb2YgSnNVbmljb2RlUHJvcGVydGllcykge1xuICBKc1VuaWNvZGVQcm9wZXJ0aWVzTWFwLnNldChzbHVnKHApLCBwKTtcbn1cbnZhciBKc1VuaWNvZGVQcm9wZXJ0aWVzT2ZTdHJpbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAvLyBFUzIwMjQgcHJvcGVydGllcyBvZiBzdHJpbmdzOyBub25lIGFyZSBzdXBwb3J0ZWQgYnkgT25pZ3VydW1hXG4gIFwiQmFzaWNfRW1vamlcIixcbiAgXCJFbW9qaV9LZXljYXBfU2VxdWVuY2VcIixcbiAgXCJSR0lfRW1vamlcIixcbiAgXCJSR0lfRW1vamlfRmxhZ19TZXF1ZW5jZVwiLFxuICBcIlJHSV9FbW9qaV9Nb2RpZmllcl9TZXF1ZW5jZVwiLFxuICBcIlJHSV9FbW9qaV9UYWdfU2VxdWVuY2VcIixcbiAgXCJSR0lfRW1vamlfWldKX1NlcXVlbmNlXCJcbl0pO1xudmFyIEpzVW5pY29kZVByb3BlcnRpZXNPZlN0cmluZ3NNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZm9yIChjb25zdCBwIG9mIEpzVW5pY29kZVByb3BlcnRpZXNPZlN0cmluZ3MpIHtcbiAgSnNVbmljb2RlUHJvcGVydGllc09mU3RyaW5nc01hcC5zZXQoc2x1ZyhwKSwgcCk7XG59XG52YXIgTG93ZXJUb0FsdGVybmF0aXZlTG93ZXJDYXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJzXCIsIGNwKDM4MyldLFxuICAvLyBzLCDFv1xuICBbY3AoMzgzKSwgXCJzXCJdXG4gIC8vIMW/LCBzXG5dKTtcbnZhciBMb3dlclRvQWx0ZXJuYXRpdmVVcHBlckNhc2VNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtjcCgyMjMpLCBjcCg3ODM4KV0sXG4gIC8vIMOfLCDhup5cbiAgW2NwKDEwNyksIGNwKDg0OTApXSxcbiAgLy8gaywg4oSqIChLZWx2aW4pXG4gIFtjcCgyMjkpLCBjcCg4NDkxKV0sXG4gIC8vIMOlLCDihKsgKEFuZ3N0cm9tKVxuICBbY3AoOTY5KSwgY3AoODQ4NildXG4gIC8vIM+JLCDihKYgKE9obSlcbl0pO1xudmFyIExvd2VyVG9UaXRsZUNhc2VNYXAgPSBuZXcgTWFwKFtcbiAgdGl0bGVFbnRyeSg0NTMpLFxuICB0aXRsZUVudHJ5KDQ1NiksXG4gIHRpdGxlRW50cnkoNDU5KSxcbiAgdGl0bGVFbnRyeSg0OTgpLFxuICAuLi50aXRsZVJhbmdlKDgwNzIsIDgwNzkpLFxuICAuLi50aXRsZVJhbmdlKDgwODgsIDgwOTUpLFxuICAuLi50aXRsZVJhbmdlKDgxMDQsIDgxMTEpLFxuICB0aXRsZUVudHJ5KDgxMjQpLFxuICB0aXRsZUVudHJ5KDgxNDApLFxuICB0aXRsZUVudHJ5KDgxODgpXG5dKTtcbnZhciBQb3NpeENsYXNzZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtcImFsbnVtXCIsIHJgW1xccHtBbHBoYX1cXHB7TmR9XWBdLFxuICBbXCJhbHBoYVwiLCByYFxccHtBbHBoYX1gXSxcbiAgW1wiYXNjaWlcIiwgcmBcXHB7QVNDSUl9YF0sXG4gIFtcImJsYW5rXCIsIHJgW1xccHtac31cXHRdYF0sXG4gIFtcImNudHJsXCIsIHJgXFxwe2NudHJsfWBdLFxuICBbXCJkaWdpdFwiLCByYFxccHtOZH1gXSxcbiAgW1wiZ3JhcGhcIiwgcmBbXFxQe3NwYWNlfSYmXFxQe2NudHJsfSYmXFxQe0NufSYmXFxQe0NzfV1gXSxcbiAgW1wibG93ZXJcIiwgcmBcXHB7TG93ZXJ9YF0sXG4gIFtcInByaW50XCIsIHJgW1tcXFB7c3BhY2V9JiZcXFB7Y250cmx9JiZcXFB7Q259JiZcXFB7Q3N9XVxccHtac31dYF0sXG4gIFtcInB1bmN0XCIsIHJgW1xccHtQfVxccHtTfV1gXSxcbiAgLy8gTmV3IHZhbHVlIGZyb20gT25pZ3VydW1hIDYuOS45XG4gIFtcInNwYWNlXCIsIHJgXFxwe3NwYWNlfWBdLFxuICBbXCJ1cHBlclwiLCByYFxccHtVcHBlcn1gXSxcbiAgW1wid29yZFwiLCByYFtcXHB7QWxwaGF9XFxwe019XFxwe05kfVxccHtQY31dYF0sXG4gIFtcInhkaWdpdFwiLCByYFxccHtBSGV4fWBdXG5dKTtcbnZhciBQb3NpeFByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYWxudW1cIixcbiAgXCJibGFua1wiLFxuICBcImdyYXBoXCIsXG4gIFwicHJpbnRcIixcbiAgXCJ3b3JkXCIsXG4gIFwieGRpZ2l0XCJcbiAgLy8gVGhlIGZvbGxvd2luZyBhcmUgYXZhaWxhYmxlIHdpdGggdGhlIHNhbWUgbmFtZSBpbiBKUyAoc2VlIGBKc1VuaWNvZGVQcm9wZXJ0aWVzYCksIHNvIGNhbiBiZVxuICAvLyBoYW5kbGVkIGFzIHN0YW5kYXJkIFVuaWNvZGUgcHJvcGVydGllc1xuICAvLyAnYWxwaGEnLCAvLyAoSlM6IEFscGhhKVxuICAvLyAnYXNjaWknLCAvLyAoSlM6IEFTQ0lJKVxuICAvLyAnY250cmwnLCAvLyAoSlM6IGNudHJsKVxuICAvLyAnZGlnaXQnLCAvLyAoSlM6IGRpZ2l0KVxuICAvLyAnbG93ZXInLCAvLyAoSlM6IExvd2VyKVxuICAvLyAncHVuY3QnLCAvLyAoSlM6IHB1bmN0KVxuICAvLyAnc3BhY2UnLCAvLyAoSlM6IHNwYWNlKVxuICAvLyAndXBwZXInLCAvLyAoSlM6IFVwcGVyKVxuXSk7XG5mdW5jdGlvbiByYW5nZShzdGFydCwgZW5kKSB7XG4gIGNvbnN0IHJhbmdlMiA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICByYW5nZTIucHVzaChpKTtcbiAgfVxuICByZXR1cm4gcmFuZ2UyO1xufVxuZnVuY3Rpb24gc2x1ZyhuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UoL1stIF9dKy9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdGl0bGVFbnRyeShjb2RlUG9pbnQpIHtcbiAgY29uc3QgY2hhciA9IGNwKGNvZGVQb2ludCk7XG4gIHJldHVybiBbY2hhci50b0xvd2VyQ2FzZSgpLCBjaGFyXTtcbn1cbmZ1bmN0aW9uIHRpdGxlUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gcmFuZ2Uoc3RhcnQsIGVuZCkubWFwKChjb2RlUG9pbnQpID0+IHRpdGxlRW50cnkoY29kZVBvaW50KSk7XG59XG52YXIgVW5pY29kZVByb3BlcnRpZXNXaXRoU3BlY2lmaWNDYXNlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIkxvd2VyXCIsXG4gIFwiTG93ZXJjYXNlXCIsXG4gIFwiVXBwZXJcIixcbiAgXCJVcHBlcmNhc2VcIixcbiAgXCJMbFwiLFxuICBcIkxvd2VyY2FzZV9MZXR0ZXJcIixcbiAgXCJMdFwiLFxuICBcIlRpdGxlY2FzZV9MZXR0ZXJcIixcbiAgXCJMdVwiLFxuICBcIlVwcGVyY2FzZV9MZXR0ZXJcIlxuICAvLyBUaGUgYENoYW5nZXNfV2hlbl8qYCBwcm9wZXJ0aWVzIChhbmQgdGhlaXIgYWxpYXNlcykgY291bGQgYmUgaW5jbHVkZWQsIGJ1dCB0aGV5J3JlIHZlcnkgcmFyZS5cbiAgLy8gU29tZSBvdGhlciBwcm9wZXJ0aWVzIGluY2x1ZGUgYSBoYW5kZnVsIG9mIGNoYXJzIHdpdGggc3BlY2lmaWMgY2FzZXMgb25seSwgYnV0IHRoZXNlIGNoYXJzIGFyZVxuICAvLyBnZW5lcmFsbHkgZXh0cmVtZSBlZGdlIGNhc2VzIGFuZCB1c2luZyBzdWNoIHByb3BlcnRpZXMgY2FzZSBpbnNlbnNpdGl2ZWx5IGdlbmVyYWxseSBwcm9kdWNlc1xuICAvLyB1bmRlc2lyZWQgYmVoYXZpb3IgYW55d2F5XG5dKTtcblxuLy8gc3JjL3Rva2VuaXplLmpzXG52YXIgVG9rZW5UeXBlcyA9IChcbiAgLyoqIEB0eXBlIHtjb25zdH0gKi9cbiAge1xuICAgIEFsdGVybmF0b3I6IFwiQWx0ZXJuYXRvclwiLFxuICAgIEFzc2VydGlvbjogXCJBc3NlcnRpb25cIixcbiAgICBCYWNrcmVmZXJlbmNlOiBcIkJhY2tyZWZlcmVuY2VcIixcbiAgICBDaGFyYWN0ZXI6IFwiQ2hhcmFjdGVyXCIsXG4gICAgQ2hhcmFjdGVyQ2xhc3NDbG9zZTogXCJDaGFyYWN0ZXJDbGFzc0Nsb3NlXCIsXG4gICAgQ2hhcmFjdGVyQ2xhc3NIeXBoZW46IFwiQ2hhcmFjdGVyQ2xhc3NIeXBoZW5cIixcbiAgICBDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdG9yOiBcIkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0b3JcIixcbiAgICBDaGFyYWN0ZXJDbGFzc09wZW46IFwiQ2hhcmFjdGVyQ2xhc3NPcGVuXCIsXG4gICAgQ2hhcmFjdGVyU2V0OiBcIkNoYXJhY3RlclNldFwiLFxuICAgIERpcmVjdGl2ZTogXCJEaXJlY3RpdmVcIixcbiAgICBHcm91cENsb3NlOiBcIkdyb3VwQ2xvc2VcIixcbiAgICBHcm91cE9wZW46IFwiR3JvdXBPcGVuXCIsXG4gICAgU3Vicm91dGluZTogXCJTdWJyb3V0aW5lXCIsXG4gICAgUXVhbnRpZmllcjogXCJRdWFudGlmaWVyXCIsXG4gICAgLy8gVGhlc2UgYXJlbid0IGFsbG93ZWQgaW4gY2hhciBjbGFzc2VzLCBzbyB0aGV5IGFyZW4ndCBlcXVpdmFsZW50IHRvIEpTIGBbXFxxe31dYFxuICAgIFZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0OiBcIlZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0XCIsXG4gICAgLy8gSW50ZXJtZWRpYXRlIHJlcHJlc2VudGF0aW9uIG5vdCBpbmNsdWRlZCBpbiByZXN1bHRzXG4gICAgRXNjYXBlZE51bWJlcjogXCJFc2NhcGVkTnVtYmVyXCJcbiAgfVxuKTtcbnZhciBUb2tlbkNoYXJhY3RlclNldEtpbmRzID0ge1xuICBhbnk6IFwiYW55XCIsXG4gIGRpZ2l0OiBcImRpZ2l0XCIsXG4gIGRvdDogXCJkb3RcIixcbiAgaGV4OiBcImhleFwiLFxuICBub25fbmV3bGluZTogXCJub25fbmV3bGluZVwiLFxuICBwb3NpeDogXCJwb3NpeFwiLFxuICBwcm9wZXJ0eTogXCJwcm9wZXJ0eVwiLFxuICBzcGFjZTogXCJzcGFjZVwiLFxuICB3b3JkOiBcIndvcmRcIlxufTtcbnZhciBUb2tlbkRpcmVjdGl2ZUtpbmRzID0ge1xuICBmbGFnczogXCJmbGFnc1wiLFxuICBrZWVwOiBcImtlZXBcIlxufTtcbnZhciBUb2tlbkdyb3VwS2luZHMgPSB7XG4gIGF0b21pYzogXCJhdG9taWNcIixcbiAgY2FwdHVyaW5nOiBcImNhcHR1cmluZ1wiLFxuICBncm91cDogXCJncm91cFwiLFxuICBsb29rYWhlYWQ6IFwibG9va2FoZWFkXCIsXG4gIGxvb2tiZWhpbmQ6IFwibG9va2JlaGluZFwiXG59O1xudmFyIEVzY2FwZUNoYXJDb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wiYVwiLCA3XSxcbiAgLy8gYWxlcnQvYmVsbCAoTm90IGF2YWlsYWJsZSBpbiBKUylcbiAgW1wiYlwiLCA4XSxcbiAgLy8gYmFja3NwYWNlIChvbmx5IGluIGNoYXIgY2xhc3NlcylcbiAgW1wiZVwiLCAyN10sXG4gIC8vIGVzY2FwZSAoTm90IGF2YWlsYWJsZSBpbiBKUylcbiAgW1wiZlwiLCAxMl0sXG4gIC8vIGZvcm0gZmVlZFxuICBbXCJuXCIsIDEwXSxcbiAgLy8gbGluZSBmZWVkXG4gIFtcInJcIiwgMTNdLFxuICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgW1widFwiLCA5XSxcbiAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgW1widlwiLCAxMV1cbiAgLy8gdmVydGljYWwgdGFiXG5dKTtcbnZhciBjaGFyQ2xhc3NPcGVuUGF0dGVybiA9IHJgXFxbXFxeP2A7XG52YXIgc2hhcmVkRXNjYXBlc1BhdHRlcm4gPSBgJHsvLyBDb250cm9sIGNoYXJcblwiYy4/IHwgQyg/Oi0uPyk/XCJ9fCR7Ly8gVW5pY29kZSBwcm9wZXJ0eTsgT25pZyBjb25zaWRlcnMgYFxccGAgYW4gaWRlbnRpdHkgZXNjYXBlLCBidXQgZS5nLiBgXFxwe2AsIGBcXHB7IF5MfWAsIGFuZFxuLy8gYFxccHtnYz1MfWAgYXJlIGludmFsaWRcbnJgW3BQXVxceyg/OlxcXj9bLVxceDIwX10qW0EtWmEtel1bLVxceDIwXFx3XSpcXH0pP2B9fCR7Ly8gSGV4IGVuY29kZWQgYnl0ZSBzZXF1ZW5jZTsgYXR0ZW1wdCBtYXRjaCBiZWZvcmUgb3RoZXIgYFxceE5OYCBoZXggY2hhclxucmB4Wzg5QS1GYS1mXVxccHtBSGV4fSg/OlxcXFx4Wzg5QS1GYS1mXVxccHtBSGV4fSkqYH18JHsvLyBIZXggY2hhclxucmB1KD86XFxwe0FIZXh9ezR9KT8gfCB4XFx7W15cXH1dKlxcfT8gfCB4XFxwe0FIZXh9ezAsMn1gfXwkey8vIEVuY2xvc2VkIG9jdGFsIGNvZGUgcG9pbnRcbnJgb1xce1teXFx9XSpcXH0/YH18JHsvLyBFc2NhcGVkIG51bWJlclxucmBcXGR7MSwzfWB9YDtcbnZhciBxdWFudGlmaWVyUmUgPSAvWz8qK11bPytdP3xcXHsoPzpcXGQrKD86LFxcZCopP3wsXFxkKylcXH1cXD8/LztcbnZhciB0b2tlblJlID0gbmV3IFJlZ0V4cChyYFxuICBcXFxcICg/OlxuICAgICR7c2hhcmVkRXNjYXBlc1BhdHRlcm59XG4gICAgfCBbZ2tdPFtePl0qPj9cbiAgICB8IFtna10nW14nXSonP1xuICAgIHwgLlxuICApXG4gIHwgXFwoICg/OiBcXD8gKD86XG4gICAgWzo9IT4ofl1cbiAgICB8IDxbPSFdXG4gICAgfCA8W14+XSo+XG4gICAgfCAnW14nXSonXG4gICAgfCAjICg/OlteKVxcXFxdIHwgXFxcXC4/KSpcbiAgICB8IFtpbXhcXC1dK1s6KV1cbiAgKT8pP1xuICB8ICR7cXVhbnRpZmllclJlLnNvdXJjZX1cbiAgfCAke2NoYXJDbGFzc09wZW5QYXR0ZXJufVxuICB8IC5cbmAucmVwbGFjZSgvXFxzKy9nLCBcIlwiKSwgXCJnc3VcIik7XG52YXIgY2hhckNsYXNzVG9rZW5SZSA9IG5ldyBSZWdFeHAocmBcbiAgXFxcXCAoPzpcbiAgICAke3NoYXJlZEVzY2FwZXNQYXR0ZXJufVxuICAgIHwgLlxuICApXG4gIHwgXFxbOlteOl0qOlxcXVxuICB8ICR7Y2hhckNsYXNzT3BlblBhdHRlcm59XG4gIHwgJiZcbiAgfCAuXG5gLnJlcGxhY2UoL1xccysvZywgXCJcIiksIFwiZ3N1XCIpO1xuZnVuY3Rpb24gdG9rZW5pemUocGF0dGVybiwgZmxhZ3MgPSBcIlwiLCBydWxlcykge1xuICBydWxlcyA9IHtcbiAgICAvLyBgT05JR19PUFRJT05fQ0FQVFVSRV9HUk9VUGBcbiAgICBjYXB0dXJlR3JvdXA6IGZhbHNlLFxuICAgIC4uLnJ1bGVzXG4gIH07XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZyBleHBlY3RlZCBhcyBwYXR0ZXJuXCIpO1xuICB9XG4gIGlmICghL15baW14RFNXXSokLy50ZXN0KGZsYWdzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmxhZ3MgXCIke2ZsYWdzfVwiIGluY2x1ZGVzIHVuc3VwcG9ydGVkIHZhbHVlYCk7XG4gIH1cbiAgY29uc3QgZXh0ZW5kZWQgPSBmbGFncy5pbmNsdWRlcyhcInhcIik7XG4gIGNvbnN0IHhTdGFjayA9IFtleHRlbmRlZF07XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgY2FwdHVyZUdyb3VwOiBydWxlcy5jYXB0dXJlR3JvdXAsXG4gICAgZ2V0Q3VycmVudE1vZFg6ICgpID0+IHhTdGFjay5hdCgtMSksXG4gICAgbnVtT3Blbkdyb3VwczogMCxcbiAgICBwb3BNb2RYKCkge1xuICAgICAgeFN0YWNrLnBvcCgpO1xuICAgIH0sXG4gICAgcHVzaE1vZFgoaXNYT24pIHtcbiAgICAgIHhTdGFjay5wdXNoKGlzWE9uKTtcbiAgICB9LFxuICAgIHJlcGxhY2VDdXJyZW50TW9kWChpc1hPbikge1xuICAgICAgeFN0YWNrW3hTdGFjay5sZW5ndGggLSAxXSA9IGlzWE9uO1xuICAgIH1cbiAgfTtcbiAgbGV0IHRva2VucyA9IFtdO1xuICBsZXQgbWF0Y2g7XG4gIHRva2VuUmUubGFzdEluZGV4ID0gMDtcbiAgd2hpbGUgKG1hdGNoID0gdG9rZW5SZS5leGVjKHBhdHRlcm4pKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0VG9rZW5XaXRoRGV0YWlscyhjb250ZXh0LCBwYXR0ZXJuLCBtYXRjaFswXSwgdG9rZW5SZS5sYXN0SW5kZXgpO1xuICAgIGlmIChyZXN1bHQudG9rZW5zKSB7XG4gICAgICB0b2tlbnMucHVzaCguLi5yZXN1bHQudG9rZW5zKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC50b2tlbikge1xuICAgICAgdG9rZW5zLnB1c2gocmVzdWx0LnRva2VuKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sYXN0SW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgdG9rZW5SZS5sYXN0SW5kZXggPSByZXN1bHQubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuICBjb25zdCBwb3RlbnRpYWxVbm5hbWVkQ2FwdHVyZVRva2VucyA9IFtdO1xuICBsZXQgbnVtTmFtZWRBbmRPcHRJblVubmFtZWRDYXB0dXJlcyA9IDA7XG4gIHRva2Vucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgaWYgKHQudHlwZSA9PT0gVG9rZW5UeXBlcy5Hcm91cE9wZW4pIHtcbiAgICAgIGlmICh0LmtpbmQgPT09IFRva2VuR3JvdXBLaW5kcy5jYXB0dXJpbmcpIHtcbiAgICAgICAgdC5udW1iZXIgPSArK251bU5hbWVkQW5kT3B0SW5Vbm5hbWVkQ2FwdHVyZXM7XG4gICAgICB9IGVsc2UgaWYgKHQucmF3ID09PSBcIihcIikge1xuICAgICAgICBwb3RlbnRpYWxVbm5hbWVkQ2FwdHVyZVRva2Vucy5wdXNoKHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmICghbnVtTmFtZWRBbmRPcHRJblVubmFtZWRDYXB0dXJlcykge1xuICAgIHBvdGVudGlhbFVubmFtZWRDYXB0dXJlVG9rZW5zLmZvckVhY2goKHQsIGkpID0+IHtcbiAgICAgIHQua2luZCA9IFRva2VuR3JvdXBLaW5kcy5jYXB0dXJpbmc7XG4gICAgICB0Lm51bWJlciA9IGkgKyAxO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IG51bUNhcHR1cmVzID0gbnVtTmFtZWRBbmRPcHRJblVubmFtZWRDYXB0dXJlcyB8fCBwb3RlbnRpYWxVbm5hbWVkQ2FwdHVyZVRva2Vucy5sZW5ndGg7XG4gIHRva2VucyA9IHRva2Vucy5tYXAoXG4gICAgKHQpID0+IHQudHlwZSA9PT0gVG9rZW5UeXBlcy5Fc2NhcGVkTnVtYmVyID8gc3BsaXRFc2NhcGVkTnVtVG9rZW4odCwgbnVtQ2FwdHVyZXMpIDogdFxuICApLmZsYXQoKTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbnMsXG4gICAgZmxhZ3M6IHtcbiAgICAgIGlnbm9yZUNhc2U6IGZsYWdzLmluY2x1ZGVzKFwiaVwiKSxcbiAgICAgIC8vIEZsYWcgbSBpcyBjYWxsZWQgYG11bHRpbGluZWAgaW4gT25pZywgYnV0IHRoYXQgaGFzIGEgZGlmZmVyZW50IG1lYW5pbmcgaW4gSlMuIE9uaWcgZmxhZyBtXG4gICAgICAvLyBpcyBlcXVpdmFsZW50IHRvIEpTIGZsYWcgc1xuICAgICAgZG90QWxsOiBmbGFncy5pbmNsdWRlcyhcIm1cIiksXG4gICAgICAvLyBGbGFnIHggaXMgZnVsbHkgaGFuZGxlZCBkdXJpbmcgdG9rZW5pemF0aW9uXG4gICAgICBleHRlbmRlZCxcbiAgICAgIC8vIEZsYWdzIEQsIFMsIFcgYXJlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBhcyB0b3AtbGV2ZWwgZmxhZ3NcbiAgICAgIGRpZ2l0SXNBc2NpaTogZmxhZ3MuaW5jbHVkZXMoXCJEXCIpLFxuICAgICAgc3BhY2VJc0FzY2lpOiBmbGFncy5pbmNsdWRlcyhcIlNcIiksXG4gICAgICB3b3JkSXNBc2NpaTogZmxhZ3MuaW5jbHVkZXMoXCJXXCIpXG4gICAgfSxcbiAgICBydWxlc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0VG9rZW5XaXRoRGV0YWlscyhjb250ZXh0LCBwYXR0ZXJuLCBtLCBsYXN0SW5kZXgpIHtcbiAgY29uc3QgW20wLCBtMSwgbTJdID0gbTtcbiAgaWYgKG0wID09PSBcIltcIikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldEFsbFRva2Vuc0ZvckNoYXJDbGFzcyhwYXR0ZXJuLCBtLCBsYXN0SW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBBcnJheSBvZiBhbGwgb2YgdGhlIGNoYXIgY2xhc3MncyB0b2tlbnNcbiAgICAgIHRva2VuczogcmVzdWx0LnRva2VucyxcbiAgICAgIC8vIEp1bXAgZm9yd2FyZCB0byB0aGUgZW5kIG9mIHRoZSBjaGFyIGNsYXNzXG4gICAgICBsYXN0SW5kZXg6IHJlc3VsdC5sYXN0SW5kZXhcbiAgICB9O1xuICB9XG4gIGlmIChtMCA9PT0gXCJcXFxcXCIpIHtcbiAgICBpZiAoXCJBYkJHelpcIi5pbmNsdWRlcyhtMSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkFzc2VydGlvbiwgbSwge1xuICAgICAgICAgIGtpbmQ6IG1cbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICgvXlxcXFxnWzwnXS8udGVzdChtKSkge1xuICAgICAgaWYgKCEvXlxcXFxnKD86PFtePl0rPnwnW14nXSsnKSQvLnRlc3QobSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGdyb3VwIG5hbWUgXCIke219XCJgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLlN1YnJvdXRpbmUsIG0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoL15cXFxca1s8J10vLnRlc3QobSkpIHtcbiAgICAgIGlmICghL15cXFxcayg/OjxbXj5dKz58J1teJ10rJykkLy50ZXN0KG0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBncm91cCBuYW1lIFwiJHttfVwiYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5CYWNrcmVmZXJlbmNlLCBtKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG0xID09PSBcIktcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuRGlyZWN0aXZlLCBtLCB7XG4gICAgICAgICAga2luZDogVG9rZW5EaXJlY3RpdmVLaW5kcy5rZWVwXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobTEgPT09IFwiTlwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJTZXQsIG0sIHtcbiAgICAgICAgICBraW5kOiBUb2tlbkNoYXJhY3RlclNldEtpbmRzLm5vbl9uZXdsaW5lXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobTEgPT09IFwiT1wiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJTZXQsIG0sIHtcbiAgICAgICAgICBraW5kOiBUb2tlbkNoYXJhY3RlclNldEtpbmRzLmFueVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKFwiUlhcIi5pbmNsdWRlcyhtMSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLlZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0LCBtLCB7XG4gICAgICAgICAga2luZDogbVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKFwieVlcIi5pbmNsdWRlcyhtMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZ3JhcGhlbWUgYm91bmRhcnkgXCIke219XCJgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlVG9rZW5Gb3JTaGFyZWRFc2NhcGUobSwgeyBpbkNoYXJDbGFzczogZmFsc2UgfSk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHsgdG9rZW5zOiByZXN1bHQgfSA6IHsgdG9rZW46IHJlc3VsdCB9O1xuICB9XG4gIGlmIChtMCA9PT0gXCIoXCIpIHtcbiAgICBpZiAobTIgPT09IFwiI1wiKSB7XG4gICAgICBpZiAocGF0dGVybltsYXN0SW5kZXhdICE9PSBcIilcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIGNvbW1lbnQgZ3JvdXAgXCIoPyNcIicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFzdEluZGV4OiBsYXN0SW5kZXggKyAxXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoXCItaW14XCIuaW5jbHVkZXMobTIpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW5Gb3JGbGFnTW9kKG0sIGNvbnRleHQpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb250ZXh0LnB1c2hNb2RYKGNvbnRleHQuZ2V0Q3VycmVudE1vZFgoKSk7XG4gICAgY29udGV4dC5udW1PcGVuR3JvdXBzKys7XG4gICAgaWYgKFxuICAgICAgLy8gVW5uYW1lZCBjYXB0dXJlIGlmIG5vIG5hbWVkIGNhcHR1cmVzIHByZXNlbnQgYW5kIGBjYXB0dXJlR3JvdXBgIG5vdCBlbmFibGVkLCBlbHNlXG4gICAgICAvLyBub25jYXB0dXJpbmcgZ3JvdXBcbiAgICAgIG0gPT09IFwiKFwiICYmICFjb250ZXh0LmNhcHR1cmVHcm91cCB8fCAvLyBOb25jYXB0dXJpbmcgZ3JvdXBcbiAgICAgIG0gPT09IFwiKD86XCJcbiAgICApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkdyb3VwT3BlbiwgbSwge1xuICAgICAgICAgIC8vIEZvciBgKGAsIHdpbGwgbGF0ZXIgY2hhbmdlIHRvIGBjYXB0dXJpbmdgIGFuZCBhZGQgYG51bWJlcmAgcHJvcCBpZiBubyBuYW1lZCBjYXB0dXJlc1xuICAgICAgICAgIGtpbmQ6IFRva2VuR3JvdXBLaW5kcy5ncm91cFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG0gPT09IFwiKD8+XCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkdyb3VwT3BlbiwgbSwge1xuICAgICAgICAgIGtpbmQ6IFRva2VuR3JvdXBLaW5kcy5hdG9taWNcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChtID09PSBcIig/PVwiIHx8IG0gPT09IFwiKD8hXCIgfHwgbSA9PT0gXCIoPzw9XCIgfHwgbSA9PT0gXCIoPzwhXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkdyb3VwT3BlbiwgbSwge1xuICAgICAgICAgIGtpbmQ6IG0yID09PSBcIjxcIiA/IFRva2VuR3JvdXBLaW5kcy5sb29rYmVoaW5kIDogVG9rZW5Hcm91cEtpbmRzLmxvb2thaGVhZCxcbiAgICAgICAgICBuZWdhdGU6IG0uZW5kc1dpdGgoXCIhXCIpXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobTIgPT09IFwiPFwiIHx8IG0yID09PSBcIidcIiB8fCBtID09PSBcIihcIiAmJiBjb250ZXh0LmNhcHR1cmVHcm91cCkge1xuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkdyb3VwT3BlbiwgbSwge1xuICAgICAgICBraW5kOiBUb2tlbkdyb3VwS2luZHMuY2FwdHVyaW5nXG4gICAgICAgIC8vIFdpbGwgYWRkIGBudW1iZXJgIGluIGEgc2Vjb25kIHBhc3NcbiAgICAgIH0pO1xuICAgICAgaWYgKG0gIT09IFwiKFwiKSB7XG4gICAgICAgIHRva2VuLm5hbWUgPSBtLnNsaWNlKDMsIC0xKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobTIgPT09IFwiKFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbmRpdGlvbmFsIFwiJHttfVwiYCk7XG4gICAgfVxuICAgIGlmIChtMiA9PT0gXCJ+XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWJzZW5jZSBvcGVyYXRvciBcIiR7bX1cImApO1xuICAgIH1cbiAgICBpZiAobSA9PT0gXCIoP1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZ3JvdXAgXCIke219XCJgKTtcbiAgfVxuICBpZiAobSA9PT0gXCIpXCIpIHtcbiAgICBjb250ZXh0LnBvcE1vZFgoKTtcbiAgICBjb250ZXh0Lm51bU9wZW5Hcm91cHMtLTtcbiAgICBpZiAoY29udGV4dC5udW1PcGVuR3JvdXBzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbm1hdGNoZWQgXCIpXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkdyb3VwQ2xvc2UsIG0pXG4gICAgfTtcbiAgfVxuICBpZiAobSA9PT0gXCIjXCIgJiYgY29udGV4dC5nZXRDdXJyZW50TW9kWCgpKSB7XG4gICAgY29uc3QgZW5kID0gcGF0dGVybi5pbmRleE9mKFwiXFxuXCIsIGxhc3RJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIEp1bXAgZm9yd2FyZCB0byB0aGUgZW5kIG9mIHRoZSBjb21tZW50XG4gICAgICBsYXN0SW5kZXg6IGVuZCA9PT0gLTEgPyBwYXR0ZXJuLmxlbmd0aCA6IGVuZFxuICAgIH07XG4gIH1cbiAgaWYgKC9eXFxzJC8udGVzdChtKSAmJiBjb250ZXh0LmdldEN1cnJlbnRNb2RYKCkpIHtcbiAgICBjb25zdCByZSA9IC9cXHMrL3k7XG4gICAgcmUubGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgIGNvbnN0IHJlc3QgPSByZS5leGVjKHBhdHRlcm4pO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBKdW1wIGZvcndhcmQgdG8gdGhlIGVuZCBvZiB0aGUgd2hpdGVzcGFjZVxuICAgICAgbGFzdEluZGV4OiByZXN0ID8gcmUubGFzdEluZGV4IDogbGFzdEluZGV4XG4gICAgfTtcbiAgfVxuICBpZiAobSA9PT0gXCIuXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyU2V0LCBtLCB7XG4gICAgICAgIGtpbmQ6IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMuZG90XG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgaWYgKG0gPT09IFwiXlwiIHx8IG0gPT09IFwiJFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkFzc2VydGlvbiwgbSwge1xuICAgICAgICBraW5kOiBtXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgaWYgKG0gPT09IFwifFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkFsdGVybmF0b3IsIG0pXG4gICAgfTtcbiAgfVxuICBpZiAocXVhbnRpZmllclJlLnRlc3QobSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW46IGNyZWF0ZVRva2VuRm9yUXVhbnRpZmllcihtKVxuICAgIH07XG4gIH1cbiAgYXNzZXJ0U2luZ2xlQ29kZVBvaW50KG0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlciwgbSwge1xuICAgICAgdmFsdWU6IG0uY29kZVBvaW50QXQoMClcbiAgICB9KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWxsVG9rZW5zRm9yQ2hhckNsYXNzKHBhdHRlcm4sIG9wZW5lciwgbGFzdEluZGV4KSB7XG4gIGNvbnN0IHRva2VucyA9IFtjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzT3Blbiwgb3BlbmVyLCB7XG4gICAgbmVnYXRlOiBvcGVuZXJbMV0gPT09IFwiXlwiXG4gIH0pXTtcbiAgbGV0IG51bUNoYXJDbGFzc2VzT3BlbiA9IDE7XG4gIGxldCBtYXRjaDtcbiAgY2hhckNsYXNzVG9rZW5SZS5sYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gIHdoaWxlIChtYXRjaCA9IGNoYXJDbGFzc1Rva2VuUmUuZXhlYyhwYXR0ZXJuKSkge1xuICAgIGNvbnN0IG0gPSBtYXRjaFswXTtcbiAgICBpZiAobVswXSA9PT0gXCJbXCIgJiYgbVsxXSAhPT0gXCI6XCIpIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3BlbisrO1xuICAgICAgdG9rZW5zLnB1c2goY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc09wZW4sIG0sIHtcbiAgICAgICAgbmVnYXRlOiBtWzFdID09PSBcIl5cIlxuICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAobSA9PT0gXCJdXCIpIHtcbiAgICAgIGlmICh0b2tlbnMuYXQoLTEpLnR5cGUgPT09IFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NPcGVuKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCBtLCB7XG4gICAgICAgICAgdmFsdWU6IDkzXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bUNoYXJDbGFzc2VzT3Blbi0tO1xuICAgICAgICB0b2tlbnMucHVzaChjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzQ2xvc2UsIG0pKTtcbiAgICAgICAgaWYgKCFudW1DaGFyQ2xhc3Nlc09wZW4pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVUb2tlbkZvckFueVRva2VuV2l0aGluQ2hhckNsYXNzKG0pO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICB0b2tlbnMucHVzaCguLi5yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnMsXG4gICAgbGFzdEluZGV4OiBjaGFyQ2xhc3NUb2tlblJlLmxhc3RJbmRleCB8fCBwYXR0ZXJuLmxlbmd0aFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JBbnlUb2tlbldpdGhpbkNoYXJDbGFzcyhyYXcpIHtcbiAgaWYgKHJhd1swXSA9PT0gXCJcXFxcXCIpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW5Gb3JTaGFyZWRFc2NhcGUocmF3LCB7IGluQ2hhckNsYXNzOiB0cnVlIH0pO1xuICB9XG4gIGlmIChyYXdbMF0gPT09IFwiW1wiKSB7XG4gICAgY29uc3QgcG9zaXggPSAvXFxbOig/PG5lZ2F0ZT5cXF4/KSg/PG5hbWU+W2Etel0rKTpcXF0vLmV4ZWMocmF3KTtcbiAgICBpZiAoIXBvc2l4IHx8ICFQb3NpeENsYXNzZXNNYXAuZ2V0KHBvc2l4Lmdyb3Vwcy5uYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFBPU0lYIGNsYXNzIFwiJHtyYXd9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyU2V0LCByYXcsIHtcbiAgICAgIGtpbmQ6IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMucG9zaXgsXG4gICAgICBuZWdhdGU6ICEhcG9zaXguZ3JvdXBzLm5lZ2F0ZSxcbiAgICAgIHZhbHVlOiBwb3NpeC5ncm91cHMubmFtZVxuICAgIH0pO1xuICB9XG4gIGlmIChyYXcgPT09IFwiLVwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NIeXBoZW4sIHJhdyk7XG4gIH1cbiAgaWYgKHJhdyA9PT0gXCImJlwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3RvciwgcmF3KTtcbiAgfVxuICBhc3NlcnRTaW5nbGVDb2RlUG9pbnQocmF3KTtcbiAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCByYXcsIHtcbiAgICB2YWx1ZTogcmF3LmNvZGVQb2ludEF0KDApXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JTaGFyZWRFc2NhcGUocmF3LCB7IGluQ2hhckNsYXNzIH0pIHtcbiAgY29uc3QgY2hhcjEgPSByYXdbMV07XG4gIGlmIChjaGFyMSA9PT0gXCJjXCIgfHwgY2hhcjEgPT09IFwiQ1wiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuRm9yQ29udHJvbENoYXIocmF3KTtcbiAgfVxuICBpZiAoXCJkRGhIc1N3V1wiLmluY2x1ZGVzKGNoYXIxKSkge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbkZvclNob3J0aGFuZENoYXJDbGFzcyhyYXcpO1xuICB9XG4gIGlmIChyYXcuc3RhcnRzV2l0aChyYFxcb3tgKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wbGV0ZSwgaW52YWxpZCwgb3IgdW5zdXBwb3J0ZWQgb2N0YWwgY29kZSBwb2ludCBcIiR7cmF3fVwiYCk7XG4gIH1cbiAgaWYgKC9eXFxcXFtwUF1cXHsvLnRlc3QocmF3KSkge1xuICAgIGlmIChyYXcubGVuZ3RoID09PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGxldGUgb3IgaW52YWxpZCBVbmljb2RlIHByb3BlcnR5IFwiJHtyYXd9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuRm9yVW5pY29kZVByb3BlcnR5KHJhdyk7XG4gIH1cbiAgaWYgKC9eXFxcXHhbODlBLUZhLWZdXFxwe0FIZXh9L3UudGVzdChyYXcpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gcmF3LnNwbGl0KC9cXFxceC8pLnNsaWNlKDEpLm1hcCgoaGV4KSA9PiBwYXJzZUludChoZXgsIDE2KSk7XG4gICAgICBjb25zdCBkZWNvZGVkID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIiwge1xuICAgICAgICBpZ25vcmVCT006IHRydWUsXG4gICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICB9KS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgIGNvbnN0IHRva2VucyA9IFsuLi5kZWNvZGVkXS5tYXAoKGNoYXIpID0+IHtcbiAgICAgICAgY29uc3QgcmF3MiA9IFsuLi5lbmNvZGVyLmVuY29kZShjaGFyKV0ubWFwKChieXRlKSA9PiBgXFxcXHgke2J5dGUudG9TdHJpbmcoMTYpfWApLmpvaW4oXCJcIik7XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlciwgcmF3Miwge1xuICAgICAgICAgIHZhbHVlOiBjaGFyLmNvZGVQb2ludEF0KDApXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aWJ5dGUgY29kZSBcIiR7cmF3fVwiIGluY29tcGxldGUgb3IgaW52YWxpZCBpbiBPbmlndXJ1bWFgKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNoYXIxID09PSBcInVcIiB8fCBjaGFyMSA9PT0gXCJ4XCIpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXIsIHJhdywge1xuICAgICAgdmFsdWU6IGdldFZhbGlkYXRlZEhleENoYXJDb2RlKHJhdylcbiAgICB9KTtcbiAgfVxuICBpZiAoRXNjYXBlQ2hhckNvZGVzLmhhcyhjaGFyMSkpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXIsIHJhdywge1xuICAgICAgdmFsdWU6IEVzY2FwZUNoYXJDb2Rlcy5nZXQoY2hhcjEpXG4gICAgfSk7XG4gIH1cbiAgaWYgKC9cXGQvLnRlc3QoY2hhcjEpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuRXNjYXBlZE51bWJlciwgcmF3LCB7XG4gICAgICBpbkNoYXJDbGFzc1xuICAgIH0pO1xuICB9XG4gIGlmIChyYXcgPT09IFwiXFxcXFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHJgSW5jb21wbGV0ZSBlc2NhcGUgXCJcXFwiYCk7XG4gIH1cbiAgaWYgKGNoYXIxID09PSBcIk1cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbWV0YSBcIiR7cmF3fVwiYCk7XG4gIH1cbiAgaWYgKFsuLi5yYXddLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlciwgcmF3LCB7XG4gICAgICB2YWx1ZTogcmF3LmNvZGVQb2ludEF0KDEpXG4gICAgfSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVzY2FwZSBcIiR7cmF3fVwiYCk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbih0eXBlLCByYXcsIGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHJhdyxcbiAgICAuLi5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkZvckNvbnRyb2xDaGFyKHJhdykge1xuICBjb25zdCBjaGFyID0gcmF3WzFdID09PSBcImNcIiA/IHJhd1syXSA6IHJhd1szXTtcbiAgaWYgKCFjaGFyIHx8ICEvW0EtWmEtel0vLnRlc3QoY2hhcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbnRyb2wgY2hhcmFjdGVyIFwiJHtyYXd9XCJgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXIsIHJhdywge1xuICAgIHZhbHVlOiBjaGFyLnRvVXBwZXJDYXNlKCkuY29kZVBvaW50QXQoMCkgLSA2NFxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuRm9yRmxhZ01vZChyYXcsIGNvbnRleHQpIHtcbiAgbGV0IHsgb24sIG9mZiB9ID0gL15cXChcXD8oPzxvbj5baW14XSopKD86LSg/PG9mZj5baW14XFwtXSopKT8vLmV4ZWMocmF3KS5ncm91cHM7XG4gIG9mZiA/Pz0gXCJcIjtcbiAgY29uc3QgaXNYT24gPSAoY29udGV4dC5nZXRDdXJyZW50TW9kWCgpIHx8IG9uLmluY2x1ZGVzKFwieFwiKSkgJiYgIW9mZi5pbmNsdWRlcyhcInhcIik7XG4gIGNvbnN0IGVuYWJsZWRGbGFncyA9IGdldEZsYWdQcm9wc0ZvclRva2VuKG9uKTtcbiAgY29uc3QgZGlzYWJsZWRGbGFncyA9IGdldEZsYWdQcm9wc0ZvclRva2VuKG9mZik7XG4gIGNvbnN0IGZsYWdDaGFuZ2VzID0ge307XG4gIGVuYWJsZWRGbGFncyAmJiAoZmxhZ0NoYW5nZXMuZW5hYmxlID0gZW5hYmxlZEZsYWdzKTtcbiAgZGlzYWJsZWRGbGFncyAmJiAoZmxhZ0NoYW5nZXMuZGlzYWJsZSA9IGRpc2FibGVkRmxhZ3MpO1xuICBpZiAocmF3LmVuZHNXaXRoKFwiKVwiKSkge1xuICAgIGNvbnRleHQucmVwbGFjZUN1cnJlbnRNb2RYKGlzWE9uKTtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5EaXJlY3RpdmUsIHJhdywge1xuICAgICAga2luZDogVG9rZW5EaXJlY3RpdmVLaW5kcy5mbGFncyxcbiAgICAgIGZsYWdzOiBmbGFnQ2hhbmdlc1xuICAgIH0pO1xuICB9XG4gIGlmIChyYXcuZW5kc1dpdGgoXCI6XCIpKSB7XG4gICAgY29udGV4dC5wdXNoTW9kWChpc1hPbik7XG4gICAgY29udGV4dC5udW1PcGVuR3JvdXBzKys7XG4gICAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkdyb3VwT3BlbiwgcmF3LCB7XG4gICAgICBraW5kOiBUb2tlbkdyb3VwS2luZHMuZ3JvdXBcbiAgICB9KTtcbiAgICBpZiAoZW5hYmxlZEZsYWdzIHx8IGRpc2FibGVkRmxhZ3MpIHtcbiAgICAgIHRva2VuLmZsYWdzID0gZmxhZ0NoYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZmxhZyBtb2RpZmllciBcIiR7cmF3fVwiYCk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkZvclF1YW50aWZpZXIocmF3KSB7XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgaWYgKHJhd1swXSA9PT0gXCJ7XCIpIHtcbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSAvXlxceyg/PG1pbj5cXGQqKSg/OiwoPzxtYXg+XFxkKikpPy8uZXhlYyhyYXcpLmdyb3VwcztcbiAgICBjb25zdCBsaW1pdCA9IDFlNTtcbiAgICBpZiAoK21pbiA+IGxpbWl0IHx8ICttYXggPiBsaW1pdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVhbnRpZmllciB2YWx1ZSB1bnN1cHBvcnRlZCBpbiBPbmlndXJ1bWFcIik7XG4gICAgfVxuICAgIGRhdGEubWluID0gK21pbjtcbiAgICBkYXRhLm1heCA9IG1heCA9PT0gdm9pZCAwID8gK21pbiA6IG1heCA9PT0gXCJcIiA/IEluZmluaXR5IDogK21heDtcbiAgICBkYXRhLmdyZWVkeSA9ICFyYXcuZW5kc1dpdGgoXCI/XCIpO1xuICAgIGRhdGEucG9zc2Vzc2l2ZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGRhdGEubWluID0gcmF3WzBdID09PSBcIitcIiA/IDEgOiAwO1xuICAgIGRhdGEubWF4ID0gcmF3WzBdID09PSBcIj9cIiA/IDEgOiBJbmZpbml0eTtcbiAgICBkYXRhLmdyZWVkeSA9IHJhd1sxXSAhPT0gXCI/XCI7XG4gICAgZGF0YS5wb3NzZXNzaXZlID0gcmF3WzFdID09PSBcIitcIjtcbiAgfVxuICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5RdWFudGlmaWVyLCByYXcsIGRhdGEpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JTaG9ydGhhbmRDaGFyQ2xhc3MocmF3KSB7XG4gIGNvbnN0IGxvd2VyID0gcmF3WzFdLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlclNldCwgcmF3LCB7XG4gICAga2luZDoge1xuICAgICAgXCJkXCI6IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMuZGlnaXQsXG4gICAgICBcImhcIjogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5oZXgsXG4gICAgICAvLyBOb3QgYXZhaWxhYmxlIGluIEpTXG4gICAgICBcInNcIjogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5zcGFjZSxcbiAgICAgIC8vIERpZmZlcmVudCB0aGFuIEpTXG4gICAgICBcIndcIjogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy53b3JkXG4gICAgfVtsb3dlcl0sXG4gICAgbmVnYXRlOiByYXdbMV0gIT09IGxvd2VyXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JVbmljb2RlUHJvcGVydHkocmF3KSB7XG4gIGNvbnN0IHsgcCwgbmVnLCB2YWx1ZSB9ID0gL15cXFxcKD88cD5bcFBdKVxceyg/PG5lZz5cXF4/KSg/PHZhbHVlPltefV0rKS8uZXhlYyhyYXcpLmdyb3VwcztcbiAgY29uc3QgbmVnYXRlID0gcCA9PT0gXCJQXCIgJiYgIW5lZyB8fCBwID09PSBcInBcIiAmJiAhIW5lZztcbiAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyU2V0LCByYXcsIHtcbiAgICBraW5kOiBUb2tlbkNoYXJhY3RlclNldEtpbmRzLnByb3BlcnR5LFxuICAgIG5lZ2F0ZSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZsYWdQcm9wc0ZvclRva2VuKGZsYWdzKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBpZiAoZmxhZ3MuaW5jbHVkZXMoXCJpXCIpKSB7XG4gICAgb2JqLmlnbm9yZUNhc2UgPSB0cnVlO1xuICB9XG4gIGlmIChmbGFncy5pbmNsdWRlcyhcIm1cIikpIHtcbiAgICBvYmouZG90QWxsID0gdHJ1ZTtcbiAgfVxuICBpZiAoZmxhZ3MuaW5jbHVkZXMoXCJ4XCIpKSB7XG4gICAgb2JqLmV4dGVuZGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPyBvYmogOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRhdGVkSGV4Q2hhckNvZGUocmF3KSB7XG4gIGlmICgvXig/OlxcXFx1KD8hXFxwe0FIZXh9ezR9KXxcXFxceCg/IVxccHtBSGV4fXsxLDJ9fFxce1xccHtBSGV4fXsxLDh9XFx9KSkvdS50ZXN0KHJhdykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGxldGUgb3IgaW52YWxpZCBlc2NhcGUgXCIke3Jhd31cImApO1xuICB9XG4gIGNvbnN0IGhleCA9IHJhd1syXSA9PT0gXCJ7XCIgPyAvXlxcXFx4XFx7XFxzKig/PGhleD5cXHB7QUhleH0rKS91LmV4ZWMocmF3KS5ncm91cHMuaGV4IDogcmF3LnNsaWNlKDIpO1xuICBjb25zdCBkZWMgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgcmV0dXJuIGRlYztcbn1cbmZ1bmN0aW9uIHNwbGl0RXNjYXBlZE51bVRva2VuKHRva2VuLCBudW1DYXB0dXJlcykge1xuICBjb25zdCB7IHJhdywgaW5DaGFyQ2xhc3MgfSA9IHRva2VuO1xuICBjb25zdCB2YWx1ZSA9IHJhdy5zbGljZSgxKTtcbiAgaWYgKCFpbkNoYXJDbGFzcyAmJiAvLyBTaW5nbGUgZGlnaXQgMS05IG91dHNpZGUgYSBjaGFyIGNsYXNzIGlzIGFsd2F5cyB0cmVhdGVkIGFzIGEgYmFja3JlZlxuICAodmFsdWUgIT09IFwiMFwiICYmIHZhbHVlLmxlbmd0aCA9PT0gMSB8fCAvLyBMZWFkaW5nIDAgbWFrZXMgaXQgb2N0YWw7IGJhY2tyZWZzIGNhbid0IGluY2x1ZGUgZm9sbG93aW5nIGxpdGVyYWwgZGlnaXRzXG4gIHZhbHVlWzBdICE9PSBcIjBcIiAmJiArdmFsdWUgPD0gbnVtQ2FwdHVyZXMpKSB7XG4gICAgcmV0dXJuIFtjcmVhdGVUb2tlbihUb2tlblR5cGVzLkJhY2tyZWZlcmVuY2UsIHJhdyldO1xuICB9XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goL15bMC03XSt8XFxkL2cpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtID0gbWF0Y2hlc1tpXTtcbiAgICBsZXQgdmFsdWUyO1xuICAgIGlmIChpID09PSAwICYmIG0gIT09IFwiOFwiICYmIG0gIT09IFwiOVwiKSB7XG4gICAgICB2YWx1ZTIgPSBwYXJzZUludChtLCA4KTtcbiAgICAgIGlmICh2YWx1ZTIgPiAxMjcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJgT2N0YWwgZW5jb2RlZCBieXRlIGFib3ZlIDE3NyB1bnN1cHBvcnRlZCBcIiR7cmF3fVwiYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlMiA9IG0uY29kZVBvaW50QXQoMCk7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCAoaSA9PT0gMCA/IFwiXFxcXFwiIDogXCJcIikgKyBtLCB7XG4gICAgICB2YWx1ZTogdmFsdWUyXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBhc3NlcnRTaW5nbGVDb2RlUG9pbnQocmF3KSB7XG4gIGlmIChbLi4ucmF3XS5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFwiJHtyYXd9XCIgdG8gYmUgYSBzaW5nbGUgY29kZSBwb2ludGApO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy1hc3QuanNcbmZ1bmN0aW9uIGhhc09ubHlDaGlsZCh7IGFsdGVybmF0aXZlcyB9LCBraWRGbikge1xuICByZXR1cm4gYWx0ZXJuYXRpdmVzLmxlbmd0aCA9PT0gMSAmJiBhbHRlcm5hdGl2ZXNbMF0uZWxlbWVudHMubGVuZ3RoID09PSAxICYmICgha2lkRm4gfHwga2lkRm4oYWx0ZXJuYXRpdmVzWzBdLmVsZW1lbnRzWzBdKSk7XG59XG5mdW5jdGlvbiBpc0xvb2thcm91bmQoeyB0eXBlLCBraW5kIH0pIHtcbiAgcmV0dXJuIHR5cGUgPT09IEFzdFR5cGVzLkFzc2VydGlvbiAmJiAoa2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubG9va2FoZWFkIHx8IGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxvb2tiZWhpbmQpO1xufVxuZnVuY3Rpb24gaXNaZXJvTGVuZ3RoTm9kZSh7IHR5cGUsIG1pbiB9KSB7XG4gIHJldHVybiB0eXBlID09PSBBc3RUeXBlcy5Bc3NlcnRpb24gfHwgdHlwZSA9PT0gQXN0VHlwZXMuRGlyZWN0aXZlIHx8IHR5cGUgPT09IEFzdFR5cGVzLlF1YW50aWZpZXIgJiYgIW1pbjtcbn1cblxuLy8gc3JjL3RyYXZlcnNlLmpzXG5mdW5jdGlvbiB0cmF2ZXJzZShwYXRoLCBzdGF0ZSwgdmlzaXRvcikge1xuICBsZXQgYXN0ID0gcGF0aC5ub2RlO1xuICB3aGlsZSAoYXN0LnBhcmVudCkge1xuICAgIGFzdCA9IGFzdC5wYXJlbnQ7XG4gIH1cbiAgZnVuY3Rpb24gdHJhdmVyc2VBcnJheShhcnJheSwgcGFyZW50KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5U2hpZnQgPSB0cmF2ZXJzZU5vZGUoYXJyYXlbaV0sIHBhcmVudCwgaSwgYXJyYXkpO1xuICAgICAgaSA9IE1hdGgubWF4KC0xLCBpICsga2V5U2hpZnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgcGFyZW50ID0gbnVsbCwga2V5ID0gbnVsbCwgY29udGFpbmVyID0gbnVsbCkge1xuICAgIGxldCBrZXlTaGlmdCA9IDA7XG4gICAgbGV0IHNraXBUcmF2ZXJzaW5nS2lkc09mUGF0aCA9IGZhbHNlO1xuICAgIGNvbnN0IHBhdGgyID0ge1xuICAgICAgbm9kZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIGtleSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGFzdCxcbiAgICAgIHJlbW92ZSgpIHtcbiAgICAgICAgdGhyb3dJZk5vdChjb250YWluZXIsIFwiQ29udGFpbmVyIGV4cGVjdGVkXCIpLnNwbGljZShNYXRoLm1heCgwLCBrZXkgKyBrZXlTaGlmdCksIDEpO1xuICAgICAgICBrZXlTaGlmdCAtPSAxO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUFsbE5leHRTaWJsaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRocm93SWZOb3QoY29udGFpbmVyLCBcIkNvbnRhaW5lciBleHBlY3RlZFwiKS5zcGxpY2Uoa2V5ICsgMSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsUHJldlNpYmxpbmdzKCkge1xuICAgICAgICBjb25zdCBzaGlmdGVkID0ga2V5ICsga2V5U2hpZnQ7XG4gICAgICAgIGtleVNoaWZ0IC09IHNoaWZ0ZWQ7XG4gICAgICAgIHJldHVybiB0aHJvd0lmTm90KGNvbnRhaW5lciwgXCJDb250YWluZXIgZXhwZWN0ZWRcIikuc3BsaWNlKDAsIE1hdGgubWF4KDAsIHNoaWZ0ZWQpKTtcbiAgICAgIH0sXG4gICAgICByZXBsYWNlV2l0aChuZXdOb2RlKSB7XG4gICAgICAgIHNldFBhcmVudChuZXdOb2RlLCBwYXJlbnQpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgY29udGFpbmVyW01hdGgubWF4KDAsIGtleSArIGtleVNoaWZ0KV0gPSBuZXdOb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFtrZXldID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNraXAoKSB7XG4gICAgICAgIHNraXBUcmF2ZXJzaW5nS2lkc09mUGF0aCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB2aXNpdG9yS2V5ID0gZ2V0QXN0VHlwZUFsaWFzZXMobm9kZSkuZmluZCgoa2V5MikgPT4gISF2aXNpdG9yW2tleTJdKTtcbiAgICBjb25zdCBtZXRob2RzID0gdmlzaXRvcktleSAmJiB2aXNpdG9yW3Zpc2l0b3JLZXldO1xuICAgIGNvbnN0IGVudGVyRm4gPSB0eXBlb2YgbWV0aG9kcyA9PT0gXCJmdW5jdGlvblwiID8gbWV0aG9kcyA6IG1ldGhvZHM/LmVudGVyO1xuICAgIGNvbnN0IGV4aXRGbiA9IG1ldGhvZHM/LmV4aXQ7XG4gICAgZW50ZXJGbj8uKHBhdGgyLCBzdGF0ZSk7XG4gICAgaWYgKCFza2lwVHJhdmVyc2luZ0tpZHNPZlBhdGgpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuUmVnZXg6XG4gICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUucGF0dGVybiwgbm9kZSwgXCJwYXR0ZXJuXCIpO1xuICAgICAgICAgIHRyYXZlcnNlTm9kZShub2RlLmZsYWdzLCBub2RlLCBcImZsYWdzXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFzdFR5cGVzLkFsdGVybmF0aXZlOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzOlxuICAgICAgICAgIHRyYXZlcnNlQXJyYXkobm9kZS5lbGVtZW50cywgbm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQXNzZXJ0aW9uOlxuICAgICAgICAgIGlmIChpc0xvb2thcm91bmQobm9kZSkpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlQXJyYXkobm9kZS5hbHRlcm5hdGl2ZXMsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5CYWNrcmVmZXJlbmNlOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlcjpcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5DaGFyYWN0ZXJTZXQ6XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuRGlyZWN0aXZlOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkZsYWdzOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLlJlY3Vyc2lvbjpcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5TdWJyb3V0aW5lOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLlZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkdyb3VwOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLlBhdHRlcm46XG4gICAgICAgICAgdHJhdmVyc2VBcnJheShub2RlLmFsdGVybmF0aXZlcywgbm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rpb246XG4gICAgICAgICAgdHJhdmVyc2VBcnJheShub2RlLmNsYXNzZXMsIG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzUmFuZ2U6XG4gICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUubWluLCBub2RlLCBcIm1pblwiKTtcbiAgICAgICAgICB0cmF2ZXJzZU5vZGUobm9kZS5tYXgsIG5vZGUsIFwibWF4XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFzdFR5cGVzLlF1YW50aWZpZXI6XG4gICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuZWxlbWVudCwgbm9kZSwgXCJlbGVtZW50XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBub2RlIHR5cGUgXCIke25vZGUudHlwZX1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBleGl0Rm4/LihwYXRoMiwgc3RhdGUpO1xuICAgIHJldHVybiBrZXlTaGlmdDtcbiAgfVxuICB0cmF2ZXJzZU5vZGUocGF0aC5ub2RlLCBwYXRoLnBhcmVudCwgcGF0aC5rZXksIHBhdGguY29udGFpbmVyKTtcbn1cbnZhciBBc3RUeXBlQWxpYXNlcyA9IHtcbiAgQW55R3JvdXA6IFwiQW55R3JvdXBcIixcbiAgQW55Tm9kZTogXCJBbnlOb2RlXCJcbn07XG5mdW5jdGlvbiBnZXRBc3RUeXBlQWxpYXNlcyhub2RlKSB7XG4gIGNvbnN0IHsgdHlwZSB9ID0gbm9kZTtcbiAgY29uc3QgdHlwZXMgPSBbQXN0VHlwZUFsaWFzZXMuQW55Tm9kZV07XG4gIGlmICh0eXBlID09PSBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cCB8fCB0eXBlID09PSBBc3RUeXBlcy5Hcm91cCB8fCBpc0xvb2thcm91bmQobm9kZSkpIHtcbiAgICB0eXBlcy5wdXNoKEFzdFR5cGVBbGlhc2VzLkFueUdyb3VwKTtcbiAgfVxuICB0eXBlcy5wdXNoKHR5cGUpO1xuICByZXR1cm4gdHlwZXM7XG59XG5mdW5jdGlvbiBzZXRQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gIGlmIChcInBhcmVudFwiIGluIHBhcmVudCkge1xuICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICB9XG59XG5cbi8vIHNyYy9wYXJzZS5qc1xudmFyIEFzdFR5cGVzID0ge1xuICBBbHRlcm5hdGl2ZTogXCJBbHRlcm5hdGl2ZVwiLFxuICBBc3NlcnRpb246IFwiQXNzZXJ0aW9uXCIsXG4gIEJhY2tyZWZlcmVuY2U6IFwiQmFja3JlZmVyZW5jZVwiLFxuICBDYXB0dXJpbmdHcm91cDogXCJDYXB0dXJpbmdHcm91cFwiLFxuICBDaGFyYWN0ZXI6IFwiQ2hhcmFjdGVyXCIsXG4gIENoYXJhY3RlckNsYXNzOiBcIkNoYXJhY3RlckNsYXNzXCIsXG4gIENoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uOiBcIkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uXCIsXG4gIENoYXJhY3RlckNsYXNzUmFuZ2U6IFwiQ2hhcmFjdGVyQ2xhc3NSYW5nZVwiLFxuICBDaGFyYWN0ZXJTZXQ6IFwiQ2hhcmFjdGVyU2V0XCIsXG4gIERpcmVjdGl2ZTogXCJEaXJlY3RpdmVcIixcbiAgRmxhZ3M6IFwiRmxhZ3NcIixcbiAgR3JvdXA6IFwiR3JvdXBcIixcbiAgUGF0dGVybjogXCJQYXR0ZXJuXCIsXG4gIFF1YW50aWZpZXI6IFwiUXVhbnRpZmllclwiLFxuICBSZWdleDogXCJSZWdleFwiLFxuICBTdWJyb3V0aW5lOiBcIlN1YnJvdXRpbmVcIixcbiAgVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXQ6IFwiVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXRcIixcbiAgLy8gVXNlZCBvbmx5IGJ5IHRoZSB0cmFuc2Zvcm1lciBmb3IgUmVnZXgrIEFTVHNcbiAgUmVjdXJzaW9uOiBcIlJlY3Vyc2lvblwiXG59O1xudmFyIEFzdEFzc2VydGlvbktpbmRzID0ge1xuICBsaW5lX2VuZDogXCJsaW5lX2VuZFwiLFxuICBsaW5lX3N0YXJ0OiBcImxpbmVfc3RhcnRcIixcbiAgbG9va2FoZWFkOiBcImxvb2thaGVhZFwiLFxuICBsb29rYmVoaW5kOiBcImxvb2tiZWhpbmRcIixcbiAgc2VhcmNoX3N0YXJ0OiBcInNlYXJjaF9zdGFydFwiLFxuICBzdHJpbmdfZW5kOiBcInN0cmluZ19lbmRcIixcbiAgc3RyaW5nX2VuZF9uZXdsaW5lOiBcInN0cmluZ19lbmRfbmV3bGluZVwiLFxuICBzdHJpbmdfc3RhcnQ6IFwic3RyaW5nX3N0YXJ0XCIsXG4gIHdvcmRfYm91bmRhcnk6IFwid29yZF9ib3VuZGFyeVwiXG59O1xudmFyIEFzdENoYXJhY3RlclNldEtpbmRzID0gVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcztcbnZhciBBc3REaXJlY3RpdmVLaW5kcyA9IFRva2VuRGlyZWN0aXZlS2luZHM7XG52YXIgQXN0VmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXRLaW5kcyA9IHtcbiAgZ3JhcGhlbWU6IFwiZ3JhcGhlbWVcIixcbiAgbmV3bGluZTogXCJuZXdsaW5lXCJcbn07XG5mdW5jdGlvbiBwYXJzZSh7IHRva2VucywgZmxhZ3MsIHJ1bGVzIH0sIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBza2lwQmFja3JlZlZhbGlkYXRpb246IGZhbHNlLFxuICAgIHNraXBMb29rYmVoaW5kVmFsaWRhdGlvbjogZmFsc2UsXG4gICAgc2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb246IGZhbHNlLFxuICAgIHZlcmJvc2U6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBjYXB0dXJpbmdHcm91cHM6IFtdLFxuICAgIGN1cnJlbnQ6IDAsXG4gICAgaGFzTnVtYmVyZWRSZWY6IGZhbHNlLFxuICAgIG5hbWVkR3JvdXBzQnlOYW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHBhcmVudDogbnVsbCxcbiAgICBza2lwQmFja3JlZlZhbGlkYXRpb246IG9wdHMuc2tpcEJhY2tyZWZWYWxpZGF0aW9uLFxuICAgIHNraXBMb29rYmVoaW5kVmFsaWRhdGlvbjogb3B0cy5za2lwTG9va2JlaGluZFZhbGlkYXRpb24sXG4gICAgc2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb246IG9wdHMuc2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb24sXG4gICAgc3Vicm91dGluZXM6IFtdLFxuICAgIHRva2VuOiBudWxsLFxuICAgIHRva2VucyxcbiAgICB2ZXJib3NlOiBvcHRzLnZlcmJvc2UsXG4gICAgd2Fsa1xuICB9O1xuICBmdW5jdGlvbiB3YWxrKHBhcmVudCwgc3RhdGUpIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tjb250ZXh0LmN1cnJlbnRdO1xuICAgIGNvbnRleHQucGFyZW50ID0gcGFyZW50O1xuICAgIGNvbnRleHQudG9rZW4gPSB0b2tlbjtcbiAgICBjb250ZXh0LmN1cnJlbnQrKztcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5BbHRlcm5hdG9yOlxuICAgICAgICByZXR1cm4gY3JlYXRlQWx0ZXJuYXRpdmUoKTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5Bc3NlcnRpb246XG4gICAgICAgIHJldHVybiBjcmVhdGVBc3NlcnRpb25Gcm9tVG9rZW4odG9rZW4pO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLkJhY2tyZWZlcmVuY2U6XG4gICAgICAgIHJldHVybiBwYXJzZUJhY2tyZWZlcmVuY2UoY29udGV4dCk7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuQ2hhcmFjdGVyOlxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyKHRva2VuLnZhbHVlLCB7IHVzZUxhc3RWYWxpZDogISFzdGF0ZS5pc0NoZWNraW5nUmFuZ2VFbmQgfSk7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NIeXBoZW46XG4gICAgICAgIHJldHVybiBwYXJzZUNoYXJhY3RlckNsYXNzSHlwaGVuKGNvbnRleHQsIHN0YXRlKTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc09wZW46XG4gICAgICAgIHJldHVybiBwYXJzZUNoYXJhY3RlckNsYXNzT3Blbihjb250ZXh0LCBzdGF0ZSk7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuQ2hhcmFjdGVyU2V0OlxuICAgICAgICByZXR1cm4gcGFyc2VDaGFyYWN0ZXJTZXQoY29udGV4dCk7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuRGlyZWN0aXZlOlxuICAgICAgICByZXR1cm4gY3JlYXRlRGlyZWN0aXZlRnJvbVRva2VuKHRva2VuKTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5Hcm91cE9wZW46XG4gICAgICAgIHJldHVybiBwYXJzZUdyb3VwT3Blbihjb250ZXh0LCBzdGF0ZSk7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuUXVhbnRpZmllcjpcbiAgICAgICAgcmV0dXJuIHBhcnNlUXVhbnRpZmllcihjb250ZXh0KTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5TdWJyb3V0aW5lOlxuICAgICAgICByZXR1cm4gcGFyc2VTdWJyb3V0aW5lKGNvbnRleHQpO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLlZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0OlxuICAgICAgICByZXR1cm4gY3JlYXRlVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXQodG9rZW4ua2luZCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdG9rZW4gdHlwZSBcIiR7dG9rZW4udHlwZX1cImApO1xuICAgIH1cbiAgfVxuICBjb25zdCBhc3QgPSBjcmVhdGVSZWdleChjcmVhdGVQYXR0ZXJuKCksIGNyZWF0ZUZsYWdzKGZsYWdzKSk7XG4gIGxldCB0b3AgPSBhc3QucGF0dGVybi5hbHRlcm5hdGl2ZXNbMF07XG4gIHdoaWxlIChjb250ZXh0LmN1cnJlbnQgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHdhbGsodG9wLCB7fSk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gQXN0VHlwZXMuQWx0ZXJuYXRpdmUpIHtcbiAgICAgIGFzdC5wYXR0ZXJuLmFsdGVybmF0aXZlcy5wdXNoKG5vZGUpO1xuICAgICAgdG9wID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wLmVsZW1lbnRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHsgY2FwdHVyaW5nR3JvdXBzLCBoYXNOdW1iZXJlZFJlZiwgbmFtZWRHcm91cHNCeU5hbWUsIHN1YnJvdXRpbmVzIH0gPSBjb250ZXh0O1xuICBpZiAoaGFzTnVtYmVyZWRSZWYgJiYgbmFtZWRHcm91cHNCeU5hbWUuc2l6ZSAmJiAhcnVsZXMuY2FwdHVyZUdyb3VwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyZWQgYmFja3JlZi9zdWJyb3V0aW5lIG5vdCBhbGxvd2VkIHdoZW4gdXNpbmcgbmFtZWQgY2FwdHVyZVwiKTtcbiAgfVxuICBmb3IgKGNvbnN0IHsgcmVmIH0gb2Ygc3Vicm91dGluZXMpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKHJlZiA+IGNhcHR1cmluZ0dyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJyb3V0aW5lIHVzZXMgYSBncm91cCBudW1iZXIgdGhhdCdzIG5vdCBkZWZpbmVkYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbmFtZWRHcm91cHNCeU5hbWUuaGFzKHJlZikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyYFN1YnJvdXRpbmUgdXNlcyBhIGdyb3VwIG5hbWUgdGhhdCdzIG5vdCBkZWZpbmVkIFwiXFxnPCR7cmVmfT5cImApO1xuICAgIH0gZWxzZSBpZiAobmFtZWRHcm91cHNCeU5hbWUuZ2V0KHJlZikubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJgU3Vicm91dGluZSB1c2VzIGEgZHVwbGljYXRlIGdyb3VwIG5hbWUgXCJcXGc8JHtyZWZ9PlwiYCk7XG4gICAgfVxuICB9XG4gIHRyYXZlcnNlKHsgbm9kZTogYXN0IH0sIG51bGwsIHtcbiAgICBBbnlOb2RlKHsgbm9kZSwgcGFyZW50IH0pIHtcbiAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhc3Q7XG59XG5mdW5jdGlvbiBwYXJzZUJhY2tyZWZlcmVuY2UoY29udGV4dCkge1xuICBjb25zdCB7IHJhdyB9ID0gY29udGV4dC50b2tlbjtcbiAgY29uc3QgaGFzS1dyYXBwZXIgPSAvXlxcXFxrWzwnXS8udGVzdChyYXcpO1xuICBjb25zdCByZWYgPSBoYXNLV3JhcHBlciA/IHJhdy5zbGljZSgzLCAtMSkgOiByYXcuc2xpY2UoMSk7XG4gIGNvbnN0IGZyb21OdW0gPSAobnVtLCBpc1JlbGF0aXZlID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBudW1DYXB0dXJlc1RvTGVmdCA9IGNvbnRleHQuY2FwdHVyaW5nR3JvdXBzLmxlbmd0aDtcbiAgICBsZXQgb3JwaGFuID0gZmFsc2U7XG4gICAgaWYgKG51bSA+IG51bUNhcHR1cmVzVG9MZWZ0KSB7XG4gICAgICBpZiAoY29udGV4dC5za2lwQmFja3JlZlZhbGlkYXRpb24pIHtcbiAgICAgICAgb3JwaGFuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGVub3VnaCBjYXB0dXJpbmcgZ3JvdXBzIGRlZmluZWQgdG8gdGhlIGxlZnQgXCIke3Jhd31cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0Lmhhc051bWJlcmVkUmVmID0gdHJ1ZTtcbiAgICByZXR1cm4gY3JlYXRlQmFja3JlZmVyZW5jZShpc1JlbGF0aXZlID8gbnVtQ2FwdHVyZXNUb0xlZnQgKyAxIC0gbnVtIDogbnVtLCB7IG9ycGhhbiB9KTtcbiAgfTtcbiAgaWYgKGhhc0tXcmFwcGVyKSB7XG4gICAgY29uc3QgbnVtYmVyZWRSZWYgPSAvXig/PHNpZ24+LT8pMCooPzxudW0+WzEtOV1cXGQqKSQvLmV4ZWMocmVmKTtcbiAgICBpZiAobnVtYmVyZWRSZWYpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtKCtudW1iZXJlZFJlZi5ncm91cHMubnVtLCAhIW51bWJlcmVkUmVmLmdyb3Vwcy5zaWduKTtcbiAgICB9XG4gICAgaWYgKC9bLStdLy50ZXN0KHJlZikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYWNrcmVmIG5hbWUgXCIke3Jhd31cImApO1xuICAgIH1cbiAgICBpZiAoIWNvbnRleHQubmFtZWRHcm91cHNCeU5hbWUuaGFzKHJlZikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR3JvdXAgbmFtZSBub3QgZGVmaW5lZCB0byB0aGUgbGVmdCBcIiR7cmF3fVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVCYWNrcmVmZXJlbmNlKHJlZik7XG4gIH1cbiAgcmV0dXJuIGZyb21OdW0oK3JlZik7XG59XG5mdW5jdGlvbiBwYXJzZUNoYXJhY3RlckNsYXNzSHlwaGVuKGNvbnRleHQsIHN0YXRlKSB7XG4gIGNvbnN0IHsgcGFyZW50LCB0b2tlbnMsIHdhbGsgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHByZXZTaWJsaW5nTm9kZSA9IHBhcmVudC5lbGVtZW50cy5hdCgtMSk7XG4gIGNvbnN0IG5leHRUb2tlbiA9IHRva2Vuc1tjb250ZXh0LmN1cnJlbnRdO1xuICBpZiAoIXN0YXRlLmlzQ2hlY2tpbmdSYW5nZUVuZCAmJiBwcmV2U2libGluZ05vZGUgJiYgcHJldlNpYmxpbmdOb2RlLnR5cGUgIT09IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzICYmIHByZXZTaWJsaW5nTm9kZS50eXBlICE9PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzc1JhbmdlICYmIG5leHRUb2tlbiAmJiBuZXh0VG9rZW4udHlwZSAhPT0gVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc09wZW4gJiYgbmV4dFRva2VuLnR5cGUgIT09IFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NDbG9zZSAmJiBuZXh0VG9rZW4udHlwZSAhPT0gVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc0ludGVyc2VjdG9yKSB7XG4gICAgY29uc3QgbmV4dE5vZGUgPSB3YWxrKHBhcmVudCwge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBpc0NoZWNraW5nUmFuZ2VFbmQ6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocHJldlNpYmxpbmdOb2RlLnR5cGUgPT09IEFzdFR5cGVzLkNoYXJhY3RlciAmJiBuZXh0Tm9kZS50eXBlID09PSBBc3RUeXBlcy5DaGFyYWN0ZXIpIHtcbiAgICAgIHBhcmVudC5lbGVtZW50cy5wb3AoKTtcbiAgICAgIHJldHVybiBjcmVhdGVDaGFyYWN0ZXJDbGFzc1JhbmdlKHByZXZTaWJsaW5nTm9kZSwgbmV4dE5vZGUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzcyByYW5nZVwiKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyKDQ1KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyQ2xhc3NPcGVuKGNvbnRleHQsIHN0YXRlKSB7XG4gIGNvbnN0IHsgdG9rZW4sIHRva2VucywgdmVyYm9zZSwgd2FsayB9ID0gY29udGV4dDtcbiAgY29uc3QgZmlyc3RDbGFzc1Rva2VuID0gdG9rZW5zW2NvbnRleHQuY3VycmVudF07XG4gIGxldCBub2RlID0gY3JlYXRlQ2hhcmFjdGVyQ2xhc3MoeyBuZWdhdGU6IHRva2VuLm5lZ2F0ZSB9KTtcbiAgY29uc3QgaW50ZXJzZWN0aW9uID0gbm9kZS5lbGVtZW50c1swXTtcbiAgbGV0IG5leHRUb2tlbiA9IHRocm93SWZVbmNsb3NlZENoYXJhY3RlckNsYXNzKGZpcnN0Q2xhc3NUb2tlbik7XG4gIHdoaWxlIChuZXh0VG9rZW4udHlwZSAhPT0gVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc0Nsb3NlKSB7XG4gICAgaWYgKG5leHRUb2tlbi50eXBlID09PSBUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0b3IpIHtcbiAgICAgIGludGVyc2VjdGlvbi5jbGFzc2VzLnB1c2goY3JlYXRlQ2hhcmFjdGVyQ2xhc3MoeyBuZWdhdGU6IGZhbHNlLCBiYXNlT25seTogdHJ1ZSB9KSk7XG4gICAgICBjb250ZXh0LmN1cnJlbnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2MgPSBpbnRlcnNlY3Rpb24uY2xhc3Nlcy5hdCgtMSk7XG4gICAgICBjYy5lbGVtZW50cy5wdXNoKHdhbGsoY2MsIHN0YXRlKSk7XG4gICAgfVxuICAgIG5leHRUb2tlbiA9IHRocm93SWZVbmNsb3NlZENoYXJhY3RlckNsYXNzKHRva2Vuc1tjb250ZXh0LmN1cnJlbnRdLCBmaXJzdENsYXNzVG9rZW4pO1xuICB9XG4gIGlmICghdmVyYm9zZSkge1xuICAgIG9wdGltaXplQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9uKTtcbiAgfVxuICBpZiAoaW50ZXJzZWN0aW9uLmNsYXNzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgY2MgPSBpbnRlcnNlY3Rpb24uY2xhc3Nlc1swXTtcbiAgICBjYy5uZWdhdGUgPSBub2RlLm5lZ2F0ZSAhPT0gY2MubmVnYXRlO1xuICAgIG5vZGUgPSBjYztcbiAgfVxuICBjb250ZXh0LmN1cnJlbnQrKztcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBwYXJzZUNoYXJhY3RlclNldCh7IHRva2VuLCBza2lwUHJvcGVydHlOYW1lVmFsaWRhdGlvbiB9KSB7XG4gIGxldCB7IGtpbmQsIG5lZ2F0ZSwgdmFsdWUgfSA9IHRva2VuO1xuICBpZiAoa2luZCA9PT0gVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5wcm9wZXJ0eSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBzbHVnKHZhbHVlKTtcbiAgICBpZiAoUG9zaXhQcm9wZXJ0aWVzLmhhcyhub3JtYWxpemVkKSkge1xuICAgICAga2luZCA9IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMucG9zaXg7XG4gICAgICB2YWx1ZSA9IG5vcm1hbGl6ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVVbmljb2RlUHJvcGVydHkodmFsdWUsIHtcbiAgICAgICAgbmVnYXRlLFxuICAgICAgICBza2lwUHJvcGVydHlOYW1lVmFsaWRhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChraW5kID09PSBUb2tlbkNoYXJhY3RlclNldEtpbmRzLnBvc2l4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IEFzdFR5cGVzLkNoYXJhY3RlclNldCxcbiAgICAgIGtpbmQ6IEFzdENoYXJhY3RlclNldEtpbmRzLnBvc2l4LFxuICAgICAgbmVnYXRlLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFyYWN0ZXJTZXQoa2luZCwgeyBuZWdhdGUgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUdyb3VwT3Blbihjb250ZXh0LCBzdGF0ZSkge1xuICBjb25zdCB7IHRva2VuLCB0b2tlbnMsIGNhcHR1cmluZ0dyb3VwcywgbmFtZWRHcm91cHNCeU5hbWUsIHNraXBMb29rYmVoaW5kVmFsaWRhdGlvbiwgdmVyYm9zZSwgd2FsayB9ID0gY29udGV4dDtcbiAgbGV0IG5vZGUgPSBjcmVhdGVCeUdyb3VwS2luZCh0b2tlbik7XG4gIGlmIChub2RlLnR5cGUgPT09IEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwKSB7XG4gICAgY2FwdHVyaW5nR3JvdXBzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUubmFtZSkge1xuICAgICAgZ2V0T3JDcmVhdGUobmFtZWRHcm91cHNCeU5hbWUsIG5vZGUubmFtZSwgW10pLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIGxldCBuZXh0VG9rZW4gPSB0aHJvd0lmVW5jbG9zZWRHcm91cCh0b2tlbnNbY29udGV4dC5jdXJyZW50XSk7XG4gIHdoaWxlIChuZXh0VG9rZW4udHlwZSAhPT0gVG9rZW5UeXBlcy5Hcm91cENsb3NlKSB7XG4gICAgaWYgKG5leHRUb2tlbi50eXBlID09PSBUb2tlblR5cGVzLkFsdGVybmF0b3IpIHtcbiAgICAgIG5vZGUuYWx0ZXJuYXRpdmVzLnB1c2goY3JlYXRlQWx0ZXJuYXRpdmUoKSk7XG4gICAgICBjb250ZXh0LmN1cnJlbnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWx0ID0gbm9kZS5hbHRlcm5hdGl2ZXMuYXQoLTEpO1xuICAgICAgY29uc3QgaXNMb29rYmVoaW5kID0gbm9kZS5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5sb29rYmVoaW5kO1xuICAgICAgY29uc3QgaXNOZWdMb29rYmVoaW5kID0gaXNMb29rYmVoaW5kICYmIG5vZGUubmVnYXRlO1xuICAgICAgY29uc3QgY2hpbGQgPSB3YWxrKGFsdCwge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaXNJbkxvb2tiZWhpbmQ6IHN0YXRlLmlzSW5Mb29rYmVoaW5kIHx8IGlzTG9va2JlaGluZCxcbiAgICAgICAgaXNJbk5lZ0xvb2tiZWhpbmQ6IHN0YXRlLmlzSW5OZWdMb29rYmVoaW5kIHx8IGlzTmVnTG9va2JlaGluZFxuICAgICAgfSk7XG4gICAgICBhbHQuZWxlbWVudHMucHVzaChjaGlsZCk7XG4gICAgICBpZiAoKGlzTG9va2JlaGluZCB8fCBzdGF0ZS5pc0luTG9va2JlaGluZCkgJiYgIXNraXBMb29rYmVoaW5kVmFsaWRhdGlvbikge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkxvb2tiZWhpbmQgaW5jbHVkZXMgYSBwYXR0ZXJuIG5vdCBhbGxvd2VkIGJ5IE9uaWd1cnVtYVwiO1xuICAgICAgICBpZiAoaXNOZWdMb29rYmVoaW5kIHx8IHN0YXRlLmlzSW5OZWdMb29rYmVoaW5kKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxvb2thaGVhZCB8fCBjaGlsZC50eXBlID09PSBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjaGlsZC5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5sb29rYWhlYWQgfHwgY2hpbGQua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubG9va2JlaGluZCAmJiBjaGlsZC5uZWdhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuZXh0VG9rZW4gPSB0aHJvd0lmVW5jbG9zZWRHcm91cCh0b2tlbnNbY29udGV4dC5jdXJyZW50XSk7XG4gIH1cbiAgaWYgKCF2ZXJib3NlKSB7XG4gICAgbm9kZSA9IGdldE9wdGltaXplZEdyb3VwKG5vZGUpO1xuICB9XG4gIGNvbnRleHQuY3VycmVudCsrO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHBhcnNlUXVhbnRpZmllcih7IHRva2VuLCBwYXJlbnQgfSkge1xuICBjb25zdCB7IG1pbiwgbWF4LCBncmVlZHksIHBvc3Nlc3NpdmU6IHBvc3Nlc3NpdmUyIH0gPSB0b2tlbjtcbiAgY29uc3QgcXVhbnRpZmllZE5vZGUgPSBwYXJlbnQuZWxlbWVudHMuYXQoLTEpO1xuICBpZiAoIXF1YW50aWZpZWROb2RlIHx8IHF1YW50aWZpZWROb2RlLnR5cGUgPT09IEFzdFR5cGVzLkFzc2VydGlvbiB8fCBxdWFudGlmaWVkTm9kZS50eXBlID09PSBBc3RUeXBlcy5EaXJlY3RpdmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFF1YW50aWZpZXIgcmVxdWlyZXMgYSByZXBlYXRhYmxlIHRva2VuYCk7XG4gIH1cbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZVF1YW50aWZpZXIocXVhbnRpZmllZE5vZGUsIG1pbiwgbWF4LCBncmVlZHksIHBvc3Nlc3NpdmUyKTtcbiAgcGFyZW50LmVsZW1lbnRzLnBvcCgpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3Vicm91dGluZShjb250ZXh0KSB7XG4gIGNvbnN0IHsgdG9rZW4sIGNhcHR1cmluZ0dyb3Vwcywgc3Vicm91dGluZXMgfSA9IGNvbnRleHQ7XG4gIGxldCByZWYgPSB0b2tlbi5yYXcuc2xpY2UoMywgLTEpO1xuICBjb25zdCBudW1iZXJlZFJlZiA9IC9eKD88c2lnbj5bLStdPykwKig/PG51bT5bMS05XVxcZCopJC8uZXhlYyhyZWYpO1xuICBpZiAobnVtYmVyZWRSZWYpIHtcbiAgICBjb25zdCBudW0gPSArbnVtYmVyZWRSZWYuZ3JvdXBzLm51bTtcbiAgICBjb25zdCBudW1DYXB0dXJlc1RvTGVmdCA9IGNhcHR1cmluZ0dyb3Vwcy5sZW5ndGg7XG4gICAgY29udGV4dC5oYXNOdW1iZXJlZFJlZiA9IHRydWU7XG4gICAgcmVmID0ge1xuICAgICAgXCJcIjogbnVtLFxuICAgICAgXCIrXCI6IG51bUNhcHR1cmVzVG9MZWZ0ICsgbnVtLFxuICAgICAgXCItXCI6IG51bUNhcHR1cmVzVG9MZWZ0ICsgMSAtIG51bVxuICAgIH1bbnVtYmVyZWRSZWYuZ3JvdXBzLnNpZ25dO1xuICAgIGlmIChyZWYgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN1YnJvdXRpbmUgbnVtYmVyXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWYgPT09IFwiMFwiKSB7XG4gICAgcmVmID0gMDtcbiAgfVxuICBjb25zdCBub2RlID0gY3JlYXRlU3Vicm91dGluZShyZWYpO1xuICBzdWJyb3V0aW5lcy5wdXNoKG5vZGUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFsdGVybmF0aXZlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkFsdGVybmF0aXZlLFxuICAgIGVsZW1lbnRzOiBbXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXNzZXJ0aW9uRnJvbVRva2VuKHsgdHlwZSwga2luZCwgbmVnYXRlIH0pIHtcbiAgaWYgKHR5cGUgPT09IFRva2VuVHlwZXMuR3JvdXBPcGVuKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvb2thcm91bmQoe1xuICAgICAgYmVoaW5kOiBraW5kID09PSBUb2tlbkdyb3VwS2luZHMubG9va2JlaGluZCxcbiAgICAgIG5lZ2F0ZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG5vZGVLaW5kID0gdGhyb3dJZk5vdCh7XG4gICAgXCJeXCI6IEFzdEFzc2VydGlvbktpbmRzLmxpbmVfc3RhcnQsXG4gICAgXCIkXCI6IEFzdEFzc2VydGlvbktpbmRzLmxpbmVfZW5kLFxuICAgIFwiXFxcXEFcIjogQXN0QXNzZXJ0aW9uS2luZHMuc3RyaW5nX3N0YXJ0LFxuICAgIFwiXFxcXGJcIjogQXN0QXNzZXJ0aW9uS2luZHMud29yZF9ib3VuZGFyeSxcbiAgICBcIlxcXFxCXCI6IEFzdEFzc2VydGlvbktpbmRzLndvcmRfYm91bmRhcnksXG4gICAgXCJcXFxcR1wiOiBBc3RBc3NlcnRpb25LaW5kcy5zZWFyY2hfc3RhcnQsXG4gICAgXCJcXFxcelwiOiBBc3RBc3NlcnRpb25LaW5kcy5zdHJpbmdfZW5kLFxuICAgIFwiXFxcXFpcIjogQXN0QXNzZXJ0aW9uS2luZHMuc3RyaW5nX2VuZF9uZXdsaW5lXG4gIH1ba2luZF0sIGBVbmV4cGVjdGVkIGFzc2VydGlvbiBraW5kIFwiJHtraW5kfVwiYCk7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogQXN0VHlwZXMuQXNzZXJ0aW9uLFxuICAgIGtpbmQ6IG5vZGVLaW5kXG4gIH07XG4gIGlmIChub2RlS2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMud29yZF9ib3VuZGFyeSkge1xuICAgIG5vZGUubmVnYXRlID0ga2luZCA9PT0gcmBcXEJgO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFja3JlZmVyZW5jZShyZWYsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3JwaGFuID0gISFvcHRpb25zPy5vcnBoYW47XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQmFja3JlZmVyZW5jZSxcbiAgICAuLi5vcnBoYW4gJiYgeyBvcnBoYW4gfSxcbiAgICByZWZcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJ5R3JvdXBLaW5kKHRva2VuKSB7XG4gIGNvbnN0IHsga2luZCwgbnVtYmVyLCBuYW1lLCBmbGFncyB9ID0gdG9rZW47XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgVG9rZW5Hcm91cEtpbmRzLmF0b21pYzpcbiAgICAgIHJldHVybiBjcmVhdGVHcm91cCh7IGF0b21pYzogdHJ1ZSB9KTtcbiAgICBjYXNlIFRva2VuR3JvdXBLaW5kcy5jYXB0dXJpbmc6XG4gICAgICByZXR1cm4gY3JlYXRlQ2FwdHVyaW5nR3JvdXAobnVtYmVyLCBuYW1lKTtcbiAgICBjYXNlIFRva2VuR3JvdXBLaW5kcy5ncm91cDpcbiAgICAgIHJldHVybiBjcmVhdGVHcm91cCh7IGZsYWdzIH0pO1xuICAgIGNhc2UgVG9rZW5Hcm91cEtpbmRzLmxvb2thaGVhZDpcbiAgICBjYXNlIFRva2VuR3JvdXBLaW5kcy5sb29rYmVoaW5kOlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzc2VydGlvbkZyb21Ub2tlbih0b2tlbik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBncm91cCBraW5kIFwiJHtraW5kfVwiYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmluZ0dyb3VwKG51bWJlciwgbmFtZSkge1xuICBjb25zdCBoYXNOYW1lID0gbmFtZSAhPT0gdm9pZCAwO1xuICBpZiAoaGFzTmFtZSAmJiAhaXNWYWxpZEdyb3VwTmFtZU9uaWd1cnVtYShuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgR3JvdXAgbmFtZSBcIiR7bmFtZX1cIiBpbnZhbGlkIGluIE9uaWd1cnVtYWApO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQ2FwdHVyaW5nR3JvdXAsXG4gICAgbnVtYmVyLFxuICAgIC4uLmhhc05hbWUgJiYgeyBuYW1lIH0sXG4gICAgYWx0ZXJuYXRpdmVzOiBbY3JlYXRlQWx0ZXJuYXRpdmUoKV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoYXJhY3RlcihjaGFyQ29kZSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIHVzZUxhc3RWYWxpZDogZmFsc2UsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBpZiAoY2hhckNvZGUgPiAxMTE0MTExKSB7XG4gICAgY29uc3QgaGV4ID0gY2hhckNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGlmIChvcHRzLnVzZUxhc3RWYWxpZCkge1xuICAgICAgY2hhckNvZGUgPSAxMTE0MTExO1xuICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPiAxMzEwNzE5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29kZSBwb2ludCBvdXQgb2YgcmFuZ2UgXCJcXFxceHske2hleH19XCJgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvZGUgcG9pbnQgb3V0IG9mIHJhbmdlIGluIEpTIFwiXFxcXHh7JHtoZXh9fVwiYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQ2hhcmFjdGVyLFxuICAgIHZhbHVlOiBjaGFyQ29kZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hhcmFjdGVyQ2xhc3Mob3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIGJhc2VPbmx5OiBmYWxzZSxcbiAgICBuZWdhdGU6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzcyxcbiAgICBuZWdhdGU6IG9wdHMubmVnYXRlLFxuICAgIGVsZW1lbnRzOiBvcHRzLmJhc2VPbmx5ID8gW10gOiBbY3JlYXRlQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rpb24oKV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uLFxuICAgIGNsYXNzZXM6IFtjcmVhdGVDaGFyYWN0ZXJDbGFzcyh7IG5lZ2F0ZTogZmFsc2UsIGJhc2VPbmx5OiB0cnVlIH0pXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hhcmFjdGVyQ2xhc3NSYW5nZShtaW4sIG1heCkge1xuICBpZiAobWF4LnZhbHVlIDwgbWluLnZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhcmFjdGVyIGNsYXNzIHJhbmdlIG91dCBvZiBvcmRlclwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzUmFuZ2UsXG4gICAgbWluLFxuICAgIG1heFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hhcmFjdGVyU2V0KGtpbmQsIHsgbmVnYXRlIH0pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBBc3RUeXBlcy5DaGFyYWN0ZXJTZXQsXG4gICAga2luZDogdGhyb3dJZk5vdChBc3RDaGFyYWN0ZXJTZXRLaW5kc1traW5kXSwgYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIHNldCBraW5kIFwiJHtraW5kfVwiYClcbiAgfTtcbiAgaWYgKGtpbmQgPT09IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMuZGlnaXQgfHwga2luZCA9PT0gVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5oZXggfHwga2luZCA9PT0gVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5zcGFjZSB8fCBraW5kID09PSBUb2tlbkNoYXJhY3RlclNldEtpbmRzLndvcmQpIHtcbiAgICBub2RlLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURpcmVjdGl2ZUZyb21Ub2tlbih7IGtpbmQsIGZsYWdzIH0pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBBc3RUeXBlcy5EaXJlY3RpdmUsXG4gICAga2luZDogdGhyb3dJZk5vdChBc3REaXJlY3RpdmVLaW5kc1traW5kXSwgYFVuZXhwZWN0ZWQgZGlyZWN0aXZlIGtpbmQgXCIke2tpbmR9XCJgKVxuICB9O1xuICBpZiAoa2luZCA9PT0gVG9rZW5EaXJlY3RpdmVLaW5kcy5mbGFncykge1xuICAgIG5vZGUuZmxhZ3MgPSBmbGFncztcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZsYWdzKHsgaWdub3JlQ2FzZSwgZG90QWxsLCBleHRlbmRlZCwgZGlnaXRJc0FzY2lpLCBzcGFjZUlzQXNjaWksIHdvcmRJc0FzY2lpIH0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5GbGFncyxcbiAgICBpZ25vcmVDYXNlLFxuICAgIGRvdEFsbCxcbiAgICBleHRlbmRlZCxcbiAgICBkaWdpdElzQXNjaWksXG4gICAgc3BhY2VJc0FzY2lpLFxuICAgIHdvcmRJc0FzY2lpXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVHcm91cChvcHRpb25zKSB7XG4gIGNvbnN0IGF0b21pYzIgPSBvcHRpb25zPy5hdG9taWM7XG4gIGNvbnN0IGZsYWdzID0gb3B0aW9ucz8uZmxhZ3M7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuR3JvdXAsXG4gICAgLi4uYXRvbWljMiAmJiB7IGF0b21pYzogYXRvbWljMiB9LFxuICAgIC4uLmZsYWdzICYmIHsgZmxhZ3MgfSxcbiAgICBhbHRlcm5hdGl2ZXM6IFtjcmVhdGVBbHRlcm5hdGl2ZSgpXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTG9va2Fyb3VuZChvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgYmVoaW5kOiBmYWxzZSxcbiAgICBuZWdhdGU6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5Bc3NlcnRpb24sXG4gICAga2luZDogb3B0cy5iZWhpbmQgPyBBc3RBc3NlcnRpb25LaW5kcy5sb29rYmVoaW5kIDogQXN0QXNzZXJ0aW9uS2luZHMubG9va2FoZWFkLFxuICAgIG5lZ2F0ZTogb3B0cy5uZWdhdGUsXG4gICAgYWx0ZXJuYXRpdmVzOiBbY3JlYXRlQWx0ZXJuYXRpdmUoKV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm4oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuUGF0dGVybixcbiAgICBhbHRlcm5hdGl2ZXM6IFtjcmVhdGVBbHRlcm5hdGl2ZSgpXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUXVhbnRpZmllcihlbGVtZW50LCBtaW4sIG1heCwgZ3JlZWR5LCBwb3NzZXNzaXZlMikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IEFzdFR5cGVzLlF1YW50aWZpZXIsXG4gICAgbWluLFxuICAgIG1heCxcbiAgICBncmVlZHksXG4gICAgcG9zc2Vzc2l2ZTogcG9zc2Vzc2l2ZTIsXG4gICAgZWxlbWVudFxuICB9O1xuICBpZiAobWF4IDwgbWluKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm5vZGUsXG4gICAgICBtaW46IG1heCxcbiAgICAgIG1heDogbWluLFxuICAgICAgcG9zc2Vzc2l2ZTogdHJ1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWdleChwYXR0ZXJuLCBmbGFncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLlJlZ2V4LFxuICAgIHBhdHRlcm4sXG4gICAgZmxhZ3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN1YnJvdXRpbmUocmVmKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuU3Vicm91dGluZSxcbiAgICByZWZcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVVuaWNvZGVQcm9wZXJ0eSh2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG5lZ2F0ZTogZmFsc2UsXG4gICAgc2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb246IGZhbHNlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5DaGFyYWN0ZXJTZXQsXG4gICAga2luZDogQXN0Q2hhcmFjdGVyU2V0S2luZHMucHJvcGVydHksXG4gICAgdmFsdWU6IG9wdHMuc2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb24gPyB2YWx1ZSA6IGdldEpzVW5pY29kZVByb3BlcnR5TmFtZSh2YWx1ZSksXG4gICAgbmVnYXRlOiBvcHRzLm5lZ2F0ZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXQoa2luZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLlZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0LFxuICAgIGtpbmQ6IHRocm93SWZOb3Qoe1xuICAgICAgXCJcXFxcUlwiOiBBc3RWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldEtpbmRzLm5ld2xpbmUsXG4gICAgICBcIlxcXFxYXCI6IEFzdFZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0S2luZHMuZ3JhcGhlbWVcbiAgICB9W2tpbmRdLCBgVW5leHBlY3RlZCB2YXJjaGFyc2V0IGtpbmQgXCIke2tpbmR9XCJgKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SnNVbmljb2RlUHJvcGVydHlOYW1lKHZhbHVlKSB7XG4gIGNvbnN0IHNsdWdnZWQgPSBzbHVnKHZhbHVlKTtcbiAgaWYgKEpzVW5pY29kZVByb3BlcnRpZXNPZlN0cmluZ3NNYXAuaGFzKHNsdWdnZWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHJgVW5pY29kZSBwcm9wZXJ0eSBcIlxccHske3ZhbHVlfX1cIiB1bnN1cHBvcnRlZCBpbiBPbmlndXJ1bWFgKTtcbiAgfVxuICBjb25zdCBqc05hbWUgPSBKc1VuaWNvZGVQcm9wZXJ0aWVzTWFwLmdldChzbHVnZ2VkKTtcbiAgaWYgKGpzTmFtZSkge1xuICAgIHJldHVybiBqc05hbWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnRyaW0oKS5yZXBsYWNlKC9bLSBfXSsvZywgXCJfXCIpLnJlcGxhY2UoL1tBLVpdW2Etel0rKD89W0EtWl0pL2csIFwiJCZfXCIpLnJlcGxhY2UoL1tBLVphLXpdKy9nLCAobSkgPT4gbVswXS50b1VwcGVyQ2FzZSgpICsgbS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGdldE9wdGltaXplZEdyb3VwKG5vZGUpIHtcbiAgY29uc3QgZmlyc3RBbHRGaXJzdEVsID0gbm9kZS5hbHRlcm5hdGl2ZXNbMF0uZWxlbWVudHNbMF07XG4gIGlmIChub2RlLnR5cGUgPT09IEFzdFR5cGVzLkdyb3VwICYmIGhhc09ubHlDaGlsZChub2RlLCAoa2lkKSA9PiBraWQudHlwZSA9PT0gQXN0VHlwZXMuR3JvdXApICYmICEobm9kZS5hdG9taWMgJiYgZmlyc3RBbHRGaXJzdEVsLmZsYWdzKSAmJiAhKG5vZGUuZmxhZ3MgJiYgKGZpcnN0QWx0Rmlyc3RFbC5hdG9taWMgfHwgZmlyc3RBbHRGaXJzdEVsLmZsYWdzKSkpIHtcbiAgICBpZiAobm9kZS5hdG9taWMpIHtcbiAgICAgIGZpcnN0QWx0Rmlyc3RFbC5hdG9taWMgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5mbGFncykge1xuICAgICAgZmlyc3RBbHRGaXJzdEVsLmZsYWdzID0gbm9kZS5mbGFncztcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0QWx0Rmlyc3RFbDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRHcm91cE5hbWVPbmlndXJ1bWEobmFtZSkge1xuICByZXR1cm4gIS9eKD86Wy1cXGRdfCQpLy50ZXN0KG5hbWUpO1xufVxuZnVuY3Rpb24gb3B0aW1pemVDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbihpbnRlcnNlY3Rpb24pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnRlcnNlY3Rpb24uY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNjID0gaW50ZXJzZWN0aW9uLmNsYXNzZXNbaV07XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGNjLmVsZW1lbnRzWzBdO1xuICAgIGlmIChjYy5lbGVtZW50cy5sZW5ndGggPT09IDEgJiYgZmlyc3RDaGlsZC50eXBlID09PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzcykge1xuICAgICAgaW50ZXJzZWN0aW9uLmNsYXNzZXNbaV0gPSBmaXJzdENoaWxkO1xuICAgICAgZmlyc3RDaGlsZC5uZWdhdGUgPSBjYy5uZWdhdGUgIT09IGZpcnN0Q2hpbGQubmVnYXRlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGhyb3dJZlVuY2xvc2VkQ2hhcmFjdGVyQ2xhc3ModG9rZW4sIGZpcnN0Q2xhc3NUb2tlbikge1xuICByZXR1cm4gdGhyb3dJZk5vdChcbiAgICB0b2tlbixcbiAgICAvLyBFYXNpZXIgdG8gdW5kZXJzdGFuZCBlcnJvciB3aGVuIGFwcGxpY2FibGVcbiAgICBgJHtmaXJzdENsYXNzVG9rZW4/LnZhbHVlID09PSA5MyA/IFwiRW1wdHlcIiA6IFwiVW5jbG9zZWRcIn0gY2hhcmFjdGVyIGNsYXNzYFxuICApO1xufVxuZnVuY3Rpb24gdGhyb3dJZlVuY2xvc2VkR3JvdXAodG9rZW4pIHtcbiAgcmV0dXJuIHRocm93SWZOb3QodG9rZW4sIFwiVW5jbG9zZWQgZ3JvdXBcIik7XG59XG5cbi8vIHNyYy9zdWJjbGFzcy5qc1xuaW1wb3J0IHsgUmVnRXhwU3ViY2xhc3MgfSBmcm9tIFwicmVnZXgvaW50ZXJuYWxzXCI7XG52YXIgRW11bGF0ZWRSZWdFeHAgPSBjbGFzcyBfRW11bGF0ZWRSZWdFeHAgZXh0ZW5kcyBSZWdFeHBTdWJjbGFzcyB7XG4gIC8qKlxuICBAcHJpdmF0ZVxuICBAdHlwZSB7c3RyaW5nIHwgbnVsbH1cbiAgKi9cbiAgI3N0cmF0ZWd5O1xuICAvKipcbiAgQ2FuIGJlIHVzZWQgdG8gc2VyaWFsaXplIHRoZSBhcmd1bWVudHMgdXNlZCB0byBjcmVhdGUgdGhlIGluc3RhbmNlLlxuICBAdHlwZSB7e1xuICAgIHBhdHRlcm46IHN0cmluZztcbiAgICBmbGFnczogc3RyaW5nO1xuICAgIG9wdGlvbnM6IEVtdWxhdGVkUmVnRXhwT3B0aW9ucztcbiAgfX1cbiAgKi9cbiAgcmF3QXJncztcbiAgLyoqXG4gIEBvdmVybG9hZFxuICBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICBAcGFyYW0ge0VtdWxhdGVkUmVnRXhwT3B0aW9uc30gW29wdGlvbnNdXG4gICovXG4gIC8qKlxuICBAb3ZlcmxvYWRcbiAgQHBhcmFtIHtFbXVsYXRlZFJlZ0V4cH0gcGF0dGVyblxuICBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAqL1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBmbGFncywgb3B0aW9ucykge1xuICAgIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcHJvdmlkZSBvcHRpb25zIHdoZW4gY29weWluZyBhIHJlZ2V4cFwiKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgX0VtdWxhdGVkUmVnRXhwKSB7XG4gICAgICAgIHRoaXMuI3N0cmF0ZWd5ID0gcGF0dGVybi4jc3RyYXRlZ3k7XG4gICAgICAgIHRoaXMucmF3QXJncyA9IHBhdHRlcm4ucmF3QXJncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI3N0cmF0ZWd5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yYXdBcmdzID0ge1xuICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4uc291cmNlLFxuICAgICAgICAgIGZsYWdzOiBwYXR0ZXJuLmZsYWdzLFxuICAgICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLnJhd0FyZ3MuZmxhZ3MgPSBmbGFncztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgc3RyYXRlZ3k6IG51bGwsXG4gICAgICAgIHVzZUVtdWxhdGlvbkdyb3VwczogZmFsc2UsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBzdXBlcihwYXR0ZXJuLCBmbGFncywgeyB1c2VFbXVsYXRpb25Hcm91cHM6IG9wdHMudXNlRW11bGF0aW9uR3JvdXBzIH0pO1xuICAgICAgdGhpcy4jc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5O1xuICAgICAgdGhpcy5yYXdBcmdzID0ge1xuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBmbGFnczogZmxhZ3MgPz8gXCJcIixcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIC4uLm9wdHMuc3RyYXRlZ3kgPyB7IHN0cmF0ZWd5OiBvcHRzLnN0cmF0ZWd5IH0gOiBudWxsLFxuICAgICAgICAgIC4uLm9wdHMudXNlRW11bGF0aW9uR3JvdXBzID8geyB1c2VFbXVsYXRpb25Hcm91cHM6IHRydWUgfSA6IG51bGxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gIENhbGxlZCBpbnRlcm5hbGx5IGJ5IGFsbCBTdHJpbmcvUmVnRXhwIG1ldGhvZHMgdGhhdCB1c2UgcmVnZXhlcy5cbiAgQG92ZXJyaWRlXG4gIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheSB8IG51bGx9XG4gICovXG4gIGV4ZWMoc3RyKSB7XG4gICAgY29uc3QgZXhlYyA9IHN1cGVyLmV4ZWM7XG4gICAgY29uc3QgdXNlTGFzdEluZGV4ID0gdGhpcy5nbG9iYWwgfHwgdGhpcy5zdGlja3k7XG4gICAgY29uc3QgcG9zID0gdGhpcy5sYXN0SW5kZXg7XG4gICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLiNzdHJhdGVneTtcbiAgICBpZiAoc3RyYXRlZ3kgPT09IFwibGluZV9vcl9zZWFyY2hfc3RhcnRcIiAmJiB1c2VMYXN0SW5kZXggJiYgdGhpcy5sYXN0SW5kZXgpIHtcbiAgICAgIHRoaXMubGFzdEluZGV4ID0gMDtcbiAgICAgIGNvbnN0IG1hdGNoID0gZXhlYy5jYWxsKHRoaXMsIHN0ci5zbGljZShwb3MpKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBhZGp1c3RNYXRjaERldGFpbHMoc3RyLCB0aGlzLCBtYXRjaCwgcG9zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgaWYgKHN0cmF0ZWd5ID09PSBcIm5vdF9zZWFyY2hfc3RhcnRcIikge1xuICAgICAgbGV0IG1hdGNoID0gZXhlYy5jYWxsKHRoaXMsIHN0cik7XG4gICAgICBpZiAobWF0Y2g/LmluZGV4ID09PSBwb3MpIHtcbiAgICAgICAgY29uc3QgZ2xvYmFsUmUgPSB1c2VMYXN0SW5kZXggPyB0aGlzIDogbmV3IFJlZ0V4cCh0aGlzLnNvdXJjZSwgYGcke3RoaXMuZmxhZ3N9YCk7XG4gICAgICAgIGdsb2JhbFJlLmxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgMTtcbiAgICAgICAgbWF0Y2ggPSBleGVjLmNhbGwoZ2xvYmFsUmUsIHN0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBleGVjLmNhbGwodGhpcywgc3RyKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGFkanVzdE1hdGNoRGV0YWlscyhzdHIsIHJlLCBtYXRjaCwgb2Zmc2V0KSB7XG4gIG1hdGNoLmlucHV0ID0gc3RyO1xuICBtYXRjaC5pbmRleCArPSBvZmZzZXQ7XG4gIHJlLmxhc3RJbmRleCArPSBvZmZzZXQ7XG4gIGlmIChyZS5oYXNJbmRpY2VzKSB7XG4gICAgY29uc3QgbWF0Y2hJbmRpY2VzID0gbWF0Y2guaW5kaWNlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJyID0gbWF0Y2hJbmRpY2VzW2ldO1xuICAgICAgbWF0Y2hJbmRpY2VzW2ldID0gW2FyclswXSArIG9mZnNldCwgYXJyWzFdICsgb2Zmc2V0XTtcbiAgICB9XG4gICAgY29uc3QgZ3JvdXBJbmRpY2VzID0gbWF0Y2hJbmRpY2VzLmdyb3VwcztcbiAgICBpZiAoZ3JvdXBJbmRpY2VzKSB7XG4gICAgICBPYmplY3Qua2V5cyhncm91cEluZGljZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBhcnIgPSBncm91cEluZGljZXNba2V5XTtcbiAgICAgICAgZ3JvdXBJbmRpY2VzW2tleV0gPSBbYXJyWzBdICsgb2Zmc2V0LCBhcnJbMV0gKyBvZmZzZXRdO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBseVN1YmNsYXNzU3RyYXRlZ2llcyhhc3QpIHtcbiAgY29uc3QgYWx0cyA9IGFzdC5wYXR0ZXJuLmFsdGVybmF0aXZlcztcbiAgY29uc3QgZmlyc3RFbCA9IGFsdHNbMF0uZWxlbWVudHNbMF07XG4gIGlmIChhbHRzLmxlbmd0aCA+IDEgfHwgIWZpcnN0RWwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBoYXNXcmFwcGVyR3JvdXAgPSBoYXNPbmx5Q2hpbGQoYXN0LnBhdHRlcm4sIChraWQpID0+IGtpZC50eXBlID09PSBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cCB8fCBraWQudHlwZSA9PT0gQXN0VHlwZXMuR3JvdXApICYmIGZpcnN0RWwuYWx0ZXJuYXRpdmVzLmxlbmd0aCA9PT0gMTtcbiAgY29uc3Qgc2luZ2xlQWx0SW4gPSBoYXNXcmFwcGVyR3JvdXAgPyBmaXJzdEVsLmFsdGVybmF0aXZlc1swXSA6IGFsdHNbMF07XG4gIGNvbnN0IGZpcnN0RWxJbiA9IGhhc1dyYXBwZXJHcm91cCA/IHNpbmdsZUFsdEluLmVsZW1lbnRzWzBdIDogZmlyc3RFbDtcbiAgaWYgKCFmaXJzdEVsSW4pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoKGZpcnN0RWxJbi50eXBlID09PSBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cCB8fCBmaXJzdEVsSW4udHlwZSA9PT0gQXN0VHlwZXMuR3JvdXApICYmIGZpcnN0RWxJbi5hbHRlcm5hdGl2ZXMubGVuZ3RoID09PSAyICYmIGZpcnN0RWxJbi5hbHRlcm5hdGl2ZXNbMF0uZWxlbWVudHMubGVuZ3RoID09PSAxICYmIGZpcnN0RWxJbi5hbHRlcm5hdGl2ZXNbMV0uZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgZWwxID0gZmlyc3RFbEluLmFsdGVybmF0aXZlc1swXS5lbGVtZW50c1swXTtcbiAgICBjb25zdCBlbDIgPSBmaXJzdEVsSW4uYWx0ZXJuYXRpdmVzWzFdLmVsZW1lbnRzWzBdO1xuICAgIGlmIChlbDEua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubGluZV9zdGFydCAmJiBlbDIua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMuc2VhcmNoX3N0YXJ0IHx8IGVsMS5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5zZWFyY2hfc3RhcnQgJiYgZWwyLmtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxpbmVfc3RhcnQpIHtcbiAgICAgIGlmIChlbDEua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubGluZV9zdGFydCkge1xuICAgICAgICBmaXJzdEVsSW4uYWx0ZXJuYXRpdmVzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RFbEluLmFsdGVybmF0aXZlcy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwibGluZV9vcl9zZWFyY2hfc3RhcnRcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTG9uZUdMb29rYXJvdW5kKGZpcnN0RWxJbiwgeyBuZWdhdGU6IHRydWUgfSkpIHtcbiAgICBmaXJzdEVsSW4ucGFyZW50LmVsZW1lbnRzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIFwibm90X3NlYXJjaF9zdGFydFwiO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2luZ2xlQWx0SW4uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlbCA9IHNpbmdsZUFsdEluLmVsZW1lbnRzW2ldO1xuICAgIGlmICghaXNaZXJvTGVuZ3RoTm9kZShlbCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaXNMb25lR0xvb2thcm91bmQoZWwsIHsgbmVnYXRlOiB0cnVlIH0pKSB7XG4gICAgICBzaW5nbGVBbHRJbi5lbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gXCJub3Rfc2VhcmNoX3N0YXJ0XCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNMb25lR0xvb2thcm91bmQobm9kZSwgb3B0aW9ucykge1xuICByZXR1cm4gaXNMb29rYXJvdW5kKG5vZGUpICYmIG5vZGUubmVnYXRlID09PSBvcHRpb25zLm5lZ2F0ZSAmJiBoYXNPbmx5Q2hpbGQobm9kZSwgKGtpZCkgPT4ga2lkLmtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLnNlYXJjaF9zdGFydCk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm0uanNcbmltcG9ydCBlbW9qaVJlZ2V4IGZyb20gXCJlbW9qaS1yZWdleC14c1wiO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGFzdCwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIC8vIEEgY291cGxlIGVkZ2UgY2FzZXMgZXhpc3Qgd2hlcmUgb3B0aW9ucyBgYWNjdXJhY3lgIGFuZCBgYmVzdEVmZm9ydFRhcmdldGAgYXJlIHVzZWQ6XG4gICAgLy8gLSBgVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXRgIGtpbmQgYGdyYXBoZW1lYCAoYFxcWGApOiBBbiBleGFjdCByZXByZXNlbnRhdGlvbiB3b3VsZCByZXF1aXJlXG4gICAgLy8gICBoZWF2eSBVbmljb2RlIGRhdGE7IGEgYmVzdC1lZmZvcnQgYXBwcm94aW1hdGlvbiByZXF1aXJlcyBrbm93aW5nIHRoZSB0YXJnZXQuXG4gICAgLy8gLSBgQ2hhcmFjdGVyU2V0YCBraW5kIGBwb3NpeGAgd2l0aCB2YWx1ZXMgYGdyYXBoYCBhbmQgYHByaW50YDogVGhlaXIgY29tcGxleCBVbmljb2RlLWJhc2VkXG4gICAgLy8gICByZXByZXNlbnRhdGlvbnMgd291bGQgYmUgaGFyZCB0byBjaGFuZ2UgdG8gQVNDSUktYmFzZWQgYWZ0ZXIgdGhlIGZhY3QgaW4gdGhlIGdlbmVyYXRvclxuICAgIC8vICAgYmFzZWQgb24gYHRhcmdldGAvYGFjY3VyYWN5YCwgc28gcHJvZHVjZSB0aGUgYXBwcm9wcmlhdGUgc3RydWN0dXJlIGhlcmUuXG4gICAgYWNjdXJhY3k6IFwiZGVmYXVsdFwiLFxuICAgIGFzY2lpV29yZEJvdW5kYXJpZXM6IGZhbHNlLFxuICAgIGF2b2lkU3ViY2xhc3M6IGZhbHNlLFxuICAgIGJlc3RFZmZvcnRUYXJnZXQ6IFwiRVMyMDI1XCIsXG4gICAgaWdub3JlVW5zdXBwb3J0ZWRHQW5jaG9yczogZmFsc2UsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBzdHJhdGVneSA9IG9wdHMuYXZvaWRTdWJjbGFzcyA/IG51bGwgOiBhcHBseVN1YmNsYXNzU3RyYXRlZ2llcyhhc3QpO1xuICBjb25zdCBmaXJzdFBhc3NTdGF0ZSA9IHtcbiAgICBhY2N1cmFjeTogb3B0cy5hY2N1cmFjeSxcbiAgICBhc2NpaVdvcmRCb3VuZGFyaWVzOiBvcHRzLmFzY2lpV29yZEJvdW5kYXJpZXMsXG4gICAgZmxhZ0RpcmVjdGl2ZXNCeUFsdDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBpZ25vcmVVbnN1cHBvcnRlZEdBbmNob3JzOiBvcHRzLmlnbm9yZVVuc3VwcG9ydGVkR0FuY2hvcnMsXG4gICAgbWluVGFyZ2V0RXMyMDI0OiBpc01pblRhcmdldChvcHRzLmJlc3RFZmZvcnRUYXJnZXQsIFwiRVMyMDI0XCIpLFxuICAgIC8vIFN1YnJvdXRpbmVzIGNhbiBhcHBlYXIgYmVmb3JlIHRoZSBncm91cHMgdGhleSByZWYsIHNvIGNvbGxlY3QgcmVmZmVkIG5vZGVzIGZvciBhIHNlY29uZCBwYXNzIFxuICAgIHN1YnJvdXRpbmVSZWZNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgc3VwcG9ydGVkR05vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIGRpZ2l0SXNBc2NpaTogYXN0LmZsYWdzLmRpZ2l0SXNBc2NpaSxcbiAgICBzcGFjZUlzQXNjaWk6IGFzdC5mbGFncy5zcGFjZUlzQXNjaWksXG4gICAgd29yZElzQXNjaWk6IGFzdC5mbGFncy53b3JkSXNBc2NpaVxuICB9O1xuICB0cmF2ZXJzZSh7IG5vZGU6IGFzdCB9LCBmaXJzdFBhc3NTdGF0ZSwgRmlyc3RQYXNzVmlzaXRvcik7XG4gIGNvbnN0IGdsb2JhbEZsYWdzID0ge1xuICAgIGRvdEFsbDogYXN0LmZsYWdzLmRvdEFsbCxcbiAgICBpZ25vcmVDYXNlOiBhc3QuZmxhZ3MuaWdub3JlQ2FzZVxuICB9O1xuICBjb25zdCBzZWNvbmRQYXNzU3RhdGUgPSB7XG4gICAgY3VycmVudEZsYWdzOiBnbG9iYWxGbGFncyxcbiAgICBwcmV2RmxhZ3M6IG51bGwsXG4gICAgZ2xvYmFsRmxhZ3MsXG4gICAgZ3JvdXBPcmlnaW5CeUNvcHk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgZ3JvdXBzQnlOYW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWY6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgb3BlblJlZnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXI6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgc3Vicm91dGluZVJlZk1hcDogZmlyc3RQYXNzU3RhdGUuc3Vicm91dGluZVJlZk1hcFxuICB9O1xuICB0cmF2ZXJzZSh7IG5vZGU6IGFzdCB9LCBzZWNvbmRQYXNzU3RhdGUsIFNlY29uZFBhc3NWaXNpdG9yKTtcbiAgY29uc3QgdGhpcmRQYXNzU3RhdGUgPSB7XG4gICAgZ3JvdXBzQnlOYW1lOiBzZWNvbmRQYXNzU3RhdGUuZ3JvdXBzQnlOYW1lLFxuICAgIGhpZ2hlc3RPcnBoYW5CYWNrcmVmOiAwLFxuICAgIG51bUNhcHR1cmVzVG9MZWZ0OiAwLFxuICAgIHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyOiBzZWNvbmRQYXNzU3RhdGUucmVmZmVkTm9kZXNCeVJlZmVyZW5jZXJcbiAgfTtcbiAgdHJhdmVyc2UoeyBub2RlOiBhc3QgfSwgdGhpcmRQYXNzU3RhdGUsIFRoaXJkUGFzc1Zpc2l0b3IpO1xuICBpZiAoc3RyYXRlZ3kpIHtcbiAgICBhc3QuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIH1cbiAgcmV0dXJuIGFzdDtcbn1cbnZhciBGaXJzdFBhc3NWaXNpdG9yID0ge1xuICBBbHRlcm5hdGl2ZToge1xuICAgIGVudGVyKHsgbm9kZSwgcGFyZW50LCBrZXkgfSwgeyBmbGFnRGlyZWN0aXZlc0J5QWx0IH0pIHtcbiAgICAgIGNvbnN0IGZsYWdEaXJlY3RpdmVzID0gbm9kZS5lbGVtZW50cy5maWx0ZXIoKGVsKSA9PiBlbC5raW5kID09PSBBc3REaXJlY3RpdmVLaW5kcy5mbGFncyk7XG4gICAgICBmb3IgKGxldCBpID0ga2V5ICsgMTsgaSA8IHBhcmVudC5hbHRlcm5hdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZm9yd2FyZFNpYmxpbmdBbHQgPSBwYXJlbnQuYWx0ZXJuYXRpdmVzW2ldO1xuICAgICAgICBnZXRPckNyZWF0ZShmbGFnRGlyZWN0aXZlc0J5QWx0LCBmb3J3YXJkU2libGluZ0FsdCwgW10pLnB1c2goLi4uZmxhZ0RpcmVjdGl2ZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdCh7IG5vZGUgfSwgeyBmbGFnRGlyZWN0aXZlc0J5QWx0IH0pIHtcbiAgICAgIGlmIChmbGFnRGlyZWN0aXZlc0J5QWx0LmdldChub2RlKT8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gZ2V0Q29tYmluZWRGbGFnTW9kc0Zyb21GbGFnTm9kZXMoZmxhZ0RpcmVjdGl2ZXNCeUFsdC5nZXQobm9kZSkpO1xuICAgICAgICBpZiAoZmxhZ3MpIHtcbiAgICAgICAgICBjb25zdCBmbGFnR3JvdXAgPSBwcmVwQ29udGFpbmVyKGNyZWF0ZUdyb3VwKHsgZmxhZ3MgfSksIG5vZGUuZWxlbWVudHMpO1xuICAgICAgICAgIGZsYWdHcm91cC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSBbZmxhZ0dyb3VwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgQXNzZXJ0aW9uKHsgbm9kZSwgYXN0LCByZW1vdmUsIHJlcGxhY2VXaXRoIH0sIHsgYXNjaWlXb3JkQm91bmRhcmllcywgaWdub3JlVW5zdXBwb3J0ZWRHQW5jaG9ycywgc3VwcG9ydGVkR05vZGVzLCB3b3JkSXNBc2NpaSB9KSB7XG4gICAgY29uc3QgeyBraW5kLCBuZWdhdGUgfSA9IG5vZGU7XG4gICAgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxpbmVfZW5kKSB7XG4gICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KHJgKD89XFx6fFxcbilgKSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5saW5lX3N0YXJ0KSB7XG4gICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KHJgKD88PVxcQXxcXG4oPyFcXHopKWAsIHsgc2tpcExvb2tiZWhpbmRWYWxpZGF0aW9uOiB0cnVlIH0pKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLnNlYXJjaF9zdGFydCkge1xuICAgICAgaWYgKHN1cHBvcnRlZEdOb2Rlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgYXN0LmZsYWdzLnN0aWNreSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFpZ25vcmVVbnN1cHBvcnRlZEdBbmNob3JzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyYFVzZXMgXCJcXEdcIiBpbiBhIHdheSB0aGF0J3MgdW5zdXBwb3J0ZWRgKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMuc3RyaW5nX2VuZF9uZXdsaW5lKSB7XG4gICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KHJgKD89XFxuP1xceilgKSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy53b3JkX2JvdW5kYXJ5ICYmICF3b3JkSXNBc2NpaSAmJiAhYXNjaWlXb3JkQm91bmRhcmllcykge1xuICAgICAgY29uc3QgYiA9IGAoPzooPzw9JHtkZWZhdWx0V29yZENoYXJ9KSg/ISR7ZGVmYXVsdFdvcmRDaGFyfSl8KD88ISR7ZGVmYXVsdFdvcmRDaGFyfSkoPz0ke2RlZmF1bHRXb3JkQ2hhcn0pKWA7XG4gICAgICBjb25zdCBCID0gYCg/Oig/PD0ke2RlZmF1bHRXb3JkQ2hhcn0pKD89JHtkZWZhdWx0V29yZENoYXJ9KXwoPzwhJHtkZWZhdWx0V29yZENoYXJ9KSg/ISR7ZGVmYXVsdFdvcmRDaGFyfSkpYDtcbiAgICAgIHJlcGxhY2VXaXRoKHBhcnNlRnJhZ21lbnQobmVnYXRlID8gQiA6IGIpKTtcbiAgICB9XG4gIH0sXG4gIENhcHR1cmluZ0dyb3VwKHsgbm9kZSB9LCB7IHN1YnJvdXRpbmVSZWZNYXAgfSkge1xuICAgIGNvbnN0IHsgbmFtZSwgbnVtYmVyIH0gPSBub2RlO1xuICAgIGlmIChuYW1lICYmICFpc1ZhbGlkR3JvdXBOYW1lSnMobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR3JvdXAgbmFtZSBcIiR7bmFtZX1cIiBpbnZhbGlkIGluIEpTYCk7XG4gICAgfVxuICAgIHN1YnJvdXRpbmVSZWZNYXAuc2V0KG51bWJlciwgbm9kZSk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHN1YnJvdXRpbmVSZWZNYXAuc2V0KG5hbWUsIG5vZGUpO1xuICAgIH1cbiAgfSxcbiAgQ2hhcmFjdGVyU2V0KHsgbm9kZSwgcmVwbGFjZVdpdGggfSwgeyBhY2N1cmFjeSwgbWluVGFyZ2V0RXMyMDI0LCBkaWdpdElzQXNjaWksIHNwYWNlSXNBc2NpaSwgd29yZElzQXNjaWkgfSkge1xuICAgIGNvbnN0IHsga2luZCwgbmVnYXRlLCB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoZGlnaXRJc0FzY2lpICYmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5kaWdpdCB8fCB2YWx1ZSA9PT0gXCJkaWdpdFwiKSkge1xuICAgICAgcmVwbGFjZVdpdGgoY3JlYXRlQ2hhcmFjdGVyU2V0KEFzdENoYXJhY3RlclNldEtpbmRzLmRpZ2l0LCB7IG5lZ2F0ZSB9KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzcGFjZUlzQXNjaWkgJiYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLnNwYWNlIHx8IHZhbHVlID09PSBcInNwYWNlXCIpKSB7XG4gICAgICByZXBsYWNlV2l0aChzZXROZWdhdGUocGFyc2VGcmFnbWVudChhc2NpaVNwYWNlQ2hhciksIG5lZ2F0ZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod29yZElzQXNjaWkgJiYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLndvcmQgfHwgdmFsdWUgPT09IFwid29yZFwiKSkge1xuICAgICAgcmVwbGFjZVdpdGgoY3JlYXRlQ2hhcmFjdGVyU2V0KEFzdENoYXJhY3RlclNldEtpbmRzLndvcmQsIHsgbmVnYXRlIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLmFueSkge1xuICAgICAgcmVwbGFjZVdpdGgoY3JlYXRlVW5pY29kZVByb3BlcnR5KFwiQW55XCIpKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLmRpZ2l0KSB7XG4gICAgICByZXBsYWNlV2l0aChjcmVhdGVVbmljb2RlUHJvcGVydHkoXCJOZFwiLCB7IG5lZ2F0ZSB9KSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5oZXgpIHtcbiAgICAgIHJlcGxhY2VXaXRoKGNyZWF0ZVVuaWNvZGVQcm9wZXJ0eShcIkFIZXhcIiwgeyBuZWdhdGUgfSkpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMubm9uX25ld2xpbmUpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHBhcnNlRnJhZ21lbnQocmBbXlxcbl1gKSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5zcGFjZSkge1xuICAgICAgcmVwbGFjZVdpdGgoY3JlYXRlVW5pY29kZVByb3BlcnR5KFwic3BhY2VcIiwgeyBuZWdhdGUgfSkpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMud29yZCkge1xuICAgICAgcmVwbGFjZVdpdGgoc2V0TmVnYXRlKHBhcnNlRnJhZ21lbnQoZGVmYXVsdFdvcmRDaGFyKSwgbmVnYXRlKSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5wcm9wZXJ0eSkge1xuICAgICAgaWYgKCFKc1VuaWNvZGVQcm9wZXJ0aWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgbm9kZS5rZXkgPSBcInNjXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5wb3NpeCkge1xuICAgICAgaWYgKCFtaW5UYXJnZXRFczIwMjQgJiYgKHZhbHVlID09PSBcImdyYXBoXCIgfHwgdmFsdWUgPT09IFwicHJpbnRcIikpIHtcbiAgICAgICAgaWYgKGFjY3VyYWN5ID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQT1NJWCBjbGFzcyBcIiR7dmFsdWV9XCIgcmVxdWlyZXMgbWluIHRhcmdldCBFUzIwMjQgb3Igbm9uLXN0cmljdCBhY2N1cmFjeWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhc2NpaSA9IHtcbiAgICAgICAgICBncmFwaDogXCIhLX5cIixcbiAgICAgICAgICBwcmludDogXCIgLX5cIlxuICAgICAgICB9W3ZhbHVlXTtcbiAgICAgICAgaWYgKG5lZ2F0ZSkge1xuICAgICAgICAgIGFzY2lpID0gYFxcMC0ke2NwKGFzY2lpLmNvZGVQb2ludEF0KDApIC0gMSl9JHtjcChhc2NpaS5jb2RlUG9pbnRBdCgyKSArIDEpfS1cXHV7MTBGRkZGfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZVdpdGgocGFyc2VGcmFnbWVudChgWyR7YXNjaWl9XWApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGxhY2VXaXRoKHNldE5lZ2F0ZShwYXJzZUZyYWdtZW50KFBvc2l4Q2xhc3Nlc01hcC5nZXQodmFsdWUpKSwgbmVnYXRlKSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBEaXJlY3RpdmUocGF0aCwgc3RhdGUpIHtcbiAgICBjb25zdCB7IG5vZGUsIHBhcmVudCwgYXN0LCByZW1vdmUsIHJlcGxhY2VXaXRoLCByZW1vdmVBbGxQcmV2U2libGluZ3MsIHJlbW92ZUFsbE5leHRTaWJsaW5ncyB9ID0gcGF0aDtcbiAgICBjb25zdCB7IGtpbmQsIGZsYWdzIH0gPSBub2RlO1xuICAgIGlmIChraW5kID09PSBBc3REaXJlY3RpdmVLaW5kcy5mbGFncykge1xuICAgICAgaWYgKCFmbGFncy5lbmFibGUgJiYgIWZsYWdzLmRpc2FibGUpIHtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmbGFnR3JvdXAgPSBwcmVwQ29udGFpbmVyKGNyZWF0ZUdyb3VwKHsgZmxhZ3MgfSksIHJlbW92ZUFsbE5leHRTaWJsaW5ncygpKTtcbiAgICAgICAgcmVwbGFjZVdpdGgoZmxhZ0dyb3VwKTtcbiAgICAgICAgdHJhdmVyc2VSZXBsYWNlbWVudChmbGFnR3JvdXAsIHBhdGgsIHN0YXRlLCBGaXJzdFBhc3NWaXNpdG9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdERpcmVjdGl2ZUtpbmRzLmtlZXApIHtcbiAgICAgIGlmIChwYXJlbnQucGFyZW50ICE9PSBhc3QucGF0dGVybiB8fCBhc3QucGF0dGVybi5hbHRlcm5hdGl2ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmBVc2VzIFwiXFxLXCIgaW4gYSB3YXkgdGhhdCdzIHVuc3VwcG9ydGVkYCk7XG4gICAgICB9XG4gICAgICByZXBsYWNlV2l0aChwcmVwQ29udGFpbmVyKGNyZWF0ZUxvb2thcm91bmQoeyBiZWhpbmQ6IHRydWUgfSksIHJlbW92ZUFsbFByZXZTaWJsaW5ncygpKSk7XG4gICAgfVxuICB9LFxuICBGbGFncyh7IG5vZGUsIHBhcmVudCB9KSB7XG4gICAgW1xuICAgICAgXCJkaWdpdElzQXNjaWlcIixcbiAgICAgIC8vIEZsYWcgRFxuICAgICAgXCJleHRlbmRlZFwiLFxuICAgICAgLy8gRmxhZyB4XG4gICAgICBcInNwYWNlSXNBc2NpaVwiLFxuICAgICAgLy8gRmxhZyBTXG4gICAgICBcIndvcmRJc0FzY2lpXCJcbiAgICAgIC8vIEZsYWcgV1xuICAgIF0uZm9yRWFjaCgoZikgPT4gZGVsZXRlIG5vZGVbZl0pO1xuICAgIE9iamVjdC5hc3NpZ24obm9kZSwge1xuICAgICAgLy8gSlMgZmxhZyBnOyBubyBPbmlnIGVxdWl2XG4gICAgICBnbG9iYWw6IGZhbHNlLFxuICAgICAgLy8gSlMgZmxhZyBkOyBubyBPbmlnIGVxdWl2XG4gICAgICBoYXNJbmRpY2VzOiBmYWxzZSxcbiAgICAgIC8vIEpTIGZsYWcgbTsgbm8gT25pZyBlcXVpdiBidXQgaXRzIGJlaGF2aW9yIGlzIGFsd2F5cyBvbiBpbiBPbmlnLiBPbmlnJ3Mgb25seSBsaW5lIGJyZWFrXG4gICAgICAvLyBjaGFyIGlzIGxpbmUgZmVlZCwgdW5saWtlIEpTLCBzbyB0aGlzIGZsYWcgaXNuJ3QgdXNlZCBzaW5jZSBpdCB3b3VsZCBwcm9kdWNlIGluYWNjdXJhdGVcbiAgICAgIC8vIHJlc3VsdHMgKGFsc28gYWxsb3dzIGBeYCBhbmQgYCRgIHRvIGJlIHVzZWQgaW4gdGhlIGdlbmVyYXRvciBmb3Igc3RyaW5nIHN0YXJ0IGFuZCBlbmQpXG4gICAgICBtdWx0aWxpbmU6IGZhbHNlLFxuICAgICAgLy8gSlMgZmxhZyB5OyBubyBPbmlnIGVxdWl2LCBidXQgdXNlZCBmb3IgYFxcR2AgZW11bGF0aW9uXG4gICAgICBzdGlja3k6IG5vZGUuc3RpY2t5ID8/IGZhbHNlXG4gICAgICAvLyBOb3RlOiBSZWdleCsgZG9lc24ndCBhbGxvdyBleHBsaWNpdGx5IGFkZGluZyBmbGFncyBpdCBoYW5kbGVzIGltcGxpY2l0bHksIHNvIGxlYXZlIG91dFxuICAgICAgLy8gcHJvcGVydGllcyBgdW5pY29kZWAgKEpTIGZsYWcgdSkgYW5kIGB1bmljb2RlU2V0c2AgKEpTIGZsYWcgdikuIEtlZXAgdGhlIGV4aXN0aW5nIHZhbHVlc1xuICAgICAgLy8gZm9yIGBpZ25vcmVDYXNlYCAoZmxhZyBpKSBhbmQgYGRvdEFsbGAgKEpTIGZsYWcgcywgYnV0IE9uaWcgZmxhZyBtKVxuICAgIH0pO1xuICAgIHBhcmVudC5vcHRpb25zID0ge1xuICAgICAgZGlzYWJsZToge1xuICAgICAgICAvLyBPbmlnIHVzZXMgZGlmZmVyZW50IHJ1bGVzIGZvciBmbGFnIHggdGhhbiBSZWdleCssIHNvIGRpc2FibGUgdGhlIGltcGxpY2l0IGZsYWdcbiAgICAgICAgeDogdHJ1ZSxcbiAgICAgICAgLy8gT25pZyBoYXMgbm8gZmxhZyB0byBjb250cm9sIFwibmFtZWQgY2FwdHVyZSBvbmx5XCIgbW9kZSBidXQgY29udGV4dHVhbGx5IGFwcGxpZXMgaXRzXG4gICAgICAgIC8vIGJlaGF2aW9yIHdoZW4gbmFtZWQgY2FwdHVyaW5nIGlzIHVzZWQsIHNvIGRpc2FibGUgUmVnZXgrJ3MgaW1wbGljaXQgZmxhZyBmb3IgaXRcbiAgICAgICAgbjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZvcmNlOiB7XG4gICAgICAgIC8vIEFsd2F5cyBhZGQgZmxhZyB2IGJlY2F1c2Ugd2UncmUgZ2VuZXJhdGluZyBhbiBBU1QgdGhhdCByZWxpZXMgb24gaXQgKGl0IGVuYWJsZXMgSlNcbiAgICAgICAgLy8gc3VwcG9ydCBmb3IgT25pZyBmZWF0dXJlcyBuZXN0ZWQgY2xhc3Nlcywgc2V0IGludGVyc2VjdGlvbiwgVW5pY29kZSBwcm9wZXJ0aWVzLCBldGMuKS5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGdlbmVyYXRvciBtaWdodCBkaXNhYmxlIGZsYWcgdiBiYXNlZCBvbiBpdHMgYHRhcmdldGAgb3B0aW9uXG4gICAgICAgIHY6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBHcm91cCh7IG5vZGUgfSkge1xuICAgIGlmICghbm9kZS5mbGFncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGVuYWJsZSwgZGlzYWJsZSB9ID0gbm9kZS5mbGFncztcbiAgICBlbmFibGU/LmV4dGVuZGVkICYmIGRlbGV0ZSBlbmFibGUuZXh0ZW5kZWQ7XG4gICAgZGlzYWJsZT8uZXh0ZW5kZWQgJiYgZGVsZXRlIGRpc2FibGUuZXh0ZW5kZWQ7XG4gICAgZW5hYmxlPy5kb3RBbGwgJiYgZGlzYWJsZT8uZG90QWxsICYmIGRlbGV0ZSBlbmFibGUuZG90QWxsO1xuICAgIGVuYWJsZT8uaWdub3JlQ2FzZSAmJiBkaXNhYmxlPy5pZ25vcmVDYXNlICYmIGRlbGV0ZSBlbmFibGUuaWdub3JlQ2FzZTtcbiAgICBlbmFibGUgJiYgIU9iamVjdC5rZXlzKGVuYWJsZSkubGVuZ3RoICYmIGRlbGV0ZSBub2RlLmZsYWdzLmVuYWJsZTtcbiAgICBkaXNhYmxlICYmICFPYmplY3Qua2V5cyhkaXNhYmxlKS5sZW5ndGggJiYgZGVsZXRlIG5vZGUuZmxhZ3MuZGlzYWJsZTtcbiAgICAhbm9kZS5mbGFncy5lbmFibGUgJiYgIW5vZGUuZmxhZ3MuZGlzYWJsZSAmJiBkZWxldGUgbm9kZS5mbGFncztcbiAgfSxcbiAgUGF0dGVybih7IG5vZGUgfSwgeyBpZ25vcmVVbnN1cHBvcnRlZEdBbmNob3JzLCBzdXBwb3J0ZWRHTm9kZXMgfSkge1xuICAgIGNvbnN0IGxlYWRpbmdHcyA9IFtdO1xuICAgIGxldCBoYXNBbHRXaXRoTGVhZEcgPSBmYWxzZTtcbiAgICBsZXQgaGFzQWx0V2l0aG91dExlYWRHID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBhbHQgb2Ygbm9kZS5hbHRlcm5hdGl2ZXMpIHtcbiAgICAgIGlmIChhbHQuZWxlbWVudHMubGVuZ3RoID09PSAxICYmIGFsdC5lbGVtZW50c1swXS5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5zZWFyY2hfc3RhcnQpIHtcbiAgICAgICAgYWx0LmVsZW1lbnRzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGVhZGluZ0cgPSBnZXRMZWFkaW5nRyhhbHQuZWxlbWVudHMpO1xuICAgICAgICBpZiAobGVhZGluZ0cpIHtcbiAgICAgICAgICBoYXNBbHRXaXRoTGVhZEcgPSB0cnVlO1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkobGVhZGluZ0cpID8gbGVhZGluZ0dzLnB1c2goLi4ubGVhZGluZ0cpIDogbGVhZGluZ0dzLnB1c2gobGVhZGluZ0cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc0FsdFdpdGhvdXRMZWFkRyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0FsdFdpdGhMZWFkRykge1xuICAgICAgaWYgKCFoYXNBbHRXaXRob3V0TGVhZEcpIHtcbiAgICAgICAgbGVhZGluZ0dzLmZvckVhY2goKGcpID0+IHN1cHBvcnRlZEdOb2Rlcy5hZGQoZykpO1xuICAgICAgfSBlbHNlIGlmICghaWdub3JlVW5zdXBwb3J0ZWRHQW5jaG9ycykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmBVc2VzIFwiXFxHXCIgaW4gYSB3YXkgdGhhdCdzIHVuc3VwcG9ydGVkYCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBRdWFudGlmaWVyKHsgbm9kZSB9KSB7XG4gICAgaWYgKG5vZGUuZWxlbWVudC50eXBlID09PSBBc3RUeXBlcy5RdWFudGlmaWVyKSB7XG4gICAgICBjb25zdCBncm91cCA9IHByZXBDb250YWluZXIoY3JlYXRlR3JvdXAoKSwgW25vZGUuZWxlbWVudF0pO1xuICAgICAgZ3JvdXAucGFyZW50ID0gbm9kZTtcbiAgICAgIG5vZGUuZWxlbWVudCA9IGdyb3VwO1xuICAgIH1cbiAgfSxcbiAgVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXQoeyBub2RlLCByZXBsYWNlV2l0aCB9LCB7IGFjY3VyYWN5LCBtaW5UYXJnZXRFczIwMjQgfSkge1xuICAgIGNvbnN0IHsga2luZCB9ID0gbm9kZTtcbiAgICBpZiAoa2luZCA9PT0gQXN0VmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXRLaW5kcy5uZXdsaW5lKSB7XG4gICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KFwiKD8+XFxyXFxuP3xbXFxuXFx2XFxmXFx4ODVcXHUyMDI4XFx1MjAyOV0pXCIpKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdFZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0S2luZHMuZ3JhcGhlbWUpIHtcbiAgICAgIGlmIChhY2N1cmFjeSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmBVc2Ugb2YgXCJcXFhcIiByZXF1aXJlcyBub24tc3RyaWN0IGFjY3VyYWN5YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlbW9qaSA9IG1pblRhcmdldEVzMjAyNCA/IHJgXFxwe1JHSV9FbW9qaX1gIDogZW1vamlSZWdleCgpLnNvdXJjZS5yZXBsYWNlKC9cXFxcdVxcey9nLCBgXFxcXHh7YCk7XG4gICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KHJgKD8+XFxyXFxufCR7ZW1vaml9fFxcUHtNfVxccHtNfSopYCwgeyBza2lwUHJvcGVydHlOYW1lVmFsaWRhdGlvbjogdHJ1ZSB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YXJjaGFyc2V0IGtpbmQgXCIke2tpbmR9XCJgKTtcbiAgICB9XG4gIH1cbn07XG52YXIgU2Vjb25kUGFzc1Zpc2l0b3IgPSB7XG4gIEJhY2tyZWZlcmVuY2UoeyBub2RlIH0sIHsgbXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZiwgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXIgfSkge1xuICAgIGNvbnN0IHsgb3JwaGFuLCByZWYgfSA9IG5vZGU7XG4gICAgaWYgKCFvcnBoYW4pIHtcbiAgICAgIHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyLnNldChub2RlLCBbLi4ubXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZi5nZXQocmVmKS5tYXAoKHsgbm9kZTogbm9kZTIgfSkgPT4gbm9kZTIpXSk7XG4gICAgfVxuICB9LFxuICBDYXB0dXJpbmdHcm91cDoge1xuICAgIGVudGVyKHtcbiAgICAgIG5vZGUsXG4gICAgICByZXBsYWNlV2l0aCxcbiAgICAgIHNraXBcbiAgICB9LCB7XG4gICAgICBncm91cE9yaWdpbkJ5Q29weSxcbiAgICAgIGdyb3Vwc0J5TmFtZSxcbiAgICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYsXG4gICAgICBvcGVuUmVmcyxcbiAgICAgIHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyXG4gICAgfSkge1xuICAgICAgY29uc3Qgb3JpZ2luID0gZ3JvdXBPcmlnaW5CeUNvcHkuZ2V0KG5vZGUpO1xuICAgICAgaWYgKG9yaWdpbiAmJiBvcGVuUmVmcy5oYXMobm9kZS5udW1iZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlY3Vyc2lvbjIgPSBjcmVhdGVSZWN1cnNpb24obm9kZS5udW1iZXIpO1xuICAgICAgICByZWZmZWROb2Rlc0J5UmVmZXJlbmNlci5zZXQocmVjdXJzaW9uMiwgb3BlblJlZnMuZ2V0KG5vZGUubnVtYmVyKSk7XG4gICAgICAgIHJlcGxhY2VXaXRoKHJlY3Vyc2lvbjIpO1xuICAgICAgICBza2lwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9wZW5SZWZzLnNldChub2RlLm51bWJlciwgbm9kZSk7XG4gICAgICBtdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmLnNldChub2RlLm51bWJlciwgW10pO1xuICAgICAgaWYgKG5vZGUubmFtZSkge1xuICAgICAgICBnZXRPckNyZWF0ZShtdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmLCBub2RlLm5hbWUsIFtdKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG11bHRpcGxleE5vZGVzID0gbXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZi5nZXQobm9kZS5uYW1lID8/IG5vZGUubnVtYmVyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXVsdGlwbGV4Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbXVsdGlwbGV4ID0gbXVsdGlwbGV4Tm9kZXNbaV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBUaGlzIGdyb3VwIGlzIGZyb20gc3Vicm91dGluZSBleHBhbnNpb24sIGFuZCB0aGVyZSdzIGEgbXVsdGlwbGV4IHZhbHVlIGZyb20gZWl0aGVyIHRoZVxuICAgICAgICAgIC8vIG9yaWdpbiBub2RlIG9yIGEgcHJpb3Igc3Vicm91dGluZSBleHBhbnNpb24gZ3JvdXAgd2l0aCB0aGUgc2FtZSBvcmlnaW5cbiAgICAgICAgICBvcmlnaW4gPT09IG11bHRpcGxleC5ub2RlIHx8IG9yaWdpbiAmJiBvcmlnaW4gPT09IG11bHRpcGxleC5vcmlnaW4gfHwgLy8gVGhpcyBncm91cCBpcyBub3QgZnJvbSBzdWJyb3V0aW5lIGV4cGFuc2lvbiwgYW5kIGl0IGNvbWVzIGFmdGVyIGEgc3Vicm91dGluZSBleHBhbnNpb25cbiAgICAgICAgICAvLyBncm91cCB0aGF0IHJlZmVycyB0byB0aGlzIGdyb3VwXG4gICAgICAgICAgbm9kZSA9PT0gbXVsdGlwbGV4Lm9yaWdpblxuICAgICAgICApIHtcbiAgICAgICAgICBtdWx0aXBsZXhOb2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYuZ2V0KG5vZGUubnVtYmVyKS5wdXNoKHsgbm9kZSwgb3JpZ2luIH0pO1xuICAgICAgaWYgKG5vZGUubmFtZSkge1xuICAgICAgICBtdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmLmdldChub2RlLm5hbWUpLnB1c2goeyBub2RlLCBvcmlnaW4gfSk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5uYW1lKSB7XG4gICAgICAgIGNvbnN0IGdyb3Vwc1dpdGhTYW1lTmFtZSA9IGdldE9yQ3JlYXRlKGdyb3Vwc0J5TmFtZSwgbm9kZS5uYW1lLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICAgICAgbGV0IGhhc0R1cGxpY2F0ZU5hbWVUb1JlbW92ZSA9IGZhbHNlO1xuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgaGFzRHVwbGljYXRlTmFtZVRvUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGdyb3VwSW5mbyBvZiBncm91cHNXaXRoU2FtZU5hbWUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmICghZ3JvdXBJbmZvLmhhc0R1cGxpY2F0ZU5hbWVUb1JlbW92ZSkge1xuICAgICAgICAgICAgICBoYXNEdXBsaWNhdGVOYW1lVG9SZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBzQnlOYW1lLmdldChub2RlLm5hbWUpLnNldChub2RlLCB7IG5vZGUsIGhhc0R1cGxpY2F0ZU5hbWVUb1JlbW92ZSB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgbm9kZS5fb3JpZ2luTnVtYmVyID0gb3JpZ2luLm51bWJlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQoeyBub2RlIH0sIHsgb3BlblJlZnMgfSkge1xuICAgICAgb3BlblJlZnMuZGVsZXRlKG5vZGUubnVtYmVyKTtcbiAgICB9XG4gIH0sXG4gIEdyb3VwOiB7XG4gICAgZW50ZXIoeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5wcmV2RmxhZ3MgPSBzdGF0ZS5jdXJyZW50RmxhZ3M7XG4gICAgICBpZiAobm9kZS5mbGFncykge1xuICAgICAgICBzdGF0ZS5jdXJyZW50RmxhZ3MgPSBnZXROZXdDdXJyZW50RmxhZ3Moc3RhdGUuY3VycmVudEZsYWdzLCBub2RlLmZsYWdzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQoXywgc3RhdGUpIHtcbiAgICAgIHN0YXRlLmN1cnJlbnRGbGFncyA9IHN0YXRlLnByZXZGbGFncztcbiAgICB9XG4gIH0sXG4gIFJlY3Vyc2lvbih7IG5vZGUsIHBhcmVudCB9LCB7IHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyIH0pIHtcbiAgICBjb25zdCB7IHJlZiB9ID0gbm9kZTtcbiAgICBsZXQgcmVmZmVkID0gcGFyZW50O1xuICAgIHdoaWxlIChyZWZmZWQgPSByZWZmZWQucGFyZW50KSB7XG4gICAgICBpZiAocmVmZmVkLnR5cGUgPT09IEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwICYmIChyZWZmZWQubmFtZSA9PT0gcmVmIHx8IHJlZmZlZC5udW1iZXIgPT09IHJlZikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyLnNldChub2RlLCByZWZmZWQpO1xuICB9LFxuICBTdWJyb3V0aW5lKHBhdGgsIHN0YXRlKSB7XG4gICAgY29uc3QgeyBub2RlLCByZXBsYWNlV2l0aCB9ID0gcGF0aDtcbiAgICBjb25zdCB7IHJlZiB9ID0gbm9kZTtcbiAgICBjb25zdCByZWZmZWRHcm91cE5vZGUgPSBzdGF0ZS5zdWJyb3V0aW5lUmVmTWFwLmdldChyZWYpO1xuICAgIGNvbnN0IGlzR2xvYmFsUmVjdXJzaW9uID0gcmVmID09PSAwO1xuICAgIGNvbnN0IGV4cGFuZGVkU3Vicm91dGluZSA9IGlzR2xvYmFsUmVjdXJzaW9uID8gY3JlYXRlUmVjdXJzaW9uKDApIDogKFxuICAgICAgLy8gVGhlIHJlZmZlZCBncm91cCBtaWdodCBpdHNlbGYgY29udGFpbiBzdWJyb3V0aW5lcywgd2hpY2ggYXJlIGV4cGFuZGVkIGR1cmluZyBzdWItdHJhdmVyc2FsXG4gICAgICBjbG9uZUNhcHR1cmluZ0dyb3VwKHJlZmZlZEdyb3VwTm9kZSwgc3RhdGUuZ3JvdXBPcmlnaW5CeUNvcHksIG51bGwpXG4gICAgKTtcbiAgICBsZXQgcmVwbGFjZW1lbnQgPSBleHBhbmRlZFN1YnJvdXRpbmU7XG4gICAgaWYgKCFpc0dsb2JhbFJlY3Vyc2lvbikge1xuICAgICAgY29uc3QgcmVmZmVkR3JvdXBGbGFnTW9kcyA9IGdldENvbWJpbmVkRmxhZ01vZHNGcm9tRmxhZ05vZGVzKGdldEFsbFBhcmVudHMocmVmZmVkR3JvdXBOb2RlLCAobm9kZTIpID0+IHtcbiAgICAgICAgcmV0dXJuIG5vZGUyLnR5cGUgPT09IEFzdFR5cGVzLkdyb3VwICYmICEhbm9kZTIuZmxhZ3M7XG4gICAgICB9KSk7XG4gICAgICBjb25zdCByZWZmZWRHcm91cEZsYWdzID0gcmVmZmVkR3JvdXBGbGFnTW9kcyA/IGdldE5ld0N1cnJlbnRGbGFncyhzdGF0ZS5nbG9iYWxGbGFncywgcmVmZmVkR3JvdXBGbGFnTW9kcykgOiBzdGF0ZS5nbG9iYWxGbGFncztcbiAgICAgIGlmICghYXJlRmxhZ3NFcXVhbChyZWZmZWRHcm91cEZsYWdzLCBzdGF0ZS5jdXJyZW50RmxhZ3MpKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gcHJlcENvbnRhaW5lcihjcmVhdGVHcm91cCh7XG4gICAgICAgICAgZmxhZ3M6IGdldEZsYWdNb2RzRnJvbUZsYWdzKHJlZmZlZEdyb3VwRmxhZ3MpXG4gICAgICAgIH0pLCBbZXhwYW5kZWRTdWJyb3V0aW5lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2VXaXRoKHJlcGxhY2VtZW50KTtcbiAgICBpZiAoIWlzR2xvYmFsUmVjdXJzaW9uKSB7XG4gICAgICB0cmF2ZXJzZVJlcGxhY2VtZW50KHJlcGxhY2VtZW50LCBwYXRoLCBzdGF0ZSwgU2Vjb25kUGFzc1Zpc2l0b3IpO1xuICAgIH1cbiAgfVxufTtcbnZhciBUaGlyZFBhc3NWaXNpdG9yID0ge1xuICBCYWNrcmVmZXJlbmNlKHsgbm9kZSwgcmVwbGFjZVdpdGggfSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5vcnBoYW4pIHtcbiAgICAgIHN0YXRlLmhpZ2hlc3RPcnBoYW5CYWNrcmVmID0gTWF0aC5tYXgoc3RhdGUuaGlnaGVzdE9ycGhhbkJhY2tyZWYsIG5vZGUucmVmKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVmZmVkTm9kZXMgPSBzdGF0ZS5yZWZmZWROb2Rlc0J5UmVmZXJlbmNlci5nZXQobm9kZSk7XG4gICAgY29uc3QgcGFydGljaXBhbnRzID0gcmVmZmVkTm9kZXMuZmlsdGVyKChyZWZmZWQpID0+IGNhblBhcnRpY2lwYXRlV2l0aE5vZGUocmVmZmVkLCBub2RlKSk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudHMubGVuZ3RoKSB7XG4gICAgICByZXBsYWNlV2l0aChjcmVhdGVMb29rYXJvdW5kKHsgbmVnYXRlOiB0cnVlIH0pKTtcbiAgICB9IGVsc2UgaWYgKHBhcnRpY2lwYW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBhbHRzID0gcGFydGljaXBhbnRzLm1hcCgocmVmZmVkKSA9PiBhZG9wdEFuZFN3YXBLaWRzKFxuICAgICAgICBjcmVhdGVBbHRlcm5hdGl2ZSgpLFxuICAgICAgICBbY3JlYXRlQmFja3JlZmVyZW5jZShyZWZmZWQubnVtYmVyKV1cbiAgICAgICkpO1xuICAgICAgcmVwbGFjZVdpdGgoYWRvcHRBbmRTd2FwS2lkcyhjcmVhdGVHcm91cCgpLCBhbHRzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVmID0gcGFydGljaXBhbnRzWzBdLm51bWJlcjtcbiAgICB9XG4gIH0sXG4gIENhcHR1cmluZ0dyb3VwKHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgIG5vZGUubnVtYmVyID0gKytzdGF0ZS5udW1DYXB0dXJlc1RvTGVmdDtcbiAgICBpZiAobm9kZS5uYW1lKSB7XG4gICAgICBpZiAoc3RhdGUuZ3JvdXBzQnlOYW1lLmdldChub2RlLm5hbWUpLmdldChub2RlKS5oYXNEdXBsaWNhdGVOYW1lVG9SZW1vdmUpIHtcbiAgICAgICAgZGVsZXRlIG5vZGUubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFJlY3Vyc2lvbih7IG5vZGUgfSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5yZWYgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5yZWYgPSBzdGF0ZS5yZWZmZWROb2Rlc0J5UmVmZXJlbmNlci5nZXQobm9kZSkubnVtYmVyO1xuICB9LFxuICBSZWdleDoge1xuICAgIGV4aXQoeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgICBjb25zdCBudW1DYXBzTmVlZGVkID0gTWF0aC5tYXgoc3RhdGUuaGlnaGVzdE9ycGhhbkJhY2tyZWYgLSBzdGF0ZS5udW1DYXB0dXJlc1RvTGVmdCwgMCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNhcHNOZWVkZWQ7IGkrKykge1xuICAgICAgICBjb25zdCBlbXB0eUNhcHR1cmUgPSBjcmVhdGVDYXB0dXJpbmdHcm91cCgpO1xuICAgICAgICBub2RlLnBhdHRlcm4uYWx0ZXJuYXRpdmVzLmF0KC0xKS5lbGVtZW50cy5wdXNoKGVtcHR5Q2FwdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGFzY2lpU3BhY2VDaGFyID0gXCJbXHQtXFxyIF1cIjtcbnZhciBkZWZhdWx0V29yZENoYXIgPSByYFtcXHB7TH1cXHB7TX1cXHB7Tn1cXHB7UGN9XWA7XG5mdW5jdGlvbiBhZG9wdEFuZFN3YXBLaWRzKHBhcmVudCwga2lkcykge1xuICBraWRzLmZvckVhY2goKGtpZCkgPT4ga2lkLnBhcmVudCA9IHBhcmVudCk7XG4gIHBhcmVudFtnZXRDb250YWluZXJBY2Nlc3NvcihwYXJlbnQpXSA9IGtpZHM7XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBhcmVGbGFnc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEuZG90QWxsID09PSBiLmRvdEFsbCAmJiBhLmlnbm9yZUNhc2UgPT09IGIuaWdub3JlQ2FzZTtcbn1cbmZ1bmN0aW9uIGNhblBhcnRpY2lwYXRlV2l0aE5vZGUoY2FwdHVyZSwgbm9kZSkge1xuICBsZXQgcmlnaHRtb3N0UG9pbnQgPSBub2RlO1xuICBkbyB7XG4gICAgaWYgKHJpZ2h0bW9zdFBvaW50LnR5cGUgPT09IEFzdFR5cGVzLlBhdHRlcm4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0bW9zdFBvaW50LnR5cGUgPT09IEFzdFR5cGVzLkFsdGVybmF0aXZlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0bW9zdFBvaW50ID09PSBjYXB0dXJlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGtpZHNPZlBhcmVudCA9IGdldEtpZHMocmlnaHRtb3N0UG9pbnQucGFyZW50KTtcbiAgICBmb3IgKGNvbnN0IGtpZCBvZiBraWRzT2ZQYXJlbnQpIHtcbiAgICAgIGlmIChraWQgPT09IHJpZ2h0bW9zdFBvaW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGtpZCA9PT0gY2FwdHVyZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNEZXNjZW5kYW50KGtpZCwgY2FwdHVyZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlIChyaWdodG1vc3RQb2ludCA9IHJpZ2h0bW9zdFBvaW50LnBhcmVudCk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgcGF0aFwiKTtcbn1cbmZ1bmN0aW9uIGNsb25lQ2FwdHVyaW5nR3JvdXAob2JqLCBvcmlnaW5NYXAsIHVwLCB1cDIpIHtcbiAgY29uc3Qgc3RvcmUgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgaWYgKGtleSA9PT0gXCJwYXJlbnRcIikge1xuICAgICAgc3RvcmUucGFyZW50ID0gQXJyYXkuaXNBcnJheSh1cCkgPyB1cDIgOiB1cDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgc3RvcmVba2V5XSA9IGNsb25lQ2FwdHVyaW5nR3JvdXAodmFsdWUsIG9yaWdpbk1hcCwgc3RvcmUsIHVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgdmFsdWUgPT09IEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwKSB7XG4gICAgICAgIG9yaWdpbk1hcC5zZXQoc3RvcmUsIG9yaWdpbk1hcC5nZXQob2JqKSA/PyBvYmopO1xuICAgICAgfVxuICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWN1cnNpb24ocmVmKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuUmVjdXJzaW9uLFxuICAgIHJlZlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWxsUGFyZW50cyhub2RlLCBmaWx0ZXJGbikge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIHdoaWxlIChub2RlID0gbm9kZS5wYXJlbnQpIHtcbiAgICBpZiAoIWZpbHRlckZuIHx8IGZpbHRlckZuKG5vZGUpKSB7XG4gICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyQWNjZXNzb3Iobm9kZSkge1xuICBmb3IgKGNvbnN0IGFjY2Vzc29yIG9mIFtcImFsdGVybmF0aXZlc1wiLCBcImNsYXNzZXNcIiwgXCJlbGVtZW50c1wiXSkge1xuICAgIGlmIChub2RlW2FjY2Vzc29yXSkge1xuICAgICAgcmV0dXJuIGFjY2Vzc29yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldENvbWJpbmVkRmxhZ01vZHNGcm9tRmxhZ05vZGVzKGZsYWdOb2Rlcykge1xuICBjb25zdCBmbGFnUHJvcHMgPSBbXCJkb3RBbGxcIiwgXCJpZ25vcmVDYXNlXCJdO1xuICBjb25zdCBjb21iaW5lZEZsYWdzID0geyBlbmFibGU6IHt9LCBkaXNhYmxlOiB7fSB9O1xuICBmbGFnTm9kZXMuZm9yRWFjaCgoeyBmbGFncyB9KSA9PiB7XG4gICAgZmxhZ1Byb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGlmIChmbGFncy5lbmFibGU/Lltwcm9wXSkge1xuICAgICAgICBkZWxldGUgY29tYmluZWRGbGFncy5kaXNhYmxlW3Byb3BdO1xuICAgICAgICBjb21iaW5lZEZsYWdzLmVuYWJsZVtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MuZGlzYWJsZT8uW3Byb3BdKSB7XG4gICAgICAgIGNvbWJpbmVkRmxhZ3MuZGlzYWJsZVtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpZiAoIU9iamVjdC5rZXlzKGNvbWJpbmVkRmxhZ3MuZW5hYmxlKS5sZW5ndGgpIHtcbiAgICBkZWxldGUgY29tYmluZWRGbGFncy5lbmFibGU7XG4gIH1cbiAgaWYgKCFPYmplY3Qua2V5cyhjb21iaW5lZEZsYWdzLmRpc2FibGUpLmxlbmd0aCkge1xuICAgIGRlbGV0ZSBjb21iaW5lZEZsYWdzLmRpc2FibGU7XG4gIH1cbiAgaWYgKGNvbWJpbmVkRmxhZ3MuZW5hYmxlIHx8IGNvbWJpbmVkRmxhZ3MuZGlzYWJsZSkge1xuICAgIHJldHVybiBjb21iaW5lZEZsYWdzO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RmxhZ01vZHNGcm9tRmxhZ3MoeyBkb3RBbGwsIGlnbm9yZUNhc2UgfSkge1xuICBjb25zdCBtb2RzID0ge307XG4gIGlmIChkb3RBbGwgfHwgaWdub3JlQ2FzZSkge1xuICAgIG1vZHMuZW5hYmxlID0ge307XG4gICAgZG90QWxsICYmIChtb2RzLmVuYWJsZS5kb3RBbGwgPSB0cnVlKTtcbiAgICBpZ25vcmVDYXNlICYmIChtb2RzLmVuYWJsZS5pZ25vcmVDYXNlID0gdHJ1ZSk7XG4gIH1cbiAgaWYgKCFkb3RBbGwgfHwgIWlnbm9yZUNhc2UpIHtcbiAgICBtb2RzLmRpc2FibGUgPSB7fTtcbiAgICAhZG90QWxsICYmIChtb2RzLmRpc2FibGUuZG90QWxsID0gdHJ1ZSk7XG4gICAgIWlnbm9yZUNhc2UgJiYgKG1vZHMuZGlzYWJsZS5pZ25vcmVDYXNlID0gdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG1vZHM7XG59XG5mdW5jdGlvbiBnZXRLaWRzKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBleHBlY3RlZFwiKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBBc3RUeXBlcy5RdWFudGlmaWVyKSB7XG4gICAgcmV0dXJuIFtub2RlLmVsZW1lbnRdO1xuICB9XG4gIGNvbnN0IGFjY2Vzc29yID0gZ2V0Q29udGFpbmVyQWNjZXNzb3Iobm9kZSk7XG4gIHJldHVybiBhY2Nlc3NvciAmJiBub2RlW2FjY2Vzc29yXTtcbn1cbmZ1bmN0aW9uIGdldExlYWRpbmdHKGVscykge1xuICBjb25zdCBmaXJzdFRvQ29uc2lkZXIgPSBlbHMuZmluZCgoZWwpID0+IGVsLmtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLnNlYXJjaF9zdGFydCB8fCBpc0xvbmVHTG9va2Fyb3VuZChlbCwgeyBuZWdhdGU6IGZhbHNlIH0pIHx8ICFpc1plcm9MZW5ndGhOb2RlKGVsKSk7XG4gIGlmICghZmlyc3RUb0NvbnNpZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGZpcnN0VG9Db25zaWRlci5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5zZWFyY2hfc3RhcnQpIHtcbiAgICByZXR1cm4gZmlyc3RUb0NvbnNpZGVyO1xuICB9XG4gIGlmIChpc0xvb2thcm91bmQoZmlyc3RUb0NvbnNpZGVyKSkge1xuICAgIHJldHVybiBmaXJzdFRvQ29uc2lkZXIuYWx0ZXJuYXRpdmVzWzBdLmVsZW1lbnRzWzBdO1xuICB9XG4gIGlmIChmaXJzdFRvQ29uc2lkZXIudHlwZSA9PT0gQXN0VHlwZXMuR3JvdXAgfHwgZmlyc3RUb0NvbnNpZGVyLnR5cGUgPT09IEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwKSB7XG4gICAgY29uc3QgZ05vZGVzRm9yR3JvdXAgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFsdCBvZiBmaXJzdFRvQ29uc2lkZXIuYWx0ZXJuYXRpdmVzKSB7XG4gICAgICBjb25zdCBsZWFkaW5nRyA9IGdldExlYWRpbmdHKGFsdC5lbGVtZW50cyk7XG4gICAgICBpZiAoIWxlYWRpbmdHKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgQXJyYXkuaXNBcnJheShsZWFkaW5nRykgPyBnTm9kZXNGb3JHcm91cC5wdXNoKC4uLmxlYWRpbmdHKSA6IGdOb2Rlc0Zvckdyb3VwLnB1c2gobGVhZGluZ0cpO1xuICAgIH1cbiAgICByZXR1cm4gZ05vZGVzRm9yR3JvdXA7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBoYXNEZXNjZW5kYW50KG5vZGUsIGRlc2NlbmRhbnQpIHtcbiAgY29uc3Qga2lkcyA9IGdldEtpZHMobm9kZSkgPz8gW107XG4gIGZvciAoY29uc3Qga2lkIG9mIGtpZHMpIHtcbiAgICBpZiAoa2lkID09PSBkZXNjZW5kYW50IHx8IGhhc0Rlc2NlbmRhbnQoa2lkLCBkZXNjZW5kYW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRHcm91cE5hbWVKcyhuYW1lKSB7XG4gIHJldHVybiAvXlskX1xccHtJRFN9XVskXFx1MjAwQ1xcdTIwMERcXHB7SURDfV0qJC91LnRlc3QobmFtZSk7XG59XG5mdW5jdGlvbiBwYXJzZUZyYWdtZW50KHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgYXN0ID0gcGFyc2UodG9rZW5pemUocGF0dGVybiksIG9wdGlvbnMpO1xuICBjb25zdCBhbHRzID0gYXN0LnBhdHRlcm4uYWx0ZXJuYXRpdmVzO1xuICBpZiAoYWx0cy5sZW5ndGggPiAxIHx8IGFsdHNbMF0uZWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBhZG9wdEFuZFN3YXBLaWRzKGNyZWF0ZUdyb3VwKCksIGFsdHMpO1xuICB9XG4gIHJldHVybiBhbHRzWzBdLmVsZW1lbnRzWzBdO1xufVxuZnVuY3Rpb24gcHJlcENvbnRhaW5lcihub2RlLCBraWRzKSB7XG4gIGNvbnN0IGFjY2Vzc29yID0gZ2V0Q29udGFpbmVyQWNjZXNzb3Iobm9kZSk7XG4gIG5vZGVbYWNjZXNzb3JdWzBdLnBhcmVudCA9IG5vZGU7XG4gIGlmIChraWRzKSB7XG4gICAgYWRvcHRBbmRTd2FwS2lkcyhub2RlW2FjY2Vzc29yXVswXSwga2lkcyk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXROZWdhdGUobm9kZSwgbmVnYXRlKSB7XG4gIG5vZGUubmVnYXRlID0gbmVnYXRlO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUmVwbGFjZW1lbnQocmVwbGFjZW1lbnQsIHsgcGFyZW50LCBrZXksIGNvbnRhaW5lciB9LCBzdGF0ZSwgdmlzaXRvcikge1xuICB0cmF2ZXJzZSh7XG4gICAgLy8gRG9uJ3QgdXNlIHRoZSBgbm9kZWAgZnJvbSBgcGF0aGBcbiAgICBub2RlOiByZXBsYWNlbWVudCxcbiAgICBwYXJlbnQsXG4gICAga2V5LFxuICAgIGNvbnRhaW5lclxuICB9LCBzdGF0ZSwgdmlzaXRvcik7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS5qc1xuaW1wb3J0IHsgZW11bGF0aW9uR3JvdXBNYXJrZXIgfSBmcm9tIFwicmVnZXgvaW50ZXJuYWxzXCI7XG5mdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IG1pblRhcmdldEVzMjAyNCA9IGlzTWluVGFyZ2V0KG9wdHMudGFyZ2V0LCBcIkVTMjAyNFwiKTtcbiAgY29uc3QgbWluVGFyZ2V0RXMyMDI1ID0gaXNNaW5UYXJnZXQob3B0cy50YXJnZXQsIFwiRVMyMDI1XCIpO1xuICBjb25zdCByZWN1cnNpb25MaW1pdCA9IG9wdHMucnVsZXMucmVjdXJzaW9uTGltaXQ7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihyZWN1cnNpb25MaW1pdCkgfHwgcmVjdXJzaW9uTGltaXQgPCAyIHx8IHJlY3Vyc2lvbkxpbWl0ID4gMjApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlY3Vyc2lvbkxpbWl0OyB1c2UgMi0yMFwiKTtcbiAgfVxuICBsZXQgaGFzQ2FzZUluc2Vuc2l0aXZlTm9kZSA9IG51bGw7XG4gIGxldCBoYXNDYXNlU2Vuc2l0aXZlTm9kZSA9IG51bGw7XG4gIGlmICghbWluVGFyZ2V0RXMyMDI1KSB7XG4gICAgY29uc3QgaVN0YWNrID0gW2FzdC5mbGFncy5pZ25vcmVDYXNlXTtcbiAgICB0cmF2ZXJzZSh7IG5vZGU6IGFzdCB9LCB7XG4gICAgICBnZXRDdXJyZW50TW9kSTogKCkgPT4gaVN0YWNrLmF0KC0xKSxcbiAgICAgIHBvcE1vZEkoKSB7XG4gICAgICAgIGlTdGFjay5wb3AoKTtcbiAgICAgIH0sXG4gICAgICBwdXNoTW9kSShpc0lPbikge1xuICAgICAgICBpU3RhY2sucHVzaChpc0lPbik7XG4gICAgICB9LFxuICAgICAgc2V0SGFzQ2FzZWRDaGFyKCkge1xuICAgICAgICBpZiAoaVN0YWNrLmF0KC0xKSkge1xuICAgICAgICAgIGhhc0Nhc2VJbnNlbnNpdGl2ZU5vZGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc0Nhc2VTZW5zaXRpdmVOb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIEZsYWdNb2RpZmllclZpc2l0b3IpO1xuICB9XG4gIGNvbnN0IGFwcGxpZWRHbG9iYWxGbGFncyA9IHtcbiAgICBkb3RBbGw6IGFzdC5mbGFncy5kb3RBbGwsXG4gICAgLy8gLSBUdXJuIGdsb2JhbCBmbGFnIGkgb24gaWYgYSBjYXNlIGluc2Vuc2l0aXZlIG5vZGUgd2FzIHVzZWQgYW5kIG5vIGNhc2Ugc2Vuc2l0aXZlIG5vZGVzIHdlcmVcbiAgICAvLyAgIHVzZWQgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IG5vZGUgZXhwYW5zaW9uKS5cbiAgICAvLyAtIFR1cm4gZ2xvYmFsIGZsYWcgaSBvZmYgaWYgYSBjYXNlIHNlbnNpdGl2ZSBub2RlIHdhcyB1c2VkIChzaW5jZSBjYXNlIHNlbnNpdGl2aXR5IGNhbid0IGJlXG4gICAgLy8gICBmb3JjZWQgd2l0aG91dCB0aGUgdXNlIG9mIEVTMjAyNSBmbGFnIGdyb3VwcylcbiAgICBpZ25vcmVDYXNlOiAhISgoYXN0LmZsYWdzLmlnbm9yZUNhc2UgfHwgaGFzQ2FzZUluc2Vuc2l0aXZlTm9kZSkgJiYgIWhhc0Nhc2VTZW5zaXRpdmVOb2RlKVxuICB9O1xuICBsZXQgbGFzdE5vZGUgPSBudWxsO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBhY2N1cmFjeTogb3B0cy5hY2N1cmFjeSxcbiAgICBhcHBsaWVkR2xvYmFsRmxhZ3MsXG4gICAgYXZvaWRTdWJjbGFzczogb3B0cy5hdm9pZFN1YmNsYXNzLFxuICAgIGNhcHR1cmVNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgY3VycmVudEZsYWdzOiB7XG4gICAgICBkb3RBbGw6IGFzdC5mbGFncy5kb3RBbGwsXG4gICAgICBpZ25vcmVDYXNlOiBhc3QuZmxhZ3MuaWdub3JlQ2FzZVxuICAgIH0sXG4gICAgaW5DaGFyQ2xhc3M6IGZhbHNlLFxuICAgIGxhc3ROb2RlLFxuICAgIHJlY3Vyc2lvbkxpbWl0LFxuICAgIHVzZUFwcGxpZWRJZ25vcmVDYXNlOiAhISghbWluVGFyZ2V0RXMyMDI1ICYmIGhhc0Nhc2VJbnNlbnNpdGl2ZU5vZGUgJiYgaGFzQ2FzZVNlbnNpdGl2ZU5vZGUpLFxuICAgIHVzZUZsYWdNb2RzOiBtaW5UYXJnZXRFczIwMjUsXG4gICAgdXNlRmxhZ1Y6IG1pblRhcmdldEVzMjAyNCxcbiAgICB2ZXJib3NlOiBvcHRzLnZlcmJvc2VcbiAgfTtcbiAgZnVuY3Rpb24gZ2VuKG5vZGUpIHtcbiAgICBzdGF0ZS5sYXN0Tm9kZSA9IGxhc3ROb2RlO1xuICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBBc3RUeXBlcy5SZWdleDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXR0ZXJuOiBnZW4obm9kZS5wYXR0ZXJuKSxcbiAgICAgICAgICBmbGFnczogZ2VuKG5vZGUuZmxhZ3MpLFxuICAgICAgICAgIG9wdGlvbnM6IHsgLi4ubm9kZS5vcHRpb25zIH1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuQWx0ZXJuYXRpdmU6XG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnRzLm1hcChnZW4pLmpvaW4oXCJcIik7XG4gICAgICBjYXNlIEFzdFR5cGVzLkFzc2VydGlvbjpcbiAgICAgICAgcmV0dXJuIGdlbkFzc2VydGlvbihub2RlLCBzdGF0ZSwgZ2VuKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuQmFja3JlZmVyZW5jZTpcbiAgICAgICAgcmV0dXJuIGdlbkJhY2tyZWZlcmVuY2Uobm9kZSwgc3RhdGUpO1xuICAgICAgY2FzZSBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cDpcbiAgICAgICAgcmV0dXJuIGdlbkNhcHR1cmluZ0dyb3VwKG5vZGUsIHN0YXRlLCBnZW4pO1xuICAgICAgY2FzZSBBc3RUeXBlcy5DaGFyYWN0ZXI6XG4gICAgICAgIHJldHVybiBnZW5DaGFyYWN0ZXIobm9kZSwgc3RhdGUpO1xuICAgICAgY2FzZSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzczpcbiAgICAgICAgcmV0dXJuIGdlbkNoYXJhY3RlckNsYXNzKG5vZGUsIHN0YXRlLCBnZW4pO1xuICAgICAgY2FzZSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbjpcbiAgICAgICAgaWYgKCFzdGF0ZS51c2VGbGFnVikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBvZiBjbGFzcyBpbnRlcnNlY3Rpb24gcmVxdWlyZXMgbWluIHRhcmdldCBFUzIwMjRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3Nlcy5tYXAoZ2VuKS5qb2luKFwiJiZcIik7XG4gICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzUmFuZ2U6XG4gICAgICAgIHJldHVybiBnZW5DaGFyYWN0ZXJDbGFzc1JhbmdlKG5vZGUsIHN0YXRlKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyU2V0OlxuICAgICAgICByZXR1cm4gZ2VuQ2hhcmFjdGVyU2V0KG5vZGUsIHN0YXRlKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuRmxhZ3M6XG4gICAgICAgIHJldHVybiBnZW5GbGFncyhub2RlLCBzdGF0ZSk7XG4gICAgICBjYXNlIEFzdFR5cGVzLkdyb3VwOlxuICAgICAgICByZXR1cm4gZ2VuR3JvdXAobm9kZSwgc3RhdGUsIGdlbik7XG4gICAgICBjYXNlIEFzdFR5cGVzLlBhdHRlcm46XG4gICAgICAgIHJldHVybiBub2RlLmFsdGVybmF0aXZlcy5tYXAoZ2VuKS5qb2luKFwifFwiKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuUXVhbnRpZmllcjpcbiAgICAgICAgcmV0dXJuIGdlbihub2RlLmVsZW1lbnQpICsgZ2V0UXVhbnRpZmllclN0cihub2RlKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuUmVjdXJzaW9uOlxuICAgICAgICByZXR1cm4gZ2VuUmVjdXJzaW9uKG5vZGUsIHN0YXRlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBub2RlIHR5cGUgXCIke25vZGUudHlwZX1cImApO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBnZW4oYXN0KTtcbiAgaWYgKCFtaW5UYXJnZXRFczIwMjQpIHtcbiAgICBkZWxldGUgcmVzdWx0Lm9wdGlvbnMuZm9yY2UudjtcbiAgICByZXN1bHQub3B0aW9ucy5kaXNhYmxlLnYgPSB0cnVlO1xuICAgIHJlc3VsdC5vcHRpb25zLnVuaWNvZGVTZXRzUGx1Z2luID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEZsYWdNb2RpZmllclZpc2l0b3IgPSB7XG4gIEFueUdyb3VwOiB7XG4gICAgZW50ZXIoeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgICBjb25zdCBjdXJyZW50TW9kSSA9IHN0YXRlLmdldEN1cnJlbnRNb2RJKCk7XG4gICAgICBzdGF0ZS5wdXNoTW9kSShcbiAgICAgICAgbm9kZS5mbGFncyA/IGdldE5ld0N1cnJlbnRGbGFncyh7IGlnbm9yZUNhc2U6IGN1cnJlbnRNb2RJIH0sIG5vZGUuZmxhZ3MpLmlnbm9yZUNhc2UgOiBjdXJyZW50TW9kSVxuICAgICAgKTtcbiAgICB9LFxuICAgIGV4aXQoXywgc3RhdGUpIHtcbiAgICAgIHN0YXRlLnBvcE1vZEkoKTtcbiAgICB9XG4gIH0sXG4gIEJhY2tyZWZlcmVuY2UoXywgc3RhdGUpIHtcbiAgICBzdGF0ZS5zZXRIYXNDYXNlZENoYXIoKTtcbiAgfSxcbiAgQ2hhcmFjdGVyKHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgIGlmIChjaGFySGFzQ2FzZShjcChub2RlLnZhbHVlKSkpIHtcbiAgICAgIHN0YXRlLnNldEhhc0Nhc2VkQ2hhcigpO1xuICAgIH1cbiAgfSxcbiAgQ2hhcmFjdGVyQ2xhc3NSYW5nZSh7IG5vZGUsIHNraXAgfSwgc3RhdGUpIHtcbiAgICBza2lwKCk7XG4gICAgaWYgKGdldENhc2VzT3V0c2lkZUNoYXJDbGFzc1JhbmdlKG5vZGUsIHsgZmlyc3RPbmx5OiB0cnVlIH0pLmxlbmd0aCkge1xuICAgICAgc3RhdGUuc2V0SGFzQ2FzZWRDaGFyKCk7XG4gICAgfVxuICB9LFxuICBDaGFyYWN0ZXJTZXQoeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUua2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMucHJvcGVydHkgJiYgVW5pY29kZVByb3BlcnRpZXNXaXRoU3BlY2lmaWNDYXNlLmhhcyhub2RlLnZhbHVlKSkge1xuICAgICAgc3RhdGUuc2V0SGFzQ2FzZWRDaGFyKCk7XG4gICAgfVxuICB9XG59O1xudmFyIEJhc2VFc2NhcGVDaGFycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCIkXCIsXG4gIFwiKFwiLFxuICBcIilcIixcbiAgXCIqXCIsXG4gIFwiK1wiLFxuICBcIi5cIixcbiAgXCI/XCIsXG4gIFwiW1wiLFxuICBcIlxcXFxcIixcbiAgXCJdXCIsXG4gIFwiXlwiLFxuICBcIntcIixcbiAgXCJ8XCIsXG4gIFwifVwiXG5dKTtcbnZhciBDaGFyQ2xhc3NFc2NhcGVDaGFycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCItXCIsXG4gIFwiXFxcXFwiLFxuICBcIl1cIixcbiAgXCJeXCIsXG4gIC8vIExpdGVyYWwgYFtgIGRvZXNuJ3QgcmVxdWlyZSBlc2NhcGluZyB3aXRoIGZsYWcgdSwgYnV0IHRoaXMgY2FuIGhlbHAgd29yayBhcm91bmQgcmVnZXggc291cmNlXG4gIC8vIGxpbnRlcnMgYW5kIHJlZ2V4IHN5bnRheCBwcm9jZXNzb3JzIHRoYXQgZXhwZWN0IHVuZXNjYXBlZCBgW2AgdG8gY3JlYXRlIGEgbmVzdGVkIGNsYXNzXG4gIFwiW1wiXG5dKTtcbnZhciBDaGFyQ2xhc3NFc2NhcGVDaGFyc0ZsYWdWID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIihcIixcbiAgXCIpXCIsXG4gIFwiLVwiLFxuICBcIi9cIixcbiAgXCJbXCIsXG4gIFwiXFxcXFwiLFxuICBcIl1cIixcbiAgXCJeXCIsXG4gIFwie1wiLFxuICBcInxcIixcbiAgXCJ9XCIsXG4gIC8vIERvdWJsZSBwdW5jdHVhdG9yczsgYWxzbyBpbmNsdWRlcyBhbHJlYWR5LWxpc3RlZCBgLWAgYW5kIGBeYFxuICBcIiFcIixcbiAgXCIjXCIsXG4gIFwiJFwiLFxuICBcIiVcIixcbiAgXCImXCIsXG4gIFwiKlwiLFxuICBcIitcIixcbiAgXCIsXCIsXG4gIFwiLlwiLFxuICBcIjpcIixcbiAgXCI7XCIsXG4gIFwiPFwiLFxuICBcIj1cIixcbiAgXCI+XCIsXG4gIFwiP1wiLFxuICBcIkBcIixcbiAgXCJgXCIsXG4gIFwiflwiXG5dKTtcbnZhciBDaGFyQ29kZUVzY2FwZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgWzksIHJgXFx0YF0sXG4gIC8vIGhvcml6b250YWwgdGFiXG4gIFsxMCwgcmBcXG5gXSxcbiAgLy8gbGluZSBmZWVkXG4gIFsxMSwgcmBcXHZgXSxcbiAgLy8gdmVydGljYWwgdGFiXG4gIFsxMiwgcmBcXGZgXSxcbiAgLy8gZm9ybSBmZWVkXG4gIFsxMywgcmBcXHJgXSxcbiAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gIFs4MjMyLCByYFxcdTIwMjhgXSxcbiAgLy8gbGluZSBzZXBhcmF0b3JcbiAgWzgyMzMsIHJgXFx1MjAyOWBdLFxuICAvLyBwYXJhZ3JhcGggc2VwYXJhdG9yXG4gIFs2NTI3OSwgcmBcXHVGRUZGYF1cbiAgLy8gWldOQlNQL0JPTVxuXSk7XG52YXIgY2FzZWRSZSA9IC9eXFxwe0Nhc2VkfSQvdTtcbmZ1bmN0aW9uIGNoYXJIYXNDYXNlKGNoYXIpIHtcbiAgcmV0dXJuIGNhc2VkUmUudGVzdChjaGFyKTtcbn1cbmZ1bmN0aW9uIGdlbkFzc2VydGlvbihub2RlLCBfLCBnZW4pIHtcbiAgY29uc3QgeyBraW5kLCBuZWdhdGUsIGFsdGVybmF0aXZlcyB9ID0gbm9kZTtcbiAgaWYgKGlzTG9va2Fyb3VuZChub2RlKSkge1xuICAgIGNvbnN0IHByZWZpeCA9IGAke2tpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxvb2thaGVhZCA/IFwiXCIgOiBcIjxcIn0ke25lZ2F0ZSA/IFwiIVwiIDogXCI9XCJ9YDtcbiAgICByZXR1cm4gYCg/JHtwcmVmaXh9JHthbHRlcm5hdGl2ZXMubWFwKGdlbikuam9pbihcInxcIil9KWA7XG4gIH1cbiAgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLnN0cmluZ19lbmQpIHtcbiAgICByZXR1cm4gXCIkXCI7XG4gIH1cbiAgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLnN0cmluZ19zdGFydCkge1xuICAgIHJldHVybiBcIl5cIjtcbiAgfVxuICBpZiAoa2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMud29yZF9ib3VuZGFyeSkge1xuICAgIHJldHVybiBuZWdhdGUgPyByYFxcQmAgOiByYFxcYmA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGFzc2VydGlvbiBraW5kIFwiJHtraW5kfVwiYCk7XG59XG5mdW5jdGlvbiBnZW5CYWNrcmVmZXJlbmNlKHsgcmVmIH0sIHN0YXRlKSB7XG4gIGlmICh0eXBlb2YgcmVmICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBuYW1lZCBiYWNrcmVmIGluIHRyYW5zZm9ybWVkIEFTVFwiKTtcbiAgfVxuICBpZiAoIXN0YXRlLnVzZUZsYWdNb2RzICYmIHN0YXRlLmFjY3VyYWN5ID09PSBcInN0cmljdFwiICYmIHN0YXRlLmN1cnJlbnRGbGFncy5pZ25vcmVDYXNlICYmICFzdGF0ZS5jYXB0dXJlTWFwLmdldChyZWYpLmlnbm9yZUNhc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2Ugb2YgY2FzZS1pbnNlbnNpdGl2ZSBiYWNrcmVmIHRvIGNhc2Utc2Vuc2l0aXZlIGdyb3VwIHJlcXVpcmVzIHRhcmdldCBFUzIwMjUgb3Igbm9uLXN0cmljdCBhY2N1cmFjeVwiKTtcbiAgfVxuICByZXR1cm4gXCJcXFxcXCIgKyByZWY7XG59XG5mdW5jdGlvbiBnZW5DYXB0dXJpbmdHcm91cCh7IG5hbWUsIG51bWJlciwgYWx0ZXJuYXRpdmVzLCBfb3JpZ2luTnVtYmVyIH0sIHN0YXRlLCBnZW4pIHtcbiAgc3RhdGUuY2FwdHVyZU1hcC5zZXQobnVtYmVyLCB7IGlnbm9yZUNhc2U6IHN0YXRlLmN1cnJlbnRGbGFncy5pZ25vcmVDYXNlIH0pO1xuICByZXR1cm4gYCgke25hbWUgPyBgPzwke25hbWV9PmAgOiBcIlwifSR7IXN0YXRlLmF2b2lkU3ViY2xhc3MgJiYgX29yaWdpbk51bWJlciA/IChcbiAgICAvLyBBbGwgY2FwdHVyZXMgZnJvbS93aXRoaW4gZXhwYW5kZWQgc3Vicm91dGluZXMgYXJlIG1hcmtlZCBhcyBlbXVsYXRpb24gZ3JvdXBzLCBhbmQgc29tZSBhcmVcbiAgICAvLyBzcGVjaWFsbHkgbWFya2VkIGFzIGVtdWxhdGlvbiBncm91cHMgd2l0aCB0cmFuc2Zlci4gYG51bWJlcmAgaXMgYmFzZWQgb24gdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAvLyBzdWJyb3V0aW5lIGV4cGFuc2lvbiwgd2hlcmVhcyBgX29yaWdpbk51bWJlcmAgcG9pbnRzIHRvIHRoZSBvcmlnaW4gY2FwdHVyZSBvZiBhbiBleHBhbmRlZFxuICAgIC8vIHN1YnJvdXRpbmUgKG9yIGNoaWxkIGNhcHR1cmUpICpwcmlvciogdG8gc3Vicm91dGluZSBleHBhbnNpb24uIGBfb3JpZ2luTnVtYmVyYCBpc1xuICAgIC8vIGB1bmRlZmluZWRgIGlmIHRoZSBjdXJyZW50IGNhcHR1cmUgaXNuJ3QgZnJvbSBhbiBleHBhbmRlZCBzdWJyb3V0aW5lXG4gICAgYCR7X29yaWdpbk51bWJlciA8IG51bWJlciA/IGAkJHtfb3JpZ2luTnVtYmVyfWAgOiBcIlwifSR7ZW11bGF0aW9uR3JvdXBNYXJrZXJ9YFxuICApIDogXCJcIn0ke2FsdGVybmF0aXZlcy5tYXAoZ2VuKS5qb2luKFwifFwiKX0pYDtcbn1cbmZ1bmN0aW9uIGdlbkNoYXJhY3Rlcih7IHZhbHVlIH0sIHN0YXRlKSB7XG4gIGNvbnN0IGNoYXIgPSBjcCh2YWx1ZSk7XG4gIGNvbnN0IGVzY2FwZWQgPSBnZXRDaGFyRXNjYXBlKHZhbHVlLCB7XG4gICAgaXNBZnRlckJhY2tyZWY6IHN0YXRlLmxhc3ROb2RlLnR5cGUgPT09IEFzdFR5cGVzLkJhY2tyZWZlcmVuY2UsXG4gICAgaW5DaGFyQ2xhc3M6IHN0YXRlLmluQ2hhckNsYXNzLFxuICAgIHVzZUZsYWdWOiBzdGF0ZS51c2VGbGFnVlxuICB9KTtcbiAgaWYgKGVzY2FwZWQgIT09IGNoYXIpIHtcbiAgICByZXR1cm4gZXNjYXBlZDtcbiAgfVxuICBpZiAoc3RhdGUudXNlQXBwbGllZElnbm9yZUNhc2UgJiYgc3RhdGUuY3VycmVudEZsYWdzLmlnbm9yZUNhc2UgJiYgY2hhckhhc0Nhc2UoY2hhcikpIHtcbiAgICBjb25zdCBjYXNlcyA9IGdldElnbm9yZUNhc2VNYXRjaENoYXJzKGNoYXIpO1xuICAgIHJldHVybiBzdGF0ZS5pbkNoYXJDbGFzcyA/IGNhc2VzLmpvaW4oXCJcIikgOiBjYXNlcy5sZW5ndGggPiAxID8gYFske2Nhc2VzLmpvaW4oXCJcIil9XWAgOiBjYXNlc1swXTtcbiAgfVxuICByZXR1cm4gY2hhcjtcbn1cbmZ1bmN0aW9uIGdlbkNoYXJhY3RlckNsYXNzKHsgbmVnYXRlLCBwYXJlbnQsIGVsZW1lbnRzIH0sIHN0YXRlLCBnZW4pIHtcbiAgY29uc3QgZ2VuQ2xhc3MgPSAoKSA9PiBgWyR7bmVnYXRlID8gXCJeXCIgOiBcIlwifSR7ZWxlbWVudHMubWFwKGdlbikuam9pbihcIlwiKX1dYDtcbiAgaWYgKCFzdGF0ZS5pbkNoYXJDbGFzcykge1xuICAgIHN0YXRlLmluQ2hhckNsYXNzID0gdHJ1ZTtcbiAgICBjb25zdCByZXN1bHQgPSBnZW5DbGFzcygpO1xuICAgIHN0YXRlLmluQ2hhckNsYXNzID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBmaXJzdFR5cGUgPSBlbGVtZW50c1swXT8udHlwZTtcbiAgaWYgKCFuZWdhdGUgJiYgZmlyc3RUeXBlICYmIC8vIEFsbG93cyBtYW55IG5lc3RlZCBjbGFzc2VzIHRvIHdvcmsgd2l0aCBgdGFyZ2V0YCBFUzIwMTggd2hpY2ggZG9lc24ndCBzdXBwb3J0IG5lc3RpbmdcbiAgKCghc3RhdGUudXNlRmxhZ1YgfHwgIXN0YXRlLnZlcmJvc2UpICYmIHBhcmVudC50eXBlID09PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzcyAmJiBmaXJzdFR5cGUgIT09IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uIHx8ICFzdGF0ZS52ZXJib3NlICYmIHBhcmVudC50eXBlID09PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbiAmJiAvLyBKUyBkb2Vzbid0IGFsbG93IGludGVyc2VjdGlvbiB3aXRoIHVuaW9uIG9yIHJhbmdlc1xuICBlbGVtZW50cy5sZW5ndGggPT09IDEgJiYgZmlyc3RUeXBlICE9PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzcyAmJiBmaXJzdFR5cGUgIT09IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzUmFuZ2UpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzLm1hcChnZW4pLmpvaW4oXCJcIik7XG4gIH1cbiAgaWYgKCFzdGF0ZS51c2VGbGFnViAmJiBwYXJlbnQudHlwZSA9PT0gQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2Ugb2YgbmVzdGVkIGNoYXJhY3RlciBjbGFzcyByZXF1aXJlcyBtaW4gdGFyZ2V0IEVTMjAyNFwiKTtcbiAgfVxuICByZXR1cm4gZ2VuQ2xhc3MoKTtcbn1cbmZ1bmN0aW9uIGdlbkNoYXJhY3RlckNsYXNzUmFuZ2Uobm9kZSwgc3RhdGUpIHtcbiAgY29uc3QgbWluID0gbm9kZS5taW4udmFsdWU7XG4gIGNvbnN0IG1heCA9IG5vZGUubWF4LnZhbHVlO1xuICBjb25zdCBlc2NPcHRzID0ge1xuICAgIGlzQWZ0ZXJCYWNrcmVmOiBmYWxzZSxcbiAgICBpbkNoYXJDbGFzczogdHJ1ZSxcbiAgICB1c2VGbGFnVjogc3RhdGUudXNlRmxhZ1ZcbiAgfTtcbiAgY29uc3QgbWluU3RyID0gZ2V0Q2hhckVzY2FwZShtaW4sIGVzY09wdHMpO1xuICBjb25zdCBtYXhTdHIgPSBnZXRDaGFyRXNjYXBlKG1heCwgZXNjT3B0cyk7XG4gIGNvbnN0IGV4dHJhQ2hhcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoc3RhdGUudXNlQXBwbGllZElnbm9yZUNhc2UgJiYgc3RhdGUuY3VycmVudEZsYWdzLmlnbm9yZUNhc2UpIHtcbiAgICBjb25zdCBjaGFyc091dHNpZGVSYW5nZSA9IGdldENhc2VzT3V0c2lkZUNoYXJDbGFzc1JhbmdlKG5vZGUpO1xuICAgIGNvbnN0IHJhbmdlcyA9IGdldENvZGVQb2ludFJhbmdlc0Zyb21DaGFycyhjaGFyc091dHNpZGVSYW5nZSk7XG4gICAgcmFuZ2VzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICBleHRyYUNoYXJzLmFkZChcbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBgJHtnZXRDaGFyRXNjYXBlKHZhbHVlWzBdLCBlc2NPcHRzKX0tJHtnZXRDaGFyRXNjYXBlKHZhbHVlWzFdLCBlc2NPcHRzKX1gIDogZ2V0Q2hhckVzY2FwZSh2YWx1ZSwgZXNjT3B0cylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGAke21pblN0cn0tJHttYXhTdHJ9JHtbLi4uZXh0cmFDaGFyc10uam9pbihcIlwiKX1gO1xufVxuZnVuY3Rpb24gZ2VuQ2hhcmFjdGVyU2V0KHsga2luZCwgbmVnYXRlLCB2YWx1ZSwga2V5IH0sIHN0YXRlKSB7XG4gIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5kb3QpIHtcbiAgICByZXR1cm4gc3RhdGUuY3VycmVudEZsYWdzLmRvdEFsbCA/IHN0YXRlLmFwcGxpZWRHbG9iYWxGbGFncy5kb3RBbGwgfHwgc3RhdGUudXNlRmxhZ01vZHMgPyBcIi5cIiA6IFwiW15dXCIgOiAoXG4gICAgICAvLyBPbmlnJ3Mgb25seSBsaW5lIGJyZWFrIGNoYXIgaXMgbGluZSBmZWVkLCB1bmxpa2UgSlNcbiAgICAgIHJgW15cXG5dYFxuICAgICk7XG4gIH1cbiAgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLmRpZ2l0KSB7XG4gICAgcmV0dXJuIG5lZ2F0ZSA/IHJgXFxEYCA6IHJgXFxkYDtcbiAgfVxuICBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMucHJvcGVydHkpIHtcbiAgICBpZiAoc3RhdGUudXNlQXBwbGllZElnbm9yZUNhc2UgJiYgc3RhdGUuY3VycmVudEZsYWdzLmlnbm9yZUNhc2UgJiYgVW5pY29kZVByb3BlcnRpZXNXaXRoU3BlY2lmaWNDYXNlLmhhcyh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5pY29kZSBwcm9wZXJ0eSBcIiR7dmFsdWV9XCIgY2FuJ3QgYmUgY2FzZS1pbnNlbnNpdGl2ZSB3aGVuIG90aGVyIGNoYXJzIGhhdmUgc3BlY2lmaWMgY2FzZWApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bmVnYXRlID8gcmBcXFBgIDogcmBcXHBgfXske2tleSA/IGAke2tleX09YCA6IFwiXCJ9JHt2YWx1ZX19YDtcbiAgfVxuICBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMud29yZCkge1xuICAgIHJldHVybiBuZWdhdGUgPyByYFxcV2AgOiByYFxcd2A7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBzZXQga2luZCBcIiR7a2luZH1cImApO1xufVxuZnVuY3Rpb24gZ2VuRmxhZ3Mobm9kZSwgc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBUaGUgdHJhbnNmb3JtZXIgc2hvdWxkIG5ldmVyIHR1cm4gb24gdGhlIHByb3BlcnRpZXMgZm9yIGZsYWdzIGQsIGcsIGFuZCBtIHNpbmNlIE9uaWcgZG9lc24ndFxuICAgIC8vIGhhdmUgZXF1aXZzLiBGbGFnIG0gaXMgbmV2ZXIgcmVsaWVkIG9uIHNpbmNlIE9uaWcgdXNlcyBkaWZmZXJlbnQgbGluZSBicmVhayBjaGFycyB0aGFuIEpTXG4gICAgLy8gKG5vZGUuaGFzSW5kaWNlcyA/ICdkJyA6ICcnKSArXG4gICAgLy8gKG5vZGUuZ2xvYmFsID8gJ2cnIDogJycpICtcbiAgICAvLyAobm9kZS5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgIChzdGF0ZS5hcHBsaWVkR2xvYmFsRmxhZ3MuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAobm9kZS5kb3RBbGwgPyBcInNcIiA6IFwiXCIpICsgKG5vZGUuc3RpY2t5ID8gXCJ5XCIgOiBcIlwiKVxuICApO1xufVxuZnVuY3Rpb24gZ2VuR3JvdXAoeyBhdG9taWM6IGF0b21pYzIsIGZsYWdzLCBwYXJlbnQsIGFsdGVybmF0aXZlcyB9LCBzdGF0ZSwgZ2VuKSB7XG4gIGNvbnN0IGN1cnJlbnRGbGFncyA9IHN0YXRlLmN1cnJlbnRGbGFncztcbiAgaWYgKGZsYWdzKSB7XG4gICAgc3RhdGUuY3VycmVudEZsYWdzID0gZ2V0TmV3Q3VycmVudEZsYWdzKGN1cnJlbnRGbGFncywgZmxhZ3MpO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRzID0gYWx0ZXJuYXRpdmVzLm1hcChnZW4pLmpvaW4oXCJ8XCIpO1xuICBjb25zdCByZXN1bHQgPSAhc3RhdGUudmVyYm9zZSAmJiBhbHRlcm5hdGl2ZXMubGVuZ3RoID09PSAxICYmIHBhcmVudC50eXBlICE9PSBBc3RUeXBlcy5RdWFudGlmaWVyICYmICFhdG9taWMyICYmICghc3RhdGUudXNlRmxhZ01vZHMgfHwgIWZsYWdzKSA/IGNvbnRlbnRzIDogYCg/JHtnZXRHcm91cFByZWZpeChhdG9taWMyLCBmbGFncywgc3RhdGUudXNlRmxhZ01vZHMpfSR7Y29udGVudHN9KWA7XG4gIHN0YXRlLmN1cnJlbnRGbGFncyA9IGN1cnJlbnRGbGFncztcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdlblJlY3Vyc2lvbih7IHJlZiB9LCBzdGF0ZSkge1xuICBjb25zdCBsaW1pdCA9IHN0YXRlLnJlY3Vyc2lvbkxpbWl0O1xuICByZXR1cm4gcmVmID09PSAwID8gYCg/Uj0ke2xpbWl0fSlgIDogcmBcXGc8JHtyZWZ9JlI9JHtsaW1pdH0+YDtcbn1cbmZ1bmN0aW9uIGdldENhc2VzT3V0c2lkZUNoYXJDbGFzc1JhbmdlKG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZmlyc3RPbmx5ID0gISFvcHRpb25zPy5maXJzdE9ubHk7XG4gIGNvbnN0IG1pbiA9IG5vZGUubWluLnZhbHVlO1xuICBjb25zdCBtYXggPSBub2RlLm1heC52YWx1ZTtcbiAgY29uc3QgZm91bmQgPSBbXTtcbiAgaWYgKG1pbiA8IDY1ICYmIChtYXggPT09IDY1NTM1IHx8IG1heCA+PSAxMzEwNzEpIHx8IG1pbiA9PT0gNjU1MzYgJiYgbWF4ID49IDEzMTA3MSkge1xuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuICBmb3IgKGxldCBpID0gbWluOyBpIDw9IG1heDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IGNwKGkpO1xuICAgIGlmICghY2hhckhhc0Nhc2UoY2hhcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjaGFyc091dHNpZGVSYW5nZSA9IGdldElnbm9yZUNhc2VNYXRjaENoYXJzKGNoYXIpLmZpbHRlcigoY2FzZU9mQ2hhcikgPT4ge1xuICAgICAgY29uc3QgbnVtID0gY2FzZU9mQ2hhci5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIHJldHVybiBudW0gPCBtaW4gfHwgbnVtID4gbWF4O1xuICAgIH0pO1xuICAgIGlmIChjaGFyc091dHNpZGVSYW5nZS5sZW5ndGgpIHtcbiAgICAgIGZvdW5kLnB1c2goLi4uY2hhcnNPdXRzaWRlUmFuZ2UpO1xuICAgICAgaWYgKGZpcnN0T25seSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gZ2V0Q2hhckVzY2FwZShjb2RlUG9pbnQsIHsgaXNBZnRlckJhY2tyZWYsIGluQ2hhckNsYXNzLCB1c2VGbGFnViB9KSB7XG4gIGlmIChDaGFyQ29kZUVzY2FwZU1hcC5oYXMoY29kZVBvaW50KSkge1xuICAgIHJldHVybiBDaGFyQ29kZUVzY2FwZU1hcC5nZXQoY29kZVBvaW50KTtcbiAgfVxuICBpZiAoXG4gICAgLy8gQ29udHJvbCBjaGFycywgZXRjLjsgY29uZGl0aW9uIG1vZGVsZWQgb24gdGhlIENocm9tZSBkZXZlbG9wZXIgY29uc29sZSdzIGRpc3BsYXkgZm9yIHN0cmluZ3NcbiAgICBjb2RlUG9pbnQgPCAzMiB8fCBjb2RlUG9pbnQgPiAxMjYgJiYgY29kZVBvaW50IDwgMTYwIHx8IC8vIFVuaWNvZGUgcGxhbmVzIDQtMTY7IHVuYXNzaWduZWQsIHNwZWNpYWwgcHVycG9zZSwgYW5kIHByaXZhdGUgdXNlIGFyZWFcbiAgICBjb2RlUG9pbnQgPiAyNjIxNDMgfHwgLy8gQXZvaWQgY29ycnVwdGluZyBhIHByZWNlZGluZyBiYWNrcmVmIGJ5IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBpdCB3aXRoIGEgbGl0ZXJhbCBkaWdpdFxuICAgIGlzQWZ0ZXJCYWNrcmVmICYmIGlzRGlnaXRDaGFyQ29kZShjb2RlUG9pbnQpXG4gICkge1xuICAgIHJldHVybiBjb2RlUG9pbnQgPiAyNTUgPyBgXFxcXHV7JHtjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9fWAgOiBgXFxcXHgke2NvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCBcIjBcIil9YDtcbiAgfVxuICBjb25zdCBlc2NhcGVDaGFycyA9IGluQ2hhckNsYXNzID8gdXNlRmxhZ1YgPyBDaGFyQ2xhc3NFc2NhcGVDaGFyc0ZsYWdWIDogQ2hhckNsYXNzRXNjYXBlQ2hhcnMgOiBCYXNlRXNjYXBlQ2hhcnM7XG4gIGNvbnN0IGNoYXIgPSBjcChjb2RlUG9pbnQpO1xuICByZXR1cm4gKGVzY2FwZUNoYXJzLmhhcyhjaGFyKSA/IFwiXFxcXFwiIDogXCJcIikgKyBjaGFyO1xufVxuZnVuY3Rpb24gZ2V0Q29kZVBvaW50UmFuZ2VzRnJvbUNoYXJzKGNoYXJzKSB7XG4gIGNvbnN0IGNvZGVQb2ludHMgPSBjaGFycy5tYXAoKGNoYXIpID0+IGNoYXIuY29kZVBvaW50QXQoMCkpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGxldCBzdGFydCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjb2RlUG9pbnRzW2kgKyAxXSA9PT0gY29kZVBvaW50c1tpXSArIDEpIHtcbiAgICAgIHN0YXJ0ID8/PSBjb2RlUG9pbnRzW2ldO1xuICAgIH0gZWxzZSBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgIHZhbHVlcy5wdXNoKGNvZGVQb2ludHNbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMucHVzaChbc3RhcnQsIGNvZGVQb2ludHNbaV1dKTtcbiAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldEdyb3VwUHJlZml4KGF0b21pYzIsIGZsYWdNb2RzLCB1c2VGbGFnTW9kcykge1xuICBpZiAoYXRvbWljMikge1xuICAgIHJldHVybiBcIj5cIjtcbiAgfVxuICBsZXQgbW9kcyA9IFwiXCI7XG4gIGlmIChmbGFnTW9kcyAmJiB1c2VGbGFnTW9kcykge1xuICAgIGNvbnN0IHsgZW5hYmxlLCBkaXNhYmxlIH0gPSBmbGFnTW9kcztcbiAgICBtb2RzID0gKGVuYWJsZT8uaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAoZW5hYmxlPy5kb3RBbGwgPyBcInNcIiA6IFwiXCIpICsgKGRpc2FibGUgPyBcIi1cIiA6IFwiXCIpICsgKGRpc2FibGU/Lmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpICsgKGRpc2FibGU/LmRvdEFsbCA/IFwic1wiIDogXCJcIik7XG4gIH1cbiAgcmV0dXJuIGAke21vZHN9OmA7XG59XG5mdW5jdGlvbiBnZXRRdWFudGlmaWVyU3RyKHsgbWluLCBtYXgsIGdyZWVkeSwgcG9zc2Vzc2l2ZTogcG9zc2Vzc2l2ZTIgfSkge1xuICBsZXQgYmFzZTtcbiAgaWYgKCFtaW4gJiYgbWF4ID09PSAxKSB7XG4gICAgYmFzZSA9IFwiP1wiO1xuICB9IGVsc2UgaWYgKCFtaW4gJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgIGJhc2UgPSBcIipcIjtcbiAgfSBlbHNlIGlmIChtaW4gPT09IDEgJiYgbWF4ID09PSBJbmZpbml0eSkge1xuICAgIGJhc2UgPSBcIitcIjtcbiAgfSBlbHNlIGlmIChtaW4gPT09IG1heCkge1xuICAgIGJhc2UgPSBgeyR7bWlufX1gO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgPSBgeyR7bWlufSwke21heCA9PT0gSW5maW5pdHkgPyBcIlwiIDogbWF4fX1gO1xuICB9XG4gIHJldHVybiBiYXNlICsgKHBvc3Nlc3NpdmUyID8gXCIrXCIgOiBncmVlZHkgPyBcIlwiIDogXCI/XCIpO1xufVxuZnVuY3Rpb24gaXNEaWdpdENoYXJDb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA+IDQ3ICYmIHZhbHVlIDwgNTg7XG59XG5cbi8vIHNyYy9pbmRleC5qc1xuaW1wb3J0IHsgYXRvbWljLCBlbXVsYXRpb25Hcm91cE1hcmtlciBhcyBlbXVsYXRpb25Hcm91cE1hcmtlcjIsIHBvc3Nlc3NpdmUgfSBmcm9tIFwicmVnZXgvaW50ZXJuYWxzXCI7XG5pbXBvcnQgeyByZWN1cnNpb24gfSBmcm9tIFwicmVnZXgtcmVjdXJzaW9uXCI7XG5mdW5jdGlvbiB0b0RldGFpbHMocGF0dGVybiwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgYXZvaWRTdWJjbGFzcyA9IG9wdHMuYXZvaWRTdWJjbGFzcztcbiAgY29uc3QgdG9rZW5pemVkID0gdG9rZW5pemUocGF0dGVybiwgb3B0cy5mbGFncywgeyBjYXB0dXJlR3JvdXA6IG9wdHMucnVsZXMuY2FwdHVyZUdyb3VwIH0pO1xuICBjb25zdCBvbmlndXJ1bWFBc3QgPSBwYXJzZSh0b2tlbml6ZWQsIHtcbiAgICBza2lwQmFja3JlZlZhbGlkYXRpb246IG9wdHMucnVsZXMuYWxsb3dPcnBoYW5CYWNrcmVmcyxcbiAgICB2ZXJib3NlOiBvcHRzLnZlcmJvc2VcbiAgfSk7XG4gIGNvbnN0IHJlZ2V4QXN0ID0gdHJhbnNmb3JtKG9uaWd1cnVtYUFzdCwge1xuICAgIGFjY3VyYWN5OiBvcHRzLmFjY3VyYWN5LFxuICAgIGFzY2lpV29yZEJvdW5kYXJpZXM6IG9wdHMucnVsZXMuYXNjaWlXb3JkQm91bmRhcmllcyxcbiAgICBhdm9pZFN1YmNsYXNzLFxuICAgIGJlc3RFZmZvcnRUYXJnZXQ6IG9wdHMudGFyZ2V0LFxuICAgIGlnbm9yZVVuc3VwcG9ydGVkR0FuY2hvcnM6IG9wdHMucnVsZXMuaWdub3JlVW5zdXBwb3J0ZWRHQW5jaG9yc1xuICB9KTtcbiAgY29uc3QgZ2VuZXJhdGVkID0gZ2VuZXJhdGUocmVnZXhBc3QsIG9wdHMpO1xuICBjb25zdCBwbHVnaW5EYXRhID0geyB1c2VFbXVsYXRpb25Hcm91cHM6ICFhdm9pZFN1YmNsYXNzIH07XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBwYXR0ZXJuOiBhdG9taWMocG9zc2Vzc2l2ZShyZWN1cnNpb24oZ2VuZXJhdGVkLnBhdHRlcm4sIHBsdWdpbkRhdGEpKSwgcGx1Z2luRGF0YSksXG4gICAgZmxhZ3M6IGAke29wdHMuaGFzSW5kaWNlcyA/IFwiZFwiIDogXCJcIn0ke29wdHMuZ2xvYmFsID8gXCJnXCIgOiBcIlwifSR7Z2VuZXJhdGVkLmZsYWdzfSR7Z2VuZXJhdGVkLm9wdGlvbnMuZGlzYWJsZS52ID8gXCJ1XCIgOiBcInZcIn1gXG4gIH07XG4gIGNvbnN0IHVzZUVtdWxhdGlvbkdyb3VwcyA9ICFhdm9pZFN1YmNsYXNzICYmIHJlc3VsdC5wYXR0ZXJuLmluY2x1ZGVzKGVtdWxhdGlvbkdyb3VwTWFya2VyMik7XG4gIGNvbnN0IHN0cmF0ZWd5ID0gcmVnZXhBc3QuX3N0cmF0ZWd5O1xuICBpZiAodXNlRW11bGF0aW9uR3JvdXBzIHx8IHN0cmF0ZWd5KSB7XG4gICAgcmVzdWx0Lm9wdGlvbnMgPSB7XG4gICAgICAuLi5zdHJhdGVneSA/IHsgc3RyYXRlZ3kgfSA6IG51bGwsXG4gICAgICAuLi51c2VFbXVsYXRpb25Hcm91cHMgPyB7IHVzZUVtdWxhdGlvbkdyb3VwcyB9IDogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvT25pZ3VydW1hQXN0KHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgZmxhZ3MgPSBvcHRpb25zPy5mbGFncyA/PyBcIlwiO1xuICBjb25zdCBjYXB0dXJlR3JvdXAgPSBvcHRpb25zPy5ydWxlcz8uY2FwdHVyZUdyb3VwID8/IGZhbHNlO1xuICByZXR1cm4gcGFyc2UodG9rZW5pemUocGF0dGVybiwgZmxhZ3MsIHsgY2FwdHVyZUdyb3VwIH0pKTtcbn1cbmZ1bmN0aW9uIHRvUmVnRXhwKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gdG9EZXRhaWxzKHBhdHRlcm4sIG9wdGlvbnMpO1xuICBpZiAocmVzdWx0Lm9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEVtdWxhdGVkUmVnRXhwKHJlc3VsdC5wYXR0ZXJuLCByZXN1bHQuZmxhZ3MsIHJlc3VsdC5vcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlZ0V4cChyZXN1bHQucGF0dGVybiwgcmVzdWx0LmZsYWdzKTtcbn1cbmV4cG9ydCB7XG4gIEVtdWxhdGVkUmVnRXhwLFxuICB0b0RldGFpbHMsXG4gIHRvT25pZ3VydW1hQXN0LFxuICB0b1JlZ0V4cFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/oniguruma-to-es@1.0.0/node_modules/oniguruma-to-es/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   find: () => (/* reexport safe */ _lib_find_js__WEBPACK_IMPORTED_MODULE_0__.find),\n/* harmony export */   hastToReact: () => (/* reexport safe */ _lib_hast_to_react_js__WEBPACK_IMPORTED_MODULE_1__.hastToReact),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   normalize: () => (/* reexport safe */ _lib_normalize_js__WEBPACK_IMPORTED_MODULE_2__.normalize),\n/* harmony export */   svg: () => (/* binding */ svg)\n/* harmony export */ });\n/* harmony import */ var _lib_util_merge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/util/merge.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/merge.js\");\n/* harmony import */ var _lib_xlink_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/xlink.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xlink.js\");\n/* harmony import */ var _lib_xml_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/xml.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xml.js\");\n/* harmony import */ var _lib_xmlns_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/xmlns.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xmlns.js\");\n/* harmony import */ var _lib_aria_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/aria.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/aria.js\");\n/* harmony import */ var _lib_html_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/html.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/html.js\");\n/* harmony import */ var _lib_svg_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/svg.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/svg.js\");\n/* harmony import */ var _lib_find_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/find.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/find.js\");\n/* harmony import */ var _lib_hast_to_react_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/hast-to-react.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/hast-to-react.js\");\n/* harmony import */ var _lib_normalize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/normalize.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/normalize.js\");\n/**\n * @typedef {import('./lib/util/info.js').Info} Info\n * @typedef {import('./lib/util/schema.js').Schema} Schema\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst html = (0,_lib_util_merge_js__WEBPACK_IMPORTED_MODULE_3__.merge)([_lib_xml_js__WEBPACK_IMPORTED_MODULE_4__.xml, _lib_xlink_js__WEBPACK_IMPORTED_MODULE_5__.xlink, _lib_xmlns_js__WEBPACK_IMPORTED_MODULE_6__.xmlns, _lib_aria_js__WEBPACK_IMPORTED_MODULE_7__.aria, _lib_html_js__WEBPACK_IMPORTED_MODULE_8__.html], 'html')\nconst svg = (0,_lib_util_merge_js__WEBPACK_IMPORTED_MODULE_3__.merge)([_lib_xml_js__WEBPACK_IMPORTED_MODULE_4__.xml, _lib_xlink_js__WEBPACK_IMPORTED_MODULE_5__.xlink, _lib_xmlns_js__WEBPACK_IMPORTED_MODULE_6__.xmlns, _lib_aria_js__WEBPACK_IMPORTED_MODULE_7__.aria, _lib_svg_js__WEBPACK_IMPORTED_MODULE_9__.svg], 'svg')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLHVDQUF1QztBQUNwRDs7QUFFeUM7QUFDTDtBQUNKO0FBQ0k7QUFDRjtBQUNZO0FBQ0g7O0FBRVQ7QUFDZ0I7QUFDTjtBQUNyQyxhQUFhLHlEQUFLLEVBQUUsNENBQUcsRUFBRSxnREFBSyxFQUFFLGdEQUFLLEVBQUUsOENBQUksRUFBRSw4Q0FBUTtBQUNyRCxZQUFZLHlEQUFLLEVBQUUsNENBQUcsRUFBRSxnREFBSyxFQUFFLGdEQUFLLEVBQUUsOENBQUksRUFBRSw0Q0FBTyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi91dGlsL2luZm8uanMnKS5JbmZvfSBJbmZvXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2xpYi91dGlsL3NjaGVtYS5qcycpLlNjaGVtYX0gU2NoZW1hXG4gKi9cblxuaW1wb3J0IHttZXJnZX0gZnJvbSAnLi9saWIvdXRpbC9tZXJnZS5qcydcbmltcG9ydCB7eGxpbmt9IGZyb20gJy4vbGliL3hsaW5rLmpzJ1xuaW1wb3J0IHt4bWx9IGZyb20gJy4vbGliL3htbC5qcydcbmltcG9ydCB7eG1sbnN9IGZyb20gJy4vbGliL3htbG5zLmpzJ1xuaW1wb3J0IHthcmlhfSBmcm9tICcuL2xpYi9hcmlhLmpzJ1xuaW1wb3J0IHtodG1sIGFzIGh0bWxCYXNlfSBmcm9tICcuL2xpYi9odG1sLmpzJ1xuaW1wb3J0IHtzdmcgYXMgc3ZnQmFzZX0gZnJvbSAnLi9saWIvc3ZnLmpzJ1xuXG5leHBvcnQge2ZpbmR9IGZyb20gJy4vbGliL2ZpbmQuanMnXG5leHBvcnQge2hhc3RUb1JlYWN0fSBmcm9tICcuL2xpYi9oYXN0LXRvLXJlYWN0LmpzJ1xuZXhwb3J0IHtub3JtYWxpemV9IGZyb20gJy4vbGliL25vcm1hbGl6ZS5qcydcbmV4cG9ydCBjb25zdCBodG1sID0gbWVyZ2UoW3htbCwgeGxpbmssIHhtbG5zLCBhcmlhLCBodG1sQmFzZV0sICdodG1sJylcbmV4cG9ydCBjb25zdCBzdmcgPSBtZXJnZShbeG1sLCB4bGluaywgeG1sbnMsIGFyaWEsIHN2Z0Jhc2VdLCAnc3ZnJylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/aria.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/aria.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aria: () => (/* binding */ aria)\n/* harmony export */ });\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/types.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/types.js\");\n/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/create.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/create.js\");\n\n\n\nconst aria = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_0__.create)({\n  transform(_, prop) {\n    return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()\n  },\n  properties: {\n    ariaActiveDescendant: null,\n    ariaAtomic: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaAutoComplete: null,\n    ariaBusy: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaChecked: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaColCount: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaColIndex: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaColSpan: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaControls: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.spaceSeparated,\n    ariaCurrent: null,\n    ariaDescribedBy: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.spaceSeparated,\n    ariaDetails: null,\n    ariaDisabled: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaDropEffect: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.spaceSeparated,\n    ariaErrorMessage: null,\n    ariaExpanded: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaFlowTo: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.spaceSeparated,\n    ariaGrabbed: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaHasPopup: null,\n    ariaHidden: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaInvalid: null,\n    ariaKeyShortcuts: null,\n    ariaLabel: null,\n    ariaLabelledBy: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.spaceSeparated,\n    ariaLevel: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaLive: null,\n    ariaModal: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaMultiLine: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaMultiSelectable: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaOrientation: null,\n    ariaOwns: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.spaceSeparated,\n    ariaPlaceholder: null,\n    ariaPosInSet: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaPressed: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaReadOnly: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaRelevant: null,\n    ariaRequired: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaRoleDescription: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.spaceSeparated,\n    ariaRowCount: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaRowIndex: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaRowSpan: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaSelected: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.booleanish,\n    ariaSetSize: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaSort: null,\n    ariaValueMax: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaValueMin: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaValueNow: _util_types_js__WEBPACK_IMPORTED_MODULE_1__.number,\n    ariaValueText: null,\n    role: null\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL2FyaWEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtFO0FBQzNCOztBQUVoQyxhQUFhLHVEQUFNO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQixzREFBVTtBQUMxQjtBQUNBLGNBQWMsc0RBQVU7QUFDeEIsaUJBQWlCLHNEQUFVO0FBQzNCLGtCQUFrQixrREFBTTtBQUN4QixrQkFBa0Isa0RBQU07QUFDeEIsaUJBQWlCLGtEQUFNO0FBQ3ZCLGtCQUFrQiwwREFBYztBQUNoQztBQUNBLHFCQUFxQiwwREFBYztBQUNuQztBQUNBLGtCQUFrQixzREFBVTtBQUM1QixvQkFBb0IsMERBQWM7QUFDbEM7QUFDQSxrQkFBa0Isc0RBQVU7QUFDNUIsZ0JBQWdCLDBEQUFjO0FBQzlCLGlCQUFpQixzREFBVTtBQUMzQjtBQUNBLGdCQUFnQixzREFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQWM7QUFDbEMsZUFBZSxrREFBTTtBQUNyQjtBQUNBLGVBQWUsc0RBQVU7QUFDekIsbUJBQW1CLHNEQUFVO0FBQzdCLHlCQUF5QixzREFBVTtBQUNuQztBQUNBLGNBQWMsMERBQWM7QUFDNUI7QUFDQSxrQkFBa0Isa0RBQU07QUFDeEIsaUJBQWlCLHNEQUFVO0FBQzNCLGtCQUFrQixzREFBVTtBQUM1QjtBQUNBLGtCQUFrQixzREFBVTtBQUM1Qix5QkFBeUIsMERBQWM7QUFDdkMsa0JBQWtCLGtEQUFNO0FBQ3hCLGtCQUFrQixrREFBTTtBQUN4QixpQkFBaUIsa0RBQU07QUFDdkIsa0JBQWtCLHNEQUFVO0FBQzVCLGlCQUFpQixrREFBTTtBQUN2QjtBQUNBLGtCQUFrQixrREFBTTtBQUN4QixrQkFBa0Isa0RBQU07QUFDeEIsa0JBQWtCLGtEQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi9hcmlhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Ym9vbGVhbmlzaCwgbnVtYmVyLCBzcGFjZVNlcGFyYXRlZH0gZnJvbSAnLi91dGlsL3R5cGVzLmpzJ1xuaW1wb3J0IHtjcmVhdGV9IGZyb20gJy4vdXRpbC9jcmVhdGUuanMnXG5cbmV4cG9ydCBjb25zdCBhcmlhID0gY3JlYXRlKHtcbiAgdHJhbnNmb3JtKF8sIHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJ3JvbGUnID8gcHJvcCA6ICdhcmlhLScgKyBwcm9wLnNsaWNlKDQpLnRvTG93ZXJDYXNlKClcbiAgfSxcbiAgcHJvcGVydGllczoge1xuICAgIGFyaWFBY3RpdmVEZXNjZW5kYW50OiBudWxsLFxuICAgIGFyaWFBdG9taWM6IGJvb2xlYW5pc2gsXG4gICAgYXJpYUF1dG9Db21wbGV0ZTogbnVsbCxcbiAgICBhcmlhQnVzeTogYm9vbGVhbmlzaCxcbiAgICBhcmlhQ2hlY2tlZDogYm9vbGVhbmlzaCxcbiAgICBhcmlhQ29sQ291bnQ6IG51bWJlcixcbiAgICBhcmlhQ29sSW5kZXg6IG51bWJlcixcbiAgICBhcmlhQ29sU3BhbjogbnVtYmVyLFxuICAgIGFyaWFDb250cm9sczogc3BhY2VTZXBhcmF0ZWQsXG4gICAgYXJpYUN1cnJlbnQ6IG51bGwsXG4gICAgYXJpYURlc2NyaWJlZEJ5OiBzcGFjZVNlcGFyYXRlZCxcbiAgICBhcmlhRGV0YWlsczogbnVsbCxcbiAgICBhcmlhRGlzYWJsZWQ6IGJvb2xlYW5pc2gsXG4gICAgYXJpYURyb3BFZmZlY3Q6IHNwYWNlU2VwYXJhdGVkLFxuICAgIGFyaWFFcnJvck1lc3NhZ2U6IG51bGwsXG4gICAgYXJpYUV4cGFuZGVkOiBib29sZWFuaXNoLFxuICAgIGFyaWFGbG93VG86IHNwYWNlU2VwYXJhdGVkLFxuICAgIGFyaWFHcmFiYmVkOiBib29sZWFuaXNoLFxuICAgIGFyaWFIYXNQb3B1cDogbnVsbCxcbiAgICBhcmlhSGlkZGVuOiBib29sZWFuaXNoLFxuICAgIGFyaWFJbnZhbGlkOiBudWxsLFxuICAgIGFyaWFLZXlTaG9ydGN1dHM6IG51bGwsXG4gICAgYXJpYUxhYmVsOiBudWxsLFxuICAgIGFyaWFMYWJlbGxlZEJ5OiBzcGFjZVNlcGFyYXRlZCxcbiAgICBhcmlhTGV2ZWw6IG51bWJlcixcbiAgICBhcmlhTGl2ZTogbnVsbCxcbiAgICBhcmlhTW9kYWw6IGJvb2xlYW5pc2gsXG4gICAgYXJpYU11bHRpTGluZTogYm9vbGVhbmlzaCxcbiAgICBhcmlhTXVsdGlTZWxlY3RhYmxlOiBib29sZWFuaXNoLFxuICAgIGFyaWFPcmllbnRhdGlvbjogbnVsbCxcbiAgICBhcmlhT3duczogc3BhY2VTZXBhcmF0ZWQsXG4gICAgYXJpYVBsYWNlaG9sZGVyOiBudWxsLFxuICAgIGFyaWFQb3NJblNldDogbnVtYmVyLFxuICAgIGFyaWFQcmVzc2VkOiBib29sZWFuaXNoLFxuICAgIGFyaWFSZWFkT25seTogYm9vbGVhbmlzaCxcbiAgICBhcmlhUmVsZXZhbnQ6IG51bGwsXG4gICAgYXJpYVJlcXVpcmVkOiBib29sZWFuaXNoLFxuICAgIGFyaWFSb2xlRGVzY3JpcHRpb246IHNwYWNlU2VwYXJhdGVkLFxuICAgIGFyaWFSb3dDb3VudDogbnVtYmVyLFxuICAgIGFyaWFSb3dJbmRleDogbnVtYmVyLFxuICAgIGFyaWFSb3dTcGFuOiBudW1iZXIsXG4gICAgYXJpYVNlbGVjdGVkOiBib29sZWFuaXNoLFxuICAgIGFyaWFTZXRTaXplOiBudW1iZXIsXG4gICAgYXJpYVNvcnQ6IG51bGwsXG4gICAgYXJpYVZhbHVlTWF4OiBudW1iZXIsXG4gICAgYXJpYVZhbHVlTWluOiBudW1iZXIsXG4gICAgYXJpYVZhbHVlTm93OiBudW1iZXIsXG4gICAgYXJpYVZhbHVlVGV4dDogbnVsbCxcbiAgICByb2xlOiBudWxsXG4gIH1cbn0pXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/aria.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/find.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/find.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   find: () => (/* binding */ find)\n/* harmony export */ });\n/* harmony import */ var _normalize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalize.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/normalize.js\");\n/* harmony import */ var _util_defined_info_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/defined-info.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/defined-info.js\");\n/* harmony import */ var _util_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/info.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/info.js\");\n/**\n * @typedef {import('./util/schema.js').Schema} Schema\n */\n\n\n\n\n\nconst valid = /^data[-\\w.:]+$/i\nconst dash = /-[a-z]/g\nconst cap = /[A-Z]/g\n\n/**\n * @param {Schema} schema\n * @param {string} value\n * @returns {Info}\n */\nfunction find(schema, value) {\n  const normal = (0,_normalize_js__WEBPACK_IMPORTED_MODULE_0__.normalize)(value)\n  let prop = value\n  let Type = _util_info_js__WEBPACK_IMPORTED_MODULE_1__.Info\n\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]]\n  }\n\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\n    // Attribute or property.\n    if (value.charAt(4) === '-') {\n      // Turn it into a property.\n      const rest = value.slice(5).replace(dash, camelcase)\n      prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1)\n    } else {\n      // Turn it into an attribute.\n      const rest = value.slice(4)\n\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab)\n\n        if (dashes.charAt(0) !== '-') {\n          dashes = '-' + dashes\n        }\n\n        value = 'data' + dashes\n      }\n    }\n\n    Type = _util_defined_info_js__WEBPACK_IMPORTED_MODULE_2__.DefinedInfo\n  }\n\n  return new Type(prop, value)\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction kebab($0) {\n  return '-' + $0.toLowerCase()\n}\n\n/**\n * @param {string} $0\n * @returns {string}\n */\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL2ZpbmQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7O0FBRXdDO0FBQ1U7QUFDZjs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTztBQUNQLGlCQUFpQix3REFBUztBQUMxQjtBQUNBLGFBQWEsK0NBQUk7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyw4REFBVztBQUN0Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi9maW5kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi91dGlsL3NjaGVtYS5qcycpLlNjaGVtYX0gU2NoZW1hXG4gKi9cblxuaW1wb3J0IHtub3JtYWxpemV9IGZyb20gJy4vbm9ybWFsaXplLmpzJ1xuaW1wb3J0IHtEZWZpbmVkSW5mb30gZnJvbSAnLi91dGlsL2RlZmluZWQtaW5mby5qcydcbmltcG9ydCB7SW5mb30gZnJvbSAnLi91dGlsL2luZm8uanMnXG5cbmNvbnN0IHZhbGlkID0gL15kYXRhWy1cXHcuOl0rJC9pXG5jb25zdCBkYXNoID0gLy1bYS16XS9nXG5jb25zdCBjYXAgPSAvW0EtWl0vZ1xuXG4vKipcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge0luZm99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKHNjaGVtYSwgdmFsdWUpIHtcbiAgY29uc3Qgbm9ybWFsID0gbm9ybWFsaXplKHZhbHVlKVxuICBsZXQgcHJvcCA9IHZhbHVlXG4gIGxldCBUeXBlID0gSW5mb1xuXG4gIGlmIChub3JtYWwgaW4gc2NoZW1hLm5vcm1hbCkge1xuICAgIHJldHVybiBzY2hlbWEucHJvcGVydHlbc2NoZW1hLm5vcm1hbFtub3JtYWxdXVxuICB9XG5cbiAgaWYgKG5vcm1hbC5sZW5ndGggPiA0ICYmIG5vcm1hbC5zbGljZSgwLCA0KSA9PT0gJ2RhdGEnICYmIHZhbGlkLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gQXR0cmlidXRlIG9yIHByb3BlcnR5LlxuICAgIGlmICh2YWx1ZS5jaGFyQXQoNCkgPT09ICctJykge1xuICAgICAgLy8gVHVybiBpdCBpbnRvIGEgcHJvcGVydHkuXG4gICAgICBjb25zdCByZXN0ID0gdmFsdWUuc2xpY2UoNSkucmVwbGFjZShkYXNoLCBjYW1lbGNhc2UpXG4gICAgICBwcm9wID0gJ2RhdGEnICsgcmVzdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHJlc3Quc2xpY2UoMSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHVybiBpdCBpbnRvIGFuIGF0dHJpYnV0ZS5cbiAgICAgIGNvbnN0IHJlc3QgPSB2YWx1ZS5zbGljZSg0KVxuXG4gICAgICBpZiAoIWRhc2gudGVzdChyZXN0KSkge1xuICAgICAgICBsZXQgZGFzaGVzID0gcmVzdC5yZXBsYWNlKGNhcCwga2ViYWIpXG5cbiAgICAgICAgaWYgKGRhc2hlcy5jaGFyQXQoMCkgIT09ICctJykge1xuICAgICAgICAgIGRhc2hlcyA9ICctJyArIGRhc2hlc1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSAnZGF0YScgKyBkYXNoZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICBUeXBlID0gRGVmaW5lZEluZm9cbiAgfVxuXG4gIHJldHVybiBuZXcgVHlwZShwcm9wLCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gJDBcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGtlYmFiKCQwKSB7XG4gIHJldHVybiAnLScgKyAkMC50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9ICQwXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGNhc2UoJDApIHtcbiAgcmV0dXJuICQwLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/find.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/hast-to-react.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/hast-to-react.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hastToReact: () => (/* binding */ hastToReact)\n/* harmony export */ });\n/**\n * `hast` is close to `React`, but differs in a couple of cases.\n *\n * To get a React property from a hast property, check if it is in\n * `hastToReact`, if it is, then use the corresponding value,\n * otherwise, use the hast property.\n *\n * @type {Record<string, string>}\n */\nconst hastToReact = {\n  classId: 'classID',\n  dataType: 'datatype',\n  itemId: 'itemID',\n  strokeDashArray: 'strokeDasharray',\n  strokeDashOffset: 'strokeDashoffset',\n  strokeLineCap: 'strokeLinecap',\n  strokeLineJoin: 'strokeLinejoin',\n  strokeMiterLimit: 'strokeMiterlimit',\n  typeOf: 'typeof',\n  xLinkActuate: 'xlinkActuate',\n  xLinkArcRole: 'xlinkArcrole',\n  xLinkHref: 'xlinkHref',\n  xLinkRole: 'xlinkRole',\n  xLinkShow: 'xlinkShow',\n  xLinkTitle: 'xlinkTitle',\n  xLinkType: 'xlinkType',\n  xmlnsXLink: 'xmlnsXlink'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL2hhc3QtdG8tcmVhY3QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi9oYXN0LXRvLXJlYWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogYGhhc3RgIGlzIGNsb3NlIHRvIGBSZWFjdGAsIGJ1dCBkaWZmZXJzIGluIGEgY291cGxlIG9mIGNhc2VzLlxuICpcbiAqIFRvIGdldCBhIFJlYWN0IHByb3BlcnR5IGZyb20gYSBoYXN0IHByb3BlcnR5LCBjaGVjayBpZiBpdCBpcyBpblxuICogYGhhc3RUb1JlYWN0YCwgaWYgaXQgaXMsIHRoZW4gdXNlIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLFxuICogb3RoZXJ3aXNlLCB1c2UgdGhlIGhhc3QgcHJvcGVydHkuXG4gKlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXN0VG9SZWFjdCA9IHtcbiAgY2xhc3NJZDogJ2NsYXNzSUQnLFxuICBkYXRhVHlwZTogJ2RhdGF0eXBlJyxcbiAgaXRlbUlkOiAnaXRlbUlEJyxcbiAgc3Ryb2tlRGFzaEFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlRGFzaE9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VMaW5lQ2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZUxpbmVKb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VNaXRlckxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHR5cGVPZjogJ3R5cGVvZicsXG4gIHhMaW5rQWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gIHhMaW5rQXJjUm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gIHhMaW5rSHJlZjogJ3hsaW5rSHJlZicsXG4gIHhMaW5rUm9sZTogJ3hsaW5rUm9sZScsXG4gIHhMaW5rU2hvdzogJ3hsaW5rU2hvdycsXG4gIHhMaW5rVGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgeExpbmtUeXBlOiAneGxpbmtUeXBlJyxcbiAgeG1sbnNYTGluazogJ3htbG5zWGxpbmsnXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/hast-to-react.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/html.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/html.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   html: () => (/* binding */ html)\n/* harmony export */ });\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/types.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/types.js\");\n/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/create.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/create.js\");\n/* harmony import */ var _util_case_insensitive_transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/case-insensitive-transform.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-insensitive-transform.js\");\n\n\n\n\nconst html = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_0__.create)({\n  space: 'html',\n  attributes: {\n    acceptcharset: 'accept-charset',\n    classname: 'class',\n    htmlfor: 'for',\n    httpequiv: 'http-equiv'\n  },\n  transform: _util_case_insensitive_transform_js__WEBPACK_IMPORTED_MODULE_1__.caseInsensitiveTransform,\n  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],\n  properties: {\n    // Standard Properties.\n    abbr: null,\n    accept: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaSeparated,\n    acceptCharset: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    accessKey: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    action: null,\n    allow: null,\n    allowFullScreen: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    allowPaymentRequest: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    allowUserMedia: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    alt: null,\n    as: null,\n    async: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    autoCapitalize: null,\n    autoComplete: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    autoFocus: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    autoPlay: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    blocking: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    capture: null,\n    charSet: null,\n    checked: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    cite: null,\n    className: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    cols: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    colSpan: null,\n    content: null,\n    contentEditable: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.booleanish,\n    controls: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    controlsList: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    coords: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number | _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaSeparated,\n    crossOrigin: null,\n    data: null,\n    dateTime: null,\n    decoding: null,\n    default: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    defer: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    dir: null,\n    dirName: null,\n    disabled: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    download: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.overloadedBoolean,\n    draggable: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.booleanish,\n    encType: null,\n    enterKeyHint: null,\n    fetchPriority: null,\n    form: null,\n    formAction: null,\n    formEncType: null,\n    formMethod: null,\n    formNoValidate: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    formTarget: null,\n    headers: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    height: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    hidden: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    high: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    href: null,\n    hrefLang: null,\n    htmlFor: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    httpEquiv: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    id: null,\n    imageSizes: null,\n    imageSrcSet: null,\n    inert: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    inputMode: null,\n    integrity: null,\n    is: null,\n    isMap: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    itemId: null,\n    itemProp: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    itemRef: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    itemScope: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    itemType: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    kind: null,\n    label: null,\n    lang: null,\n    language: null,\n    list: null,\n    loading: null,\n    loop: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    low: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    manifest: null,\n    max: null,\n    maxLength: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    media: null,\n    method: null,\n    min: null,\n    minLength: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    multiple: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    muted: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    name: null,\n    nonce: null,\n    noModule: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    noValidate: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    onAbort: null,\n    onAfterPrint: null,\n    onAuxClick: null,\n    onBeforeMatch: null,\n    onBeforePrint: null,\n    onBeforeToggle: null,\n    onBeforeUnload: null,\n    onBlur: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onContextLost: null,\n    onContextMenu: null,\n    onContextRestored: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFormData: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLanguageChange: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadEnd: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMessageError: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRejectionHandled: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onScrollEnd: null,\n    onSecurityPolicyViolation: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onSlotChange: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnhandledRejection: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onWheel: null,\n    open: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    optimum: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    pattern: null,\n    ping: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    placeholder: null,\n    playsInline: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    popover: null,\n    popoverTarget: null,\n    popoverTargetAction: null,\n    poster: null,\n    preload: null,\n    readOnly: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    referrerPolicy: null,\n    rel: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    required: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    reversed: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    rows: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    rowSpan: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    sandbox: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    scope: null,\n    scoped: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    seamless: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    selected: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    shadowRootClonable: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    shadowRootDelegatesFocus: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    shadowRootMode: null,\n    shape: null,\n    size: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    sizes: null,\n    slot: null,\n    span: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    spellCheck: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.booleanish,\n    src: null,\n    srcDoc: null,\n    srcLang: null,\n    srcSet: null,\n    start: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    step: null,\n    style: null,\n    tabIndex: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    target: null,\n    title: null,\n    translate: null,\n    type: null,\n    typeMustMatch: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    useMap: null,\n    value: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.booleanish,\n    width: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    wrap: null,\n    writingSuggestions: null,\n\n    // Legacy.\n    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n    align: null, // Several. Use CSS `text-align` instead,\n    aLink: null, // `<body>`. Use CSS `a:active {color}` instead\n    archive: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated, // `<object>`. List of URIs to archives\n    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`\n    background: null, // `<body>`. Use CSS `background-image` instead\n    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead\n    border: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number, // `<table>`. Use CSS `border-width` instead,\n    borderColor: null, // `<table>`. Use CSS `border-color` instead,\n    bottomMargin: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number, // `<body>`\n    cellPadding: null, // `<table>`\n    cellSpacing: null, // `<table>`\n    char: null, // Several table elements. When `align=char`, sets the character to align on\n    charOff: null, // Several table elements. When `char`, offsets the alignment\n    classId: null, // `<object>`\n    clear: null, // `<br>`. Use CSS `clear` instead\n    code: null, // `<object>`\n    codeBase: null, // `<object>`\n    codeType: null, // `<object>`\n    color: null, // `<font>` and `<hr>`. Use CSS instead\n    compact: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean, // Lists. Use CSS to reduce space between items instead\n    declare: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean, // `<object>`\n    event: null, // `<script>`\n    face: null, // `<font>`. Use CSS instead\n    frame: null, // `<table>`\n    frameBorder: null, // `<iframe>`. Use CSS `border` instead\n    hSpace: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number, // `<img>` and `<object>`\n    leftMargin: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number, // `<body>`\n    link: null, // `<body>`. Use CSS `a:link {color: *}` instead\n    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`\n    lowSrc: null, // `<img>`. Use a `<picture>`\n    marginHeight: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number, // `<body>`\n    marginWidth: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number, // `<body>`\n    noResize: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean, // `<frame>`\n    noHref: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean, // `<area>`. Use no href instead of an explicit `nohref`\n    noShade: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean, // `<hr>`. Use background-color and height instead of borders\n    noWrap: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean, // `<td>` and `<th>`\n    object: null, // `<applet>`\n    profile: null, // `<head>`\n    prompt: null, // `<isindex>`\n    rev: null, // `<link>`\n    rightMargin: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number, // `<body>`\n    rules: null, // `<table>`\n    scheme: null, // `<meta>`\n    scrolling: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.booleanish, // `<frame>`. Use overflow in the child context\n    standby: null, // `<object>`\n    summary: null, // `<table>`\n    text: null, // `<body>`. Use CSS `color` instead\n    topMargin: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number, // `<body>`\n    valueType: null, // `<param>`\n    version: null, // `<html>`. Use a doctype.\n    vAlign: null, // Several. Use CSS `vertical-align` instead\n    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead\n    vSpace: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number, // `<img>` and `<object>`\n\n    // Non-standard Properties.\n    allowTransparency: null,\n    autoCorrect: null,\n    autoSave: null,\n    disablePictureInPicture: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    disableRemotePlayback: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    prefix: null,\n    property: null,\n    results: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    security: null,\n    unselectable: null\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL2h0bWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQU93QjtBQUNlO0FBQ3NDOztBQUV0RSxhQUFhLHVEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxhQUFhLHlGQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWM7QUFDMUIsbUJBQW1CLDBEQUFjO0FBQ2pDLGVBQWUsMERBQWM7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQixtREFBTztBQUM1Qix5QkFBeUIsbURBQU87QUFDaEMsb0JBQW9CLG1EQUFPO0FBQzNCO0FBQ0E7QUFDQSxXQUFXLG1EQUFPO0FBQ2xCO0FBQ0Esa0JBQWtCLDBEQUFjO0FBQ2hDLGVBQWUsbURBQU87QUFDdEIsY0FBYyxtREFBTztBQUNyQixjQUFjLDBEQUFjO0FBQzVCO0FBQ0E7QUFDQSxhQUFhLG1EQUFPO0FBQ3BCO0FBQ0EsZUFBZSwwREFBYztBQUM3QixVQUFVLGtEQUFNO0FBQ2hCO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQVU7QUFDL0IsY0FBYyxtREFBTztBQUNyQixrQkFBa0IsMERBQWM7QUFDaEMsWUFBWSxrREFBTSxHQUFHLDBEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBTztBQUNwQixXQUFXLG1EQUFPO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjLG1EQUFPO0FBQ3JCLGNBQWMsNkRBQWlCO0FBQy9CLGVBQWUsc0RBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQU87QUFDM0I7QUFDQSxhQUFhLDBEQUFjO0FBQzNCLFlBQVksa0RBQU07QUFDbEIsWUFBWSxtREFBTztBQUNuQixVQUFVLGtEQUFNO0FBQ2hCO0FB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QUFlLHNEQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQsWUFBWSxrREFBTTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbURBQU87QUFDcEMsMkJBQTJCLG1EQUFPO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhLGtEQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi9odG1sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGJvb2xlYW4sXG4gIG92ZXJsb2FkZWRCb29sZWFuLFxuICBib29sZWFuaXNoLFxuICBudW1iZXIsXG4gIHNwYWNlU2VwYXJhdGVkLFxuICBjb21tYVNlcGFyYXRlZFxufSBmcm9tICcuL3V0aWwvdHlwZXMuanMnXG5pbXBvcnQge2NyZWF0ZX0gZnJvbSAnLi91dGlsL2NyZWF0ZS5qcydcbmltcG9ydCB7Y2FzZUluc2Vuc2l0aXZlVHJhbnNmb3JtfSBmcm9tICcuL3V0aWwvY2FzZS1pbnNlbnNpdGl2ZS10cmFuc2Zvcm0uanMnXG5cbmV4cG9ydCBjb25zdCBodG1sID0gY3JlYXRlKHtcbiAgc3BhY2U6ICdodG1sJyxcbiAgYXR0cmlidXRlczoge1xuICAgIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NuYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxmb3I6ICdmb3InLFxuICAgIGh0dHBlcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIHRyYW5zZm9ybTogY2FzZUluc2Vuc2l0aXZlVHJhbnNmb3JtLFxuICBtdXN0VXNlUHJvcGVydHk6IFsnY2hlY2tlZCcsICdtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCddLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLy8gU3RhbmRhcmQgUHJvcGVydGllcy5cbiAgICBhYmJyOiBudWxsLFxuICAgIGFjY2VwdDogY29tbWFTZXBhcmF0ZWQsXG4gICAgYWNjZXB0Q2hhcnNldDogc3BhY2VTZXBhcmF0ZWQsXG4gICAgYWNjZXNzS2V5OiBzcGFjZVNlcGFyYXRlZCxcbiAgICBhY3Rpb246IG51bGwsXG4gICAgYWxsb3c6IG51bGwsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBib29sZWFuLFxuICAgIGFsbG93UGF5bWVudFJlcXVlc3Q6IGJvb2xlYW4sXG4gICAgYWxsb3dVc2VyTWVkaWE6IGJvb2xlYW4sXG4gICAgYWx0OiBudWxsLFxuICAgIGFzOiBudWxsLFxuICAgIGFzeW5jOiBib29sZWFuLFxuICAgIGF1dG9DYXBpdGFsaXplOiBudWxsLFxuICAgIGF1dG9Db21wbGV0ZTogc3BhY2VTZXBhcmF0ZWQsXG4gICAgYXV0b0ZvY3VzOiBib29sZWFuLFxuICAgIGF1dG9QbGF5OiBib29sZWFuLFxuICAgIGJsb2NraW5nOiBzcGFjZVNlcGFyYXRlZCxcbiAgICBjYXB0dXJlOiBudWxsLFxuICAgIGNoYXJTZXQ6IG51bGwsXG4gICAgY2hlY2tlZDogYm9vbGVhbixcbiAgICBjaXRlOiBudWxsLFxuICAgIGNsYXNzTmFtZTogc3BhY2VTZXBhcmF0ZWQsXG4gICAgY29sczogbnVtYmVyLFxuICAgIGNvbFNwYW46IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBjb250ZW50RWRpdGFibGU6IGJvb2xlYW5pc2gsXG4gICAgY29udHJvbHM6IGJvb2xlYW4sXG4gICAgY29udHJvbHNMaXN0OiBzcGFjZVNlcGFyYXRlZCxcbiAgICBjb29yZHM6IG51bWJlciB8IGNvbW1hU2VwYXJhdGVkLFxuICAgIGNyb3NzT3JpZ2luOiBudWxsLFxuICAgIGRhdGE6IG51bGwsXG4gICAgZGF0ZVRpbWU6IG51bGwsXG4gICAgZGVjb2Rpbmc6IG51bGwsXG4gICAgZGVmYXVsdDogYm9vbGVhbixcbiAgICBkZWZlcjogYm9vbGVhbixcbiAgICBkaXI6IG51bGwsXG4gICAgZGlyTmFtZTogbnVsbCxcbiAgICBkaXNhYmxlZDogYm9vbGVhbixcbiAgICBkb3dubG9hZDogb3ZlcmxvYWRlZEJvb2xlYW4sXG4gICAgZHJhZ2dhYmxlOiBib29sZWFuaXNoLFxuICAgIGVuY1R5cGU6IG51bGwsXG4gICAgZW50ZXJLZXlIaW50OiBudWxsLFxuICAgIGZldGNoUHJpb3JpdHk6IG51bGwsXG4gICAgZm9ybTogbnVsbCxcbiAgICBmb3JtQWN0aW9uOiBudWxsLFxuICAgIGZvcm1FbmNUeXBlOiBudWxsLFxuICAgIGZvcm1NZXRob2Q6IG51bGwsXG4gICAgZm9ybU5vVmFsaWRhdGU6IGJvb2xlYW4sXG4gICAgZm9ybVRhcmdldDogbnVsbCxcbiAgICBoZWFkZXJzOiBzcGFjZVNlcGFyYXRlZCxcbiAgICBoZWlnaHQ6IG51bWJlcixcbiAgICBoaWRkZW46IGJvb2xlYW4sXG4gICAgaGlnaDogbnVtYmVyLFxuICAgIGhyZWY6IG51bGwsXG4gICAgaHJlZkxhbmc6IG51bGwsXG4gICAgaHRtbEZvcjogc3BhY2VTZXBhcmF0ZWQsXG4gICAgaHR0cEVxdWl2OiBzcGFjZVNlcGFyYXRlZCxcbiAgICBpZDogbnVsbCxcbiAgICBpbWFnZVNpemVzOiBudWxsLFxuICAgIGltYWdlU3JjU2V0OiBudWxsLFxuICAgIGluZXJ0OiBib29sZWFuLFxuICAgIGlucHV0TW9kZTogbnVsbCxcbiAgICBpbnRlZ3JpdHk6IG51bGwsXG4gICAgaXM6IG51bGwsXG4gICAgaXNNYXA6IGJvb2xlYW4sXG4gICAgaXRlbUlkOiBudWxsLFxuICAgIGl0ZW1Qcm9wOiBzcGFjZVNlcGFyYXRlZCxcbiAgICBpdGVtUmVmOiBzcGFjZVNlcGFyYXRlZCxcbiAgICBpdGVtU2NvcGU6IGJvb2xlYW4sXG4gICAgaXRlbVR5cGU6IHNwYWNlU2VwYXJhdGVkLFxuICAgIGtpbmQ6IG51bGwsXG4gICAgbGFiZWw6IG51bGwsXG4gICAgbGFuZzogbnVsbCxcbiAgICBsYW5ndWFnZTogbnVsbCxcbiAgICBsaXN0OiBudWxsLFxuICAgIGxvYWRpbmc6IG51bGwsXG4gICAgbG9vcDogYm9vbGVhbixcbiAgICBsb3c6IG51bWJlcixcbiAgICBtYW5pZmVzdDogbnVsbCxcbiAgICBtYXg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBudW1iZXIsXG4gICAgbWVkaWE6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBtaW5MZW5ndGg6IG51bWJlcixcbiAgICBtdWx0aXBsZTogYm9vbGVhbixcbiAgICBtdXRlZDogYm9vbGVhbixcbiAgICBuYW1lOiBudWxsLFxuICAgIG5vbmNlOiBudWxsLFxuICAgIG5vTW9kdWxlOiBib29sZWFuLFxuICAgIG5vVmFsaWRhdGU6IGJvb2xlYW4sXG4gICAgb25BYm9ydDogbnVsbCxcbiAgICBvbkFmdGVyUHJpbnQ6IG51bGwsXG4gICAgb25BdXhDbGljazogbnVsbCxcbiAgICBvbkJlZm9yZU1hdGNoOiBudWxsLFxuICAgIG9uQmVmb3JlUHJpbnQ6IG51bGwsXG4gICAgb25CZWZvcmVUb2dnbGU6IG51bGwsXG4gICAgb25CZWZvcmVVbmxvYWQ6IG51bGwsXG4gICAgb25CbHVyOiBudWxsLFxuICAgIG9uQ2FuY2VsOiBudWxsLFxuICAgIG9uQ2FuUGxheTogbnVsbCxcbiAgICBvbkNhblBsYXlUaHJvdWdoOiBudWxsLFxuICAgIG9uQ2hhbmdlOiBudWxsLFxuICAgIG9uQ2xpY2s6IG51bGwsXG4gICAgb25DbG9zZTogbnVsbCxcbiAgICBvbkNvbnRleHRMb3N0OiBudWxsLFxuICAgIG9uQ29udGV4dE1lbnU6IG51bGwsXG4gICAgb25Db250ZXh0UmVzdG9yZWQ6IG51bGwsXG4gICAgb25Db3B5OiBudWxsLFxuICAgIG9uQ3VlQ2hhbmdlOiBudWxsLFxuICAgIG9uQ3V0OiBudWxsLFxuICAgIG9uRGJsQ2xpY2s6IG51bGwsXG4gICAgb25EcmFnOiBudWxsLFxuICAgIG9uRHJhZ0VuZDogbnVsbCxcbiAgICBvbkRyYWdFbnRlcjogbnVsbCxcbiAgICBvbkRyYWdFeGl0OiBudWxsLFxuICAgIG9uRHJhZ0xlYXZlOiBudWxsLFxuICAgIG9uRHJhZ092ZXI6IG51bGwsXG4gICAgb25EcmFnU3RhcnQ6IG51bGwsXG4gICAgb25Ecm9wOiBudWxsLFxuICAgIG9uRHVyYXRpb25DaGFuZ2U6IG51bGwsXG4gICAgb25FbXB0aWVkOiBudWxsLFxuICAgIG9uRW5kZWQ6IG51bGwsXG4gICAgb25FcnJvcjogbnVsbCxcbiAgICBvbkZvY3VzOiBudWxsLFxuICAgIG9uRm9ybURhdGE6IG51bGwsXG4gICAgb25IYXNoQ2hhbmdlOiBudWxsLFxuICAgIG9uSW5wdXQ6IG51bGwsXG4gICAgb25JbnZhbGlkOiBudWxsLFxuICAgIG9uS2V5RG93bjogbnVsbCxcbiAgICBvbktleVByZXNzOiBudWxsLFxuICAgIG9uS2V5VXA6IG51bGwsXG4gICAgb25MYW5ndWFnZUNoYW5nZTogbnVsbCxcbiAgICBvbkxvYWQ6IG51bGwsXG4gICAgb25Mb2FkZWREYXRhOiBudWxsLFxuICAgIG9uTG9hZGVkTWV0YWRhdGE6IG51bGwsXG4gICAgb25Mb2FkRW5kOiBudWxsLFxuICAgIG9uTG9hZFN0YXJ0OiBudWxsLFxuICAgIG9uTWVzc2FnZTogbnVsbCxcbiAgICBvbk1lc3NhZ2VFcnJvcjogbnVsbCxcbiAgICBvbk1vdXNlRG93bjogbnVsbCxcbiAgICBvbk1vdXNlRW50ZXI6IG51bGwsXG4gICAgb25Nb3VzZUxlYXZlOiBudWxsLFxuICAgIG9uTW91c2VNb3ZlOiBudWxsLFxuICAgIG9uTW91c2VPdXQ6IG51bGwsXG4gICAgb25Nb3VzZU92ZXI6IG51bGwsXG4gICAgb25Nb3VzZVVwOiBudWxsLFxuICAgIG9uT2ZmbGluZTogbnVsbCxcbiAgICBvbk9ubGluZTogbnVsbCxcbiAgICBvblBhZ2VIaWRlOiBudWxsLFxuICAgIG9uUGFnZVNob3c6IG51bGwsXG4gICAgb25QYXN0ZTogbnVsbCxcbiAgICBvblBhdXNlOiBudWxsLFxuICAgIG9uUGxheTogbnVsbCxcbiAgICBvblBsYXlpbmc6IG51bGwsXG4gICAgb25Qb3BTdGF0ZTogbnVsbCxcbiAgICBvblByb2dyZXNzOiBudWxsLFxuICAgIG9uUmF0ZUNoYW5nZTogbnVsbCxcbiAgICBvblJlamVjdGlvbkhhbmRsZWQ6IG51bGwsXG4gICAgb25SZXNldDogbnVsbCxcbiAgICBvblJlc2l6ZTogbnVsbCxcbiAgICBvblNjcm9sbDogbnVsbCxcbiAgICBvblNjcm9sbEVuZDogbnVsbCxcbiAgICBvblNlY3VyaXR5UG9saWN5VmlvbGF0aW9uOiBudWxsLFxuICAgIG9uU2Vla2VkOiBudWxsLFxuICAgIG9uU2Vla2luZzogbnVsbCxcbiAgICBvblNlbGVjdDogbnVsbCxcbiAgICBvblNsb3RDaGFuZ2U6IG51bGwsXG4gICAgb25TdGFsbGVkOiBudWxsLFxuICAgIG9uU3RvcmFnZTogbnVsbCxcbiAgICBvblN1Ym1pdDogbnVsbCxcbiAgICBvblN1c3BlbmQ6IG51bGwsXG4gICAgb25UaW1lVXBkYXRlOiBudWxsLFxuICAgIG9uVG9nZ2xlOiBudWxsLFxuICAgIG9uVW5oYW5kbGVkUmVqZWN0aW9uOiBudWxsLFxuICAgIG9uVW5sb2FkOiBudWxsLFxuICAgIG9uVm9sdW1lQ2hhbmdlOiBudWxsLFxuICAgIG9uV2FpdGluZzogbnVsbCxcbiAgICBvbldoZWVsOiBudWxsLFxuICAgIG9wZW46IGJvb2xlYW4sXG4gICAgb3B0aW11bTogbnVtYmVyLFxuICAgIHBhdHRlcm46IG51bGwsXG4gICAgcGluZzogc3BhY2VTZXBhcmF0ZWQsXG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgcGxheXNJbmxpbmU6IGJvb2xlYW4sXG4gICAgcG9wb3ZlcjogbnVsbCxcbiAgICBwb3BvdmVyVGFyZ2V0OiBudWxsLFxuICAgIHBvcG92ZXJUYXJnZXRBY3Rpb246IG51bGwsXG4gICAgcG9zdGVyOiBudWxsLFxuICAgIHByZWxvYWQ6IG51bGwsXG4gICAgcmVhZE9ubHk6IGJvb2xlYW4sXG4gICAgcmVmZXJyZXJQb2xpY3k6IG51bGwsXG4gICAgcmVsOiBzcGFjZVNlcGFyYXRlZCxcbiAgICByZXF1aXJlZDogYm9vbGVhbixcbiAgICByZXZlcnNlZDogYm9vbGVhbixcbiAgICByb3dzOiBudW1iZXIsXG4gICAgcm93U3BhbjogbnVtYmVyLFxuICAgIHNhbmRib3g6IHNwYWNlU2VwYXJhdGVkLFxuICAgIHNjb3BlOiBudWxsLFxuICAgIHNjb3BlZDogYm9vbGVhbixcbiAgICBzZWFtbGVzczogYm9vbGVhbixcbiAgICBzZWxlY3RlZDogYm9vbGVhbixcbiAgICBzaGFkb3dSb290Q2xvbmFibGU6IGJvb2xlYW4sXG4gICAgc2hhZG93Um9vdERlbGVnYXRlc0ZvY3VzOiBib29sZWFuLFxuICAgIHNoYWRvd1Jvb3RNb2RlOiBudWxsLFxuICAgIHNoYXBlOiBudWxsLFxuICAgIHNpemU6IG51bWJlcixcbiAgICBzaXplczogbnVsbCxcbiAgICBzbG90OiBudWxsLFxuICAgIHNwYW46IG51bWJlcixcbiAgICBzcGVsbENoZWNrOiBib29sZWFuaXNoLFxuICAgIHNyYzogbnVsbCxcbiAgICBzcmNEb2M6IG51bGwsXG4gICAgc3JjTGFuZzogbnVsbCxcbiAgICBzcmNTZXQ6IG51bGwsXG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBzdGVwOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIHRhYkluZGV4OiBudW1iZXIsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHRyYW5zbGF0ZTogbnVsbCxcbiAgICB0eXBlOiBudWxsLFxuICAgIHR5cGVNdXN0TWF0Y2g6IGJvb2xlYW4sXG4gICAgdXNlTWFwOiBudWxsLFxuICAgIHZhbHVlOiBib29sZWFuaXNoLFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgd3JhcDogbnVsbCxcbiAgICB3cml0aW5nU3VnZ2VzdGlvbnM6IG51bGwsXG5cbiAgICAvLyBMZWdhY3kuXG4gICAgLy8gU2VlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNvdGhlci1lbGVtZW50cywtYXR0cmlidXRlcy1hbmQtYXBpc1xuICAgIGFsaWduOiBudWxsLCAvLyBTZXZlcmFsLiBVc2UgQ1NTIGB0ZXh0LWFsaWduYCBpbnN0ZWFkLFxuICAgIGFMaW5rOiBudWxsLCAvLyBgPGJvZHk+YC4gVXNlIENTUyBgYTphY3RpdmUge2NvbG9yfWAgaW5zdGVhZFxuICAgIGFyY2hpdmU6IHNwYWNlU2VwYXJhdGVkLCAvLyBgPG9iamVjdD5gLiBMaXN0IG9mIFVSSXMgdG8gYXJjaGl2ZXNcbiAgICBheGlzOiBudWxsLCAvLyBgPHRkPmAgYW5kIGA8dGg+YC4gVXNlIGBzY29wZWAgb24gYDx0aD5gXG4gICAgYmFja2dyb3VuZDogbnVsbCwgLy8gYDxib2R5PmAuIFVzZSBDU1MgYGJhY2tncm91bmQtaW1hZ2VgIGluc3RlYWRcbiAgICBiZ0NvbG9yOiBudWxsLCAvLyBgPGJvZHk+YCBhbmQgdGFibGUgZWxlbWVudHMuIFVzZSBDU1MgYGJhY2tncm91bmQtY29sb3JgIGluc3RlYWRcbiAgICBib3JkZXI6IG51bWJlciwgLy8gYDx0YWJsZT5gLiBVc2UgQ1NTIGBib3JkZXItd2lkdGhgIGluc3RlYWQsXG4gICAgYm9yZGVyQ29sb3I6IG51bGwsIC8vIGA8dGFibGU+YC4gVXNlIENTUyBgYm9yZGVyLWNvbG9yYCBpbnN0ZWFkLFxuICAgIGJvdHRvbU1hcmdpbjogbnVtYmVyLCAvLyBgPGJvZHk+YFxuICAgIGNlbGxQYWRkaW5nOiBudWxsLCAvLyBgPHRhYmxlPmBcbiAgICBjZWxsU3BhY2luZzogbnVsbCwgLy8gYDx0YWJsZT5gXG4gICAgY2hhcjogbnVsbCwgLy8gU2V2ZXJhbCB0YWJsZSBlbGVtZW50cy4gV2hlbiBgYWxpZ249Y2hhcmAsIHNldHMgdGhlIGNoYXJhY3RlciB0byBhbGlnbiBvblxuICAgIGNoYXJPZmY6IG51bGwsIC8vIFNldmVyYWwgdGFibGUgZWxlbWVudHMuIFdoZW4gYGNoYXJgLCBvZmZzZXRzIHRoZSBhbGlnbm1lbnRcbiAgICBjbGFzc0lkOiBudWxsLCAvLyBgPG9iamVjdD5gXG4gICAgY2xlYXI6IG51bGwsIC8vIGA8YnI+YC4gVXNlIENTUyBgY2xlYXJgIGluc3RlYWRcbiAgICBjb2RlOiBudWxsLCAvLyBgPG9iamVjdD5gXG4gICAgY29kZUJhc2U6IG51bGwsIC8vIGA8b2JqZWN0PmBcbiAgICBjb2RlVHlwZTogbnVsbCwgLy8gYDxvYmplY3Q+YFxuICAgIGNvbG9yOiBudWxsLCAvLyBgPGZvbnQ+YCBhbmQgYDxocj5gLiBVc2UgQ1NTIGluc3RlYWRcbiAgICBjb21wYWN0OiBib29sZWFuLCAvLyBMaXN0cy4gVXNlIENTUyB0byByZWR1Y2Ugc3BhY2UgYmV0d2VlbiBpdGVtcyBpbnN0ZWFkXG4gICAgZGVjbGFyZTogYm9vbGVhbiwgLy8gYDxvYmplY3Q+YFxuICAgIGV2ZW50OiBudWxsLCAvLyBgPHNjcmlwdD5gXG4gICAgZmFjZTogbnVsbCwgLy8gYDxmb250PmAuIFVzZSBDU1MgaW5zdGVhZFxuICAgIGZyYW1lOiBudWxsLCAvLyBgPHRhYmxlPmBcbiAgICBmcmFtZUJvcmRlcjogbnVsbCwgLy8gYDxpZnJhbWU+YC4gVXNlIENTUyBgYm9yZGVyYCBpbnN0ZWFkXG4gICAgaFNwYWNlOiBudW1iZXIsIC8vIGA8aW1nPmAgYW5kIGA8b2JqZWN0PmBcbiAgICBsZWZ0TWFyZ2luOiBudW1iZXIsIC8vIGA8Ym9keT5gXG4gICAgbGluazogbnVsbCwgLy8gYDxib2R5PmAuIFVzZSBDU1MgYGE6bGluayB7Y29sb3I6ICp9YCBpbnN0ZWFkXG4gICAgbG9uZ0Rlc2M6IG51bGwsIC8vIGA8ZnJhbWU+YCwgYDxpZnJhbWU+YCwgYW5kIGA8aW1nPmAuIFVzZSBhbiBgPGE+YFxuICAgIGxvd1NyYzogbnVsbCwgLy8gYDxpbWc+YC4gVXNlIGEgYDxwaWN0dXJlPmBcbiAgICBtYXJnaW5IZWlnaHQ6IG51bWJlciwgLy8gYDxib2R5PmBcbiAgICBtYXJnaW5XaWR0aDogbnVtYmVyLCAvLyBgPGJvZHk+YFxuICAgIG5vUmVzaXplOiBib29sZWFuLCAvLyBgPGZyYW1lPmBcbiAgICBub0hyZWY6IGJvb2xlYW4sIC8vIGA8YXJlYT5gLiBVc2Ugbm8gaHJlZiBpbnN0ZWFkIG9mIGFuIGV4cGxpY2l0IGBub2hyZWZgXG4gICAgbm9TaGFkZTogYm9vbGVhbiwgLy8gYDxocj5gLiBVc2UgYmFja2dyb3VuZC1jb2xvciBhbmQgaGVpZ2h0IGluc3RlYWQgb2YgYm9yZGVyc1xuICAgIG5vV3JhcDogYm9vbGVhbiwgLy8gYDx0ZD5gIGFuZCBgPHRoPmBcbiAgICBvYmplY3Q6IG51bGwsIC8vIGA8YXBwbGV0PmBcbiAgICBwcm9maWxlOiBudWxsLCAvLyBgPGhlYWQ+YFxuICAgIHByb21wdDogbnVsbCwgLy8gYDxpc2luZGV4PmBcbiAgICByZXY6IG51bGwsIC8vIGA8bGluaz5gXG4gICAgcmlnaHRNYXJnaW46IG51bWJlciwgLy8gYDxib2R5PmBcbiAgICBydWxlczogbnVsbCwgLy8gYDx0YWJsZT5gXG4gICAgc2NoZW1lOiBudWxsLCAvLyBgPG1ldGE+YFxuICAgIHNjcm9sbGluZzogYm9vbGVhbmlzaCwgLy8gYDxmcmFtZT5gLiBVc2Ugb3ZlcmZsb3cgaW4gdGhlIGNoaWxkIGNvbnRleHRcbiAgICBzdGFuZGJ5OiBudWxsLCAvLyBgPG9iamVjdD5gXG4gICAgc3VtbWFyeTogbnVsbCwgLy8gYDx0YWJsZT5gXG4gICAgdGV4dDogbnVsbCwgLy8gYDxib2R5PmAuIFVzZSBDU1MgYGNvbG9yYCBpbnN0ZWFkXG4gICAgdG9wTWFyZ2luOiBudW1iZXIsIC8vIGA8Ym9keT5gXG4gICAgdmFsdWVUeXBlOiBudWxsLCAvLyBgPHBhcmFtPmBcbiAgICB2ZXJzaW9uOiBudWxsLCAvLyBgPGh0bWw+YC4gVXNlIGEgZG9jdHlwZS5cbiAgICB2QWxpZ246IG51bGwsIC8vIFNldmVyYWwuIFVzZSBDU1MgYHZlcnRpY2FsLWFsaWduYCBpbnN0ZWFkXG4gICAgdkxpbms6IG51bGwsIC8vIGA8Ym9keT5gLiBVc2UgQ1NTIGBhOnZpc2l0ZWQge2NvbG9yfWAgaW5zdGVhZFxuICAgIHZTcGFjZTogbnVtYmVyLCAvLyBgPGltZz5gIGFuZCBgPG9iamVjdD5gXG5cbiAgICAvLyBOb24tc3RhbmRhcmQgUHJvcGVydGllcy5cbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogbnVsbCxcbiAgICBhdXRvQ29ycmVjdDogbnVsbCxcbiAgICBhdXRvU2F2ZTogbnVsbCxcbiAgICBkaXNhYmxlUGljdHVyZUluUGljdHVyZTogYm9vbGVhbixcbiAgICBkaXNhYmxlUmVtb3RlUGxheWJhY2s6IGJvb2xlYW4sXG4gICAgcHJlZml4OiBudWxsLFxuICAgIHByb3BlcnR5OiBudWxsLFxuICAgIHJlc3VsdHM6IG51bWJlcixcbiAgICBzZWN1cml0eTogbnVsbCxcbiAgICB1bnNlbGVjdGFibGU6IG51bGxcbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/normalize.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/normalize.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalize: () => (/* binding */ normalize)\n/* harmony export */ });\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction normalize(value) {\n  return value.toLowerCase()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL25vcm1hbGl6ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3BlcnR5LWluZm9ybWF0aW9uQDYuNS4wL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1pbmZvcm1hdGlvbi9saWIvbm9ybWFsaXplLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/normalize.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/svg.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/svg.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   svg: () => (/* binding */ svg)\n/* harmony export */ });\n/* harmony import */ var _util_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/types.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/types.js\");\n/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/create.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/create.js\");\n/* harmony import */ var _util_case_sensitive_transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/case-sensitive-transform.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-sensitive-transform.js\");\n\n\n\n\nconst svg = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_0__.create)({\n  space: 'svg',\n  attributes: {\n    accentHeight: 'accent-height',\n    alignmentBaseline: 'alignment-baseline',\n    arabicForm: 'arabic-form',\n    baselineShift: 'baseline-shift',\n    capHeight: 'cap-height',\n    className: 'class',\n    clipPath: 'clip-path',\n    clipRule: 'clip-rule',\n    colorInterpolation: 'color-interpolation',\n    colorInterpolationFilters: 'color-interpolation-filters',\n    colorProfile: 'color-profile',\n    colorRendering: 'color-rendering',\n    crossOrigin: 'crossorigin',\n    dataType: 'datatype',\n    dominantBaseline: 'dominant-baseline',\n    enableBackground: 'enable-background',\n    fillOpacity: 'fill-opacity',\n    fillRule: 'fill-rule',\n    floodColor: 'flood-color',\n    floodOpacity: 'flood-opacity',\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    fontSizeAdjust: 'font-size-adjust',\n    fontStretch: 'font-stretch',\n    fontStyle: 'font-style',\n    fontVariant: 'font-variant',\n    fontWeight: 'font-weight',\n    glyphName: 'glyph-name',\n    glyphOrientationHorizontal: 'glyph-orientation-horizontal',\n    glyphOrientationVertical: 'glyph-orientation-vertical',\n    hrefLang: 'hreflang',\n    horizAdvX: 'horiz-adv-x',\n    horizOriginX: 'horiz-origin-x',\n    horizOriginY: 'horiz-origin-y',\n    imageRendering: 'image-rendering',\n    letterSpacing: 'letter-spacing',\n    lightingColor: 'lighting-color',\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    navDown: 'nav-down',\n    navDownLeft: 'nav-down-left',\n    navDownRight: 'nav-down-right',\n    navLeft: 'nav-left',\n    navNext: 'nav-next',\n    navPrev: 'nav-prev',\n    navRight: 'nav-right',\n    navUp: 'nav-up',\n    navUpLeft: 'nav-up-left',\n    navUpRight: 'nav-up-right',\n    onAbort: 'onabort',\n    onActivate: 'onactivate',\n    onAfterPrint: 'onafterprint',\n    onBeforePrint: 'onbeforeprint',\n    onBegin: 'onbegin',\n    onCancel: 'oncancel',\n    onCanPlay: 'oncanplay',\n    onCanPlayThrough: 'oncanplaythrough',\n    onChange: 'onchange',\n    onClick: 'onclick',\n    onClose: 'onclose',\n    onCopy: 'oncopy',\n    onCueChange: 'oncuechange',\n    onCut: 'oncut',\n    onDblClick: 'ondblclick',\n    onDrag: 'ondrag',\n    onDragEnd: 'ondragend',\n    onDragEnter: 'ondragenter',\n    onDragExit: 'ondragexit',\n    onDragLeave: 'ondragleave',\n    onDragOver: 'ondragover',\n    onDragStart: 'ondragstart',\n    onDrop: 'ondrop',\n    onDurationChange: 'ondurationchange',\n    onEmptied: 'onemptied',\n    onEnd: 'onend',\n    onEnded: 'onended',\n    onError: 'onerror',\n    onFocus: 'onfocus',\n    onFocusIn: 'onfocusin',\n    onFocusOut: 'onfocusout',\n    onHashChange: 'onhashchange',\n    onInput: 'oninput',\n    onInvalid: 'oninvalid',\n    onKeyDown: 'onkeydown',\n    onKeyPress: 'onkeypress',\n    onKeyUp: 'onkeyup',\n    onLoad: 'onload',\n    onLoadedData: 'onloadeddata',\n    onLoadedMetadata: 'onloadedmetadata',\n    onLoadStart: 'onloadstart',\n    onMessage: 'onmessage',\n    onMouseDown: 'onmousedown',\n    onMouseEnter: 'onmouseenter',\n    onMouseLeave: 'onmouseleave',\n    onMouseMove: 'onmousemove',\n    onMouseOut: 'onmouseout',\n    onMouseOver: 'onmouseover',\n    onMouseUp: 'onmouseup',\n    onMouseWheel: 'onmousewheel',\n    onOffline: 'onoffline',\n    onOnline: 'ononline',\n    onPageHide: 'onpagehide',\n    onPageShow: 'onpageshow',\n    onPaste: 'onpaste',\n    onPause: 'onpause',\n    onPlay: 'onplay',\n    onPlaying: 'onplaying',\n    onPopState: 'onpopstate',\n    onProgress: 'onprogress',\n    onRateChange: 'onratechange',\n    onRepeat: 'onrepeat',\n    onReset: 'onreset',\n    onResize: 'onresize',\n    onScroll: 'onscroll',\n    onSeeked: 'onseeked',\n    onSeeking: 'onseeking',\n    onSelect: 'onselect',\n    onShow: 'onshow',\n    onStalled: 'onstalled',\n    onStorage: 'onstorage',\n    onSubmit: 'onsubmit',\n    onSuspend: 'onsuspend',\n    onTimeUpdate: 'ontimeupdate',\n    onToggle: 'ontoggle',\n    onUnload: 'onunload',\n    onVolumeChange: 'onvolumechange',\n    onWaiting: 'onwaiting',\n    onZoom: 'onzoom',\n    overlinePosition: 'overline-position',\n    overlineThickness: 'overline-thickness',\n    paintOrder: 'paint-order',\n    panose1: 'panose-1',\n    pointerEvents: 'pointer-events',\n    referrerPolicy: 'referrerpolicy',\n    renderingIntent: 'rendering-intent',\n    shapeRendering: 'shape-rendering',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strikethroughPosition: 'strikethrough-position',\n    strikethroughThickness: 'strikethrough-thickness',\n    strokeDashArray: 'stroke-dasharray',\n    strokeDashOffset: 'stroke-dashoffset',\n    strokeLineCap: 'stroke-linecap',\n    strokeLineJoin: 'stroke-linejoin',\n    strokeMiterLimit: 'stroke-miterlimit',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    tabIndex: 'tabindex',\n    textAnchor: 'text-anchor',\n    textDecoration: 'text-decoration',\n    textRendering: 'text-rendering',\n    transformOrigin: 'transform-origin',\n    typeOf: 'typeof',\n    underlinePosition: 'underline-position',\n    underlineThickness: 'underline-thickness',\n    unicodeBidi: 'unicode-bidi',\n    unicodeRange: 'unicode-range',\n    unitsPerEm: 'units-per-em',\n    vAlphabetic: 'v-alphabetic',\n    vHanging: 'v-hanging',\n    vIdeographic: 'v-ideographic',\n    vMathematical: 'v-mathematical',\n    vectorEffect: 'vector-effect',\n    vertAdvY: 'vert-adv-y',\n    vertOriginX: 'vert-origin-x',\n    vertOriginY: 'vert-origin-y',\n    wordSpacing: 'word-spacing',\n    writingMode: 'writing-mode',\n    xHeight: 'x-height',\n    // These were camelcased in Tiny. Now lowercased in SVG 2\n    playbackOrder: 'playbackorder',\n    timelineBegin: 'timelinebegin'\n  },\n  transform: _util_case_sensitive_transform_js__WEBPACK_IMPORTED_MODULE_1__.caseSensitiveTransform,\n  properties: {\n    about: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    accentHeight: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    accumulate: null,\n    additive: null,\n    alignmentBaseline: null,\n    alphabetic: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    amplitude: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    arabicForm: null,\n    ascent: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    attributeName: null,\n    attributeType: null,\n    azimuth: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    bandwidth: null,\n    baselineShift: null,\n    baseFrequency: null,\n    baseProfile: null,\n    bbox: null,\n    begin: null,\n    bias: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    by: null,\n    calcMode: null,\n    capHeight: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    className: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    clip: null,\n    clipPath: null,\n    clipPathUnits: null,\n    clipRule: null,\n    color: null,\n    colorInterpolation: null,\n    colorInterpolationFilters: null,\n    colorProfile: null,\n    colorRendering: null,\n    content: null,\n    contentScriptType: null,\n    contentStyleType: null,\n    crossOrigin: null,\n    cursor: null,\n    cx: null,\n    cy: null,\n    d: null,\n    dataType: null,\n    defaultAction: null,\n    descent: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    diffuseConstant: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    direction: null,\n    display: null,\n    dur: null,\n    divisor: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    dominantBaseline: null,\n    download: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.boolean,\n    dx: null,\n    dy: null,\n    edgeMode: null,\n    editable: null,\n    elevation: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    enableBackground: null,\n    end: null,\n    event: null,\n    exponent: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    externalResourcesRequired: null,\n    fill: null,\n    fillOpacity: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    fillRule: null,\n    filter: null,\n    filterRes: null,\n    filterUnits: null,\n    floodColor: null,\n    floodOpacity: null,\n    focusable: null,\n    focusHighlight: null,\n    fontFamily: null,\n    fontSize: null,\n    fontSizeAdjust: null,\n    fontStretch: null,\n    fontStyle: null,\n    fontVariant: null,\n    fontWeight: null,\n    format: null,\n    fr: null,\n    from: null,\n    fx: null,\n    fy: null,\n    g1: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaSeparated,\n    g2: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaSeparated,\n    glyphName: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaSeparated,\n    glyphOrientationHorizontal: null,\n    glyphOrientationVertical: null,\n    glyphRef: null,\n    gradientTransform: null,\n    gradientUnits: null,\n    handler: null,\n    hanging: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    hatchContentUnits: null,\n    hatchUnits: null,\n    height: null,\n    href: null,\n    hrefLang: null,\n    horizAdvX: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    horizOriginX: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    horizOriginY: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    id: null,\n    ideographic: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    imageRendering: null,\n    initialVisibility: null,\n    in: null,\n    in2: null,\n    intercept: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    k: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    k1: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    k2: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    k3: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    k4: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    kernelMatrix: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    kernelUnitLength: null,\n    keyPoints: null, // SEMI_COLON_SEPARATED\n    keySplines: null, // SEMI_COLON_SEPARATED\n    keyTimes: null, // SEMI_COLON_SEPARATED\n    kerning: null,\n    lang: null,\n    lengthAdjust: null,\n    letterSpacing: null,\n    lightingColor: null,\n    limitingConeAngle: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    local: null,\n    markerEnd: null,\n    markerMid: null,\n    markerStart: null,\n    markerHeight: null,\n    markerUnits: null,\n    markerWidth: null,\n    mask: null,\n    maskContentUnits: null,\n    maskUnits: null,\n    mathematical: null,\n    max: null,\n    media: null,\n    mediaCharacterEncoding: null,\n    mediaContentEncodings: null,\n    mediaSize: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    mediaTime: null,\n    method: null,\n    min: null,\n    mode: null,\n    name: null,\n    navDown: null,\n    navDownLeft: null,\n    navDownRight: null,\n    navLeft: null,\n    navNext: null,\n    navPrev: null,\n    navRight: null,\n    navUp: null,\n    navUpLeft: null,\n    navUpRight: null,\n    numOctaves: null,\n    observer: null,\n    offset: null,\n    onAbort: null,\n    onActivate: null,\n    onAfterPrint: null,\n    onBeforePrint: null,\n    onBegin: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnd: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFocusIn: null,\n    onFocusOut: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onMouseWheel: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRepeat: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onShow: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onZoom: null,\n    opacity: null,\n    operator: null,\n    order: null,\n    orient: null,\n    orientation: null,\n    origin: null,\n    overflow: null,\n    overlay: null,\n    overlinePosition: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    overlineThickness: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    paintOrder: null,\n    panose1: null,\n    path: null,\n    pathLength: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    patternContentUnits: null,\n    patternTransform: null,\n    patternUnits: null,\n    phase: null,\n    ping: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.spaceSeparated,\n    pitch: null,\n    playbackOrder: null,\n    pointerEvents: null,\n    points: null,\n    pointsAtX: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    pointsAtY: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    pointsAtZ: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    preserveAlpha: null,\n    preserveAspectRatio: null,\n    primitiveUnits: null,\n    propagate: null,\n    property: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    r: null,\n    radius: null,\n    referrerPolicy: null,\n    refX: null,\n    refY: null,\n    rel: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    rev: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    renderingIntent: null,\n    repeatCount: null,\n    repeatDur: null,\n    requiredExtensions: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    requiredFeatures: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    requiredFonts: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    requiredFormats: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    resource: null,\n    restart: null,\n    result: null,\n    rotate: null,\n    rx: null,\n    ry: null,\n    scale: null,\n    seed: null,\n    shapeRendering: null,\n    side: null,\n    slope: null,\n    snapshotTime: null,\n    specularConstant: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    specularExponent: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    spreadMethod: null,\n    spacing: null,\n    startOffset: null,\n    stdDeviation: null,\n    stemh: null,\n    stemv: null,\n    stitchTiles: null,\n    stopColor: null,\n    stopOpacity: null,\n    strikethroughPosition: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    strikethroughThickness: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    string: null,\n    stroke: null,\n    strokeDashArray: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    strokeDashOffset: null,\n    strokeLineCap: null,\n    strokeLineJoin: null,\n    strokeMiterLimit: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    strokeOpacity: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    strokeWidth: null,\n    style: null,\n    surfaceScale: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    syncBehavior: null,\n    syncBehaviorDefault: null,\n    syncMaster: null,\n    syncTolerance: null,\n    syncToleranceDefault: null,\n    systemLanguage: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    tabIndex: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    tableValues: null,\n    target: null,\n    targetX: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    targetY: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    textAnchor: null,\n    textDecoration: null,\n    textRendering: null,\n    textLength: null,\n    timelineBegin: null,\n    title: null,\n    transformBehavior: null,\n    type: null,\n    typeOf: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.commaOrSpaceSeparated,\n    to: null,\n    transform: null,\n    transformOrigin: null,\n    u1: null,\n    u2: null,\n    underlinePosition: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    underlineThickness: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    unicode: null,\n    unicodeBidi: null,\n    unicodeRange: null,\n    unitsPerEm: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    values: null,\n    vAlphabetic: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    vMathematical: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    vectorEffect: null,\n    vHanging: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    vIdeographic: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    version: null,\n    vertAdvY: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    vertOriginX: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    vertOriginY: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    viewBox: null,\n    viewTarget: null,\n    visibility: null,\n    width: null,\n    widths: null,\n    wordSpacing: null,\n    writingMode: null,\n    x: null,\n    x1: null,\n    x2: null,\n    xChannelSelector: null,\n    xHeight: _util_types_js__WEBPACK_IMPORTED_MODULE_2__.number,\n    y: null,\n    y1: null,\n    y2: null,\n    yChannelSelector: null,\n    z: null,\n    zoomAndPan: null\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3N2Zy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBTXdCO0FBQ2U7QUFDa0M7O0FBRWxFLFlBQVksdURBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QU07QUFDN0Isd0JBQXdCLGtEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBTTtBQUN0QjtBQUNBLGlCQUFpQixrREFBTTtBQUN2QixtQkFBbUIsa0RBQU07QUFDekI7QUFDQSxjQUFjLGtEQUFNO0FBQ3BCLGtCQUFrQixrREFBTTtBQUN4QjtBQUNBLGNBQWMsa0RBQU07QUFDcEIsaUJBQWlCLGtEQUFNO0FBQ3ZCLGlCQUFpQixrREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrREFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi9zdmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgYm9vbGVhbixcbiAgbnVtYmVyLFxuICBzcGFjZVNlcGFyYXRlZCxcbiAgY29tbWFTZXBhcmF0ZWQsXG4gIGNvbW1hT3JTcGFjZVNlcGFyYXRlZFxufSBmcm9tICcuL3V0aWwvdHlwZXMuanMnXG5pbXBvcnQge2NyZWF0ZX0gZnJvbSAnLi91dGlsL2NyZWF0ZS5qcydcbmltcG9ydCB7Y2FzZVNlbnNpdGl2ZVRyYW5zZm9ybX0gZnJvbSAnLi91dGlsL2Nhc2Utc2Vuc2l0aXZlLXRyYW5zZm9ybS5qcydcblxuZXhwb3J0IGNvbnN0IHN2ZyA9IGNyZWF0ZSh7XG4gIHNwYWNlOiAnc3ZnJyxcbiAgYXR0cmlidXRlczoge1xuICAgIGFjY2VudEhlaWdodDogJ2FjY2VudC1oZWlnaHQnLFxuICAgIGFsaWdubWVudEJhc2VsaW5lOiAnYWxpZ25tZW50LWJhc2VsaW5lJyxcbiAgICBhcmFiaWNGb3JtOiAnYXJhYmljLWZvcm0nLFxuICAgIGJhc2VsaW5lU2hpZnQ6ICdiYXNlbGluZS1zaGlmdCcsXG4gICAgY2FwSGVpZ2h0OiAnY2FwLWhlaWdodCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgICBjbGlwUnVsZTogJ2NsaXAtcnVsZScsXG4gICAgY29sb3JJbnRlcnBvbGF0aW9uOiAnY29sb3ItaW50ZXJwb2xhdGlvbicsXG4gICAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsXG4gICAgY29sb3JQcm9maWxlOiAnY29sb3ItcHJvZmlsZScsXG4gICAgY29sb3JSZW5kZXJpbmc6ICdjb2xvci1yZW5kZXJpbmcnLFxuICAgIGNyb3NzT3JpZ2luOiAnY3Jvc3NvcmlnaW4nLFxuICAgIGRhdGFUeXBlOiAnZGF0YXR5cGUnLFxuICAgIGRvbWluYW50QmFzZWxpbmU6ICdkb21pbmFudC1iYXNlbGluZScsXG4gICAgZW5hYmxlQmFja2dyb3VuZDogJ2VuYWJsZS1iYWNrZ3JvdW5kJyxcbiAgICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gICAgZmlsbFJ1bGU6ICdmaWxsLXJ1bGUnLFxuICAgIGZsb29kQ29sb3I6ICdmbG9vZC1jb2xvcicsXG4gICAgZmxvb2RPcGFjaXR5OiAnZmxvb2Qtb3BhY2l0eScsXG4gICAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gICAgZm9udFNpemVBZGp1c3Q6ICdmb250LXNpemUtYWRqdXN0JyxcbiAgICBmb250U3RyZXRjaDogJ2ZvbnQtc3RyZXRjaCcsXG4gICAgZm9udFN0eWxlOiAnZm9udC1zdHlsZScsXG4gICAgZm9udFZhcmlhbnQ6ICdmb250LXZhcmlhbnQnLFxuICAgIGZvbnRXZWlnaHQ6ICdmb250LXdlaWdodCcsXG4gICAgZ2x5cGhOYW1lOiAnZ2x5cGgtbmFtZScsXG4gICAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6ICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcbiAgICBnbHlwaE9yaWVudGF0aW9uVmVydGljYWw6ICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsXG4gICAgaHJlZkxhbmc6ICdocmVmbGFuZycsXG4gICAgaG9yaXpBZHZYOiAnaG9yaXotYWR2LXgnLFxuICAgIGhvcml6T3JpZ2luWDogJ2hvcml6LW9yaWdpbi14JyxcbiAgICBob3Jpek9yaWdpblk6ICdob3Jpei1vcmlnaW4teScsXG4gICAgaW1hZ2VSZW5kZXJpbmc6ICdpbWFnZS1yZW5kZXJpbmcnLFxuICAgIGxldHRlclNwYWNpbmc6ICdsZXR0ZXItc3BhY2luZycsXG4gICAgbGlnaHRpbmdDb2xvcjogJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gICAgbmF2RG93bjogJ25hdi1kb3duJyxcbiAgICBuYXZEb3duTGVmdDogJ25hdi1kb3duLWxlZnQnLFxuICAgIG5hdkRvd25SaWdodDogJ25hdi1kb3duLXJpZ2h0JyxcbiAgICBuYXZMZWZ0OiAnbmF2LWxlZnQnLFxuICAgIG5hdk5leHQ6ICduYXYtbmV4dCcsXG4gICAgbmF2UHJldjogJ25hdi1wcmV2JyxcbiAgICBuYXZSaWdodDogJ25hdi1yaWdodCcsXG4gICAgbmF2VXA6ICduYXYtdXAnLFxuICAgIG5hdlVwTGVmdDogJ25hdi11cC1sZWZ0JyxcbiAgICBuYXZVcFJpZ2h0OiAnbmF2LXVwLXJpZ2h0JyxcbiAgICBvbkFib3J0OiAnb25hYm9ydCcsXG4gICAgb25BY3RpdmF0ZTogJ29uYWN0aXZhdGUnLFxuICAgIG9uQWZ0ZXJQcmludDogJ29uYWZ0ZXJwcmludCcsXG4gICAgb25CZWZvcmVQcmludDogJ29uYmVmb3JlcHJpbnQnLFxuICAgIG9uQmVnaW46ICdvbmJlZ2luJyxcbiAgICBvbkNhbmNlbDogJ29uY2FuY2VsJyxcbiAgICBvbkNhblBsYXk6ICdvbmNhbnBsYXknLFxuICAgIG9uQ2FuUGxheVRocm91Z2g6ICdvbmNhbnBsYXl0aHJvdWdoJyxcbiAgICBvbkNoYW5nZTogJ29uY2hhbmdlJyxcbiAgICBvbkNsaWNrOiAnb25jbGljaycsXG4gICAgb25DbG9zZTogJ29uY2xvc2UnLFxuICAgIG9uQ29weTogJ29uY29weScsXG4gICAgb25DdWVDaGFuZ2U6ICdvbmN1ZWNoYW5nZScsXG4gICAgb25DdXQ6ICdvbmN1dCcsXG4gICAgb25EYmxDbGljazogJ29uZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ29uZHJhZycsXG4gICAgb25EcmFnRW5kOiAnb25kcmFnZW5kJyxcbiAgICBvbkRyYWdFbnRlcjogJ29uZHJhZ2VudGVyJyxcbiAgICBvbkRyYWdFeGl0OiAnb25kcmFnZXhpdCcsXG4gICAgb25EcmFnTGVhdmU6ICdvbmRyYWdsZWF2ZScsXG4gICAgb25EcmFnT3ZlcjogJ29uZHJhZ292ZXInLFxuICAgIG9uRHJhZ1N0YXJ0OiAnb25kcmFnc3RhcnQnLFxuICAgIG9uRHJvcDogJ29uZHJvcCcsXG4gICAgb25EdXJhdGlvbkNoYW5nZTogJ29uZHVyYXRpb25jaGFuZ2UnLFxuICAgIG9uRW1wdGllZDogJ29uZW1wdGllZCcsXG4gICAgb25FbmQ6ICdvbmVuZCcsXG4gICAgb25FbmRlZDogJ29uZW5kZWQnLFxuICAgIG9uRXJyb3I6ICdvbmVycm9yJyxcbiAgICBvbkZvY3VzOiAnb25mb2N1cycsXG4gICAgb25Gb2N1c0luOiAnb25mb2N1c2luJyxcbiAgICBvbkZvY3VzT3V0OiAnb25mb2N1c291dCcsXG4gICAgb25IYXNoQ2hhbmdlOiAnb25oYXNoY2hhbmdlJyxcbiAgICBvbklucHV0OiAnb25pbnB1dCcsXG4gICAgb25JbnZhbGlkOiAnb25pbnZhbGlkJyxcbiAgICBvbktleURvd246ICdvbmtleWRvd24nLFxuICAgIG9uS2V5UHJlc3M6ICdvbmtleXByZXNzJyxcbiAgICBvbktleVVwOiAnb25rZXl1cCcsXG4gICAgb25Mb2FkOiAnb25sb2FkJyxcbiAgICBvbkxvYWRlZERhdGE6ICdvbmxvYWRlZGRhdGEnLFxuICAgIG9uTG9hZGVkTWV0YWRhdGE6ICdvbmxvYWRlZG1ldGFkYXRhJyxcbiAgICBvbkxvYWRTdGFydDogJ29ubG9hZHN0YXJ0JyxcbiAgICBvbk1lc3NhZ2U6ICdvbm1lc3NhZ2UnLFxuICAgIG9uTW91c2VEb3duOiAnb25tb3VzZWRvd24nLFxuICAgIG9uTW91c2VFbnRlcjogJ29ubW91c2VlbnRlcicsXG4gICAgb25Nb3VzZUxlYXZlOiAnb25tb3VzZWxlYXZlJyxcbiAgICBvbk1vdXNlTW92ZTogJ29ubW91c2Vtb3ZlJyxcbiAgICBvbk1vdXNlT3V0OiAnb25tb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdvbm1vdXNlb3ZlcicsXG4gICAgb25Nb3VzZVVwOiAnb25tb3VzZXVwJyxcbiAgICBvbk1vdXNlV2hlZWw6ICdvbm1vdXNld2hlZWwnLFxuICAgIG9uT2ZmbGluZTogJ29ub2ZmbGluZScsXG4gICAgb25PbmxpbmU6ICdvbm9ubGluZScsXG4gICAgb25QYWdlSGlkZTogJ29ucGFnZWhpZGUnLFxuICAgIG9uUGFnZVNob3c6ICdvbnBhZ2VzaG93JyxcbiAgICBvblBhc3RlOiAnb25wYXN0ZScsXG4gICAgb25QYXVzZTogJ29ucGF1c2UnLFxuICAgIG9uUGxheTogJ29ucGxheScsXG4gICAgb25QbGF5aW5nOiAnb25wbGF5aW5nJyxcbiAgICBvblBvcFN0YXRlOiAnb25wb3BzdGF0ZScsXG4gICAgb25Qcm9ncmVzczogJ29ucHJvZ3Jlc3MnLFxuICAgIG9uUmF0ZUNoYW5nZTogJ29ucmF0ZWNoYW5nZScsXG4gICAgb25SZXBlYXQ6ICdvbnJlcGVhdCcsXG4gICAgb25SZXNldDogJ29ucmVzZXQnLFxuICAgIG9uUmVzaXplOiAnb25yZXNpemUnLFxuICAgIG9uU2Nyb2xsOiAnb25zY3JvbGwnLFxuICAgIG9uU2Vla2VkOiAnb25zZWVrZWQnLFxuICAgIG9uU2Vla2luZzogJ29uc2Vla2luZycsXG4gICAgb25TZWxlY3Q6ICdvbnNlbGVjdCcsXG4gICAgb25TaG93OiAnb25zaG93JyxcbiAgICBvblN0YWxsZWQ6ICdvbnN0YWxsZWQnLFxuICAgIG9uU3RvcmFnZTogJ29uc3RvcmFnZScsXG4gICAgb25TdWJtaXQ6ICdvbnN1Ym1pdCcsXG4gICAgb25TdXNwZW5kOiAnb25zdXNwZW5kJyxcbiAgICBvblRpbWVVcGRhdGU6ICdvbnRpbWV1cGRhdGUnLFxuICAgIG9uVG9nZ2xlOiAnb250b2dnbGUnLFxuICAgIG9uVW5sb2FkOiAnb251bmxvYWQnLFxuICAgIG9uVm9sdW1lQ2hhbmdlOiAnb252b2x1bWVjaGFuZ2UnLFxuICAgIG9uV2FpdGluZzogJ29ud2FpdGluZycsXG4gICAgb25ab29tOiAnb256b29tJyxcbiAgICBvdmVybGluZVBvc2l0aW9uOiAnb3ZlcmxpbmUtcG9zaXRpb24nLFxuICAgIG92ZXJsaW5lVGhpY2tuZXNzOiAnb3ZlcmxpbmUtdGhpY2tuZXNzJyxcbiAgICBwYWludE9yZGVyOiAncGFpbnQtb3JkZXInLFxuICAgIHBhbm9zZTE6ICdwYW5vc2UtMScsXG4gICAgcG9pbnRlckV2ZW50czogJ3BvaW50ZXItZXZlbnRzJyxcbiAgICByZWZlcnJlclBvbGljeTogJ3JlZmVycmVycG9saWN5JyxcbiAgICByZW5kZXJpbmdJbnRlbnQ6ICdyZW5kZXJpbmctaW50ZW50JyxcbiAgICBzaGFwZVJlbmRlcmluZzogJ3NoYXBlLXJlbmRlcmluZycsXG4gICAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gICAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICAgIHN0cmlrZXRocm91Z2hQb3NpdGlvbjogJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLFxuICAgIHN0cmlrZXRocm91Z2hUaGlja25lc3M6ICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsXG4gICAgc3Ryb2tlRGFzaEFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgICBzdHJva2VMaW5lQ2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICAgIHN0cm9rZUxpbmVKb2luOiAnc3Ryb2tlLWxpbmVqb2luJyxcbiAgICBzdHJva2VNaXRlckxpbWl0OiAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAgIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gICAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICAgIHRhYkluZGV4OiAndGFiaW5kZXgnLFxuICAgIHRleHRBbmNob3I6ICd0ZXh0LWFuY2hvcicsXG4gICAgdGV4dERlY29yYXRpb246ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgIHRleHRSZW5kZXJpbmc6ICd0ZXh0LXJlbmRlcmluZycsXG4gICAgdHJhbnNmb3JtT3JpZ2luOiAndHJhbnNmb3JtLW9yaWdpbicsXG4gICAgdHlwZU9mOiAndHlwZW9mJyxcbiAgICB1bmRlcmxpbmVQb3NpdGlvbjogJ3VuZGVybGluZS1wb3NpdGlvbicsXG4gICAgdW5kZXJsaW5lVGhpY2tuZXNzOiAndW5kZXJsaW5lLXRoaWNrbmVzcycsXG4gICAgdW5pY29kZUJpZGk6ICd1bmljb2RlLWJpZGknLFxuICAgIHVuaWNvZGVSYW5nZTogJ3VuaWNvZGUtcmFuZ2UnLFxuICAgIHVuaXRzUGVyRW06ICd1bml0cy1wZXItZW0nLFxuICAgIHZBbHBoYWJldGljOiAndi1hbHBoYWJldGljJyxcbiAgICB2SGFuZ2luZzogJ3YtaGFuZ2luZycsXG4gICAgdklkZW9ncmFwaGljOiAndi1pZGVvZ3JhcGhpYycsXG4gICAgdk1hdGhlbWF0aWNhbDogJ3YtbWF0aGVtYXRpY2FsJyxcbiAgICB2ZWN0b3JFZmZlY3Q6ICd2ZWN0b3ItZWZmZWN0JyxcbiAgICB2ZXJ0QWR2WTogJ3ZlcnQtYWR2LXknLFxuICAgIHZlcnRPcmlnaW5YOiAndmVydC1vcmlnaW4teCcsXG4gICAgdmVydE9yaWdpblk6ICd2ZXJ0LW9yaWdpbi15JyxcbiAgICB3b3JkU3BhY2luZzogJ3dvcmQtc3BhY2luZycsXG4gICAgd3JpdGluZ01vZGU6ICd3cml0aW5nLW1vZGUnLFxuICAgIHhIZWlnaHQ6ICd4LWhlaWdodCcsXG4gICAgLy8gVGhlc2Ugd2VyZSBjYW1lbGNhc2VkIGluIFRpbnkuIE5vdyBsb3dlcmNhc2VkIGluIFNWRyAyXG4gICAgcGxheWJhY2tPcmRlcjogJ3BsYXliYWNrb3JkZXInLFxuICAgIHRpbWVsaW5lQmVnaW46ICd0aW1lbGluZWJlZ2luJ1xuICB9LFxuICB0cmFuc2Zvcm06IGNhc2VTZW5zaXRpdmVUcmFuc2Zvcm0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBhYm91dDogY29tbWFPclNwYWNlU2VwYXJhdGVkLFxuICAgIGFjY2VudEhlaWdodDogbnVtYmVyLFxuICAgIGFjY3VtdWxhdGU6IG51bGwsXG4gICAgYWRkaXRpdmU6IG51bGwsXG4gICAgYWxpZ25tZW50QmFzZWxpbmU6IG51bGwsXG4gICAgYWxwaGFiZXRpYzogbnVtYmVyLFxuICAgIGFtcGxpdHVkZTogbnVtYmVyLFxuICAgIGFyYWJpY0Zvcm06IG51bGwsXG4gICAgYXNjZW50OiBudW1iZXIsXG4gICAgYXR0cmlidXRlTmFtZTogbnVsbCxcbiAgICBhdHRyaWJ1dGVUeXBlOiBudWxsLFxuICAgIGF6aW11dGg6IG51bWJlcixcbiAgICBiYW5kd2lkdGg6IG51bGwsXG4gICAgYmFzZWxpbmVTaGlmdDogbnVsbCxcbiAgICBiYXNlRnJlcXVlbmN5OiBudWxsLFxuICAgIGJhc2VQcm9maWxlOiBudWxsLFxuICAgIGJib3g6IG51bGwsXG4gICAgYmVnaW46IG51bGwsXG4gICAgYmlhczogbnVtYmVyLFxuICAgIGJ5OiBudWxsLFxuICAgIGNhbGNNb2RlOiBudWxsLFxuICAgIGNhcEhlaWdodDogbnVtYmVyLFxuICAgIGNsYXNzTmFtZTogc3BhY2VTZXBhcmF0ZWQsXG4gICAgY2xpcDogbnVsbCxcbiAgICBjbGlwUGF0aDogbnVsbCxcbiAgICBjbGlwUGF0aFVuaXRzOiBudWxsLFxuICAgIGNsaXBSdWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsLFxuICAgIGNvbG9ySW50ZXJwb2xhdGlvbjogbnVsbCxcbiAgICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiBudWxsLFxuICAgIGNvbG9yUHJvZmlsZTogbnVsbCxcbiAgICBjb2xvclJlbmRlcmluZzogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGNvbnRlbnRTY3JpcHRUeXBlOiBudWxsLFxuICAgIGNvbnRlbnRTdHlsZVR5cGU6IG51bGwsXG4gICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgY3Vyc29yOiBudWxsLFxuICAgIGN4OiBudWxsLFxuICAgIGN5OiBudWxsLFxuICAgIGQ6IG51bGwsXG4gICAgZGF0YVR5cGU6IG51bGwsXG4gICAgZGVmYXVsdEFjdGlvbjogbnVsbCxcbiAgICBkZXNjZW50OiBudW1iZXIsXG4gICAgZGlmZnVzZUNvbnN0YW50OiBudW1iZXIsXG4gICAgZGlyZWN0aW9uOiBudWxsLFxuICAgIGRpc3BsYXk6IG51bGwsXG4gICAgZHVyOiBudWxsLFxuICAgIGRpdmlzb3I6IG51bWJlcixcbiAgICBkb21pbmFudEJhc2VsaW5lOiBudWxsLFxuICAgIGRvd25sb2FkOiBib29sZWFuLFxuICAgIGR4OiBudWxsLFxuICAgIGR5OiBudWxsLFxuICAgIGVkZ2VNb2RlOiBudWxsLFxuICAgIGVkaXRhYmxlOiBudWxsLFxuICAgIGVsZXZhdGlvbjogbnVtYmVyLFxuICAgIGVuYWJsZUJhY2tncm91bmQ6IG51bGwsXG4gICAgZW5kOiBudWxsLFxuICAgIGV2ZW50OiBudWxsLFxuICAgIGV4cG9uZW50OiBudW1iZXIsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogbnVsbCxcbiAgICBmaWxsOiBudWxsLFxuICAgIGZpbGxPcGFjaXR5OiBudW1iZXIsXG4gICAgZmlsbFJ1bGU6IG51bGwsXG4gICAgZmlsdGVyOiBudWxsLFxuICAgIGZpbHRlclJlczogbnVsbCxcbiAgICBmaWx0ZXJVbml0czogbnVsbCxcbiAgICBmbG9vZENvbG9yOiBudWxsLFxuICAgIGZsb29kT3BhY2l0eTogbnVsbCxcbiAgICBmb2N1c2FibGU6IG51bGwsXG4gICAgZm9jdXNIaWdobGlnaHQ6IG51bGwsXG4gICAgZm9udEZhbWlseTogbnVsbCxcbiAgICBmb250U2l6ZTogbnVsbCxcbiAgICBmb250U2l6ZUFkanVzdDogbnVsbCxcbiAgICBmb250U3RyZXRjaDogbnVsbCxcbiAgICBmb250U3R5bGU6IG51bGwsXG4gICAgZm9udFZhcmlhbnQ6IG51bGwsXG4gICAgZm9udFdlaWdodDogbnVsbCxcbiAgICBmb3JtYXQ6IG51bGwsXG4gICAgZnI6IG51bGwsXG4gICAgZnJvbTogbnVsbCxcbiAgICBmeDogbnVsbCxcbiAgICBmeTogbnVsbCxcbiAgICBnMTogY29tbWFTZXBhcmF0ZWQsXG4gICAgZzI6IGNvbW1hU2VwYXJhdGVkLFxuICAgIGdseXBoTmFtZTogY29tbWFTZXBhcmF0ZWQsXG4gICAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6IG51bGwsXG4gICAgZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOiBudWxsLFxuICAgIGdseXBoUmVmOiBudWxsLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiBudWxsLFxuICAgIGdyYWRpZW50VW5pdHM6IG51bGwsXG4gICAgaGFuZGxlcjogbnVsbCxcbiAgICBoYW5naW5nOiBudW1iZXIsXG4gICAgaGF0Y2hDb250ZW50VW5pdHM6IG51bGwsXG4gICAgaGF0Y2hVbml0czogbnVsbCxcbiAgICBoZWlnaHQ6IG51bGwsXG4gICAgaHJlZjogbnVsbCxcbiAgICBocmVmTGFuZzogbnVsbCxcbiAgICBob3JpekFkdlg6IG51bWJlcixcbiAgICBob3Jpek9yaWdpblg6IG51bWJlcixcbiAgICBob3Jpek9yaWdpblk6IG51bWJlcixcbiAgICBpZDogbnVsbCxcbiAgICBpZGVvZ3JhcGhpYzogbnVtYmVyLFxuICAgIGltYWdlUmVuZGVyaW5nOiBudWxsLFxuICAgIGluaXRpYWxWaXNpYmlsaXR5OiBudWxsLFxuICAgIGluOiBudWxsLFxuICAgIGluMjogbnVsbCxcbiAgICBpbnRlcmNlcHQ6IG51bWJlcixcbiAgICBrOiBudW1iZXIsXG4gICAgazE6IG51bWJlcixcbiAgICBrMjogbnVtYmVyLFxuICAgIGszOiBudW1iZXIsXG4gICAgazQ6IG51bWJlcixcbiAgICBrZXJuZWxNYXRyaXg6IGNvbW1hT3JTcGFjZVNlcGFyYXRlZCxcbiAgICBrZXJuZWxVbml0TGVuZ3RoOiBudWxsLFxuICAgIGtleVBvaW50czogbnVsbCwgLy8gU0VNSV9DT0xPTl9TRVBBUkFURURcbiAgICBrZXlTcGxpbmVzOiBudWxsLCAvLyBTRU1JX0NPTE9OX1NFUEFSQVRFRFxuICAgIGtleVRpbWVzOiBudWxsLCAvLyBTRU1JX0NPTE9OX1NFUEFSQVRFRFxuICAgIGtlcm5pbmc6IG51bGwsXG4gICAgbGFuZzogbnVsbCxcbiAgICBsZW5ndGhBZGp1c3Q6IG51bGwsXG4gICAgbGV0dGVyU3BhY2luZzogbnVsbCxcbiAgICBsaWdodGluZ0NvbG9yOiBudWxsLFxuICAgIGxpbWl0aW5nQ29uZUFuZ2xlOiBudW1iZXIsXG4gICAgbG9jYWw6IG51bGwsXG4gICAgbWFya2VyRW5kOiBudWxsLFxuICAgIG1hcmtlck1pZDogbnVsbCxcbiAgICBtYXJrZXJTdGFydDogbnVsbCxcbiAgICBtYXJrZXJIZWlnaHQ6IG51bGwsXG4gICAgbWFya2VyVW5pdHM6IG51bGwsXG4gICAgbWFya2VyV2lkdGg6IG51bGwsXG4gICAgbWFzazogbnVsbCxcbiAgICBtYXNrQ29udGVudFVuaXRzOiBudWxsLFxuICAgIG1hc2tVbml0czogbnVsbCxcbiAgICBtYXRoZW1hdGljYWw6IG51bGwsXG4gICAgbWF4OiBudWxsLFxuICAgIG1lZGlhOiBudWxsLFxuICAgIG1lZGlhQ2hhcmFjdGVyRW5jb2Rpbmc6IG51bGwsXG4gICAgbWVkaWFDb250ZW50RW5jb2RpbmdzOiBudWxsLFxuICAgIG1lZGlhU2l6ZTogbnVtYmVyLFxuICAgIG1lZGlhVGltZTogbnVsbCxcbiAgICBtZXRob2Q6IG51bGwsXG4gICAgbWluOiBudWxsLFxuICAgIG1vZGU6IG51bGwsXG4gICAgbmFtZTogbnVsbCxcbiAgICBuYXZEb3duOiBudWxsLFxuICAgIG5hdkRvd25MZWZ0OiBudWxsLFxuICAgIG5hdkRvd25SaWdodDogbnVsbCxcbiAgICBuYXZMZWZ0OiBudWxsLFxuICAgIG5hdk5leHQ6IG51bGwsXG4gICAgbmF2UHJldjogbnVsbCxcbiAgICBuYXZSaWdodDogbnVsbCxcbiAgICBuYXZVcDogbnVsbCxcbiAgICBuYXZVcExlZnQ6IG51bGwsXG4gICAgbmF2VXBSaWdodDogbnVsbCxcbiAgICBudW1PY3RhdmVzOiBudWxsLFxuICAgIG9ic2VydmVyOiBudWxsLFxuICAgIG9mZnNldDogbnVsbCxcbiAgICBvbkFib3J0OiBudWxsLFxuICAgIG9uQWN0aXZhdGU6IG51bGwsXG4gICAgb25BZnRlclByaW50OiBudWxsLFxuICAgIG9uQmVmb3JlUHJpbnQ6IG51bGwsXG4gICAgb25CZWdpbjogbnVsbCxcbiAgICBvbkNhbmNlbDogbnVsbCxcbiAgICBvbkNhblBsYXk6IG51bGwsXG4gICAgb25DYW5QbGF5VGhyb3VnaDogbnVsbCxcbiAgICBvbkNoYW5nZTogbnVsbCxcbiAgICBvbkNsaWNrOiBudWxsLFxuICAgIG9uQ2xvc2U6IG51bGwsXG4gICAgb25Db3B5OiBudWxsLFxuICAgIG9uQ3VlQ2hhbmdlOiBudWxsLFxuICAgIG9uQ3V0OiBudWxsLFxuICAgIG9uRGJsQ2xpY2s6IG51bGwsXG4gICAgb25EcmFnOiBudWxsLFxuICAgIG9uRHJhZ0VuZDogbnVsbCxcbiAgICBvbkRyYWdFbnRlcjogbnVsbCxcbiAgICBvbkRyYWdFeGl0OiBudWxsLFxuICAgIG9uRHJhZ0xlYXZlOiBudWxsLFxuICAgIG9uRHJhZ092ZXI6IG51bGwsXG4gICAgb25EcmFnU3RhcnQ6IG51bGwsXG4gICAgb25Ecm9wOiBudWxsLFxuICAgIG9uRHVyYXRpb25DaGFuZ2U6IG51bGwsXG4gICAgb25FbXB0aWVkOiBudWxsLFxuICAgIG9uRW5kOiBudWxsLFxuICAgIG9uRW5kZWQ6IG51bGwsXG4gICAgb25FcnJvcjogbnVsbCxcbiAgICBvbkZvY3VzOiBudWxsLFxuICAgIG9uRm9jdXNJbjogbnVsbCxcbiAgICBvbkZvY3VzT3V0OiBudWxsLFxuICAgIG9uSGFzaENoYW5nZTogbnVsbCxcbiAgICBvbklucHV0OiBudWxsLFxuICAgIG9uSW52YWxpZDogbnVsbCxcbiAgICBvbktleURvd246IG51bGwsXG4gICAgb25LZXlQcmVzczogbnVsbCxcbiAgICBvbktleVVwOiBudWxsLFxuICAgIG9uTG9hZDogbnVsbCxcbiAgICBvbkxvYWRlZERhdGE6IG51bGwsXG4gICAgb25Mb2FkZWRNZXRhZGF0YTogbnVsbCxcbiAgICBvbkxvYWRTdGFydDogbnVsbCxcbiAgICBvbk1lc3NhZ2U6IG51bGwsXG4gICAgb25Nb3VzZURvd246IG51bGwsXG4gICAgb25Nb3VzZUVudGVyOiBudWxsLFxuICAgIG9uTW91c2VMZWF2ZTogbnVsbCxcbiAgICBvbk1vdXNlTW92ZTogbnVsbCxcbiAgICBvbk1vdXNlT3V0OiBudWxsLFxuICAgIG9uTW91c2VPdmVyOiBudWxsLFxuICAgIG9uTW91c2VVcDogbnVsbCxcbiAgICBvbk1vdXNlV2hlZWw6IG51bGwsXG4gICAgb25PZmZsaW5lOiBudWxsLFxuICAgIG9uT25saW5lOiBudWxsLFxuICAgIG9uUGFnZUhpZGU6IG51bGwsXG4gICAgb25QYWdlU2hvdzogbnVsbCxcbiAgICBvblBhc3RlOiBudWxsLFxuICAgIG9uUGF1c2U6IG51bGwsXG4gICAgb25QbGF5OiBudWxsLFxuICAgIG9uUGxheWluZzogbnVsbCxcbiAgICBvblBvcFN0YXRlOiBudWxsLFxuICAgIG9uUHJvZ3Jlc3M6IG51bGwsXG4gICAgb25SYXRlQ2hhbmdlOiBudWxsLFxuICAgIG9uUmVwZWF0OiBudWxsLFxuICAgIG9uUmVzZXQ6IG51bGwsXG4gICAgb25SZXNpemU6IG51bGwsXG4gICAgb25TY3JvbGw6IG51bGwsXG4gICAgb25TZWVrZWQ6IG51bGwsXG4gICAgb25TZWVraW5nOiBudWxsLFxuICAgIG9uU2VsZWN0OiBudWxsLFxuICAgIG9uU2hvdzogbnVsbCxcbiAgICBvblN0YWxsZWQ6IG51bGwsXG4gICAgb25TdG9yYWdlOiBudWxsLFxuICAgIG9uU3VibWl0OiBudWxsLFxuICAgIG9uU3VzcGVuZDogbnVsbCxcbiAgICBvblRpbWVVcGRhdGU6IG51bGwsXG4gICAgb25Ub2dnbGU6IG51bGwsXG4gICAgb25VbmxvYWQ6IG51bGwsXG4gICAgb25Wb2x1bWVDaGFuZ2U6IG51bGwsXG4gICAgb25XYWl0aW5nOiBudWxsLFxuICAgIG9uWm9vbTogbnVsbCxcbiAgICBvcGFjaXR5OiBudWxsLFxuICAgIG9wZXJhdG9yOiBudWxsLFxuICAgIG9yZGVyOiBudWxsLFxuICAgIG9yaWVudDogbnVsbCxcbiAgICBvcmllbnRhdGlvbjogbnVsbCxcbiAgICBvcmlnaW46IG51bGwsXG4gICAgb3ZlcmZsb3c6IG51bGwsXG4gICAgb3ZlcmxheTogbnVsbCxcbiAgICBvdmVybGluZVBvc2l0aW9uOiBudW1iZXIsXG4gICAgb3ZlcmxpbmVUaGlja25lc3M6IG51bWJlcixcbiAgICBwYWludE9yZGVyOiBudWxsLFxuICAgIHBhbm9zZTE6IG51bGwsXG4gICAgcGF0aDogbnVsbCxcbiAgICBwYXRoTGVuZ3RoOiBudW1iZXIsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogbnVsbCxcbiAgICBwYXR0ZXJuVHJhbnNmb3JtOiBudWxsLFxuICAgIHBhdHRlcm5Vbml0czogbnVsbCxcbiAgICBwaGFzZTogbnVsbCxcbiAgICBwaW5nOiBzcGFjZVNlcGFyYXRlZCxcbiAgICBwaXRjaDogbnVsbCxcbiAgICBwbGF5YmFja09yZGVyOiBudWxsLFxuICAgIHBvaW50ZXJFdmVudHM6IG51bGwsXG4gICAgcG9pbnRzOiBudWxsLFxuICAgIHBvaW50c0F0WDogbnVtYmVyLFxuICAgIHBvaW50c0F0WTogbnVtYmVyLFxuICAgIHBvaW50c0F0WjogbnVtYmVyLFxuICAgIHByZXNlcnZlQWxwaGE6IG51bGwsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogbnVsbCxcbiAgICBwcmltaXRpdmVVbml0czogbnVsbCxcbiAgICBwcm9wYWdhdGU6IG51bGwsXG4gICAgcHJvcGVydHk6IGNvbW1hT3JTcGFjZVNlcGFyYXRlZCxcbiAgICByOiBudWxsLFxuICAgIHJhZGl1czogbnVsbCxcbiAgICByZWZlcnJlclBvbGljeTogbnVsbCxcbiAgICByZWZYOiBudWxsLFxuICAgIHJlZlk6IG51bGwsXG4gICAgcmVsOiBjb21tYU9yU3BhY2VTZXBhcmF0ZWQsXG4gICAgcmV2OiBjb21tYU9yU3BhY2VTZXBhcmF0ZWQsXG4gICAgcmVuZGVyaW5nSW50ZW50OiBudWxsLFxuICAgIHJlcGVhdENvdW50OiBudWxsLFxuICAgIHJlcGVhdER1cjogbnVsbCxcbiAgICByZXF1aXJlZEV4dGVuc2lvbnM6IGNvbW1hT3JTcGFjZVNlcGFyYXRlZCxcbiAgICByZXF1aXJlZEZlYXR1cmVzOiBjb21tYU9yU3BhY2VTZXBhcmF0ZWQsXG4gICAgcmVxdWlyZWRGb250czogY29tbWFPclNwYWNlU2VwYXJhdGVkLFxuICAgIHJlcXVpcmVkRm9ybWF0czogY29tbWFPclNwYWNlU2VwYXJhdGVkLFxuICAgIHJlc291cmNlOiBudWxsLFxuICAgIHJlc3RhcnQ6IG51bGwsXG4gICAgcmVzdWx0OiBudWxsLFxuICAgIHJvdGF0ZTogbnVsbCxcbiAgICByeDogbnVsbCxcbiAgICByeTogbnVsbCxcbiAgICBzY2FsZTogbnVsbCxcbiAgICBzZWVkOiBudWxsLFxuICAgIHNoYXBlUmVuZGVyaW5nOiBudWxsLFxuICAgIHNpZGU6IG51bGwsXG4gICAgc2xvcGU6IG51bGwsXG4gICAgc25hcHNob3RUaW1lOiBudWxsLFxuICAgIHNwZWN1bGFyQ29uc3RhbnQ6IG51bWJlcixcbiAgICBzcGVjdWxhckV4cG9uZW50OiBudW1iZXIsXG4gICAgc3ByZWFkTWV0aG9kOiBudWxsLFxuICAgIHNwYWNpbmc6IG51bGwsXG4gICAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gICAgc3RkRGV2aWF0aW9uOiBudWxsLFxuICAgIHN0ZW1oOiBudWxsLFxuICAgIHN0ZW12OiBudWxsLFxuICAgIHN0aXRjaFRpbGVzOiBudWxsLFxuICAgIHN0b3BDb2xvcjogbnVsbCxcbiAgICBzdG9wT3BhY2l0eTogbnVsbCxcbiAgICBzdHJpa2V0aHJvdWdoUG9zaXRpb246IG51bWJlcixcbiAgICBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOiBudW1iZXIsXG4gICAgc3RyaW5nOiBudWxsLFxuICAgIHN0cm9rZTogbnVsbCxcbiAgICBzdHJva2VEYXNoQXJyYXk6IGNvbW1hT3JTcGFjZVNlcGFyYXRlZCxcbiAgICBzdHJva2VEYXNoT2Zmc2V0OiBudWxsLFxuICAgIHN0cm9rZUxpbmVDYXA6IG51bGwsXG4gICAgc3Ryb2tlTGluZUpvaW46IG51bGwsXG4gICAgc3Ryb2tlTWl0ZXJMaW1pdDogbnVtYmVyLFxuICAgIHN0cm9rZU9wYWNpdHk6IG51bWJlcixcbiAgICBzdHJva2VXaWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBzdXJmYWNlU2NhbGU6IG51bWJlcixcbiAgICBzeW5jQmVoYXZpb3I6IG51bGwsXG4gICAgc3luY0JlaGF2aW9yRGVmYXVsdDogbnVsbCxcbiAgICBzeW5jTWFzdGVyOiBudWxsLFxuICAgIHN5bmNUb2xlcmFuY2U6IG51bGwsXG4gICAgc3luY1RvbGVyYW5jZURlZmF1bHQ6IG51bGwsXG4gICAgc3lzdGVtTGFuZ3VhZ2U6IGNvbW1hT3JTcGFjZVNlcGFyYXRlZCxcbiAgICB0YWJJbmRleDogbnVtYmVyLFxuICAgIHRhYmxlVmFsdWVzOiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0YXJnZXRYOiBudW1iZXIsXG4gICAgdGFyZ2V0WTogbnVtYmVyLFxuICAgIHRleHRBbmNob3I6IG51bGwsXG4gICAgdGV4dERlY29yYXRpb246IG51bGwsXG4gICAgdGV4dFJlbmRlcmluZzogbnVsbCxcbiAgICB0ZXh0TGVuZ3RoOiBudWxsLFxuICAgIHRpbWVsaW5lQmVnaW46IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHJhbnNmb3JtQmVoYXZpb3I6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB0eXBlT2Y6IGNvbW1hT3JTcGFjZVNlcGFyYXRlZCxcbiAgICB0bzogbnVsbCxcbiAgICB0cmFuc2Zvcm06IG51bGwsXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBudWxsLFxuICAgIHUxOiBudWxsLFxuICAgIHUyOiBudWxsLFxuICAgIHVuZGVybGluZVBvc2l0aW9uOiBudW1iZXIsXG4gICAgdW5kZXJsaW5lVGhpY2tuZXNzOiBudW1iZXIsXG4gICAgdW5pY29kZTogbnVsbCxcbiAgICB1bmljb2RlQmlkaTogbnVsbCxcbiAgICB1bmljb2RlUmFuZ2U6IG51bGwsXG4gICAgdW5pdHNQZXJFbTogbnVtYmVyLFxuICAgIHZhbHVlczogbnVsbCxcbiAgICB2QWxwaGFiZXRpYzogbnVtYmVyLFxuICAgIHZNYXRoZW1hdGljYWw6IG51bWJlcixcbiAgICB2ZWN0b3JFZmZlY3Q6IG51bGwsXG4gICAgdkhhbmdpbmc6IG51bWJlcixcbiAgICB2SWRlb2dyYXBoaWM6IG51bWJlcixcbiAgICB2ZXJzaW9uOiBudWxsLFxuICAgIHZlcnRBZHZZOiBudW1iZXIsXG4gICAgdmVydE9yaWdpblg6IG51bWJlcixcbiAgICB2ZXJ0T3JpZ2luWTogbnVtYmVyLFxuICAgIHZpZXdCb3g6IG51bGwsXG4gICAgdmlld1RhcmdldDogbnVsbCxcbiAgICB2aXNpYmlsaXR5OiBudWxsLFxuICAgIHdpZHRoOiBudWxsLFxuICAgIHdpZHRoczogbnVsbCxcbiAgICB3b3JkU3BhY2luZzogbnVsbCxcbiAgICB3cml0aW5nTW9kZTogbnVsbCxcbiAgICB4OiBudWxsLFxuICAgIHgxOiBudWxsLFxuICAgIHgyOiBudWxsLFxuICAgIHhDaGFubmVsU2VsZWN0b3I6IG51bGwsXG4gICAgeEhlaWdodDogbnVtYmVyLFxuICAgIHk6IG51bGwsXG4gICAgeTE6IG51bGwsXG4gICAgeTI6IG51bGwsXG4gICAgeUNoYW5uZWxTZWxlY3RvcjogbnVsbCxcbiAgICB6OiBudWxsLFxuICAgIHpvb21BbmRQYW46IG51bGxcbiAgfVxufSlcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-insensitive-transform.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-insensitive-transform.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   caseInsensitiveTransform: () => (/* binding */ caseInsensitiveTransform)\n/* harmony export */ });\n/* harmony import */ var _case_sensitive_transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./case-sensitive-transform.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-sensitive-transform.js\");\n\n\n/**\n * @param {Record<string, string>} attributes\n * @param {string} property\n * @returns {string}\n */\nfunction caseInsensitiveTransform(attributes, property) {\n  return (0,_case_sensitive_transform_js__WEBPACK_IMPORTED_MODULE_0__.caseSensitiveTransform)(attributes, property.toLowerCase())\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvY2FzZS1pbnNlbnNpdGl2ZS10cmFuc2Zvcm0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0U7O0FBRXBFO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNPO0FBQ1AsU0FBUyxvRkFBc0I7QUFDL0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi91dGlsL2Nhc2UtaW5zZW5zaXRpdmUtdHJhbnNmb3JtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y2FzZVNlbnNpdGl2ZVRyYW5zZm9ybX0gZnJvbSAnLi9jYXNlLXNlbnNpdGl2ZS10cmFuc2Zvcm0uanMnXG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXNlSW5zZW5zaXRpdmVUcmFuc2Zvcm0oYXR0cmlidXRlcywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIGNhc2VTZW5zaXRpdmVUcmFuc2Zvcm0oYXR0cmlidXRlcywgcHJvcGVydHkudG9Mb3dlckNhc2UoKSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-insensitive-transform.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-sensitive-transform.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-sensitive-transform.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   caseSensitiveTransform: () => (/* binding */ caseSensitiveTransform)\n/* harmony export */ });\n/**\n * @param {Record<string, string>} attributes\n * @param {string} attribute\n * @returns {string}\n */\nfunction caseSensitiveTransform(attributes, attribute) {\n  return attribute in attributes ? attributes[attribute] : attribute\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvY2FzZS1zZW5zaXRpdmUtdHJhbnNmb3JtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi91dGlsL2Nhc2Utc2Vuc2l0aXZlLXRyYW5zZm9ybS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gYXR0cmlidXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhc2VTZW5zaXRpdmVUcmFuc2Zvcm0oYXR0cmlidXRlcywgYXR0cmlidXRlKSB7XG4gIHJldHVybiBhdHRyaWJ1dGUgaW4gYXR0cmlidXRlcyA/IGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA6IGF0dHJpYnV0ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-sensitive-transform.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/create.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/create.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _normalize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../normalize.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/normalize.js\");\n/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/schema.js\");\n/* harmony import */ var _defined_info_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defined-info.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/defined-info.js\");\n/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n *\n * @typedef {Record<string, string>} Attributes\n *\n * @typedef {Object} Definition\n * @property {Record<string, number|null>} properties\n * @property {(attributes: Attributes, property: string) => string} transform\n * @property {string} [space]\n * @property {Attributes} [attributes]\n * @property {Array<string>} [mustUseProperty]\n */\n\n\n\n\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Definition} definition\n * @returns {Schema}\n */\nfunction create(definition) {\n  /** @type {Properties} */\n  const property = {}\n  /** @type {Normal} */\n  const normal = {}\n  /** @type {string} */\n  let prop\n\n  for (prop in definition.properties) {\n    if (own.call(definition.properties, prop)) {\n      const value = definition.properties[prop]\n      const info = new _defined_info_js__WEBPACK_IMPORTED_MODULE_0__.DefinedInfo(\n        prop,\n        definition.transform(definition.attributes || {}, prop),\n        value,\n        definition.space\n      )\n\n      if (\n        definition.mustUseProperty &&\n        definition.mustUseProperty.includes(prop)\n      ) {\n        info.mustUseProperty = true\n      }\n\n      property[prop] = info\n\n      normal[(0,_normalize_js__WEBPACK_IMPORTED_MODULE_1__.normalize)(prop)] = prop\n      normal[(0,_normalize_js__WEBPACK_IMPORTED_MODULE_1__.normalize)(info.attribute)] = prop\n    }\n  }\n\n  return new _schema_js__WEBPACK_IMPORTED_MODULE_2__.Schema(property, normal, definition.space)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvY3JlYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyw2QkFBNkI7QUFDM0MsY0FBYyxzREFBc0Q7QUFDcEUsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsWUFBWTtBQUMxQixjQUFjLGVBQWU7QUFDN0I7O0FBRXlDO0FBQ1A7QUFDVzs7QUFFN0MsY0FBYzs7QUFFZDtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDTztBQUNQLGFBQWEsWUFBWTtBQUN6QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQVc7QUFDbEM7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLHdEQUFTO0FBQ3RCLGFBQWEsd0RBQVM7QUFDdEI7QUFDQTs7QUFFQSxhQUFhLDhDQUFNO0FBQ25CIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3BlcnR5LWluZm9ybWF0aW9uQDYuNS4wL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1pbmZvcm1hdGlvbi9saWIvdXRpbC9jcmVhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NjaGVtYS5qcycpLlByb3BlcnRpZXN9IFByb3BlcnRpZXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2NoZW1hLmpzJykuTm9ybWFsfSBOb3JtYWxcbiAqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gQXR0cmlidXRlc1xuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgbnVtYmVyfG51bGw+fSBwcm9wZXJ0aWVzXG4gKiBAcHJvcGVydHkgeyhhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVzLCBwcm9wZXJ0eTogc3RyaW5nKSA9PiBzdHJpbmd9IHRyYW5zZm9ybVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzcGFjZV1cbiAqIEBwcm9wZXJ0eSB7QXR0cmlidXRlc30gW2F0dHJpYnV0ZXNdXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFttdXN0VXNlUHJvcGVydHldXG4gKi9cblxuaW1wb3J0IHtub3JtYWxpemV9IGZyb20gJy4uL25vcm1hbGl6ZS5qcydcbmltcG9ydCB7U2NoZW1hfSBmcm9tICcuL3NjaGVtYS5qcydcbmltcG9ydCB7RGVmaW5lZEluZm99IGZyb20gJy4vZGVmaW5lZC1pbmZvLmpzJ1xuXG5jb25zdCBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG4vKipcbiAqIEBwYXJhbSB7RGVmaW5pdGlvbn0gZGVmaW5pdGlvblxuICogQHJldHVybnMge1NjaGVtYX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShkZWZpbml0aW9uKSB7XG4gIC8qKiBAdHlwZSB7UHJvcGVydGllc30gKi9cbiAgY29uc3QgcHJvcGVydHkgPSB7fVxuICAvKiogQHR5cGUge05vcm1hbH0gKi9cbiAgY29uc3Qgbm9ybWFsID0ge31cbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBwcm9wXG5cbiAgZm9yIChwcm9wIGluIGRlZmluaXRpb24ucHJvcGVydGllcykge1xuICAgIGlmIChvd24uY2FsbChkZWZpbml0aW9uLnByb3BlcnRpZXMsIHByb3ApKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGRlZmluaXRpb24ucHJvcGVydGllc1twcm9wXVxuICAgICAgY29uc3QgaW5mbyA9IG5ldyBEZWZpbmVkSW5mbyhcbiAgICAgICAgcHJvcCxcbiAgICAgICAgZGVmaW5pdGlvbi50cmFuc2Zvcm0oZGVmaW5pdGlvbi5hdHRyaWJ1dGVzIHx8IHt9LCBwcm9wKSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRlZmluaXRpb24uc3BhY2VcbiAgICAgIClcblxuICAgICAgaWYgKFxuICAgICAgICBkZWZpbml0aW9uLm11c3RVc2VQcm9wZXJ0eSAmJlxuICAgICAgICBkZWZpbml0aW9uLm11c3RVc2VQcm9wZXJ0eS5pbmNsdWRlcyhwcm9wKVxuICAgICAgKSB7XG4gICAgICAgIGluZm8ubXVzdFVzZVByb3BlcnR5ID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBwcm9wZXJ0eVtwcm9wXSA9IGluZm9cblxuICAgICAgbm9ybWFsW25vcm1hbGl6ZShwcm9wKV0gPSBwcm9wXG4gICAgICBub3JtYWxbbm9ybWFsaXplKGluZm8uYXR0cmlidXRlKV0gPSBwcm9wXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEocHJvcGVydHksIG5vcm1hbCwgZGVmaW5pdGlvbi5zcGFjZSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/create.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/defined-info.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/defined-info.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefinedInfo: () => (/* binding */ DefinedInfo)\n/* harmony export */ });\n/* harmony import */ var _info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./info.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/info.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/types.js\");\n\n\n\n/** @type {Array<keyof types>} */\n// @ts-expect-error: hush.\nconst checks = Object.keys(_types_js__WEBPACK_IMPORTED_MODULE_0__)\n\nclass DefinedInfo extends _info_js__WEBPACK_IMPORTED_MODULE_1__.Info {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   * @param {number|null} [mask]\n   * @param {string} [space]\n   */\n  constructor(property, attribute, mask, space) {\n    let index = -1\n\n    super(property, attribute)\n\n    mark(this, 'space', space)\n\n    if (typeof mask === 'number') {\n      while (++index < checks.length) {\n        const check = checks[index]\n        mark(this, checks[index], (mask & _types_js__WEBPACK_IMPORTED_MODULE_0__[check]) === _types_js__WEBPACK_IMPORTED_MODULE_0__[check])\n      }\n    }\n  }\n}\n\nDefinedInfo.prototype.defined = true\n\n/**\n * @param {DefinedInfo} values\n * @param {string} key\n * @param {unknown} value\n */\nfunction mark(values, key, value) {\n  if (value) {\n    // @ts-expect-error: assume `value` matches the expected value of `key`.\n    values[key] = value\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvZGVmaW5lZC1pbmZvLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QjtBQUNLOztBQUVuQyxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLDJCQUEyQixzQ0FBSzs7QUFFekIsMEJBQTBCLDBDQUFJO0FBQ3JDO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQ0FBSyxhQUFhLHNDQUFLO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi91dGlsL2RlZmluZWQtaW5mby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luZm99IGZyb20gJy4vaW5mby5qcydcbmltcG9ydCAqIGFzIHR5cGVzIGZyb20gJy4vdHlwZXMuanMnXG5cbi8qKiBAdHlwZSB7QXJyYXk8a2V5b2YgdHlwZXM+fSAqL1xuLy8gQHRzLWV4cGVjdC1lcnJvcjogaHVzaC5cbmNvbnN0IGNoZWNrcyA9IE9iamVjdC5rZXlzKHR5cGVzKVxuXG5leHBvcnQgY2xhc3MgRGVmaW5lZEluZm8gZXh0ZW5kcyBJbmZvIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSBbbWFza11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzcGFjZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5LCBhdHRyaWJ1dGUsIG1hc2ssIHNwYWNlKSB7XG4gICAgbGV0IGluZGV4ID0gLTFcblxuICAgIHN1cGVyKHByb3BlcnR5LCBhdHRyaWJ1dGUpXG5cbiAgICBtYXJrKHRoaXMsICdzcGFjZScsIHNwYWNlKVxuXG4gICAgaWYgKHR5cGVvZiBtYXNrID09PSAnbnVtYmVyJykge1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBjaGVja3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gY2hlY2tzW2luZGV4XVxuICAgICAgICBtYXJrKHRoaXMsIGNoZWNrc1tpbmRleF0sIChtYXNrICYgdHlwZXNbY2hlY2tdKSA9PT0gdHlwZXNbY2hlY2tdKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5EZWZpbmVkSW5mby5wcm90b3R5cGUuZGVmaW5lZCA9IHRydWVcblxuLyoqXG4gKiBAcGFyYW0ge0RlZmluZWRJbmZvfSB2YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gbWFyayh2YWx1ZXMsIGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYXNzdW1lIGB2YWx1ZWAgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgdmFsdWUgb2YgYGtleWAuXG4gICAgdmFsdWVzW2tleV0gPSB2YWx1ZVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/defined-info.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/info.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/info.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Info: () => (/* binding */ Info)\n/* harmony export */ });\nclass Info {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   */\n  constructor(property, attribute) {\n    /** @type {string} */\n    this.property = property\n    /** @type {string} */\n    this.attribute = attribute\n  }\n}\n\n/** @type {string|null} */\nInfo.prototype.space = null\nInfo.prototype.boolean = false\nInfo.prototype.booleanish = false\nInfo.prototype.overloadedBoolean = false\nInfo.prototype.number = false\nInfo.prototype.commaSeparated = false\nInfo.prototype.spaceSeparated = false\nInfo.prototype.commaOrSpaceSeparated = false\nInfo.prototype.mustUseProperty = false\nInfo.prototype.defined = false\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvaW5mby5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi91dGlsL2luZm8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEluZm8ge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSwgYXR0cmlidXRlKSB7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGVcbiAgfVxufVxuXG4vKiogQHR5cGUge3N0cmluZ3xudWxsfSAqL1xuSW5mby5wcm90b3R5cGUuc3BhY2UgPSBudWxsXG5JbmZvLnByb3RvdHlwZS5ib29sZWFuID0gZmFsc2VcbkluZm8ucHJvdG90eXBlLmJvb2xlYW5pc2ggPSBmYWxzZVxuSW5mby5wcm90b3R5cGUub3ZlcmxvYWRlZEJvb2xlYW4gPSBmYWxzZVxuSW5mby5wcm90b3R5cGUubnVtYmVyID0gZmFsc2VcbkluZm8ucHJvdG90eXBlLmNvbW1hU2VwYXJhdGVkID0gZmFsc2VcbkluZm8ucHJvdG90eXBlLnNwYWNlU2VwYXJhdGVkID0gZmFsc2VcbkluZm8ucHJvdG90eXBlLmNvbW1hT3JTcGFjZVNlcGFyYXRlZCA9IGZhbHNlXG5JbmZvLnByb3RvdHlwZS5tdXN0VXNlUHJvcGVydHkgPSBmYWxzZVxuSW5mby5wcm90b3R5cGUuZGVmaW5lZCA9IGZhbHNlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/info.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/merge.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/merge.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   merge: () => (/* binding */ merge)\n/* harmony export */ });\n/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schema.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/schema.js\");\n/**\n * @typedef {import('./schema.js').Properties} Properties\n * @typedef {import('./schema.js').Normal} Normal\n */\n\n\n\n/**\n * @param {Schema[]} definitions\n * @param {string} [space]\n * @returns {Schema}\n */\nfunction merge(definitions, space) {\n  /** @type {Properties} */\n  const property = {}\n  /** @type {Normal} */\n  const normal = {}\n  let index = -1\n\n  while (++index < definitions.length) {\n    Object.assign(property, definitions[index].property)\n    Object.assign(normal, definitions[index].normal)\n  }\n\n  return new _schema_js__WEBPACK_IMPORTED_MODULE_0__.Schema(property, normal, space)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvbWVyZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsOEJBQThCO0FBQzNDOztBQUVrQzs7QUFFbEM7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNPO0FBQ1AsYUFBYSxZQUFZO0FBQ3pCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSw4Q0FBTTtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvbWVyZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NjaGVtYS5qcycpLlByb3BlcnRpZXN9IFByb3BlcnRpZXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2NoZW1hLmpzJykuTm9ybWFsfSBOb3JtYWxcbiAqL1xuXG5pbXBvcnQge1NjaGVtYX0gZnJvbSAnLi9zY2hlbWEuanMnXG5cbi8qKlxuICogQHBhcmFtIHtTY2hlbWFbXX0gZGVmaW5pdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3BhY2VdXG4gKiBAcmV0dXJucyB7U2NoZW1hfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UoZGVmaW5pdGlvbnMsIHNwYWNlKSB7XG4gIC8qKiBAdHlwZSB7UHJvcGVydGllc30gKi9cbiAgY29uc3QgcHJvcGVydHkgPSB7fVxuICAvKiogQHR5cGUge05vcm1hbH0gKi9cbiAgY29uc3Qgbm9ybWFsID0ge31cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGRlZmluaXRpb25zLmxlbmd0aCkge1xuICAgIE9iamVjdC5hc3NpZ24ocHJvcGVydHksIGRlZmluaXRpb25zW2luZGV4XS5wcm9wZXJ0eSlcbiAgICBPYmplY3QuYXNzaWduKG5vcm1hbCwgZGVmaW5pdGlvbnNbaW5kZXhdLm5vcm1hbClcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHByb3BlcnR5LCBub3JtYWwsIHNwYWNlKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/merge.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/schema.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/schema.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Schema: () => (/* binding */ Schema)\n/* harmony export */ });\n/**\n * @typedef {import('./info.js').Info} Info\n * @typedef {Record<string, Info>} Properties\n * @typedef {Record<string, string>} Normal\n */\n\nclass Schema {\n  /**\n   * @constructor\n   * @param {Properties} property\n   * @param {Normal} normal\n   * @param {string} [space]\n   */\n  constructor(property, normal, space) {\n    this.property = property\n    this.normal = normal\n    if (space) {\n      this.space = space\n    }\n  }\n}\n\n/** @type {Properties} */\nSchema.prototype.property = {}\n/** @type {Normal} */\nSchema.prototype.normal = {}\n/** @type {string|null} */\nSchema.prototype.space = null\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvc2NoZW1hLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsd0JBQXdCO0FBQ3JDOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFlBQVk7QUFDdkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLGFBQWE7QUFDeEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi91dGlsL3NjaGVtYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vaW5mby5qcycpLkluZm99IEluZm9cbiAqIEB0eXBlZGVmIHtSZWNvcmQ8c3RyaW5nLCBJbmZvPn0gUHJvcGVydGllc1xuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IE5vcm1hbFxuICovXG5cbmV4cG9ydCBjbGFzcyBTY2hlbWEge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UHJvcGVydGllc30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtOb3JtYWx9IG5vcm1hbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NwYWNlXVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcGVydHksIG5vcm1hbCwgc3BhY2UpIHtcbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHlcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbFxuICAgIGlmIChzcGFjZSkge1xuICAgICAgdGhpcy5zcGFjZSA9IHNwYWNlXG4gICAgfVxuICB9XG59XG5cbi8qKiBAdHlwZSB7UHJvcGVydGllc30gKi9cblNjaGVtYS5wcm90b3R5cGUucHJvcGVydHkgPSB7fVxuLyoqIEB0eXBlIHtOb3JtYWx9ICovXG5TY2hlbWEucHJvdG90eXBlLm5vcm1hbCA9IHt9XG4vKiogQHR5cGUge3N0cmluZ3xudWxsfSAqL1xuU2NoZW1hLnByb3RvdHlwZS5zcGFjZSA9IG51bGxcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/schema.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/types.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/types.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   booleanish: () => (/* binding */ booleanish),\n/* harmony export */   commaOrSpaceSeparated: () => (/* binding */ commaOrSpaceSeparated),\n/* harmony export */   commaSeparated: () => (/* binding */ commaSeparated),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   overloadedBoolean: () => (/* binding */ overloadedBoolean),\n/* harmony export */   spaceSeparated: () => (/* binding */ spaceSeparated)\n/* harmony export */ });\nlet powers = 0\n\nconst boolean = increment()\nconst booleanish = increment()\nconst overloadedBoolean = increment()\nconst number = increment()\nconst spaceSeparated = increment()\nconst commaSeparated = increment()\nconst commaOrSpaceSeparated = increment()\n\nfunction increment() {\n  return 2 ** ++powers\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOztBQUVPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3V0aWwvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHBvd2VycyA9IDBcblxuZXhwb3J0IGNvbnN0IGJvb2xlYW4gPSBpbmNyZW1lbnQoKVxuZXhwb3J0IGNvbnN0IGJvb2xlYW5pc2ggPSBpbmNyZW1lbnQoKVxuZXhwb3J0IGNvbnN0IG92ZXJsb2FkZWRCb29sZWFuID0gaW5jcmVtZW50KClcbmV4cG9ydCBjb25zdCBudW1iZXIgPSBpbmNyZW1lbnQoKVxuZXhwb3J0IGNvbnN0IHNwYWNlU2VwYXJhdGVkID0gaW5jcmVtZW50KClcbmV4cG9ydCBjb25zdCBjb21tYVNlcGFyYXRlZCA9IGluY3JlbWVudCgpXG5leHBvcnQgY29uc3QgY29tbWFPclNwYWNlU2VwYXJhdGVkID0gaW5jcmVtZW50KClcblxuZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICByZXR1cm4gMiAqKiArK3Bvd2Vyc1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xlink.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xlink.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   xlink: () => (/* binding */ xlink)\n/* harmony export */ });\n/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/create.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/create.js\");\n\n\nconst xlink = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_0__.create)({\n  space: 'xlink',\n  transform(_, prop) {\n    return 'xlink:' + prop.slice(5).toLowerCase()\n  },\n  properties: {\n    xLinkActuate: null,\n    xLinkArcRole: null,\n    xLinkHref: null,\n    xLinkRole: null,\n    xLinkShow: null,\n    xLinkTitle: null,\n    xLinkType: null\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3hsaW5rLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDOztBQUVoQyxjQUFjLHVEQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3BlcnR5LWluZm9ybWF0aW9uQDYuNS4wL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1pbmZvcm1hdGlvbi9saWIveGxpbmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjcmVhdGV9IGZyb20gJy4vdXRpbC9jcmVhdGUuanMnXG5cbmV4cG9ydCBjb25zdCB4bGluayA9IGNyZWF0ZSh7XG4gIHNwYWNlOiAneGxpbmsnLFxuICB0cmFuc2Zvcm0oXywgcHJvcCkge1xuICAgIHJldHVybiAneGxpbms6JyArIHByb3Auc2xpY2UoNSkudG9Mb3dlckNhc2UoKVxuICB9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgeExpbmtBY3R1YXRlOiBudWxsLFxuICAgIHhMaW5rQXJjUm9sZTogbnVsbCxcbiAgICB4TGlua0hyZWY6IG51bGwsXG4gICAgeExpbmtSb2xlOiBudWxsLFxuICAgIHhMaW5rU2hvdzogbnVsbCxcbiAgICB4TGlua1RpdGxlOiBudWxsLFxuICAgIHhMaW5rVHlwZTogbnVsbFxuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xlink.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xml.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xml.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   xml: () => (/* binding */ xml)\n/* harmony export */ });\n/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/create.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/create.js\");\n\n\nconst xml = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_0__.create)({\n  space: 'xml',\n  transform(_, prop) {\n    return 'xml:' + prop.slice(3).toLowerCase()\n  },\n  properties: {xmlLang: null, xmlBase: null, xmlSpace: null}\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3htbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1Qzs7QUFFaEMsWUFBWSx1REFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZTtBQUNmLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcHJvcGVydHktaW5mb3JtYXRpb25ANi41LjAvbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWluZm9ybWF0aW9uL2xpYi94bWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjcmVhdGV9IGZyb20gJy4vdXRpbC9jcmVhdGUuanMnXG5cbmV4cG9ydCBjb25zdCB4bWwgPSBjcmVhdGUoe1xuICBzcGFjZTogJ3htbCcsXG4gIHRyYW5zZm9ybShfLCBwcm9wKSB7XG4gICAgcmV0dXJuICd4bWw6JyArIHByb3Auc2xpY2UoMykudG9Mb3dlckNhc2UoKVxuICB9LFxuICBwcm9wZXJ0aWVzOiB7eG1sTGFuZzogbnVsbCwgeG1sQmFzZTogbnVsbCwgeG1sU3BhY2U6IG51bGx9XG59KVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xml.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xmlns.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xmlns.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   xmlns: () => (/* binding */ xmlns)\n/* harmony export */ });\n/* harmony import */ var _util_create_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/create.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/create.js\");\n/* harmony import */ var _util_case_insensitive_transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/case-insensitive-transform.js */ \"(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/util/case-insensitive-transform.js\");\n\n\n\nconst xmlns = (0,_util_create_js__WEBPACK_IMPORTED_MODULE_0__.create)({\n  space: 'xmlns',\n  attributes: {xmlnsxlink: 'xmlns:xlink'},\n  transform: _util_case_insensitive_transform_js__WEBPACK_IMPORTED_MODULE_1__.caseInsensitiveTransform,\n  properties: {xmlns: null, xmlnsXLink: null}\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9wcm9wZXJ0eS1pbmZvcm1hdGlvbkA2LjUuMC9ub2RlX21vZHVsZXMvcHJvcGVydHktaW5mb3JtYXRpb24vbGliL3htbG5zLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1QztBQUNzQzs7QUFFdEUsY0FBYyx1REFBTTtBQUMzQjtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGFBQWEseUZBQXdCO0FBQ3JDLGVBQWU7QUFDZixDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3BlcnR5LWluZm9ybWF0aW9uQDYuNS4wL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1pbmZvcm1hdGlvbi9saWIveG1sbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjcmVhdGV9IGZyb20gJy4vdXRpbC9jcmVhdGUuanMnXG5pbXBvcnQge2Nhc2VJbnNlbnNpdGl2ZVRyYW5zZm9ybX0gZnJvbSAnLi91dGlsL2Nhc2UtaW5zZW5zaXRpdmUtdHJhbnNmb3JtLmpzJ1xuXG5leHBvcnQgY29uc3QgeG1sbnMgPSBjcmVhdGUoe1xuICBzcGFjZTogJ3htbG5zJyxcbiAgYXR0cmlidXRlczoge3htbG5zeGxpbms6ICd4bWxuczp4bGluayd9LFxuICB0cmFuc2Zvcm06IGNhc2VJbnNlbnNpdGl2ZVRyYW5zZm9ybSxcbiAgcHJvcGVydGllczoge3htbG5zOiBudWxsLCB4bWxuc1hMaW5rOiBudWxsfVxufSlcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/property-information@6.5.0/node_modules/property-information/lib/xmlns.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/regex-recursion@5.1.1/node_modules/regex-recursion/src/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/regex-recursion@5.1.1/node_modules/regex-recursion/src/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   recursion: () => (/* binding */ recursion)\n/* harmony export */ });\n/* harmony import */ var regex_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regex-utilities */ \"(app-pages-browser)/./node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\");\n/* harmony import */ var regex_internals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! regex/internals */ \"(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/internals.js\");\n\n\n\nconst r = String.raw;\nconst gRToken = r`\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;\nconst recursiveToken = r`\\(\\?R=(?<rDepth>[^\\)]+)\\)|${gRToken}`;\nconst namedCapturingDelim = r`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst token = new RegExp(r`${namedCapturingDelim}|${recursiveToken}|\\(\\?|\\\\?.`, 'gsu');\nconst overlappingRecursionMsg = 'Cannot use multiple overlapping recursions';\n// Support emulation groups with transfer marker prefix\nconst emulationGroupMarkerRe = new RegExp(r`(?:\\$[1-9]\\d*)?${regex_internals__WEBPACK_IMPORTED_MODULE_1__.emulationGroupMarker.replace(/\\$/g, r`\\$`)}`, 'y');\n\n/**\n@param {string} expression\n@param {{\n  flags?: string;\n  useEmulationGroups?: boolean;\n}} [data]\n@returns {string}\n*/\nfunction recursion(expression, data) {\n  // Keep the initial fail-check (which avoids unneeded processing) as fast as possible by testing\n  // without the accuracy improvement of using `hasUnescaped` with default `Context`\n  if (!(new RegExp(recursiveToken, 'su').test(expression))) {\n    return expression;\n  }\n  if ((0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(expression, r`\\(\\?\\(DEFINE\\)`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)) {\n    throw new Error('DEFINE groups cannot be used with recursion');\n  }\n  const useEmulationGroups = !!data?.useEmulationGroups;\n  const hasNumberedBackref = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(expression, r`\\\\[1-9]`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n  const groupContentsStartPos = new Map();\n  const openGroups = [];\n  let hasRecursed = false;\n  let numCharClassesOpen = 0;\n  let numCaptures = 0;\n  let match;\n  token.lastIndex = 0;\n  while ((match = token.exec(expression))) {\n    const {0: m, groups: {captureName, rDepth, gRNameOrNum, gRDepth}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n\n      // `(?R=N)`\n      if (rDepth) {\n        assertMaxInBounds(rDepth);\n        if (hasRecursed) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        if (hasNumberedBackref) {\n          // Could add support for numbered backrefs with extra effort, but it's probably not worth\n          // it. To trigger this error, the regex must include recursion and one of the following:\n          // - An interpolated regex that contains a numbered backref (since other numbered\n          //   backrefs are prevented by implicit flag n).\n          // - A numbered backref, when flag n is explicitly disabled.\n          // Note that Regex+'s extended syntax (atomic groups and sometimes subroutines) can also\n          // add numbered backrefs, but those work fine because external plugins like this one run\n          // *before* the transformation of built-in syntax extensions\n          throw new Error('Numbered backrefs cannot be used with global recursion');\n        }\n        const pre = expression.slice(0, match.index);\n        const post = expression.slice(token.lastIndex);\n        if ((0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(post, recursiveToken, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        // No need to parse further\n        return makeRecursive(pre, post, +rDepth, false, useEmulationGroups);\n      // `\\g<name&R=N>`, `\\g<number&R=N>`\n      } else if (gRNameOrNum) {\n        assertMaxInBounds(gRDepth);\n        let isWithinReffedGroup = false;\n        for (const g of openGroups) {\n          if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {\n            isWithinReffedGroup = true;\n            if (g.hasRecursedWithin) {\n              throw new Error(overlappingRecursionMsg);\n            }\n            break;\n          }\n        }\n        if (!isWithinReffedGroup) {\n          throw new Error(r`Recursive \\g cannot be used outside the referenced group \"\\g<${gRNameOrNum}&R=${gRDepth}>\"`);\n        }\n        const startPos = groupContentsStartPos.get(gRNameOrNum);\n        const groupContents = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.getGroupContents)(expression, startPos);\n        if (\n          hasNumberedBackref &&\n          (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(groupContents, r`${namedCapturingDelim}|\\((?!\\?)`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)\n        ) {\n          throw new Error('Numbered backrefs cannot be used with recursion of capturing groups');\n        }\n        const groupContentsPre = expression.slice(startPos, match.index);\n        const groupContentsPost = groupContents.slice(groupContentsPre.length + m.length);\n        const expansion = makeRecursive(groupContentsPre, groupContentsPost, +gRDepth, true, useEmulationGroups);\n        const pre = expression.slice(0, startPos);\n        const post = expression.slice(startPos + groupContents.length);\n        // Modify the string we're looping over\n        expression = `${pre}${expansion}${post}`;\n        // Step forward for the next loop iteration\n        token.lastIndex += expansion.length - m.length - groupContentsPre.length - groupContentsPost.length;\n        openGroups.forEach(g => g.hasRecursedWithin = true);\n        hasRecursed = true;\n      } else if (captureName) {\n        numCaptures++;\n        // NOTE: Not currently handling *named* emulation groups that already exist in the pattern\n        groupContentsStartPos.set(String(numCaptures), token.lastIndex);\n        groupContentsStartPos.set(captureName, token.lastIndex);\n        openGroups.push({\n          num: numCaptures,\n          name: captureName,\n        });\n      } else if (m.startsWith('(')) {\n        const isUnnamedCapture = m === '(';\n        if (isUnnamedCapture) {\n          numCaptures++;\n          groupContentsStartPos.set(\n            String(numCaptures),\n            token.lastIndex + (useEmulationGroups ? emulationGroupMarkerLength(expression, token.lastIndex) : 0)\n          );\n        }\n        openGroups.push(isUnnamedCapture ? {num: numCaptures} : {});\n      } else if (m === ')') {\n        openGroups.pop();\n      }\n\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n\n  return expression;\n}\n\n/**\n@param {string} max\n*/\nfunction assertMaxInBounds(max) {\n  const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;\n  if (!/^[1-9]\\d*$/.test(max)) {\n    throw new Error(errMsg);\n  }\n  max = +max;\n  if (max < 2 || max > 100) {\n    throw new Error(errMsg);\n  }\n}\n\n/**\n@param {string} pre\n@param {string} post\n@param {number} maxDepth\n@param {boolean} isSubpattern\n@param {boolean} useEmulationGroups\n@returns {string}\n*/\nfunction makeRecursive(pre, post, maxDepth, isSubpattern, useEmulationGroups) {\n  const namesInRecursed = new Set();\n  // Avoid this work if not needed\n  if (isSubpattern) {\n    (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.forEachUnescaped)(pre + post, namedCapturingDelim, ({groups: {captureName}}) => {\n      namesInRecursed.add(captureName);\n    }, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n  }\n  const reps = maxDepth - 1;\n  // Depth 2: 'pre(?:pre(?:)post)post'\n  // Depth 3: 'pre(?:pre(?:pre(?:)post)post)post'\n  return `${pre}${\n    repeatWithDepth(`(?:${pre}`, reps, (isSubpattern ? namesInRecursed : null), 'forward', useEmulationGroups)\n  }(?:)${\n    repeatWithDepth(`${post})`, reps, (isSubpattern ? namesInRecursed : null), 'backward', useEmulationGroups)\n  }${post}`;\n}\n\n/**\n@param {string} expression\n@param {number} reps\n@param {Set<string> | null} namesInRecursed\n@param {'forward' | 'backward'} direction\n@param {boolean} useEmulationGroups\n@returns {string}\n*/\nfunction repeatWithDepth(expression, reps, namesInRecursed, direction, useEmulationGroups) {\n  const startNum = 2;\n  const depthNum = i => direction === 'backward' ? reps - i + startNum - 1 : i + startNum;\n  let result = '';\n  for (let i = 0; i < reps; i++) {\n    const captureNum = depthNum(i);\n    result += (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.replaceUnescaped)(\n      expression,\n      // NOTE: Not currently handling *named* emulation groups that already exist in the pattern\n      r`${namedCapturingDelim}|\\\\k<(?<backref>[^>]+)>${\n        useEmulationGroups ? r`|(?<unnamed>\\()(?!\\?)(?:${emulationGroupMarkerRe.source})?` : ''\n      }`,\n      ({0: m, index, groups: {captureName, backref, unnamed}}) => {\n        if (backref && namesInRecursed && !namesInRecursed.has(backref)) {\n          // Don't alter backrefs to groups outside the recursed subpattern\n          return m;\n        }\n        // Only matches unnamed capture delim if `useEmulationGroups`\n        if (unnamed) {\n          // Add an emulation group marker, possibly replacing an existing marker (removes any\n          // transfer prefix)\n          return `(${regex_internals__WEBPACK_IMPORTED_MODULE_1__.emulationGroupMarker}`;\n        }\n        const suffix = `_$${captureNum}`;\n        return captureName ?\n          `(?<${captureName}${suffix}>${useEmulationGroups ? regex_internals__WEBPACK_IMPORTED_MODULE_1__.emulationGroupMarker : ''}` :\n          r`\\k<${backref}${suffix}>`;\n      },\n      regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT\n    );\n  }\n  return result;\n}\n\nfunction emulationGroupMarkerLength(expression, index) {\n  emulationGroupMarkerRe.lastIndex = index;\n  const match = emulationGroupMarkerRe.exec(expression);\n  return match ? match[0].length : 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleC1yZWN1cnNpb25ANS4xLjEvbm9kZV9tb2R1bGVzL3JlZ2V4LXJlY3Vyc2lvbi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRHO0FBQ3ZEOztBQUVyRDtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQSw2QkFBNkIsb0JBQW9CLEdBQUcsZUFBZTtBQUNuRTtBQUNBO0FBQ0EsNkRBQTZELGlFQUFvQix1QkFBdUI7O0FBRXhHO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZEQUFZLGdDQUFnQyxvREFBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQVkseUJBQXlCLG9EQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsNENBQTRDO0FBQ3RFO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2REFBWSx1QkFBdUIsb0RBQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsWUFBWSxLQUFLLFFBQVE7QUFDcEg7QUFDQTtBQUNBLDhCQUE4QixpRUFBZ0I7QUFDOUM7QUFDQTtBQUNBLFVBQVUsNkRBQVksb0JBQW9CLG9CQUFvQixZQUFZLG9EQUFPO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJLEVBQUUsVUFBVSxFQUFFLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCLElBQUk7QUFDbEUsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQSwrREFBK0QsT0FBTyxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRLFNBQVM7QUFDakIsUUFBUSxTQUFTO0FBQ2pCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBZ0Isb0NBQW9DLFNBQVMsYUFBYTtBQUM5RTtBQUNBLEtBQUssRUFBRSxvREFBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCLDBCQUEwQixJQUFJO0FBQzlCLEdBQUc7QUFDSCx1QkFBdUIsS0FBSztBQUM1QixHQUFHLEVBQUUsS0FBSztBQUNWOztBQUVBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRLG9CQUFvQjtBQUM1QixRQUFRLHdCQUF3QjtBQUNoQyxRQUFRLFNBQVM7QUFDakIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLGNBQWMsaUVBQWdCO0FBQzlCO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5Qix5REFBeUQsOEJBQThCO0FBQ3ZGLE9BQU87QUFDUCxRQUFRLHNCQUFzQiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpRUFBb0IsQ0FBQztBQUMxQztBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0EsZ0JBQWdCLFlBQVksRUFBRSxPQUFPLEdBQUcscUJBQXFCLGlFQUFvQixNQUFNO0FBQ3ZGLGlCQUFpQixRQUFRLEVBQUUsT0FBTztBQUNsQyxPQUFPO0FBQ1AsTUFBTSxvREFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcmVnZXgtcmVjdXJzaW9uQDUuMS4xL25vZGVfbW9kdWxlcy9yZWdleC1yZWN1cnNpb24vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29udGV4dCwgZm9yRWFjaFVuZXNjYXBlZCwgZ2V0R3JvdXBDb250ZW50cywgaGFzVW5lc2NhcGVkLCByZXBsYWNlVW5lc2NhcGVkfSBmcm9tICdyZWdleC11dGlsaXRpZXMnO1xuaW1wb3J0IHtlbXVsYXRpb25Hcm91cE1hcmtlcn0gZnJvbSAncmVnZXgvaW50ZXJuYWxzJztcblxuY29uc3QgciA9IFN0cmluZy5yYXc7XG5jb25zdCBnUlRva2VuID0gcmBcXFxcZzwoPzxnUk5hbWVPck51bT5bXj4mXSspJlI9KD88Z1JEZXB0aD5bXj5dKyk+YDtcbmNvbnN0IHJlY3Vyc2l2ZVRva2VuID0gcmBcXChcXD9SPSg/PHJEZXB0aD5bXlxcKV0rKVxcKXwke2dSVG9rZW59YDtcbmNvbnN0IG5hbWVkQ2FwdHVyaW5nRGVsaW0gPSByYFxcKFxcPzwoPyFbPSFdKSg/PGNhcHR1cmVOYW1lPltePl0rKT5gO1xuY29uc3QgdG9rZW4gPSBuZXcgUmVnRXhwKHJgJHtuYW1lZENhcHR1cmluZ0RlbGltfXwke3JlY3Vyc2l2ZVRva2VufXxcXChcXD98XFxcXD8uYCwgJ2dzdScpO1xuY29uc3Qgb3ZlcmxhcHBpbmdSZWN1cnNpb25Nc2cgPSAnQ2Fubm90IHVzZSBtdWx0aXBsZSBvdmVybGFwcGluZyByZWN1cnNpb25zJztcbi8vIFN1cHBvcnQgZW11bGF0aW9uIGdyb3VwcyB3aXRoIHRyYW5zZmVyIG1hcmtlciBwcmVmaXhcbmNvbnN0IGVtdWxhdGlvbkdyb3VwTWFya2VyUmUgPSBuZXcgUmVnRXhwKHJgKD86XFwkWzEtOV1cXGQqKT8ke2VtdWxhdGlvbkdyb3VwTWFya2VyLnJlcGxhY2UoL1xcJC9nLCByYFxcJGApfWAsICd5Jyk7XG5cbi8qKlxuQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb25cbkBwYXJhbSB7e1xuICBmbGFncz86IHN0cmluZztcbiAgdXNlRW11bGF0aW9uR3JvdXBzPzogYm9vbGVhbjtcbn19IFtkYXRhXVxuQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnQgZnVuY3Rpb24gcmVjdXJzaW9uKGV4cHJlc3Npb24sIGRhdGEpIHtcbiAgLy8gS2VlcCB0aGUgaW5pdGlhbCBmYWlsLWNoZWNrICh3aGljaCBhdm9pZHMgdW5uZWVkZWQgcHJvY2Vzc2luZykgYXMgZmFzdCBhcyBwb3NzaWJsZSBieSB0ZXN0aW5nXG4gIC8vIHdpdGhvdXQgdGhlIGFjY3VyYWN5IGltcHJvdmVtZW50IG9mIHVzaW5nIGBoYXNVbmVzY2FwZWRgIHdpdGggZGVmYXVsdCBgQ29udGV4dGBcbiAgaWYgKCEobmV3IFJlZ0V4cChyZWN1cnNpdmVUb2tlbiwgJ3N1JykudGVzdChleHByZXNzaW9uKSkpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuICBpZiAoaGFzVW5lc2NhcGVkKGV4cHJlc3Npb24sIHJgXFwoXFw/XFwoREVGSU5FXFwpYCwgQ29udGV4dC5ERUZBVUxUKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignREVGSU5FIGdyb3VwcyBjYW5ub3QgYmUgdXNlZCB3aXRoIHJlY3Vyc2lvbicpO1xuICB9XG4gIGNvbnN0IHVzZUVtdWxhdGlvbkdyb3VwcyA9ICEhZGF0YT8udXNlRW11bGF0aW9uR3JvdXBzO1xuICBjb25zdCBoYXNOdW1iZXJlZEJhY2tyZWYgPSBoYXNVbmVzY2FwZWQoZXhwcmVzc2lvbiwgcmBcXFxcWzEtOV1gLCBDb250ZXh0LkRFRkFVTFQpO1xuICBjb25zdCBncm91cENvbnRlbnRzU3RhcnRQb3MgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG9wZW5Hcm91cHMgPSBbXTtcbiAgbGV0IGhhc1JlY3Vyc2VkID0gZmFsc2U7XG4gIGxldCBudW1DaGFyQ2xhc3Nlc09wZW4gPSAwO1xuICBsZXQgbnVtQ2FwdHVyZXMgPSAwO1xuICBsZXQgbWF0Y2g7XG4gIHRva2VuLmxhc3RJbmRleCA9IDA7XG4gIHdoaWxlICgobWF0Y2ggPSB0b2tlbi5leGVjKGV4cHJlc3Npb24pKSkge1xuICAgIGNvbnN0IHswOiBtLCBncm91cHM6IHtjYXB0dXJlTmFtZSwgckRlcHRoLCBnUk5hbWVPck51bSwgZ1JEZXB0aH19ID0gbWF0Y2g7XG4gICAgaWYgKG0gPT09ICdbJykge1xuICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuKys7XG4gICAgfSBlbHNlIGlmICghbnVtQ2hhckNsYXNzZXNPcGVuKSB7XG5cbiAgICAgIC8vIGAoP1I9TilgXG4gICAgICBpZiAockRlcHRoKSB7XG4gICAgICAgIGFzc2VydE1heEluQm91bmRzKHJEZXB0aCk7XG4gICAgICAgIGlmIChoYXNSZWN1cnNlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvdmVybGFwcGluZ1JlY3Vyc2lvbk1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc051bWJlcmVkQmFja3JlZikge1xuICAgICAgICAgIC8vIENvdWxkIGFkZCBzdXBwb3J0IGZvciBudW1iZXJlZCBiYWNrcmVmcyB3aXRoIGV4dHJhIGVmZm9ydCwgYnV0IGl0J3MgcHJvYmFibHkgbm90IHdvcnRoXG4gICAgICAgICAgLy8gaXQuIFRvIHRyaWdnZXIgdGhpcyBlcnJvciwgdGhlIHJlZ2V4IG11c3QgaW5jbHVkZSByZWN1cnNpb24gYW5kIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgIC8vIC0gQW4gaW50ZXJwb2xhdGVkIHJlZ2V4IHRoYXQgY29udGFpbnMgYSBudW1iZXJlZCBiYWNrcmVmIChzaW5jZSBvdGhlciBudW1iZXJlZFxuICAgICAgICAgIC8vICAgYmFja3JlZnMgYXJlIHByZXZlbnRlZCBieSBpbXBsaWNpdCBmbGFnIG4pLlxuICAgICAgICAgIC8vIC0gQSBudW1iZXJlZCBiYWNrcmVmLCB3aGVuIGZsYWcgbiBpcyBleHBsaWNpdGx5IGRpc2FibGVkLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCBSZWdleCsncyBleHRlbmRlZCBzeW50YXggKGF0b21pYyBncm91cHMgYW5kIHNvbWV0aW1lcyBzdWJyb3V0aW5lcykgY2FuIGFsc29cbiAgICAgICAgICAvLyBhZGQgbnVtYmVyZWQgYmFja3JlZnMsIGJ1dCB0aG9zZSB3b3JrIGZpbmUgYmVjYXVzZSBleHRlcm5hbCBwbHVnaW5zIGxpa2UgdGhpcyBvbmUgcnVuXG4gICAgICAgICAgLy8gKmJlZm9yZSogdGhlIHRyYW5zZm9ybWF0aW9uIG9mIGJ1aWx0LWluIHN5bnRheCBleHRlbnNpb25zXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXJlZCBiYWNrcmVmcyBjYW5ub3QgYmUgdXNlZCB3aXRoIGdsb2JhbCByZWN1cnNpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmUgPSBleHByZXNzaW9uLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgY29uc3QgcG9zdCA9IGV4cHJlc3Npb24uc2xpY2UodG9rZW4ubGFzdEluZGV4KTtcbiAgICAgICAgaWYgKGhhc1VuZXNjYXBlZChwb3N0LCByZWN1cnNpdmVUb2tlbiwgQ29udGV4dC5ERUZBVUxUKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvdmVybGFwcGluZ1JlY3Vyc2lvbk1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBwYXJzZSBmdXJ0aGVyXG4gICAgICAgIHJldHVybiBtYWtlUmVjdXJzaXZlKHByZSwgcG9zdCwgK3JEZXB0aCwgZmFsc2UsIHVzZUVtdWxhdGlvbkdyb3Vwcyk7XG4gICAgICAvLyBgXFxnPG5hbWUmUj1OPmAsIGBcXGc8bnVtYmVyJlI9Tj5gXG4gICAgICB9IGVsc2UgaWYgKGdSTmFtZU9yTnVtKSB7XG4gICAgICAgIGFzc2VydE1heEluQm91bmRzKGdSRGVwdGgpO1xuICAgICAgICBsZXQgaXNXaXRoaW5SZWZmZWRHcm91cCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGcgb2Ygb3Blbkdyb3Vwcykge1xuICAgICAgICAgIGlmIChnLm5hbWUgPT09IGdSTmFtZU9yTnVtIHx8IGcubnVtID09PSArZ1JOYW1lT3JOdW0pIHtcbiAgICAgICAgICAgIGlzV2l0aGluUmVmZmVkR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGcuaGFzUmVjdXJzZWRXaXRoaW4pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG92ZXJsYXBwaW5nUmVjdXJzaW9uTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzV2l0aGluUmVmZmVkR3JvdXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmBSZWN1cnNpdmUgXFxnIGNhbm5vdCBiZSB1c2VkIG91dHNpZGUgdGhlIHJlZmVyZW5jZWQgZ3JvdXAgXCJcXGc8JHtnUk5hbWVPck51bX0mUj0ke2dSRGVwdGh9PlwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBncm91cENvbnRlbnRzU3RhcnRQb3MuZ2V0KGdSTmFtZU9yTnVtKTtcbiAgICAgICAgY29uc3QgZ3JvdXBDb250ZW50cyA9IGdldEdyb3VwQ29udGVudHMoZXhwcmVzc2lvbiwgc3RhcnRQb3MpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaGFzTnVtYmVyZWRCYWNrcmVmICYmXG4gICAgICAgICAgaGFzVW5lc2NhcGVkKGdyb3VwQ29udGVudHMsIHJgJHtuYW1lZENhcHR1cmluZ0RlbGltfXxcXCgoPyFcXD8pYCwgQ29udGV4dC5ERUZBVUxUKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlcmVkIGJhY2tyZWZzIGNhbm5vdCBiZSB1c2VkIHdpdGggcmVjdXJzaW9uIG9mIGNhcHR1cmluZyBncm91cHMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncm91cENvbnRlbnRzUHJlID0gZXhwcmVzc2lvbi5zbGljZShzdGFydFBvcywgbWF0Y2guaW5kZXgpO1xuICAgICAgICBjb25zdCBncm91cENvbnRlbnRzUG9zdCA9IGdyb3VwQ29udGVudHMuc2xpY2UoZ3JvdXBDb250ZW50c1ByZS5sZW5ndGggKyBtLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGV4cGFuc2lvbiA9IG1ha2VSZWN1cnNpdmUoZ3JvdXBDb250ZW50c1ByZSwgZ3JvdXBDb250ZW50c1Bvc3QsICtnUkRlcHRoLCB0cnVlLCB1c2VFbXVsYXRpb25Hcm91cHMpO1xuICAgICAgICBjb25zdCBwcmUgPSBleHByZXNzaW9uLnNsaWNlKDAsIHN0YXJ0UG9zKTtcbiAgICAgICAgY29uc3QgcG9zdCA9IGV4cHJlc3Npb24uc2xpY2Uoc3RhcnRQb3MgKyBncm91cENvbnRlbnRzLmxlbmd0aCk7XG4gICAgICAgIC8vIE1vZGlmeSB0aGUgc3RyaW5nIHdlJ3JlIGxvb3Bpbmcgb3ZlclxuICAgICAgICBleHByZXNzaW9uID0gYCR7cHJlfSR7ZXhwYW5zaW9ufSR7cG9zdH1gO1xuICAgICAgICAvLyBTdGVwIGZvcndhcmQgZm9yIHRoZSBuZXh0IGxvb3AgaXRlcmF0aW9uXG4gICAgICAgIHRva2VuLmxhc3RJbmRleCArPSBleHBhbnNpb24ubGVuZ3RoIC0gbS5sZW5ndGggLSBncm91cENvbnRlbnRzUHJlLmxlbmd0aCAtIGdyb3VwQ29udGVudHNQb3N0Lmxlbmd0aDtcbiAgICAgICAgb3Blbkdyb3Vwcy5mb3JFYWNoKGcgPT4gZy5oYXNSZWN1cnNlZFdpdGhpbiA9IHRydWUpO1xuICAgICAgICBoYXNSZWN1cnNlZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNhcHR1cmVOYW1lKSB7XG4gICAgICAgIG51bUNhcHR1cmVzKys7XG4gICAgICAgIC8vIE5PVEU6IE5vdCBjdXJyZW50bHkgaGFuZGxpbmcgKm5hbWVkKiBlbXVsYXRpb24gZ3JvdXBzIHRoYXQgYWxyZWFkeSBleGlzdCBpbiB0aGUgcGF0dGVyblxuICAgICAgICBncm91cENvbnRlbnRzU3RhcnRQb3Muc2V0KFN0cmluZyhudW1DYXB0dXJlcyksIHRva2VuLmxhc3RJbmRleCk7XG4gICAgICAgIGdyb3VwQ29udGVudHNTdGFydFBvcy5zZXQoY2FwdHVyZU5hbWUsIHRva2VuLmxhc3RJbmRleCk7XG4gICAgICAgIG9wZW5Hcm91cHMucHVzaCh7XG4gICAgICAgICAgbnVtOiBudW1DYXB0dXJlcyxcbiAgICAgICAgICBuYW1lOiBjYXB0dXJlTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG0uc3RhcnRzV2l0aCgnKCcpKSB7XG4gICAgICAgIGNvbnN0IGlzVW5uYW1lZENhcHR1cmUgPSBtID09PSAnKCc7XG4gICAgICAgIGlmIChpc1VubmFtZWRDYXB0dXJlKSB7XG4gICAgICAgICAgbnVtQ2FwdHVyZXMrKztcbiAgICAgICAgICBncm91cENvbnRlbnRzU3RhcnRQb3Muc2V0KFxuICAgICAgICAgICAgU3RyaW5nKG51bUNhcHR1cmVzKSxcbiAgICAgICAgICAgIHRva2VuLmxhc3RJbmRleCArICh1c2VFbXVsYXRpb25Hcm91cHMgPyBlbXVsYXRpb25Hcm91cE1hcmtlckxlbmd0aChleHByZXNzaW9uLCB0b2tlbi5sYXN0SW5kZXgpIDogMClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG9wZW5Hcm91cHMucHVzaChpc1VubmFtZWRDYXB0dXJlID8ge251bTogbnVtQ2FwdHVyZXN9IDoge30pO1xuICAgICAgfSBlbHNlIGlmIChtID09PSAnKScpIHtcbiAgICAgICAgb3Blbkdyb3Vwcy5wb3AoKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAobSA9PT0gJ10nKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4tLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuLyoqXG5AcGFyYW0ge3N0cmluZ30gbWF4XG4qL1xuZnVuY3Rpb24gYXNzZXJ0TWF4SW5Cb3VuZHMobWF4KSB7XG4gIGNvbnN0IGVyck1zZyA9IGBNYXggZGVwdGggbXVzdCBiZSBpbnRlZ2VyIGJldHdlZW4gMiBhbmQgMTAwOyB1c2VkICR7bWF4fWA7XG4gIGlmICghL15bMS05XVxcZCokLy50ZXN0KG1heCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgfVxuICBtYXggPSArbWF4O1xuICBpZiAobWF4IDwgMiB8fCBtYXggPiAxMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgfVxufVxuXG4vKipcbkBwYXJhbSB7c3RyaW5nfSBwcmVcbkBwYXJhbSB7c3RyaW5nfSBwb3N0XG5AcGFyYW0ge251bWJlcn0gbWF4RGVwdGhcbkBwYXJhbSB7Ym9vbGVhbn0gaXNTdWJwYXR0ZXJuXG5AcGFyYW0ge2Jvb2xlYW59IHVzZUVtdWxhdGlvbkdyb3Vwc1xuQHJldHVybnMge3N0cmluZ31cbiovXG5mdW5jdGlvbiBtYWtlUmVjdXJzaXZlKHByZSwgcG9zdCwgbWF4RGVwdGgsIGlzU3VicGF0dGVybiwgdXNlRW11bGF0aW9uR3JvdXBzKSB7XG4gIGNvbnN0IG5hbWVzSW5SZWN1cnNlZCA9IG5ldyBTZXQoKTtcbiAgLy8gQXZvaWQgdGhpcyB3b3JrIGlmIG5vdCBuZWVkZWRcbiAgaWYgKGlzU3VicGF0dGVybikge1xuICAgIGZvckVhY2hVbmVzY2FwZWQocHJlICsgcG9zdCwgbmFtZWRDYXB0dXJpbmdEZWxpbSwgKHtncm91cHM6IHtjYXB0dXJlTmFtZX19KSA9PiB7XG4gICAgICBuYW1lc0luUmVjdXJzZWQuYWRkKGNhcHR1cmVOYW1lKTtcbiAgICB9LCBDb250ZXh0LkRFRkFVTFQpO1xuICB9XG4gIGNvbnN0IHJlcHMgPSBtYXhEZXB0aCAtIDE7XG4gIC8vIERlcHRoIDI6ICdwcmUoPzpwcmUoPzopcG9zdClwb3N0J1xuICAvLyBEZXB0aCAzOiAncHJlKD86cHJlKD86cHJlKD86KXBvc3QpcG9zdClwb3N0J1xuICByZXR1cm4gYCR7cHJlfSR7XG4gICAgcmVwZWF0V2l0aERlcHRoKGAoPzoke3ByZX1gLCByZXBzLCAoaXNTdWJwYXR0ZXJuID8gbmFtZXNJblJlY3Vyc2VkIDogbnVsbCksICdmb3J3YXJkJywgdXNlRW11bGF0aW9uR3JvdXBzKVxuICB9KD86KSR7XG4gICAgcmVwZWF0V2l0aERlcHRoKGAke3Bvc3R9KWAsIHJlcHMsIChpc1N1YnBhdHRlcm4gPyBuYW1lc0luUmVjdXJzZWQgOiBudWxsKSwgJ2JhY2t3YXJkJywgdXNlRW11bGF0aW9uR3JvdXBzKVxuICB9JHtwb3N0fWA7XG59XG5cbi8qKlxuQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb25cbkBwYXJhbSB7bnVtYmVyfSByZXBzXG5AcGFyYW0ge1NldDxzdHJpbmc+IHwgbnVsbH0gbmFtZXNJblJlY3Vyc2VkXG5AcGFyYW0geydmb3J3YXJkJyB8ICdiYWNrd2FyZCd9IGRpcmVjdGlvblxuQHBhcmFtIHtib29sZWFufSB1c2VFbXVsYXRpb25Hcm91cHNcbkByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZnVuY3Rpb24gcmVwZWF0V2l0aERlcHRoKGV4cHJlc3Npb24sIHJlcHMsIG5hbWVzSW5SZWN1cnNlZCwgZGlyZWN0aW9uLCB1c2VFbXVsYXRpb25Hcm91cHMpIHtcbiAgY29uc3Qgc3RhcnROdW0gPSAyO1xuICBjb25zdCBkZXB0aE51bSA9IGkgPT4gZGlyZWN0aW9uID09PSAnYmFja3dhcmQnID8gcmVwcyAtIGkgKyBzdGFydE51bSAtIDEgOiBpICsgc3RhcnROdW07XG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXBzOyBpKyspIHtcbiAgICBjb25zdCBjYXB0dXJlTnVtID0gZGVwdGhOdW0oaSk7XG4gICAgcmVzdWx0ICs9IHJlcGxhY2VVbmVzY2FwZWQoXG4gICAgICBleHByZXNzaW9uLFxuICAgICAgLy8gTk9URTogTm90IGN1cnJlbnRseSBoYW5kbGluZyAqbmFtZWQqIGVtdWxhdGlvbiBncm91cHMgdGhhdCBhbHJlYWR5IGV4aXN0IGluIHRoZSBwYXR0ZXJuXG4gICAgICByYCR7bmFtZWRDYXB0dXJpbmdEZWxpbX18XFxcXGs8KD88YmFja3JlZj5bXj5dKyk+JHtcbiAgICAgICAgdXNlRW11bGF0aW9uR3JvdXBzID8gcmB8KD88dW5uYW1lZD5cXCgpKD8hXFw/KSg/OiR7ZW11bGF0aW9uR3JvdXBNYXJrZXJSZS5zb3VyY2V9KT9gIDogJydcbiAgICAgIH1gLFxuICAgICAgKHswOiBtLCBpbmRleCwgZ3JvdXBzOiB7Y2FwdHVyZU5hbWUsIGJhY2tyZWYsIHVubmFtZWR9fSkgPT4ge1xuICAgICAgICBpZiAoYmFja3JlZiAmJiBuYW1lc0luUmVjdXJzZWQgJiYgIW5hbWVzSW5SZWN1cnNlZC5oYXMoYmFja3JlZikpIHtcbiAgICAgICAgICAvLyBEb24ndCBhbHRlciBiYWNrcmVmcyB0byBncm91cHMgb3V0c2lkZSB0aGUgcmVjdXJzZWQgc3VicGF0dGVyblxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgbWF0Y2hlcyB1bm5hbWVkIGNhcHR1cmUgZGVsaW0gaWYgYHVzZUVtdWxhdGlvbkdyb3Vwc2BcbiAgICAgICAgaWYgKHVubmFtZWQpIHtcbiAgICAgICAgICAvLyBBZGQgYW4gZW11bGF0aW9uIGdyb3VwIG1hcmtlciwgcG9zc2libHkgcmVwbGFjaW5nIGFuIGV4aXN0aW5nIG1hcmtlciAocmVtb3ZlcyBhbnlcbiAgICAgICAgICAvLyB0cmFuc2ZlciBwcmVmaXgpXG4gICAgICAgICAgcmV0dXJuIGAoJHtlbXVsYXRpb25Hcm91cE1hcmtlcn1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGBfJCR7Y2FwdHVyZU51bX1gO1xuICAgICAgICByZXR1cm4gY2FwdHVyZU5hbWUgP1xuICAgICAgICAgIGAoPzwke2NhcHR1cmVOYW1lfSR7c3VmZml4fT4ke3VzZUVtdWxhdGlvbkdyb3VwcyA/IGVtdWxhdGlvbkdyb3VwTWFya2VyIDogJyd9YCA6XG4gICAgICAgICAgcmBcXGs8JHtiYWNrcmVmfSR7c3VmZml4fT5gO1xuICAgICAgfSxcbiAgICAgIENvbnRleHQuREVGQVVMVFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW11bGF0aW9uR3JvdXBNYXJrZXJMZW5ndGgoZXhwcmVzc2lvbiwgaW5kZXgpIHtcbiAgZW11bGF0aW9uR3JvdXBNYXJrZXJSZS5sYXN0SW5kZXggPSBpbmRleDtcbiAgY29uc3QgbWF0Y2ggPSBlbXVsYXRpb25Hcm91cE1hcmtlclJlLmV4ZWMoZXhwcmVzc2lvbik7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzBdLmxlbmd0aCA6IDA7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/regex-recursion@5.1.1/node_modules/regex-recursion/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Context: () => (/* binding */ Context),\n/* harmony export */   execUnescaped: () => (/* binding */ execUnescaped),\n/* harmony export */   forEachUnescaped: () => (/* binding */ forEachUnescaped),\n/* harmony export */   getGroupContents: () => (/* binding */ getGroupContents),\n/* harmony export */   hasUnescaped: () => (/* binding */ hasUnescaped),\n/* harmony export */   replaceUnescaped: () => (/* binding */ replaceUnescaped)\n/* harmony export */ });\n// Constant properties for tracking regex syntax context\nconst Context = Object.freeze({\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n});\n\n/**\nReplaces all unescaped instances of a regex pattern in the given context, using a replacement\nstring or callback.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {string | (match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => string} replacement\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {string} Updated expression\n@example\nconst str = '.\\\\.\\\\\\\\.[[\\\\.].].';\nreplaceUnescaped(str, '\\\\.', '@');\n//  '@\\\\.\\\\\\\\@[[\\\\.]@]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.DEFAULT);\n//  '@\\\\.\\\\\\\\@[[\\\\.].]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.CHAR_CLASS);\n//  '.\\\\.\\\\\\\\.[[\\\\.]@].'\n*/\nfunction replaceUnescaped(expression, needle, replacement, context) {\n  const re = new RegExp(String.raw`${needle}|(?<$skip>\\[\\^?|\\\\?.)`, 'gsu');\n  const negated = [false];\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const match of expression.matchAll(re)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match, {\n          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,\n          negated: negated[negated.length - 1],\n        });\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m[0] === '[') {\n      numCharClassesOpen++;\n      negated.push(m[1] === '^');\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n      negated.pop();\n    }\n    result += m;\n  }\n  return result;\n}\n\n/**\nRuns a callback for each unescaped instance of a regex pattern in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {(match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => void} callback\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n*/\nfunction forEachUnescaped(expression, needle, callback, context) {\n  // Do this the easy way\n  replaceUnescaped(expression, needle, callback, context);\n}\n\n/**\nReturns a match object for the first unescaped instance of a regex pattern in the given context, or\n`null`.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {number} [pos] Offset to start the search\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {RegExpExecArray | null}\n*/\nfunction execUnescaped(expression, needle, pos = 0, context) {\n  // Quick partial test; avoid the loop if not needed\n  if (!(new RegExp(needle, 'su').test(expression))) {\n    return null;\n  }\n  const re = new RegExp(`${needle}|(?<$skip>\\\\\\\\?.)`, 'gsu');\n  re.lastIndex = pos;\n  let numCharClassesOpen = 0;\n  let match;\n  while (match = re.exec(expression)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      return match;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    // Avoid an infinite loop on zero-length matches\n    if (re.lastIndex == match.index) {\n      re.lastIndex++;\n    }\n  }\n  return null;\n}\n\n/**\nChecks whether an unescaped instance of a regex pattern appears in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {boolean} Whether the pattern was found\n*/\nfunction hasUnescaped(expression, needle, context) {\n  // Do this the easy way\n  return !!execUnescaped(expression, needle, 0, context);\n}\n\n/**\nExtracts the full contents of a group (subpattern) from the given expression, accounting for\nescaped characters, nested groups, and character classes. The group is identified by the position\nwhere its contents start (the string index just after the group's opening delimiter). Returns the\nrest of the string if the group is unclosed.\n\nAssumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {number} contentsStartPos\n@returns {string}\n*/\nfunction getGroupContents(expression, contentsStartPos) {\n  const token = /\\\\?./gsu;\n  token.lastIndex = contentsStartPos;\n  let contentsEndPos = expression.length;\n  let numCharClassesOpen = 0;\n  // Starting search within an open group, after the group's opening\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token.exec(expression)) {\n    const [m] = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (m === '(') {\n        numGroupsOpen++;\n      } else if (m === ')') {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return expression.slice(contentsStartPos, contentsEndPos);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleC11dGlsaXRpZXNAMi4zLjAvbm9kZV9tb2R1bGVzL3JlZ2V4LXV0aWxpdGllcy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRO0FBQ1I7QUFDQTtBQUNBLENBQUMsYUFBYTtBQUNkLFFBQVEsMEJBQTBCO0FBQ2xDLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRO0FBQ1I7QUFDQTtBQUNBLENBQUMsV0FBVztBQUNaLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRLDBCQUEwQjtBQUNsQyxVQUFVO0FBQ1Y7QUFDTztBQUNQLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLFFBQVE7QUFDaEIsUUFBUSwwQkFBMEI7QUFDbEMsVUFBVSxTQUFTO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLFFBQVE7QUFDaEIsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcmVnZXgtdXRpbGl0aWVzQDIuMy4wL25vZGVfbW9kdWxlcy9yZWdleC11dGlsaXRpZXMvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbnN0YW50IHByb3BlcnRpZXMgZm9yIHRyYWNraW5nIHJlZ2V4IHN5bnRheCBjb250ZXh0XG5leHBvcnQgY29uc3QgQ29udGV4dCA9IE9iamVjdC5mcmVlemUoe1xuICBERUZBVUxUOiAnREVGQVVMVCcsXG4gIENIQVJfQ0xBU1M6ICdDSEFSX0NMQVNTJyxcbn0pO1xuXG4vKipcblJlcGxhY2VzIGFsbCB1bmVzY2FwZWQgaW5zdGFuY2VzIG9mIGEgcmVnZXggcGF0dGVybiBpbiB0aGUgZ2l2ZW4gY29udGV4dCwgdXNpbmcgYSByZXBsYWNlbWVudFxuc3RyaW5nIG9yIGNhbGxiYWNrLlxuXG5Eb2Vzbid0IHNraXAgb3ZlciBjb21wbGV0ZSBtdWx0aWNoYXJhY3RlciB0b2tlbnMgKG9ubHkgYFxcYCBwbHVzIGl0cyBmb2xvd2luZyBjaGFyKSBzbyBtdXN0IGJlIHVzZWRcbndpdGgga25vd2xlZGdlIG9mIHdoYXQncyBzYWZlIHRvIGRvIGdpdmVuIHJlZ2V4IHN5bnRheC4gQXNzdW1lcyBVbmljb2RlU2V0cy1tb2RlIHN5bnRheC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFNlYXJjaCB0YXJnZXRcbkBwYXJhbSB7c3RyaW5nfSBuZWVkbGUgU2VhcmNoIGFzIGEgcmVnZXggcGF0dGVybiwgd2l0aCBmbGFncyBgc3VgIGFwcGxpZWRcbkBwYXJhbSB7c3RyaW5nIHwgKG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIGRldGFpbHM6IHtcbiAgY29udGV4dDogJ0RFRkFVTFQnIHwgJ0NIQVJfQ0xBU1MnO1xuICBuZWdhdGVkOiBib29sZWFuO1xufSkgPT4gc3RyaW5nfSByZXBsYWNlbWVudFxuQHBhcmFtIHsnREVGQVVMVCcgfCAnQ0hBUl9DTEFTUyd9IFtjb250ZXh0XSBBbGwgY29udGV4dHMgaWYgbm90IHNwZWNpZmllZFxuQHJldHVybnMge3N0cmluZ30gVXBkYXRlZCBleHByZXNzaW9uXG5AZXhhbXBsZVxuY29uc3Qgc3RyID0gJy5cXFxcLlxcXFxcXFxcLltbXFxcXC5dLl0uJztcbnJlcGxhY2VVbmVzY2FwZWQoc3RyLCAnXFxcXC4nLCAnQCcpO1xuLy8g4oaSICdAXFxcXC5cXFxcXFxcXEBbW1xcXFwuXUBdQCdcbnJlcGxhY2VVbmVzY2FwZWQoc3RyLCAnXFxcXC4nLCAnQCcsIENvbnRleHQuREVGQVVMVCk7XG4vLyDihpIgJ0BcXFxcLlxcXFxcXFxcQFtbXFxcXC5dLl1AJ1xucmVwbGFjZVVuZXNjYXBlZChzdHIsICdcXFxcLicsICdAJywgQ29udGV4dC5DSEFSX0NMQVNTKTtcbi8vIOKGkiAnLlxcXFwuXFxcXFxcXFwuW1tcXFxcLl1AXS4nXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VVbmVzY2FwZWQoZXhwcmVzc2lvbiwgbmVlZGxlLCByZXBsYWNlbWVudCwgY29udGV4dCkge1xuICBjb25zdCByZSA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhd2Ake25lZWRsZX18KD88JHNraXA+XFxbXFxeP3xcXFxcPy4pYCwgJ2dzdScpO1xuICBjb25zdCBuZWdhdGVkID0gW2ZhbHNlXTtcbiAgbGV0IG51bUNoYXJDbGFzc2VzT3BlbiA9IDA7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBleHByZXNzaW9uLm1hdGNoQWxsKHJlKSkge1xuICAgIGNvbnN0IHswOiBtLCBncm91cHM6IHskc2tpcH19ID0gbWF0Y2g7XG4gICAgaWYgKCEkc2tpcCAmJiAoIWNvbnRleHQgfHwgKGNvbnRleHQgPT09IENvbnRleHQuREVGQVVMVCkgPT09ICFudW1DaGFyQ2xhc3Nlc09wZW4pKSB7XG4gICAgICBpZiAocmVwbGFjZW1lbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICByZXN1bHQgKz0gcmVwbGFjZW1lbnQobWF0Y2gsIHtcbiAgICAgICAgICBjb250ZXh0OiBudW1DaGFyQ2xhc3Nlc09wZW4gPyBDb250ZXh0LkNIQVJfQ0xBU1MgOiBDb250ZXh0LkRFRkFVTFQsXG4gICAgICAgICAgbmVnYXRlZDogbmVnYXRlZFtuZWdhdGVkLmxlbmd0aCAtIDFdLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSByZXBsYWNlbWVudDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobVswXSA9PT0gJ1snKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICAgIG5lZ2F0ZWQucHVzaChtWzFdID09PSAnXicpO1xuICAgIH0gZWxzZSBpZiAobSA9PT0gJ10nICYmIG51bUNoYXJDbGFzc2VzT3Blbikge1xuICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuLS07XG4gICAgICBuZWdhdGVkLnBvcCgpO1xuICAgIH1cbiAgICByZXN1bHQgKz0gbTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcblJ1bnMgYSBjYWxsYmFjayBmb3IgZWFjaCB1bmVzY2FwZWQgaW5zdGFuY2Ugb2YgYSByZWdleCBwYXR0ZXJuIGluIHRoZSBnaXZlbiBjb250ZXh0LlxuXG5Eb2Vzbid0IHNraXAgb3ZlciBjb21wbGV0ZSBtdWx0aWNoYXJhY3RlciB0b2tlbnMgKG9ubHkgYFxcYCBwbHVzIGl0cyBmb2xvd2luZyBjaGFyKSBzbyBtdXN0IGJlIHVzZWRcbndpdGgga25vd2xlZGdlIG9mIHdoYXQncyBzYWZlIHRvIGRvIGdpdmVuIHJlZ2V4IHN5bnRheC4gQXNzdW1lcyBVbmljb2RlU2V0cy1tb2RlIHN5bnRheC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFNlYXJjaCB0YXJnZXRcbkBwYXJhbSB7c3RyaW5nfSBuZWVkbGUgU2VhcmNoIGFzIGEgcmVnZXggcGF0dGVybiwgd2l0aCBmbGFncyBgc3VgIGFwcGxpZWRcbkBwYXJhbSB7KG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIGRldGFpbHM6IHtcbiAgY29udGV4dDogJ0RFRkFVTFQnIHwgJ0NIQVJfQ0xBU1MnO1xuICBuZWdhdGVkOiBib29sZWFuO1xufSkgPT4gdm9pZH0gY2FsbGJhY2tcbkBwYXJhbSB7J0RFRkFVTFQnIHwgJ0NIQVJfQ0xBU1MnfSBbY29udGV4dF0gQWxsIGNvbnRleHRzIGlmIG5vdCBzcGVjaWZpZWRcbiovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaFVuZXNjYXBlZChleHByZXNzaW9uLCBuZWVkbGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIC8vIERvIHRoaXMgdGhlIGVhc3kgd2F5XG4gIHJlcGxhY2VVbmVzY2FwZWQoZXhwcmVzc2lvbiwgbmVlZGxlLCBjYWxsYmFjaywgY29udGV4dCk7XG59XG5cbi8qKlxuUmV0dXJucyBhIG1hdGNoIG9iamVjdCBmb3IgdGhlIGZpcnN0IHVuZXNjYXBlZCBpbnN0YW5jZSBvZiBhIHJlZ2V4IHBhdHRlcm4gaW4gdGhlIGdpdmVuIGNvbnRleHQsIG9yXG5gbnVsbGAuXG5cbkRvZXNuJ3Qgc2tpcCBvdmVyIGNvbXBsZXRlIG11bHRpY2hhcmFjdGVyIHRva2VucyAob25seSBgXFxgIHBsdXMgaXRzIGZvbG93aW5nIGNoYXIpIHNvIG11c3QgYmUgdXNlZFxud2l0aCBrbm93bGVkZ2Ugb2Ygd2hhdCdzIHNhZmUgdG8gZG8gZ2l2ZW4gcmVnZXggc3ludGF4LiBBc3N1bWVzIFVuaWNvZGVTZXRzLW1vZGUgc3ludGF4LlxuQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gU2VhcmNoIHRhcmdldFxuQHBhcmFtIHtzdHJpbmd9IG5lZWRsZSBTZWFyY2ggYXMgYSByZWdleCBwYXR0ZXJuLCB3aXRoIGZsYWdzIGBzdWAgYXBwbGllZFxuQHBhcmFtIHtudW1iZXJ9IFtwb3NdIE9mZnNldCB0byBzdGFydCB0aGUgc2VhcmNoXG5AcGFyYW0geydERUZBVUxUJyB8ICdDSEFSX0NMQVNTJ30gW2NvbnRleHRdIEFsbCBjb250ZXh0cyBpZiBub3Qgc3BlY2lmaWVkXG5AcmV0dXJucyB7UmVnRXhwRXhlY0FycmF5IHwgbnVsbH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZXhlY1VuZXNjYXBlZChleHByZXNzaW9uLCBuZWVkbGUsIHBvcyA9IDAsIGNvbnRleHQpIHtcbiAgLy8gUXVpY2sgcGFydGlhbCB0ZXN0OyBhdm9pZCB0aGUgbG9vcCBpZiBub3QgbmVlZGVkXG4gIGlmICghKG5ldyBSZWdFeHAobmVlZGxlLCAnc3UnKS50ZXN0KGV4cHJlc3Npb24pKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgJHtuZWVkbGV9fCg/PCRza2lwPlxcXFxcXFxcPy4pYCwgJ2dzdScpO1xuICByZS5sYXN0SW5kZXggPSBwb3M7XG4gIGxldCBudW1DaGFyQ2xhc3Nlc09wZW4gPSAwO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMoZXhwcmVzc2lvbikpIHtcbiAgICBjb25zdCB7MDogbSwgZ3JvdXBzOiB7JHNraXB9fSA9IG1hdGNoO1xuICAgIGlmICghJHNraXAgJiYgKCFjb250ZXh0IHx8IChjb250ZXh0ID09PSBDb250ZXh0LkRFRkFVTFQpID09PSAhbnVtQ2hhckNsYXNzZXNPcGVuKSkge1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBpZiAobSA9PT0gJ1snKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICB9IGVsc2UgaWYgKG0gPT09ICddJyAmJiBudW1DaGFyQ2xhc3Nlc09wZW4pIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3Blbi0tO1xuICAgIH1cbiAgICAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIG9uIHplcm8tbGVuZ3RoIG1hdGNoZXNcbiAgICBpZiAocmUubGFzdEluZGV4ID09IG1hdGNoLmluZGV4KSB7XG4gICAgICByZS5sYXN0SW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuQ2hlY2tzIHdoZXRoZXIgYW4gdW5lc2NhcGVkIGluc3RhbmNlIG9mIGEgcmVnZXggcGF0dGVybiBhcHBlYXJzIGluIHRoZSBnaXZlbiBjb250ZXh0LlxuXG5Eb2Vzbid0IHNraXAgb3ZlciBjb21wbGV0ZSBtdWx0aWNoYXJhY3RlciB0b2tlbnMgKG9ubHkgYFxcYCBwbHVzIGl0cyBmb2xvd2luZyBjaGFyKSBzbyBtdXN0IGJlIHVzZWRcbndpdGgga25vd2xlZGdlIG9mIHdoYXQncyBzYWZlIHRvIGRvIGdpdmVuIHJlZ2V4IHN5bnRheC4gQXNzdW1lcyBVbmljb2RlU2V0cy1tb2RlIHN5bnRheC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFNlYXJjaCB0YXJnZXRcbkBwYXJhbSB7c3RyaW5nfSBuZWVkbGUgU2VhcmNoIGFzIGEgcmVnZXggcGF0dGVybiwgd2l0aCBmbGFncyBgc3VgIGFwcGxpZWRcbkBwYXJhbSB7J0RFRkFVTFQnIHwgJ0NIQVJfQ0xBU1MnfSBbY29udGV4dF0gQWxsIGNvbnRleHRzIGlmIG5vdCBzcGVjaWZpZWRcbkByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYXR0ZXJuIHdhcyBmb3VuZFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNVbmVzY2FwZWQoZXhwcmVzc2lvbiwgbmVlZGxlLCBjb250ZXh0KSB7XG4gIC8vIERvIHRoaXMgdGhlIGVhc3kgd2F5XG4gIHJldHVybiAhIWV4ZWNVbmVzY2FwZWQoZXhwcmVzc2lvbiwgbmVlZGxlLCAwLCBjb250ZXh0KTtcbn1cblxuLyoqXG5FeHRyYWN0cyB0aGUgZnVsbCBjb250ZW50cyBvZiBhIGdyb3VwIChzdWJwYXR0ZXJuKSBmcm9tIHRoZSBnaXZlbiBleHByZXNzaW9uLCBhY2NvdW50aW5nIGZvclxuZXNjYXBlZCBjaGFyYWN0ZXJzLCBuZXN0ZWQgZ3JvdXBzLCBhbmQgY2hhcmFjdGVyIGNsYXNzZXMuIFRoZSBncm91cCBpcyBpZGVudGlmaWVkIGJ5IHRoZSBwb3NpdGlvblxud2hlcmUgaXRzIGNvbnRlbnRzIHN0YXJ0ICh0aGUgc3RyaW5nIGluZGV4IGp1c3QgYWZ0ZXIgdGhlIGdyb3VwJ3Mgb3BlbmluZyBkZWxpbWl0ZXIpLiBSZXR1cm5zIHRoZVxucmVzdCBvZiB0aGUgc3RyaW5nIGlmIHRoZSBncm91cCBpcyB1bmNsb3NlZC5cblxuQXNzdW1lcyBVbmljb2RlU2V0cy1tb2RlIHN5bnRheC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFNlYXJjaCB0YXJnZXRcbkBwYXJhbSB7bnVtYmVyfSBjb250ZW50c1N0YXJ0UG9zXG5AcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcm91cENvbnRlbnRzKGV4cHJlc3Npb24sIGNvbnRlbnRzU3RhcnRQb3MpIHtcbiAgY29uc3QgdG9rZW4gPSAvXFxcXD8uL2dzdTtcbiAgdG9rZW4ubGFzdEluZGV4ID0gY29udGVudHNTdGFydFBvcztcbiAgbGV0IGNvbnRlbnRzRW5kUG9zID0gZXhwcmVzc2lvbi5sZW5ndGg7XG4gIGxldCBudW1DaGFyQ2xhc3Nlc09wZW4gPSAwO1xuICAvLyBTdGFydGluZyBzZWFyY2ggd2l0aGluIGFuIG9wZW4gZ3JvdXAsIGFmdGVyIHRoZSBncm91cCdzIG9wZW5pbmdcbiAgbGV0IG51bUdyb3Vwc09wZW4gPSAxO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlIChtYXRjaCA9IHRva2VuLmV4ZWMoZXhwcmVzc2lvbikpIHtcbiAgICBjb25zdCBbbV0gPSBtYXRjaDtcbiAgICBpZiAobSA9PT0gJ1snKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICB9IGVsc2UgaWYgKCFudW1DaGFyQ2xhc3Nlc09wZW4pIHtcbiAgICAgIGlmIChtID09PSAnKCcpIHtcbiAgICAgICAgbnVtR3JvdXBzT3BlbisrO1xuICAgICAgfSBlbHNlIGlmIChtID09PSAnKScpIHtcbiAgICAgICAgbnVtR3JvdXBzT3Blbi0tO1xuICAgICAgICBpZiAoIW51bUdyb3Vwc09wZW4pIHtcbiAgICAgICAgICBjb250ZW50c0VuZFBvcyA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtID09PSAnXScpIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3Blbi0tO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwcmVzc2lvbi5zbGljZShjb250ZW50c1N0YXJ0UG9zLCBjb250ZW50c0VuZFBvcyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/atomic.js":
/*!*************************************************************************!*\
  !*** ./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/atomic.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atomic: () => (/* binding */ atomic),\n/* harmony export */   possessive: () => (/* binding */ possessive)\n/* harmony export */ });\n/* harmony import */ var _subclass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subclass.js */ \"(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/subclass.js\");\n/* harmony import */ var _utils_internals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils-internals.js */ \"(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/utils-internals.js\");\n/* harmony import */ var regex_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! regex-utilities */ \"(app-pages-browser)/./node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\");\n\n\n\n\nconst atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${_utils_internals_js__WEBPACK_IMPORTED_MODULE_1__.noncapturingDelim})|(?<capturingStart>\\((?:\\?<[^>]+>)?)|\\\\?.`, 'gsu');\n\n/**\nApply transformations for atomic groups: `(?>)`.\n@param {string} expression\n@param {import('./regex.js').PluginData} [data]\n@returns {string}\n*/\nfunction atomic(expression, data) {\n  if (!/\\(\\?>/.test(expression)) {\n    return expression;\n  }\n  const aGDelim = '(?>';\n  const emulatedAGDelim = `(?:(?=(${data?.useEmulationGroups ? _subclass_js__WEBPACK_IMPORTED_MODULE_0__.emulationGroupMarker : ''}`;\n  const captureNumMap = [0];\n  let numCapturesBeforeAG = 0;\n  let numAGs = 0;\n  let aGPos = NaN;\n  let hasProcessedAG;\n  do {\n    hasProcessedAG = false;\n    let numCharClassesOpen = 0;\n    let numGroupsOpenInAG = 0;\n    let inAG = false;\n    let match;\n    atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + emulatedAGDelim.length;\n    while (match = atomicPluginToken.exec(expression)) {\n      const {0: m, index, groups: {capturingStart, noncapturingStart}} = match;\n      if (m === '[') {\n        numCharClassesOpen++;\n      } else if (!numCharClassesOpen) {\n\n        if (m === aGDelim && !inAG) {\n          aGPos = index;\n          inAG = true;\n        } else if (inAG && noncapturingStart) {\n          numGroupsOpenInAG++;\n        } else if (capturingStart) {\n          if (inAG) {\n            numGroupsOpenInAG++;\n          } else {\n            numCapturesBeforeAG++;\n            captureNumMap.push(numCapturesBeforeAG + numAGs);\n          }\n        } else if (m === ')' && inAG) {\n          if (!numGroupsOpenInAG) {\n            numAGs++;\n            // Replace `expression` and use `<$$N>` as a temporary wrapper for the backref so it\n            // can avoid backref renumbering afterward. Need to wrap the whole substitution\n            // (including the lookahead and following backref) in a noncapturing group to handle\n            // following quantifiers and literal digits\n            expression = `${expression.slice(0, aGPos)}${emulatedAGDelim}${\n                expression.slice(aGPos + aGDelim.length, index)\n              }))<$$${numAGs + numCapturesBeforeAG}>)${expression.slice(index + 1)}`;\n            hasProcessedAG = true;\n            break;\n          }\n          numGroupsOpenInAG--;\n        }\n\n      } else if (m === ']') {\n        numCharClassesOpen--;\n      }\n    }\n  // Start over from the beginning of the last atomic group's contents, in case the processed group\n  // contains additional atomic groups\n  } while (hasProcessedAG);\n\n  // Second pass to adjust numbered backrefs\n  expression = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_2__.replaceUnescaped)(\n    expression,\n    String.raw`\\\\(?<backrefNum>[1-9]\\d*)|<\\$\\$(?<wrappedBackrefNum>\\d+)>`,\n    ({0: m, groups: {backrefNum, wrappedBackrefNum}}) => {\n      if (backrefNum) {\n        const bNum = +backrefNum;\n        if (bNum > captureNumMap.length - 1) {\n          throw new Error(`Backref \"${m}\" greater than number of captures`);\n        }\n        return `\\\\${captureNumMap[bNum]}`;\n      }\n      return `\\\\${wrappedBackrefNum}`;\n    },\n    regex_utilities__WEBPACK_IMPORTED_MODULE_2__.Context.DEFAULT\n  );\n  return expression;\n}\n\nconst baseQuantifier = String.raw`(?:[?*+]|\\{\\d+(?:,\\d*)?\\})`;\n// Complete tokenizer for base syntax; doesn't (need to) know about character-class-only syntax\nconst possessivePluginToken = new RegExp(String.raw`\n\\\\(?: \\d+\n  | c[A-Za-z]\n  | [gk]<[^>]+>\n  | [pPu]\\{[^\\}]+\\}\n  | u[A-Fa-f\\d]{4}\n  | x[A-Fa-f\\d]{2}\n  )\n| \\((?: \\? (?: [:=!>]\n  | <(?:[=!]|[^>]+>)\n  | [A-Za-z\\-]+:\n  | \\(DEFINE\\)\n  ))?\n| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\\{]?)\n| \\\\?.\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\nTransform posessive quantifiers into atomic groups. The posessessive quantifiers are:\n`?+`, `*+`, `++`, `{N}+`, `{N,}+`, `{N,N}+`.\nThis follows Java, PCRE, Perl, and Python.\nPossessive quantifiers in Oniguruma and Onigmo are only: `?+`, `*+`, `++`.\n@param {string} expression\n@returns {string}\n*/\nfunction possessive(expression) {\n  if (!(new RegExp(`${baseQuantifier}\\\\+`).test(expression))) {\n    return expression;\n  }\n  const openGroupIndices = [];\n  let lastGroupIndex = null;\n  let lastCharClassIndex = null;\n  let lastToken = '';\n  let numCharClassesOpen = 0;\n  let match;\n  possessivePluginToken.lastIndex = 0;\n  while (match = possessivePluginToken.exec(expression)) {\n    const {0: m, index, groups: {qBase, qMod, invalidQ}} = match;\n    if (m === '[') {\n      if (!numCharClassesOpen) {\n        lastCharClassIndex = index;\n      }\n      numCharClassesOpen++;\n    } else if (m === ']') {\n      if (numCharClassesOpen) {\n        numCharClassesOpen--;\n      // Unmatched `]`\n      } else {\n        lastCharClassIndex = null;\n      }\n    } else if (!numCharClassesOpen) {\n\n      if (qMod === '+' && lastToken && !lastToken.startsWith('(')) {\n        // Invalid following quantifier would become valid via the wrapping group\n        if (invalidQ) {\n          throw new Error(`Invalid quantifier \"${m}\"`);\n        }\n        let charsAdded = -1; // -1 for removed trailing `+`\n        // Possessivizing fixed repetition quantifiers like `{2}` does't change their behavior, so\n        // avoid doing so (convert them to greedy)\n        if (/^\\{\\d+\\}$/.test(qBase)) {\n          expression = (0,_utils_internals_js__WEBPACK_IMPORTED_MODULE_1__.spliceStr)(expression, index + qBase.length, qMod, '');\n        } else {\n          if (lastToken === ')' || lastToken === ']') {\n            const nodeIndex = lastToken === ')' ? lastGroupIndex : lastCharClassIndex;\n            // Unmatched `)` would break out of the wrapping group and mess with handling.\n            // Unmatched `]` wouldn't be a problem, but it's unnecessary to have dedicated support\n            // for unescaped `]++` since this won't work with flag u or v anyway\n            if (nodeIndex === null) {\n              throw new Error(`Invalid unmatched \"${lastToken}\"`);\n            }\n            expression = `${expression.slice(0, nodeIndex)}(?>${expression.slice(nodeIndex, index)}${qBase})${expression.slice(index + m.length)}`;\n          } else {\n            expression = `${expression.slice(0, index - lastToken.length)}(?>${lastToken}${qBase})${expression.slice(index + m.length)}`;\n          }\n          charsAdded += 4; // `(?>)`\n        }\n        possessivePluginToken.lastIndex += charsAdded;\n      } else if (m[0] === '(') {\n        openGroupIndices.push(index);\n      } else if (m === ')') {\n        lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;\n      }\n\n    }\n    lastToken = m;\n  }\n  return expression;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleEA1LjEuMS9ub2RlX21vZHVsZXMvcmVnZXgvc3JjL2F0b21pYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRDtBQUNlO0FBQ1I7O0FBRTFELHVFQUF1RSxrRUFBaUIsQ0FBQzs7QUFFekY7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQixRQUFRLGlDQUFpQztBQUN6QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQiw4REFBb0IsTUFBTTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQixFQUFFLGdCQUFnQjtBQUN6RTtBQUNBLGVBQWUsT0FBTyw2QkFBNkIsSUFBSSw0QkFBNEI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxlQUFlLGlFQUFnQjtBQUMvQjtBQUNBO0FBQ0EsTUFBTSxlQUFlLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRTtBQUN4QztBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLEtBQUs7QUFDTCxJQUFJLG9EQUFPO0FBQ1g7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxjQUFjO0FBQzNELHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlLGlDQUFpQztBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsRUFBRSxNQUFNLEdBQUcsTUFBTSxJQUFJO0FBQ3pDO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCLHdCQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBLDZCQUE2QjtBQUM3Qiw4REFBOEQsRUFBRTtBQUNoRTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCLHVCQUF1Qiw4REFBUztBQUNoQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFVBQVU7QUFDOUQ7QUFDQSw0QkFBNEIsK0JBQStCLEtBQUssbUNBQW1DLEVBQUUsTUFBTSxHQUFHLG1DQUFtQztBQUNqSixZQUFZO0FBQ1osNEJBQTRCLDhDQUE4QyxLQUFLLFVBQVUsRUFBRSxNQUFNLEdBQUcsbUNBQW1DO0FBQ3ZJO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4QDUuMS4xL25vZGVfbW9kdWxlcy9yZWdleC9zcmMvYXRvbWljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZW11bGF0aW9uR3JvdXBNYXJrZXJ9IGZyb20gJy4vc3ViY2xhc3MuanMnO1xuaW1wb3J0IHtub25jYXB0dXJpbmdEZWxpbSwgc3BsaWNlU3RyfSBmcm9tICcuL3V0aWxzLWludGVybmFscy5qcyc7XG5pbXBvcnQge0NvbnRleHQsIHJlcGxhY2VVbmVzY2FwZWR9IGZyb20gJ3JlZ2V4LXV0aWxpdGllcyc7XG5cbmNvbnN0IGF0b21pY1BsdWdpblRva2VuID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3YCg/PG5vbmNhcHR1cmluZ1N0YXJ0PiR7bm9uY2FwdHVyaW5nRGVsaW19KXwoPzxjYXB0dXJpbmdTdGFydD5cXCgoPzpcXD88W14+XSs+KT8pfFxcXFw/LmAsICdnc3UnKTtcblxuLyoqXG5BcHBseSB0cmFuc2Zvcm1hdGlvbnMgZm9yIGF0b21pYyBncm91cHM6IGAoPz7igKYpYC5cbkBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uXG5AcGFyYW0ge2ltcG9ydCgnLi9yZWdleC5qcycpLlBsdWdpbkRhdGF9IFtkYXRhXVxuQHJldHVybnMge3N0cmluZ31cbiovXG5mdW5jdGlvbiBhdG9taWMoZXhwcmVzc2lvbiwgZGF0YSkge1xuICBpZiAoIS9cXChcXD8+Ly50ZXN0KGV4cHJlc3Npb24pKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG4gIH1cbiAgY29uc3QgYUdEZWxpbSA9ICcoPz4nO1xuICBjb25zdCBlbXVsYXRlZEFHRGVsaW0gPSBgKD86KD89KCR7ZGF0YT8udXNlRW11bGF0aW9uR3JvdXBzID8gZW11bGF0aW9uR3JvdXBNYXJrZXIgOiAnJ31gO1xuICBjb25zdCBjYXB0dXJlTnVtTWFwID0gWzBdO1xuICBsZXQgbnVtQ2FwdHVyZXNCZWZvcmVBRyA9IDA7XG4gIGxldCBudW1BR3MgPSAwO1xuICBsZXQgYUdQb3MgPSBOYU47XG4gIGxldCBoYXNQcm9jZXNzZWRBRztcbiAgZG8ge1xuICAgIGhhc1Byb2Nlc3NlZEFHID0gZmFsc2U7XG4gICAgbGV0IG51bUNoYXJDbGFzc2VzT3BlbiA9IDA7XG4gICAgbGV0IG51bUdyb3Vwc09wZW5JbkFHID0gMDtcbiAgICBsZXQgaW5BRyA9IGZhbHNlO1xuICAgIGxldCBtYXRjaDtcbiAgICBhdG9taWNQbHVnaW5Ub2tlbi5sYXN0SW5kZXggPSBOdW1iZXIuaXNOYU4oYUdQb3MpID8gMCA6IGFHUG9zICsgZW11bGF0ZWRBR0RlbGltLmxlbmd0aDtcbiAgICB3aGlsZSAobWF0Y2ggPSBhdG9taWNQbHVnaW5Ub2tlbi5leGVjKGV4cHJlc3Npb24pKSB7XG4gICAgICBjb25zdCB7MDogbSwgaW5kZXgsIGdyb3Vwczoge2NhcHR1cmluZ1N0YXJ0LCBub25jYXB0dXJpbmdTdGFydH19ID0gbWF0Y2g7XG4gICAgICBpZiAobSA9PT0gJ1snKSB7XG4gICAgICAgIG51bUNoYXJDbGFzc2VzT3BlbisrO1xuICAgICAgfSBlbHNlIGlmICghbnVtQ2hhckNsYXNzZXNPcGVuKSB7XG5cbiAgICAgICAgaWYgKG0gPT09IGFHRGVsaW0gJiYgIWluQUcpIHtcbiAgICAgICAgICBhR1BvcyA9IGluZGV4O1xuICAgICAgICAgIGluQUcgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGluQUcgJiYgbm9uY2FwdHVyaW5nU3RhcnQpIHtcbiAgICAgICAgICBudW1Hcm91cHNPcGVuSW5BRysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmluZ1N0YXJ0KSB7XG4gICAgICAgICAgaWYgKGluQUcpIHtcbiAgICAgICAgICAgIG51bUdyb3Vwc09wZW5JbkFHKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG51bUNhcHR1cmVzQmVmb3JlQUcrKztcbiAgICAgICAgICAgIGNhcHR1cmVOdW1NYXAucHVzaChudW1DYXB0dXJlc0JlZm9yZUFHICsgbnVtQUdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJyknICYmIGluQUcpIHtcbiAgICAgICAgICBpZiAoIW51bUdyb3Vwc09wZW5JbkFHKSB7XG4gICAgICAgICAgICBudW1BR3MrKztcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgYGV4cHJlc3Npb25gIGFuZCB1c2UgYDwkJE4+YCBhcyBhIHRlbXBvcmFyeSB3cmFwcGVyIGZvciB0aGUgYmFja3JlZiBzbyBpdFxuICAgICAgICAgICAgLy8gY2FuIGF2b2lkIGJhY2tyZWYgcmVudW1iZXJpbmcgYWZ0ZXJ3YXJkLiBOZWVkIHRvIHdyYXAgdGhlIHdob2xlIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgLy8gKGluY2x1ZGluZyB0aGUgbG9va2FoZWFkIGFuZCBmb2xsb3dpbmcgYmFja3JlZikgaW4gYSBub25jYXB0dXJpbmcgZ3JvdXAgdG8gaGFuZGxlXG4gICAgICAgICAgICAvLyBmb2xsb3dpbmcgcXVhbnRpZmllcnMgYW5kIGxpdGVyYWwgZGlnaXRzXG4gICAgICAgICAgICBleHByZXNzaW9uID0gYCR7ZXhwcmVzc2lvbi5zbGljZSgwLCBhR1Bvcyl9JHtlbXVsYXRlZEFHRGVsaW19JHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLnNsaWNlKGFHUG9zICsgYUdEZWxpbS5sZW5ndGgsIGluZGV4KVxuICAgICAgICAgICAgICB9KSk8JCQke251bUFHcyArIG51bUNhcHR1cmVzQmVmb3JlQUd9Pikke2V4cHJlc3Npb24uc2xpY2UoaW5kZXggKyAxKX1gO1xuICAgICAgICAgICAgaGFzUHJvY2Vzc2VkQUcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bUdyb3Vwc09wZW5JbkFHLS07XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChtID09PSAnXScpIHtcbiAgICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuLS07XG4gICAgICB9XG4gICAgfVxuICAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGFzdCBhdG9taWMgZ3JvdXAncyBjb250ZW50cywgaW4gY2FzZSB0aGUgcHJvY2Vzc2VkIGdyb3VwXG4gIC8vIGNvbnRhaW5zIGFkZGl0aW9uYWwgYXRvbWljIGdyb3Vwc1xuICB9IHdoaWxlIChoYXNQcm9jZXNzZWRBRyk7XG5cbiAgLy8gU2Vjb25kIHBhc3MgdG8gYWRqdXN0IG51bWJlcmVkIGJhY2tyZWZzXG4gIGV4cHJlc3Npb24gPSByZXBsYWNlVW5lc2NhcGVkKFxuICAgIGV4cHJlc3Npb24sXG4gICAgU3RyaW5nLnJhd2BcXFxcKD88YmFja3JlZk51bT5bMS05XVxcZCopfDxcXCRcXCQoPzx3cmFwcGVkQmFja3JlZk51bT5cXGQrKT5gLFxuICAgICh7MDogbSwgZ3JvdXBzOiB7YmFja3JlZk51bSwgd3JhcHBlZEJhY2tyZWZOdW19fSkgPT4ge1xuICAgICAgaWYgKGJhY2tyZWZOdW0pIHtcbiAgICAgICAgY29uc3QgYk51bSA9ICtiYWNrcmVmTnVtO1xuICAgICAgICBpZiAoYk51bSA+IGNhcHR1cmVOdW1NYXAubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFja3JlZiBcIiR7bX1cIiBncmVhdGVyIHRoYW4gbnVtYmVyIG9mIGNhcHR1cmVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBcXFxcJHtjYXB0dXJlTnVtTWFwW2JOdW1dfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYFxcXFwke3dyYXBwZWRCYWNrcmVmTnVtfWA7XG4gICAgfSxcbiAgICBDb250ZXh0LkRFRkFVTFRcbiAgKTtcbiAgcmV0dXJuIGV4cHJlc3Npb247XG59XG5cbmNvbnN0IGJhc2VRdWFudGlmaWVyID0gU3RyaW5nLnJhd2AoPzpbPyorXXxcXHtcXGQrKD86LFxcZCopP1xcfSlgO1xuLy8gQ29tcGxldGUgdG9rZW5pemVyIGZvciBiYXNlIHN5bnRheDsgZG9lc24ndCAobmVlZCB0bykga25vdyBhYm91dCBjaGFyYWN0ZXItY2xhc3Mtb25seSBzeW50YXhcbmNvbnN0IHBvc3Nlc3NpdmVQbHVnaW5Ub2tlbiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhd2BcblxcXFwoPzogXFxkK1xuICB8IGNbQS1aYS16XVxuICB8IFtna108W14+XSs+XG4gIHwgW3BQdV1cXHtbXlxcfV0rXFx9XG4gIHwgdVtBLUZhLWZcXGRdezR9XG4gIHwgeFtBLUZhLWZcXGRdezJ9XG4gIClcbnwgXFwoKD86IFxcPyAoPzogWzo9IT5dXG4gIHwgPCg/Ols9IV18W14+XSs+KVxuICB8IFtBLVphLXpcXC1dKzpcbiAgfCBcXChERUZJTkVcXClcbiAgKSk/XG58ICg/PHFCYXNlPiR7YmFzZVF1YW50aWZpZXJ9KSg/PHFNb2Q+Wz8rXT8pKD88aW52YWxpZFE+Wz8qK1xce10/KVxufCBcXFxcPy5cbmAucmVwbGFjZSgvXFxzKy9nLCAnJyksICdnc3UnKTtcblxuLyoqXG5UcmFuc2Zvcm0gcG9zZXNzaXZlIHF1YW50aWZpZXJzIGludG8gYXRvbWljIGdyb3Vwcy4gVGhlIHBvc2Vzc2Vzc2l2ZSBxdWFudGlmaWVycyBhcmU6XG5gPytgLCBgKitgLCBgKytgLCBge059K2AsIGB7Tix9K2AsIGB7TixOfStgLlxuVGhpcyBmb2xsb3dzIEphdmEsIFBDUkUsIFBlcmwsIGFuZCBQeXRob24uXG5Qb3NzZXNzaXZlIHF1YW50aWZpZXJzIGluIE9uaWd1cnVtYSBhbmQgT25pZ21vIGFyZSBvbmx5OiBgPytgLCBgKitgLCBgKytgLlxuQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb25cbkByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZnVuY3Rpb24gcG9zc2Vzc2l2ZShleHByZXNzaW9uKSB7XG4gIGlmICghKG5ldyBSZWdFeHAoYCR7YmFzZVF1YW50aWZpZXJ9XFxcXCtgKS50ZXN0KGV4cHJlc3Npb24pKSkge1xuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9XG4gIGNvbnN0IG9wZW5Hcm91cEluZGljZXMgPSBbXTtcbiAgbGV0IGxhc3RHcm91cEluZGV4ID0gbnVsbDtcbiAgbGV0IGxhc3RDaGFyQ2xhc3NJbmRleCA9IG51bGw7XG4gIGxldCBsYXN0VG9rZW4gPSAnJztcbiAgbGV0IG51bUNoYXJDbGFzc2VzT3BlbiA9IDA7XG4gIGxldCBtYXRjaDtcbiAgcG9zc2Vzc2l2ZVBsdWdpblRva2VuLmxhc3RJbmRleCA9IDA7XG4gIHdoaWxlIChtYXRjaCA9IHBvc3Nlc3NpdmVQbHVnaW5Ub2tlbi5leGVjKGV4cHJlc3Npb24pKSB7XG4gICAgY29uc3QgezA6IG0sIGluZGV4LCBncm91cHM6IHtxQmFzZSwgcU1vZCwgaW52YWxpZFF9fSA9IG1hdGNoO1xuICAgIGlmIChtID09PSAnWycpIHtcbiAgICAgIGlmICghbnVtQ2hhckNsYXNzZXNPcGVuKSB7XG4gICAgICAgIGxhc3RDaGFyQ2xhc3NJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuKys7XG4gICAgfSBlbHNlIGlmIChtID09PSAnXScpIHtcbiAgICAgIGlmIChudW1DaGFyQ2xhc3Nlc09wZW4pIHtcbiAgICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuLS07XG4gICAgICAvLyBVbm1hdGNoZWQgYF1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhckNsYXNzSW5kZXggPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW51bUNoYXJDbGFzc2VzT3Blbikge1xuXG4gICAgICBpZiAocU1vZCA9PT0gJysnICYmIGxhc3RUb2tlbiAmJiAhbGFzdFRva2VuLnN0YXJ0c1dpdGgoJygnKSkge1xuICAgICAgICAvLyBJbnZhbGlkIGZvbGxvd2luZyBxdWFudGlmaWVyIHdvdWxkIGJlY29tZSB2YWxpZCB2aWEgdGhlIHdyYXBwaW5nIGdyb3VwXG4gICAgICAgIGlmIChpbnZhbGlkUSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBxdWFudGlmaWVyIFwiJHttfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoYXJzQWRkZWQgPSAtMTsgLy8gLTEgZm9yIHJlbW92ZWQgdHJhaWxpbmcgYCtgXG4gICAgICAgIC8vIFBvc3Nlc3Npdml6aW5nIGZpeGVkIHJlcGV0aXRpb24gcXVhbnRpZmllcnMgbGlrZSBgezJ9YCBkb2VzJ3QgY2hhbmdlIHRoZWlyIGJlaGF2aW9yLCBzb1xuICAgICAgICAvLyBhdm9pZCBkb2luZyBzbyAoY29udmVydCB0aGVtIHRvIGdyZWVkeSlcbiAgICAgICAgaWYgKC9eXFx7XFxkK1xcfSQvLnRlc3QocUJhc2UpKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IHNwbGljZVN0cihleHByZXNzaW9uLCBpbmRleCArIHFCYXNlLmxlbmd0aCwgcU1vZCwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsYXN0VG9rZW4gPT09ICcpJyB8fCBsYXN0VG9rZW4gPT09ICddJykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gbGFzdFRva2VuID09PSAnKScgPyBsYXN0R3JvdXBJbmRleCA6IGxhc3RDaGFyQ2xhc3NJbmRleDtcbiAgICAgICAgICAgIC8vIFVubWF0Y2hlZCBgKWAgd291bGQgYnJlYWsgb3V0IG9mIHRoZSB3cmFwcGluZyBncm91cCBhbmQgbWVzcyB3aXRoIGhhbmRsaW5nLlxuICAgICAgICAgICAgLy8gVW5tYXRjaGVkIGBdYCB3b3VsZG4ndCBiZSBhIHByb2JsZW0sIGJ1dCBpdCdzIHVubmVjZXNzYXJ5IHRvIGhhdmUgZGVkaWNhdGVkIHN1cHBvcnRcbiAgICAgICAgICAgIC8vIGZvciB1bmVzY2FwZWQgYF0rK2Agc2luY2UgdGhpcyB3b24ndCB3b3JrIHdpdGggZmxhZyB1IG9yIHYgYW55d2F5XG4gICAgICAgICAgICBpZiAobm9kZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB1bm1hdGNoZWQgXCIke2xhc3RUb2tlbn1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGAke2V4cHJlc3Npb24uc2xpY2UoMCwgbm9kZUluZGV4KX0oPz4ke2V4cHJlc3Npb24uc2xpY2Uobm9kZUluZGV4LCBpbmRleCl9JHtxQmFzZX0pJHtleHByZXNzaW9uLnNsaWNlKGluZGV4ICsgbS5sZW5ndGgpfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBgJHtleHByZXNzaW9uLnNsaWNlKDAsIGluZGV4IC0gbGFzdFRva2VuLmxlbmd0aCl9KD8+JHtsYXN0VG9rZW59JHtxQmFzZX0pJHtleHByZXNzaW9uLnNsaWNlKGluZGV4ICsgbS5sZW5ndGgpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYXJzQWRkZWQgKz0gNDsgLy8gYCg/PilgXG4gICAgICAgIH1cbiAgICAgICAgcG9zc2Vzc2l2ZVBsdWdpblRva2VuLmxhc3RJbmRleCArPSBjaGFyc0FkZGVkO1xuICAgICAgfSBlbHNlIGlmIChtWzBdID09PSAnKCcpIHtcbiAgICAgICAgb3Blbkdyb3VwSW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICAgIH0gZWxzZSBpZiAobSA9PT0gJyknKSB7XG4gICAgICAgIGxhc3RHcm91cEluZGV4ID0gb3Blbkdyb3VwSW5kaWNlcy5sZW5ndGggPyBvcGVuR3JvdXBJbmRpY2VzLnBvcCgpIDogbnVsbDtcbiAgICAgIH1cblxuICAgIH1cbiAgICBsYXN0VG9rZW4gPSBtO1xuICB9XG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnQge1xuICBhdG9taWMsXG4gIHBvc3Nlc3NpdmUsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/atomic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/internals.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/internals.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpSubclass: () => (/* reexport safe */ _subclass_js__WEBPACK_IMPORTED_MODULE_1__.RegExpSubclass),\n/* harmony export */   atomic: () => (/* reexport safe */ _atomic_js__WEBPACK_IMPORTED_MODULE_0__.atomic),\n/* harmony export */   emulationGroupMarker: () => (/* reexport safe */ _subclass_js__WEBPACK_IMPORTED_MODULE_1__.emulationGroupMarker),\n/* harmony export */   possessive: () => (/* reexport safe */ _atomic_js__WEBPACK_IMPORTED_MODULE_0__.possessive)\n/* harmony export */ });\n/* harmony import */ var _atomic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./atomic.js */ \"(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/atomic.js\");\n/* harmony import */ var _subclass_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./subclass.js */ \"(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/subclass.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleEA1LjEuMS9ub2RlX21vZHVsZXMvcmVnZXgvc3JjL2ludGVybmFscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0M7QUFDb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vcmVnZXhANS4xLjEvbm9kZV9tb2R1bGVzL3JlZ2V4L3NyYy9pbnRlcm5hbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHthdG9taWMsIHBvc3Nlc3NpdmV9IGZyb20gJy4vYXRvbWljLmpzJztcbmV4cG9ydCB7ZW11bGF0aW9uR3JvdXBNYXJrZXIsIFJlZ0V4cFN1YmNsYXNzfSBmcm9tICcuL3N1YmNsYXNzLmpzJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/internals.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/subclass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/subclass.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpSubclass: () => (/* binding */ RegExpSubclass),\n/* harmony export */   emulationGroupMarker: () => (/* binding */ emulationGroupMarker)\n/* harmony export */ });\n/* harmony import */ var regex_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regex-utilities */ \"(app-pages-browser)/./node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\");\n\n\n// This marker was chosen because it's impossible to match (so its extemely unlikely to be used in\n// a user-provided regex); it's not at risk of being optimized away, transformed, or flagged as an\n// error by a plugin; and it ends with an unquantifiable token\nconst emulationGroupMarker = '$E$';\n// Note: Emulation groups with transfer are also supported. They look like `($N$E$)` where `N` is\n// an integer 1 or greater. They're not used directly by Regex+ but can be used by plugins and\n// libraries that use Regex+ internals. Emulation groups with transfer are not only excluded from\n// match results, but additionally transfer their match to the group specified by `N`\n\n/**\nWorks the same as JavaScript's native `RegExp` constructor in all contexts, but automatically\nadjusts matches and subpattern indices (with flag `d`) to account for injected emulation groups.\n*/\nclass RegExpSubclass extends RegExp {\n  // Avoid `#private` to allow for subclassing\n  /**\n  @private\n  @type {Array<{\n    exclude: boolean;\n    transfer?: number;\n  }> | undefined}\n  */\n  _captureMap;\n  /**\n  @private\n  @type {Record<number, string> | undefined}\n  */\n  _namesByIndex;\n  /**\n  @param {string | RegExpSubclass} expression\n  @param {string} [flags]\n  @param {{useEmulationGroups: boolean;}} [options]\n  */\n  constructor(expression, flags, options) {\n    if (expression instanceof RegExp && options) {\n      throw new Error('Cannot provide options when copying a regexp');\n    }\n    const useEmulationGroups = !!options?.useEmulationGroups;\n    const unmarked = useEmulationGroups ? unmarkEmulationGroups(expression) : null;\n    super(unmarked?.expression || expression, flags);\n    // The third argument `options` isn't provided when regexes are copied as part of the internal\n    // handling of string methods `matchAll` and `split`\n    const src = useEmulationGroups ? unmarked : (expression instanceof RegExpSubclass ? expression : null);\n    if (src) {\n      this._captureMap = src._captureMap;\n      this._namesByIndex = src._namesByIndex;\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray | null}\n  */\n  exec(str) {\n    const match = RegExp.prototype.exec.call(this, str);\n    if (!match || !this._captureMap) {\n      return match;\n    }\n    const matchCopy = [...match];\n    // Empty all but the first value of the array while preserving its other properties\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    for (let i = 1; i < matchCopy.length; i++) {\n      if (this._captureMap[i].exclude) {\n        const transfer = this._captureMap[i].transfer;\n        if (transfer && match.length > transfer) {\n          match[transfer] = matchCopy[i];\n          const transferName = this._namesByIndex[transfer];\n          if (transferName) {\n            match.groups[transferName] = matchCopy[i];\n            if (this.hasIndices) {\n              match.indices.groups[transferName] = indicesCopy[i];\n            }\n          }\n          if (this.hasIndices) {\n            match.indices[transfer] = indicesCopy[i];\n          }\n        }\n      } else {\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n    }\n    return match;\n  }\n}\n\n/**\nBuild the capturing group map (with emulation groups marked to indicate their submatches shouldn't\nappear in results), and remove the markers for captures that were added to emulate extended syntax.\n@param {string} expression\n@returns {{\n  _captureMap: Array<{\n    exclude: boolean;\n    transfer?: number;\n  }>;\n  _namesByIndex: Record<number, string>;\n  expression: string;\n}}\n*/\nfunction unmarkEmulationGroups(expression) {\n  const marker = emulationGroupMarker.replace(/\\$/g, '\\\\$');\n  const _captureMap = [{exclude: false}];\n  const _namesByIndex = {0: ''};\n  let realCaptureNum = 0;\n  expression = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.replaceUnescaped)(\n    expression,\n    String.raw`\\((?:(?!\\?)|\\?<(?![=!])(?<name>[^>]+)>)(?<mark>(?:\\$(?<transfer>[1-9]\\d*))?${marker})?`,\n    ({0: m, groups: {name, mark, transfer}}) => {\n      if (mark) {\n        _captureMap.push({\n          exclude: true,\n          transfer: transfer && +transfer,\n        });\n        return m.slice(0, -mark.length);\n      }\n      realCaptureNum++;\n      if (name) {\n        _namesByIndex[realCaptureNum] = name;\n      }\n      _captureMap.push({\n        exclude: false,\n      });\n      return m;\n    },\n    regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT\n  );\n  return {\n    _captureMap,\n    _namesByIndex,\n    expression,\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleEA1LjEuMS9ub2RlX21vZHVsZXMvcmVnZXgvc3JjL3N1YmNsYXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwRDs7QUFFMUQ7QUFDQSwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DLFVBQVUsUUFBUTtBQUNsQixXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkMseUJBQXlCO0FBQ3pCO0FBQ0EsZUFBZSxpRUFBZ0I7QUFDL0I7QUFDQSw0RkFBNEYsT0FBTztBQUNuRyxNQUFNLGVBQWUsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsSUFBSSxvREFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtFIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4QDUuMS4xL25vZGVfbW9kdWxlcy9yZWdleC9zcmMvc3ViY2xhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb250ZXh0LCByZXBsYWNlVW5lc2NhcGVkfSBmcm9tICdyZWdleC11dGlsaXRpZXMnO1xuXG4vLyBUaGlzIG1hcmtlciB3YXMgY2hvc2VuIGJlY2F1c2UgaXQncyBpbXBvc3NpYmxlIHRvIG1hdGNoIChzbyBpdHMgZXh0ZW1lbHkgdW5saWtlbHkgdG8gYmUgdXNlZCBpblxuLy8gYSB1c2VyLXByb3ZpZGVkIHJlZ2V4KTsgaXQncyBub3QgYXQgcmlzayBvZiBiZWluZyBvcHRpbWl6ZWQgYXdheSwgdHJhbnNmb3JtZWQsIG9yIGZsYWdnZWQgYXMgYW5cbi8vIGVycm9yIGJ5IGEgcGx1Z2luOyBhbmQgaXQgZW5kcyB3aXRoIGFuIHVucXVhbnRpZmlhYmxlIHRva2VuXG5jb25zdCBlbXVsYXRpb25Hcm91cE1hcmtlciA9ICckRSQnO1xuLy8gTm90ZTogRW11bGF0aW9uIGdyb3VwcyB3aXRoIHRyYW5zZmVyIGFyZSBhbHNvIHN1cHBvcnRlZC4gVGhleSBsb29rIGxpa2UgYCgkTiRFJOKApilgIHdoZXJlIGBOYCBpc1xuLy8gYW4gaW50ZWdlciAxIG9yIGdyZWF0ZXIuIFRoZXkncmUgbm90IHVzZWQgZGlyZWN0bHkgYnkgUmVnZXgrIGJ1dCBjYW4gYmUgdXNlZCBieSBwbHVnaW5zIGFuZFxuLy8gbGlicmFyaWVzIHRoYXQgdXNlIFJlZ2V4KyBpbnRlcm5hbHMuIEVtdWxhdGlvbiBncm91cHMgd2l0aCB0cmFuc2ZlciBhcmUgbm90IG9ubHkgZXhjbHVkZWQgZnJvbVxuLy8gbWF0Y2ggcmVzdWx0cywgYnV0IGFkZGl0aW9uYWxseSB0cmFuc2ZlciB0aGVpciBtYXRjaCB0byB0aGUgZ3JvdXAgc3BlY2lmaWVkIGJ5IGBOYFxuXG4vKipcbldvcmtzIHRoZSBzYW1lIGFzIEphdmFTY3JpcHQncyBuYXRpdmUgYFJlZ0V4cGAgY29uc3RydWN0b3IgaW4gYWxsIGNvbnRleHRzLCBidXQgYXV0b21hdGljYWxseVxuYWRqdXN0cyBtYXRjaGVzIGFuZCBzdWJwYXR0ZXJuIGluZGljZXMgKHdpdGggZmxhZyBgZGApIHRvIGFjY291bnQgZm9yIGluamVjdGVkIGVtdWxhdGlvbiBncm91cHMuXG4qL1xuY2xhc3MgUmVnRXhwU3ViY2xhc3MgZXh0ZW5kcyBSZWdFeHAge1xuICAvLyBBdm9pZCBgI3ByaXZhdGVgIHRvIGFsbG93IGZvciBzdWJjbGFzc2luZ1xuICAvKipcbiAgQHByaXZhdGVcbiAgQHR5cGUge0FycmF5PHtcbiAgICBleGNsdWRlOiBib29sZWFuO1xuICAgIHRyYW5zZmVyPzogbnVtYmVyO1xuICB9PiB8IHVuZGVmaW5lZH1cbiAgKi9cbiAgX2NhcHR1cmVNYXA7XG4gIC8qKlxuICBAcHJpdmF0ZVxuICBAdHlwZSB7UmVjb3JkPG51bWJlciwgc3RyaW5nPiB8IHVuZGVmaW5lZH1cbiAgKi9cbiAgX25hbWVzQnlJbmRleDtcbiAgLyoqXG4gIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwU3ViY2xhc3N9IGV4cHJlc3Npb25cbiAgQHBhcmFtIHtzdHJpbmd9IFtmbGFnc11cbiAgQHBhcmFtIHt7dXNlRW11bGF0aW9uR3JvdXBzOiBib29sZWFuO319IFtvcHRpb25zXVxuICAqL1xuICBjb25zdHJ1Y3RvcihleHByZXNzaW9uLCBmbGFncywgb3B0aW9ucykge1xuICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgUmVnRXhwICYmIG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHByb3ZpZGUgb3B0aW9ucyB3aGVuIGNvcHlpbmcgYSByZWdleHAnKTtcbiAgICB9XG4gICAgY29uc3QgdXNlRW11bGF0aW9uR3JvdXBzID0gISFvcHRpb25zPy51c2VFbXVsYXRpb25Hcm91cHM7XG4gICAgY29uc3QgdW5tYXJrZWQgPSB1c2VFbXVsYXRpb25Hcm91cHMgPyB1bm1hcmtFbXVsYXRpb25Hcm91cHMoZXhwcmVzc2lvbikgOiBudWxsO1xuICAgIHN1cGVyKHVubWFya2VkPy5leHByZXNzaW9uIHx8IGV4cHJlc3Npb24sIGZsYWdzKTtcbiAgICAvLyBUaGUgdGhpcmQgYXJndW1lbnQgYG9wdGlvbnNgIGlzbid0IHByb3ZpZGVkIHdoZW4gcmVnZXhlcyBhcmUgY29waWVkIGFzIHBhcnQgb2YgdGhlIGludGVybmFsXG4gICAgLy8gaGFuZGxpbmcgb2Ygc3RyaW5nIG1ldGhvZHMgYG1hdGNoQWxsYCBhbmQgYHNwbGl0YFxuICAgIGNvbnN0IHNyYyA9IHVzZUVtdWxhdGlvbkdyb3VwcyA/IHVubWFya2VkIDogKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBSZWdFeHBTdWJjbGFzcyA/IGV4cHJlc3Npb24gOiBudWxsKTtcbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aGlzLl9jYXB0dXJlTWFwID0gc3JjLl9jYXB0dXJlTWFwO1xuICAgICAgdGhpcy5fbmFtZXNCeUluZGV4ID0gc3JjLl9uYW1lc0J5SW5kZXg7XG4gICAgfVxuICB9XG4gIC8qKlxuICBDYWxsZWQgaW50ZXJuYWxseSBieSBhbGwgU3RyaW5nL1JlZ0V4cCBtZXRob2RzIHRoYXQgdXNlIHJlZ2V4ZXMuXG4gIEBvdmVycmlkZVxuICBAcGFyYW0ge3N0cmluZ30gc3RyXG4gIEByZXR1cm5zIHtSZWdFeHBFeGVjQXJyYXkgfCBudWxsfVxuICAqL1xuICBleGVjKHN0cikge1xuICAgIGNvbnN0IG1hdGNoID0gUmVnRXhwLnByb3RvdHlwZS5leGVjLmNhbGwodGhpcywgc3RyKTtcbiAgICBpZiAoIW1hdGNoIHx8ICF0aGlzLl9jYXB0dXJlTWFwKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoQ29weSA9IFsuLi5tYXRjaF07XG4gICAgLy8gRW1wdHkgYWxsIGJ1dCB0aGUgZmlyc3QgdmFsdWUgb2YgdGhlIGFycmF5IHdoaWxlIHByZXNlcnZpbmcgaXRzIG90aGVyIHByb3BlcnRpZXNcbiAgICBtYXRjaC5sZW5ndGggPSAxO1xuICAgIGxldCBpbmRpY2VzQ29weTtcbiAgICBpZiAodGhpcy5oYXNJbmRpY2VzKSB7XG4gICAgICBpbmRpY2VzQ29weSA9IFsuLi5tYXRjaC5pbmRpY2VzXTtcbiAgICAgIG1hdGNoLmluZGljZXMubGVuZ3RoID0gMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRjaENvcHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9jYXB0dXJlTWFwW2ldLmV4Y2x1ZGUpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmZXIgPSB0aGlzLl9jYXB0dXJlTWFwW2ldLnRyYW5zZmVyO1xuICAgICAgICBpZiAodHJhbnNmZXIgJiYgbWF0Y2gubGVuZ3RoID4gdHJhbnNmZXIpIHtcbiAgICAgICAgICBtYXRjaFt0cmFuc2Zlcl0gPSBtYXRjaENvcHlbaV07XG4gICAgICAgICAgY29uc3QgdHJhbnNmZXJOYW1lID0gdGhpcy5fbmFtZXNCeUluZGV4W3RyYW5zZmVyXTtcbiAgICAgICAgICBpZiAodHJhbnNmZXJOYW1lKSB7XG4gICAgICAgICAgICBtYXRjaC5ncm91cHNbdHJhbnNmZXJOYW1lXSA9IG1hdGNoQ29weVtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0luZGljZXMpIHtcbiAgICAgICAgICAgICAgbWF0Y2guaW5kaWNlcy5ncm91cHNbdHJhbnNmZXJOYW1lXSA9IGluZGljZXNDb3B5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5oYXNJbmRpY2VzKSB7XG4gICAgICAgICAgICBtYXRjaC5pbmRpY2VzW3RyYW5zZmVyXSA9IGluZGljZXNDb3B5W2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2gucHVzaChtYXRjaENvcHlbaV0pO1xuICAgICAgICBpZiAodGhpcy5oYXNJbmRpY2VzKSB7XG4gICAgICAgICAgbWF0Y2guaW5kaWNlcy5wdXNoKGluZGljZXNDb3B5W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cbn1cblxuLyoqXG5CdWlsZCB0aGUgY2FwdHVyaW5nIGdyb3VwIG1hcCAod2l0aCBlbXVsYXRpb24gZ3JvdXBzIG1hcmtlZCB0byBpbmRpY2F0ZSB0aGVpciBzdWJtYXRjaGVzIHNob3VsZG4ndFxuYXBwZWFyIGluIHJlc3VsdHMpLCBhbmQgcmVtb3ZlIHRoZSBtYXJrZXJzIGZvciBjYXB0dXJlcyB0aGF0IHdlcmUgYWRkZWQgdG8gZW11bGF0ZSBleHRlbmRlZCBzeW50YXguXG5AcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvblxuQHJldHVybnMge3tcbiAgX2NhcHR1cmVNYXA6IEFycmF5PHtcbiAgICBleGNsdWRlOiBib29sZWFuO1xuICAgIHRyYW5zZmVyPzogbnVtYmVyO1xuICB9PjtcbiAgX25hbWVzQnlJbmRleDogUmVjb3JkPG51bWJlciwgc3RyaW5nPjtcbiAgZXhwcmVzc2lvbjogc3RyaW5nO1xufX1cbiovXG5mdW5jdGlvbiB1bm1hcmtFbXVsYXRpb25Hcm91cHMoZXhwcmVzc2lvbikge1xuICBjb25zdCBtYXJrZXIgPSBlbXVsYXRpb25Hcm91cE1hcmtlci5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJyk7XG4gIGNvbnN0IF9jYXB0dXJlTWFwID0gW3tleGNsdWRlOiBmYWxzZX1dO1xuICBjb25zdCBfbmFtZXNCeUluZGV4ID0gezA6ICcnfTtcbiAgbGV0IHJlYWxDYXB0dXJlTnVtID0gMDtcbiAgZXhwcmVzc2lvbiA9IHJlcGxhY2VVbmVzY2FwZWQoXG4gICAgZXhwcmVzc2lvbixcbiAgICBTdHJpbmcucmF3YFxcKCg/Oig/IVxcPyl8XFw/PCg/IVs9IV0pKD88bmFtZT5bXj5dKyk+KSg/PG1hcms+KD86XFwkKD88dHJhbnNmZXI+WzEtOV1cXGQqKSk/JHttYXJrZXJ9KT9gLFxuICAgICh7MDogbSwgZ3JvdXBzOiB7bmFtZSwgbWFyaywgdHJhbnNmZXJ9fSkgPT4ge1xuICAgICAgaWYgKG1hcmspIHtcbiAgICAgICAgX2NhcHR1cmVNYXAucHVzaCh7XG4gICAgICAgICAgZXhjbHVkZTogdHJ1ZSxcbiAgICAgICAgICB0cmFuc2ZlcjogdHJhbnNmZXIgJiYgK3RyYW5zZmVyLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG0uc2xpY2UoMCwgLW1hcmsubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJlYWxDYXB0dXJlTnVtKys7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBfbmFtZXNCeUluZGV4W3JlYWxDYXB0dXJlTnVtXSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBfY2FwdHVyZU1hcC5wdXNoKHtcbiAgICAgICAgZXhjbHVkZTogZmFsc2UsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtO1xuICAgIH0sXG4gICAgQ29udGV4dC5ERUZBVUxUXG4gICk7XG4gIHJldHVybiB7XG4gICAgX2NhcHR1cmVNYXAsXG4gICAgX25hbWVzQnlJbmRleCxcbiAgICBleHByZXNzaW9uLFxuICB9O1xufVxuXG5leHBvcnQge1xuICBlbXVsYXRpb25Hcm91cE1hcmtlcixcbiAgUmVnRXhwU3ViY2xhc3MsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/subclass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/utils-internals.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/utils-internals.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   noncapturingDelim: () => (/* binding */ noncapturingDelim),\n/* harmony export */   spliceStr: () => (/* binding */ spliceStr)\n/* harmony export */ });\n// Separating some utils for improved tree shaking of the `./internals` export\n\nconst noncapturingDelim = String.raw`\\(\\?(?:[:=!>A-Za-z\\-]|<[=!]|\\(DEFINE\\))`;\n\n/**\n@param {string} str\n@param {number} pos\n@param {string} oldValue\n@param {string} newValue\n@returns {string}\n*/\nfunction spliceStr(str, pos, oldValue, newValue) {\n  return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleEA1LjEuMS9ub2RlX21vZHVsZXMvcmVnZXgvc3JjL3V0aWxzLWludGVybmFscy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVBOztBQUVBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixRQUFRLFFBQVE7QUFDaEIsUUFBUSxRQUFRO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFLRSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9yZWdleEA1LjEuMS9ub2RlX21vZHVsZXMvcmVnZXgvc3JjL3V0aWxzLWludGVybmFscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZXBhcmF0aW5nIHNvbWUgdXRpbHMgZm9yIGltcHJvdmVkIHRyZWUgc2hha2luZyBvZiB0aGUgYC4vaW50ZXJuYWxzYCBleHBvcnRcblxuY29uc3Qgbm9uY2FwdHVyaW5nRGVsaW0gPSBTdHJpbmcucmF3YFxcKFxcPyg/Ols6PSE+QS1aYS16XFwtXXw8Wz0hXXxcXChERUZJTkVcXCkpYDtcblxuLyoqXG5AcGFyYW0ge3N0cmluZ30gc3RyXG5AcGFyYW0ge251bWJlcn0gcG9zXG5AcGFyYW0ge3N0cmluZ30gb2xkVmFsdWVcbkBwYXJhbSB7c3RyaW5nfSBuZXdWYWx1ZVxuQHJldHVybnMge3N0cmluZ31cbiovXG5mdW5jdGlvbiBzcGxpY2VTdHIoc3RyLCBwb3MsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICByZXR1cm4gc3RyLnNsaWNlKDAsIHBvcykgKyBuZXdWYWx1ZSArIHN0ci5zbGljZShwb3MgKyBvbGRWYWx1ZS5sZW5ndGgpO1xufVxuXG5leHBvcnQge1xuICBub25jYXB0dXJpbmdEZWxpbSxcbiAgc3BsaWNlU3RyLFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/regex@5.1.1/node_modules/regex/src/utils-internals.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/bundle-full.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/bundle-full.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FontStyle: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.FontStyle),\n/* harmony export */   ShikiError: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.ShikiError),\n/* harmony export */   StackElementMetadata: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.StackElementMetadata),\n/* harmony export */   addClassToHast: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.addClassToHast),\n/* harmony export */   applyColorReplacements: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.applyColorReplacements),\n/* harmony export */   bundledLanguages: () => (/* reexport safe */ _langs_mjs__WEBPACK_IMPORTED_MODULE_0__.bundledLanguages),\n/* harmony export */   bundledLanguagesAlias: () => (/* reexport safe */ _langs_mjs__WEBPACK_IMPORTED_MODULE_0__.bundledLanguagesAlias),\n/* harmony export */   bundledLanguagesBase: () => (/* reexport safe */ _langs_mjs__WEBPACK_IMPORTED_MODULE_0__.bundledLanguagesBase),\n/* harmony export */   bundledLanguagesInfo: () => (/* reexport safe */ _langs_mjs__WEBPACK_IMPORTED_MODULE_0__.bundledLanguagesInfo),\n/* harmony export */   bundledThemes: () => (/* reexport safe */ _themes_mjs__WEBPACK_IMPORTED_MODULE_1__.bundledThemes),\n/* harmony export */   bundledThemesInfo: () => (/* reexport safe */ _themes_mjs__WEBPACK_IMPORTED_MODULE_1__.bundledThemesInfo),\n/* harmony export */   codeToHast: () => (/* binding */ codeToHast),\n/* harmony export */   codeToHtml: () => (/* binding */ codeToHtml),\n/* harmony export */   codeToTokens: () => (/* binding */ codeToTokens),\n/* harmony export */   codeToTokensBase: () => (/* binding */ codeToTokensBase),\n/* harmony export */   codeToTokensWithThemes: () => (/* binding */ codeToTokensWithThemes),\n/* harmony export */   createCssVariablesTheme: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createCssVariablesTheme),\n/* harmony export */   createHighlighter: () => (/* binding */ createHighlighter),\n/* harmony export */   createHighlighterCore: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createHighlighterCore),\n/* harmony export */   createHighlighterCoreSync: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createHighlighterCoreSync),\n/* harmony export */   createJavaScriptRegexEngine: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createJavaScriptRegexEngine),\n/* harmony export */   createOnigurumaEngine: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createOnigurumaEngine),\n/* harmony export */   createPositionConverter: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createPositionConverter),\n/* harmony export */   createShikiInternal: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createShikiInternal),\n/* harmony export */   createShikiInternalSync: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createShikiInternalSync),\n/* harmony export */   createSingletonShorthands: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createSingletonShorthands),\n/* harmony export */   createWasmOnigEngine: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createWasmOnigEngine),\n/* harmony export */   createdBundledHighlighter: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createdBundledHighlighter),\n/* harmony export */   defaultJavaScriptRegexConstructor: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.defaultJavaScriptRegexConstructor),\n/* harmony export */   enableDeprecationWarnings: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.enableDeprecationWarnings),\n/* harmony export */   getHighlighter: () => (/* binding */ getHighlighter),\n/* harmony export */   getHighlighterCore: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.getHighlighterCore),\n/* harmony export */   getLastGrammarState: () => (/* binding */ getLastGrammarState),\n/* harmony export */   getShikiInternal: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.getShikiInternal),\n/* harmony export */   getSingletonHighlighter: () => (/* binding */ getSingletonHighlighter),\n/* harmony export */   getSingletonHighlighterCore: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.getSingletonHighlighterCore),\n/* harmony export */   getTokenStyleObject: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.getTokenStyleObject),\n/* harmony export */   getWasmInlined: () => (/* reexport safe */ _wasm_dynamic_K7LwWlz7_js__WEBPACK_IMPORTED_MODULE_2__.g),\n/* harmony export */   hastToHtml: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.hastToHtml),\n/* harmony export */   isNoneTheme: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.isNoneTheme),\n/* harmony export */   isPlainLang: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.isPlainLang),\n/* harmony export */   isSpecialLang: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.isSpecialLang),\n/* harmony export */   isSpecialTheme: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.isSpecialTheme),\n/* harmony export */   loadWasm: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.loadWasm),\n/* harmony export */   makeSingletonHighlighter: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.makeSingletonHighlighter),\n/* harmony export */   makeSingletonHighlighterCore: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.makeSingletonHighlighterCore),\n/* harmony export */   normalizeGetter: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.normalizeGetter),\n/* harmony export */   normalizeTheme: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.normalizeTheme),\n/* harmony export */   resolveColorReplacements: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.resolveColorReplacements),\n/* harmony export */   splitLines: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.splitLines),\n/* harmony export */   splitToken: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.splitToken),\n/* harmony export */   splitTokens: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.splitTokens),\n/* harmony export */   stringifyTokenStyle: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.stringifyTokenStyle),\n/* harmony export */   toArray: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.toArray),\n/* harmony export */   tokenizeAnsiWithTheme: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.tokenizeAnsiWithTheme),\n/* harmony export */   tokenizeWithTheme: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.tokenizeWithTheme),\n/* harmony export */   tokensToHast: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.tokensToHast),\n/* harmony export */   transformerDecorations: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.transformerDecorations),\n/* harmony export */   warnDeprecated: () => (/* reexport safe */ _shikijs_core__WEBPACK_IMPORTED_MODULE_3__.warnDeprecated)\n/* harmony export */ });\n/* harmony import */ var _langs_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./langs.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/langs.mjs\");\n/* harmony import */ var _themes_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./themes.mjs */ \"(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/themes.mjs\");\n/* harmony import */ var _wasm_dynamic_K7LwWlz7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wasm-dynamic-K7LwWlz7.js */ \"(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/wasm-dynamic-K7LwWlz7.js\");\n/* harmony import */ var _shikijs_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @shikijs/core */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/index.mjs\");\n/* harmony import */ var _shikijs_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @shikijs/core */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/shared/core.DVV8c4RZ.mjs\");\n/* harmony import */ var _shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @shikijs/engine-oniguruma */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+engine-oniguruma@1.27.0/node_modules/@shikijs/engine-oniguruma/dist/index.mjs\");\n\n\n\n\n\n\n\n\n\nconst createHighlighter = /* @__PURE__ */ (0,_shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createdBundledHighlighter)({\n  langs: _langs_mjs__WEBPACK_IMPORTED_MODULE_0__.bundledLanguages,\n  themes: _themes_mjs__WEBPACK_IMPORTED_MODULE_1__.bundledThemes,\n  engine: () => (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(__webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shiki_1_27_0_node_modules_shiki_dist_wasm_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! shiki/wasm */ \"(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/wasm.mjs\")))\n});\nconst {\n  codeToHtml,\n  codeToHast,\n  codeToTokens,\n  codeToTokensBase,\n  codeToTokensWithThemes,\n  getSingletonHighlighter,\n  getLastGrammarState\n} = /* @__PURE__ */ (0,_shikijs_core__WEBPACK_IMPORTED_MODULE_3__.createSingletonShorthands)(\n  createHighlighter\n);\nconst getHighlighter = (options) => {\n  (0,_shikijs_core__WEBPACK_IMPORTED_MODULE_5__.w)(\"`getHighlighter` is deprecated. Use `createHighlighter` or `getSingletonHighlighter` instead.\");\n  return createHighlighter(options);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGlraUAxLjI3LjAvbm9kZV9tb2R1bGVzL3NoaWtpL2Rpc3QvYnVuZGxlLWZ1bGwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStDO0FBQ2lEO0FBQ25EO0FBQ0k7QUFDZ0I7QUFDb0M7QUFDdkU7QUFDb0M7O0FBRWxFLDBDQUEwQyx3RUFBeUI7QUFDbkUsU0FBUyx3REFBZ0I7QUFDekIsVUFBVSxzREFBYTtBQUN2QixnQkFBZ0IsZ0ZBQXFCLENBQUMsMlJBQW9CO0FBQzFELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxrQkFBa0Isd0VBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQWM7QUFDaEI7QUFDQTs7QUFFNE0iLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vc2hpa2lAMS4yNy4wL25vZGVfbW9kdWxlcy9zaGlraS9kaXN0L2J1bmRsZS1mdWxsLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidW5kbGVkTGFuZ3VhZ2VzIH0gZnJvbSAnLi9sYW5ncy5tanMnO1xuZXhwb3J0IHsgYnVuZGxlZExhbmd1YWdlc0FsaWFzLCBidW5kbGVkTGFuZ3VhZ2VzQmFzZSwgYnVuZGxlZExhbmd1YWdlc0luZm8gfSBmcm9tICcuL2xhbmdzLm1qcyc7XG5pbXBvcnQgeyBidW5kbGVkVGhlbWVzIH0gZnJvbSAnLi90aGVtZXMubWpzJztcbmV4cG9ydCB7IGJ1bmRsZWRUaGVtZXNJbmZvIH0gZnJvbSAnLi90aGVtZXMubWpzJztcbmV4cG9ydCB7IGcgYXMgZ2V0V2FzbUlubGluZWQgfSBmcm9tICcuL3dhc20tZHluYW1pYy1LN0x3V2x6Ny5qcyc7XG5pbXBvcnQgeyBjcmVhdGVkQnVuZGxlZEhpZ2hsaWdodGVyLCBjcmVhdGVTaW5nbGV0b25TaG9ydGhhbmRzLCB3YXJuRGVwcmVjYXRlZCB9IGZyb20gJ0BzaGlraWpzL2NvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHNoaWtpanMvY29yZSc7XG5pbXBvcnQgeyBjcmVhdGVPbmlndXJ1bWFFbmdpbmUgfSBmcm9tICdAc2hpa2lqcy9lbmdpbmUtb25pZ3VydW1hJztcblxuY29uc3QgY3JlYXRlSGlnaGxpZ2h0ZXIgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlZEJ1bmRsZWRIaWdobGlnaHRlcih7XG4gIGxhbmdzOiBidW5kbGVkTGFuZ3VhZ2VzLFxuICB0aGVtZXM6IGJ1bmRsZWRUaGVtZXMsXG4gIGVuZ2luZTogKCkgPT4gY3JlYXRlT25pZ3VydW1hRW5naW5lKGltcG9ydCgnc2hpa2kvd2FzbScpKVxufSk7XG5jb25zdCB7XG4gIGNvZGVUb0h0bWwsXG4gIGNvZGVUb0hhc3QsXG4gIGNvZGVUb1Rva2VucyxcbiAgY29kZVRvVG9rZW5zQmFzZSxcbiAgY29kZVRvVG9rZW5zV2l0aFRoZW1lcyxcbiAgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIsXG4gIGdldExhc3RHcmFtbWFyU3RhdGVcbn0gPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2luZ2xldG9uU2hvcnRoYW5kcyhcbiAgY3JlYXRlSGlnaGxpZ2h0ZXJcbik7XG5jb25zdCBnZXRIaWdobGlnaHRlciA9IChvcHRpb25zKSA9PiB7XG4gIHdhcm5EZXByZWNhdGVkKFwiYGdldEhpZ2hsaWdodGVyYCBpcyBkZXByZWNhdGVkLiBVc2UgYGNyZWF0ZUhpZ2hsaWdodGVyYCBvciBgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXJgIGluc3RlYWQuXCIpO1xuICByZXR1cm4gY3JlYXRlSGlnaGxpZ2h0ZXIob3B0aW9ucyk7XG59O1xuXG5leHBvcnQgeyBidW5kbGVkTGFuZ3VhZ2VzLCBidW5kbGVkVGhlbWVzLCBjb2RlVG9IYXN0LCBjb2RlVG9IdG1sLCBjb2RlVG9Ub2tlbnMsIGNvZGVUb1Rva2Vuc0Jhc2UsIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMsIGNyZWF0ZUhpZ2hsaWdodGVyLCBnZXRIaWdobGlnaHRlciwgZ2V0TGFzdEdyYW1tYXJTdGF0ZSwgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/bundle-full.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/langs.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/langs.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bundledLanguages: () => (/* binding */ bundledLanguages),\n/* harmony export */   bundledLanguagesAlias: () => (/* binding */ bundledLanguagesAlias),\n/* harmony export */   bundledLanguagesBase: () => (/* binding */ bundledLanguagesBase),\n/* harmony export */   bundledLanguagesInfo: () => (/* binding */ bundledLanguagesInfo)\n/* harmony export */ });\nconst bundledLanguagesInfo = [\n  {\n    \"id\": \"abap\",\n    \"name\": \"ABAP\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_abap_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/abap */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/abap.mjs\"))\n  },\n  {\n    \"id\": \"actionscript-3\",\n    \"name\": \"ActionScript\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_act-e4949d\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/actionscript-3 */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/actionscript-3.mjs\"))\n  },\n  {\n    \"id\": \"ada\",\n    \"name\": \"Ada\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ada_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/ada */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/ada.mjs\"))\n  },\n  {\n    \"id\": \"angular-html\",\n    \"name\": \"Angular HTML\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ang-f53c11\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/angular-html */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/angular-html.mjs\"))\n  },\n  {\n    \"id\": \"angular-ts\",\n    \"name\": \"Angular TypeScript\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ang-bee229\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/angular-ts */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/angular-ts.mjs\"))\n  },\n  {\n    \"id\": \"apache\",\n    \"name\": \"Apache Conf\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_apa-d426ca\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/apache */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/apache.mjs\"))\n  },\n  {\n    \"id\": \"apex\",\n    \"name\": \"Apex\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_apex_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/apex */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/apex.mjs\"))\n  },\n  {\n    \"id\": \"apl\",\n    \"name\": \"APL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_apl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/apl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/apl.mjs\"))\n  },\n  {\n    \"id\": \"applescript\",\n    \"name\": \"AppleScript\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_app-5b77a1\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/applescript */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/applescript.mjs\"))\n  },\n  {\n    \"id\": \"ara\",\n    \"name\": \"Ara\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ara_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/ara */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/ara.mjs\"))\n  },\n  {\n    \"id\": \"asciidoc\",\n    \"name\": \"AsciiDoc\",\n    \"aliases\": [\n      \"adoc\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_asc-3d306f\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/asciidoc */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/asciidoc.mjs\"))\n  },\n  {\n    \"id\": \"asm\",\n    \"name\": \"Assembly\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_asm_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/asm */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/asm.mjs\"))\n  },\n  {\n    \"id\": \"astro\",\n    \"name\": \"Astro\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_astro_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/astro */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/astro.mjs\"))\n  },\n  {\n    \"id\": \"awk\",\n    \"name\": \"AWK\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_awk_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/awk */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/awk.mjs\"))\n  },\n  {\n    \"id\": \"ballerina\",\n    \"name\": \"Ballerina\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_bal-954741\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/ballerina */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/ballerina.mjs\"))\n  },\n  {\n    \"id\": \"bat\",\n    \"name\": \"Batch File\",\n    \"aliases\": [\n      \"batch\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_bat_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/bat */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/bat.mjs\"))\n  },\n  {\n    \"id\": \"beancount\",\n    \"name\": \"Beancount\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_bea-d59d53\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/beancount */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/beancount.mjs\"))\n  },\n  {\n    \"id\": \"berry\",\n    \"name\": \"Berry\",\n    \"aliases\": [\n      \"be\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_berry_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/berry */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/berry.mjs\"))\n  },\n  {\n    \"id\": \"bibtex\",\n    \"name\": \"BibTeX\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_bib-ac31ea\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/bibtex */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/bibtex.mjs\"))\n  },\n  {\n    \"id\": \"bicep\",\n    \"name\": \"Bicep\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_bicep_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/bicep */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/bicep.mjs\"))\n  },\n  {\n    \"id\": \"blade\",\n    \"name\": \"Blade\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_blade_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/blade */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/blade.mjs\"))\n  },\n  {\n    \"id\": \"bsl\",\n    \"name\": \"1C (Enterprise)\",\n    \"aliases\": [\n      \"1c\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_bsl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/bsl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/bsl.mjs\"))\n  },\n  {\n    \"id\": \"c\",\n    \"name\": \"C\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_c_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/c */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/c.mjs\"))\n  },\n  {\n    \"id\": \"cadence\",\n    \"name\": \"Cadence\",\n    \"aliases\": [\n      \"cdc\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cad-542281\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/cadence */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/cadence.mjs\"))\n  },\n  {\n    \"id\": \"cairo\",\n    \"name\": \"Cairo\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cairo_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/cairo */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/cairo.mjs\"))\n  },\n  {\n    \"id\": \"clarity\",\n    \"name\": \"Clarity\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cla-512608\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/clarity */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/clarity.mjs\"))\n  },\n  {\n    \"id\": \"clojure\",\n    \"name\": \"Clojure\",\n    \"aliases\": [\n      \"clj\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_clo-dc9965\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/clojure */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/clojure.mjs\"))\n  },\n  {\n    \"id\": \"cmake\",\n    \"name\": \"CMake\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cmake_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/cmake */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/cmake.mjs\"))\n  },\n  {\n    \"id\": \"cobol\",\n    \"name\": \"COBOL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cobol_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/cobol */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/cobol.mjs\"))\n  },\n  {\n    \"id\": \"codeowners\",\n    \"name\": \"CODEOWNERS\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cod-b7a8a3\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/codeowners */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/codeowners.mjs\"))\n  },\n  {\n    \"id\": \"codeql\",\n    \"name\": \"CodeQL\",\n    \"aliases\": [\n      \"ql\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cod-570fd2\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/codeql */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/codeql.mjs\"))\n  },\n  {\n    \"id\": \"coffee\",\n    \"name\": \"CoffeeScript\",\n    \"aliases\": [\n      \"coffeescript\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cof-89cb1f\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/coffee */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/coffee.mjs\"))\n  },\n  {\n    \"id\": \"common-lisp\",\n    \"name\": \"Common Lisp\",\n    \"aliases\": [\n      \"lisp\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_com-4d2dc4\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/common-lisp */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/common-lisp.mjs\"))\n  },\n  {\n    \"id\": \"coq\",\n    \"name\": \"Coq\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_coq_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/coq */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/coq.mjs\"))\n  },\n  {\n    \"id\": \"cpp\",\n    \"name\": \"C++\",\n    \"aliases\": [\n      \"c++\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cpp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/cpp */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/cpp.mjs\"))\n  },\n  {\n    \"id\": \"crystal\",\n    \"name\": \"Crystal\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cry-64267c\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/crystal */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/crystal.mjs\"))\n  },\n  {\n    \"id\": \"csharp\",\n    \"name\": \"C#\",\n    \"aliases\": [\n      \"c#\",\n      \"cs\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_csh-3899fc\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/csharp */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/csharp.mjs\"))\n  },\n  {\n    \"id\": \"css\",\n    \"name\": \"CSS\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_css_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/css */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/css.mjs\"))\n  },\n  {\n    \"id\": \"csv\",\n    \"name\": \"CSV\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_csv_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/csv */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/csv.mjs\"))\n  },\n  {\n    \"id\": \"cue\",\n    \"name\": \"CUE\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cue_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/cue */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/cue.mjs\"))\n  },\n  {\n    \"id\": \"cypher\",\n    \"name\": \"Cypher\",\n    \"aliases\": [\n      \"cql\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_cyp-5d1c88\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/cypher */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/cypher.mjs\"))\n  },\n  {\n    \"id\": \"d\",\n    \"name\": \"D\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_d_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/d */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/d.mjs\"))\n  },\n  {\n    \"id\": \"dart\",\n    \"name\": \"Dart\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_dart_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/dart */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/dart.mjs\"))\n  },\n  {\n    \"id\": \"dax\",\n    \"name\": \"DAX\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_dax_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/dax */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/dax.mjs\"))\n  },\n  {\n    \"id\": \"desktop\",\n    \"name\": \"Desktop\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_des-a57efe\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/desktop */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/desktop.mjs\"))\n  },\n  {\n    \"id\": \"diff\",\n    \"name\": \"Diff\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_diff_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/diff */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/diff.mjs\"))\n  },\n  {\n    \"id\": \"docker\",\n    \"name\": \"Dockerfile\",\n    \"aliases\": [\n      \"dockerfile\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_doc-fc1de7\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/docker */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/docker.mjs\"))\n  },\n  {\n    \"id\": \"dotenv\",\n    \"name\": \"dotEnv\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_dot-019857\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/dotenv */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/dotenv.mjs\"))\n  },\n  {\n    \"id\": \"dream-maker\",\n    \"name\": \"Dream Maker\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_dre-83ae30\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/dream-maker */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/dream-maker.mjs\"))\n  },\n  {\n    \"id\": \"edge\",\n    \"name\": \"Edge\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_edge_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/edge */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/edge.mjs\"))\n  },\n  {\n    \"id\": \"elixir\",\n    \"name\": \"Elixir\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_eli-095150\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/elixir */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/elixir.mjs\"))\n  },\n  {\n    \"id\": \"elm\",\n    \"name\": \"Elm\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_elm_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/elm */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/elm.mjs\"))\n  },\n  {\n    \"id\": \"emacs-lisp\",\n    \"name\": \"Emacs Lisp\",\n    \"aliases\": [\n      \"elisp\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ema-72a98c\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/emacs-lisp */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/emacs-lisp.mjs\"))\n  },\n  {\n    \"id\": \"erb\",\n    \"name\": \"ERB\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_erb_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/erb */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/erb.mjs\"))\n  },\n  {\n    \"id\": \"erlang\",\n    \"name\": \"Erlang\",\n    \"aliases\": [\n      \"erl\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_erl-6f7229\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/erlang */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/erlang.mjs\"))\n  },\n  {\n    \"id\": \"fennel\",\n    \"name\": \"Fennel\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_fen-dfa4d3\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/fennel */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/fennel.mjs\"))\n  },\n  {\n    \"id\": \"fish\",\n    \"name\": \"Fish\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_fish_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/fish */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/fish.mjs\"))\n  },\n  {\n    \"id\": \"fluent\",\n    \"name\": \"Fluent\",\n    \"aliases\": [\n      \"ftl\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_flu-9a098d\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/fluent */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/fluent.mjs\"))\n  },\n  {\n    \"id\": \"fortran-fixed-form\",\n    \"name\": \"Fortran (Fixed Form)\",\n    \"aliases\": [\n      \"f\",\n      \"for\",\n      \"f77\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_for-69c445\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/fortran-fixed-form */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/fortran-fixed-form.mjs\"))\n  },\n  {\n    \"id\": \"fortran-free-form\",\n    \"name\": \"Fortran (Free Form)\",\n    \"aliases\": [\n      \"f90\",\n      \"f95\",\n      \"f03\",\n      \"f08\",\n      \"f18\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_for-f8adfc\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/fortran-free-form */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/fortran-free-form.mjs\"))\n  },\n  {\n    \"id\": \"fsharp\",\n    \"name\": \"F#\",\n    \"aliases\": [\n      \"f#\",\n      \"fs\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_fsh-03d4ef\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/fsharp */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/fsharp.mjs\"))\n  },\n  {\n    \"id\": \"gdresource\",\n    \"name\": \"GDResource\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_gdr-48d426\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/gdresource */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/gdresource.mjs\"))\n  },\n  {\n    \"id\": \"gdscript\",\n    \"name\": \"GDScript\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_gds-2013e6\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/gdscript */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/gdscript.mjs\"))\n  },\n  {\n    \"id\": \"gdshader\",\n    \"name\": \"GDShader\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_gds-f16bce\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/gdshader */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/gdshader.mjs\"))\n  },\n  {\n    \"id\": \"genie\",\n    \"name\": \"Genie\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_genie_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/genie */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/genie.mjs\"))\n  },\n  {\n    \"id\": \"gherkin\",\n    \"name\": \"Gherkin\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ghe-a4f4d9\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/gherkin */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/gherkin.mjs\"))\n  },\n  {\n    \"id\": \"git-commit\",\n    \"name\": \"Git Commit Message\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_git-206536\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/git-commit */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/git-commit.mjs\"))\n  },\n  {\n    \"id\": \"git-rebase\",\n    \"name\": \"Git Rebase Message\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_git-bafce6\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/git-rebase */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/git-rebase.mjs\"))\n  },\n  {\n    \"id\": \"gleam\",\n    \"name\": \"Gleam\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_gleam_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/gleam */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/gleam.mjs\"))\n  },\n  {\n    \"id\": \"glimmer-js\",\n    \"name\": \"Glimmer JS\",\n    \"aliases\": [\n      \"gjs\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_gli-d04844\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/glimmer-js */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/glimmer-js.mjs\"))\n  },\n  {\n    \"id\": \"glimmer-ts\",\n    \"name\": \"Glimmer TS\",\n    \"aliases\": [\n      \"gts\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_gli-a9a6b7\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/glimmer-ts */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/glimmer-ts.mjs\"))\n  },\n  {\n    \"id\": \"glsl\",\n    \"name\": \"GLSL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_glsl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/glsl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/glsl.mjs\"))\n  },\n  {\n    \"id\": \"gnuplot\",\n    \"name\": \"Gnuplot\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_gnu-cff870\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/gnuplot */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/gnuplot.mjs\"))\n  },\n  {\n    \"id\": \"go\",\n    \"name\": \"Go\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_go_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/go */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/go.mjs\"))\n  },\n  {\n    \"id\": \"graphql\",\n    \"name\": \"GraphQL\",\n    \"aliases\": [\n      \"gql\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_gra-84d1a4\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/graphql */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/graphql.mjs\"))\n  },\n  {\n    \"id\": \"groovy\",\n    \"name\": \"Groovy\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_gro-3268d8\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/groovy */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/groovy.mjs\"))\n  },\n  {\n    \"id\": \"hack\",\n    \"name\": \"Hack\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_hack_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/hack */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/hack.mjs\"))\n  },\n  {\n    \"id\": \"haml\",\n    \"name\": \"Ruby Haml\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_haml_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/haml */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/haml.mjs\"))\n  },\n  {\n    \"id\": \"handlebars\",\n    \"name\": \"Handlebars\",\n    \"aliases\": [\n      \"hbs\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_han-f329a0\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/handlebars */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/handlebars.mjs\"))\n  },\n  {\n    \"id\": \"haskell\",\n    \"name\": \"Haskell\",\n    \"aliases\": [\n      \"hs\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_has-68352f\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/haskell */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/haskell.mjs\"))\n  },\n  {\n    \"id\": \"haxe\",\n    \"name\": \"Haxe\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_haxe_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/haxe */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/haxe.mjs\"))\n  },\n  {\n    \"id\": \"hcl\",\n    \"name\": \"HashiCorp HCL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_hcl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/hcl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/hcl.mjs\"))\n  },\n  {\n    \"id\": \"hjson\",\n    \"name\": \"Hjson\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_hjson_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/hjson */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/hjson.mjs\"))\n  },\n  {\n    \"id\": \"hlsl\",\n    \"name\": \"HLSL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_hlsl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/hlsl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/hlsl.mjs\"))\n  },\n  {\n    \"id\": \"html\",\n    \"name\": \"HTML\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_html_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/html */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/html.mjs\"))\n  },\n  {\n    \"id\": \"html-derivative\",\n    \"name\": \"HTML (Derivative)\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_htm-f7b09d\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/html-derivative */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/html-derivative.mjs\"))\n  },\n  {\n    \"id\": \"http\",\n    \"name\": \"HTTP\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_http_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/http */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/http.mjs\"))\n  },\n  {\n    \"id\": \"hxml\",\n    \"name\": \"HXML\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_hxml_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/hxml */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/hxml.mjs\"))\n  },\n  {\n    \"id\": \"hy\",\n    \"name\": \"Hy\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_hy_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/hy */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/hy.mjs\"))\n  },\n  {\n    \"id\": \"imba\",\n    \"name\": \"Imba\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_imba_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/imba */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/imba.mjs\"))\n  },\n  {\n    \"id\": \"ini\",\n    \"name\": \"INI\",\n    \"aliases\": [\n      \"properties\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ini_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/ini */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/ini.mjs\"))\n  },\n  {\n    \"id\": \"java\",\n    \"name\": \"Java\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_java_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/java */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/java.mjs\"))\n  },\n  {\n    \"id\": \"javascript\",\n    \"name\": \"JavaScript\",\n    \"aliases\": [\n      \"js\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_jav-03a5df\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/javascript */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/javascript.mjs\"))\n  },\n  {\n    \"id\": \"jinja\",\n    \"name\": \"Jinja\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_jinja_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/jinja */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/jinja.mjs\"))\n  },\n  {\n    \"id\": \"jison\",\n    \"name\": \"Jison\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_jison_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/jison */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/jison.mjs\"))\n  },\n  {\n    \"id\": \"json\",\n    \"name\": \"JSON\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_json_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/json */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/json.mjs\"))\n  },\n  {\n    \"id\": \"json5\",\n    \"name\": \"JSON5\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_json5_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/json5 */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/json5.mjs\"))\n  },\n  {\n    \"id\": \"jsonc\",\n    \"name\": \"JSON with Comments\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_jsonc_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/jsonc */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/jsonc.mjs\"))\n  },\n  {\n    \"id\": \"jsonl\",\n    \"name\": \"JSON Lines\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_jsonl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/jsonl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/jsonl.mjs\"))\n  },\n  {\n    \"id\": \"jsonnet\",\n    \"name\": \"Jsonnet\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_jso-62b91f\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/jsonnet */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/jsonnet.mjs\"))\n  },\n  {\n    \"id\": \"jssm\",\n    \"name\": \"JSSM\",\n    \"aliases\": [\n      \"fsl\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_jssm_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/jssm */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/jssm.mjs\"))\n  },\n  {\n    \"id\": \"jsx\",\n    \"name\": \"JSX\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_jsx_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/jsx */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/jsx.mjs\"))\n  },\n  {\n    \"id\": \"julia\",\n    \"name\": \"Julia\",\n    \"aliases\": [\n      \"jl\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_julia_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/julia */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/julia.mjs\"))\n  },\n  {\n    \"id\": \"kotlin\",\n    \"name\": \"Kotlin\",\n    \"aliases\": [\n      \"kt\",\n      \"kts\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_kot-6a1d25\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/kotlin */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/kotlin.mjs\"))\n  },\n  {\n    \"id\": \"kusto\",\n    \"name\": \"Kusto\",\n    \"aliases\": [\n      \"kql\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_kusto_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/kusto */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/kusto.mjs\"))\n  },\n  {\n    \"id\": \"latex\",\n    \"name\": \"LaTeX\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_latex_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/latex */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/latex.mjs\"))\n  },\n  {\n    \"id\": \"lean\",\n    \"name\": \"Lean 4\",\n    \"aliases\": [\n      \"lean4\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_lean_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/lean */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/lean.mjs\"))\n  },\n  {\n    \"id\": \"less\",\n    \"name\": \"Less\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_less_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/less */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/less.mjs\"))\n  },\n  {\n    \"id\": \"liquid\",\n    \"name\": \"Liquid\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_liq-c9ec09\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/liquid */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/liquid.mjs\"))\n  },\n  {\n    \"id\": \"log\",\n    \"name\": \"Log file\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_log_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/log */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/log.mjs\"))\n  },\n  {\n    \"id\": \"logo\",\n    \"name\": \"Logo\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_logo_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/logo */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/logo.mjs\"))\n  },\n  {\n    \"id\": \"lua\",\n    \"name\": \"Lua\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_lua_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/lua */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/lua.mjs\"))\n  },\n  {\n    \"id\": \"luau\",\n    \"name\": \"Luau\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_luau_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/luau */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/luau.mjs\"))\n  },\n  {\n    \"id\": \"make\",\n    \"name\": \"Makefile\",\n    \"aliases\": [\n      \"makefile\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_make_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/make */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/make.mjs\"))\n  },\n  {\n    \"id\": \"markdown\",\n    \"name\": \"Markdown\",\n    \"aliases\": [\n      \"md\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_mar-a66371\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/markdown */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/markdown.mjs\"))\n  },\n  {\n    \"id\": \"marko\",\n    \"name\": \"Marko\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_marko_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/marko */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/marko.mjs\"))\n  },\n  {\n    \"id\": \"matlab\",\n    \"name\": \"MATLAB\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_mat-fc9448\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/matlab */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/matlab.mjs\"))\n  },\n  {\n    \"id\": \"mdc\",\n    \"name\": \"MDC\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_mdc_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/mdc */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/mdc.mjs\"))\n  },\n  {\n    \"id\": \"mdx\",\n    \"name\": \"MDX\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_mdx_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/mdx */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/mdx.mjs\"))\n  },\n  {\n    \"id\": \"mermaid\",\n    \"name\": \"Mermaid\",\n    \"aliases\": [\n      \"mmd\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_mer-d96905\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/mermaid */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/mermaid.mjs\"))\n  },\n  {\n    \"id\": \"mipsasm\",\n    \"name\": \"MIPS Assembly\",\n    \"aliases\": [\n      \"mips\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_mip-c597c0\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/mipsasm */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/mipsasm.mjs\"))\n  },\n  {\n    \"id\": \"mojo\",\n    \"name\": \"Mojo\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_mojo_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/mojo */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/mojo.mjs\"))\n  },\n  {\n    \"id\": \"move\",\n    \"name\": \"Move\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_move_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/move */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/move.mjs\"))\n  },\n  {\n    \"id\": \"narrat\",\n    \"name\": \"Narrat Language\",\n    \"aliases\": [\n      \"nar\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_nar-55b0e0\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/narrat */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/narrat.mjs\"))\n  },\n  {\n    \"id\": \"nextflow\",\n    \"name\": \"Nextflow\",\n    \"aliases\": [\n      \"nf\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_nex-0b731c\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/nextflow */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/nextflow.mjs\"))\n  },\n  {\n    \"id\": \"nginx\",\n    \"name\": \"Nginx\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_nginx_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/nginx */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/nginx.mjs\"))\n  },\n  {\n    \"id\": \"nim\",\n    \"name\": \"Nim\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_nim_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/nim */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/nim.mjs\"))\n  },\n  {\n    \"id\": \"nix\",\n    \"name\": \"Nix\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_nix_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/nix */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/nix.mjs\"))\n  },\n  {\n    \"id\": \"nushell\",\n    \"name\": \"nushell\",\n    \"aliases\": [\n      \"nu\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_nus-f331d5\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/nushell */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/nushell.mjs\"))\n  },\n  {\n    \"id\": \"objective-c\",\n    \"name\": \"Objective-C\",\n    \"aliases\": [\n      \"objc\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_obj-0ac30b\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/objective-c */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/objective-c.mjs\"))\n  },\n  {\n    \"id\": \"objective-cpp\",\n    \"name\": \"Objective-C++\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_obj-7e85ae\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/objective-cpp */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/objective-cpp.mjs\"))\n  },\n  {\n    \"id\": \"ocaml\",\n    \"name\": \"OCaml\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ocaml_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/ocaml */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/ocaml.mjs\"))\n  },\n  {\n    \"id\": \"pascal\",\n    \"name\": \"Pascal\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pas-c6e954\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/pascal */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/pascal.mjs\"))\n  },\n  {\n    \"id\": \"perl\",\n    \"name\": \"Perl\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_perl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/perl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/perl.mjs\"))\n  },\n  {\n    \"id\": \"php\",\n    \"name\": \"PHP\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_php_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/php */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/php.mjs\"))\n  },\n  {\n    \"id\": \"plsql\",\n    \"name\": \"PL/SQL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_plsql_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/plsql */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/plsql.mjs\"))\n  },\n  {\n    \"id\": \"po\",\n    \"name\": \"Gettext PO\",\n    \"aliases\": [\n      \"pot\",\n      \"potx\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_po_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/po */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/po.mjs\"))\n  },\n  {\n    \"id\": \"polar\",\n    \"name\": \"Polar\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_polar_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/polar */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/polar.mjs\"))\n  },\n  {\n    \"id\": \"postcss\",\n    \"name\": \"PostCSS\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pos-226d93\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/postcss */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/postcss.mjs\"))\n  },\n  {\n    \"id\": \"powerquery\",\n    \"name\": \"PowerQuery\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pow-110001\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/powerquery */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/powerquery.mjs\"))\n  },\n  {\n    \"id\": \"powershell\",\n    \"name\": \"PowerShell\",\n    \"aliases\": [\n      \"ps\",\n      \"ps1\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pow-143159\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/powershell */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/powershell.mjs\"))\n  },\n  {\n    \"id\": \"prisma\",\n    \"name\": \"Prisma\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pri-6d1642\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/prisma */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/prisma.mjs\"))\n  },\n  {\n    \"id\": \"prolog\",\n    \"name\": \"Prolog\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pro-42dd63\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/prolog */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/prolog.mjs\"))\n  },\n  {\n    \"id\": \"proto\",\n    \"name\": \"Protocol Buffer 3\",\n    \"aliases\": [\n      \"protobuf\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_proto_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/proto */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/proto.mjs\"))\n  },\n  {\n    \"id\": \"pug\",\n    \"name\": \"Pug\",\n    \"aliases\": [\n      \"jade\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pug_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/pug */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/pug.mjs\"))\n  },\n  {\n    \"id\": \"puppet\",\n    \"name\": \"Puppet\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pup-6c216c\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/puppet */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/puppet.mjs\"))\n  },\n  {\n    \"id\": \"purescript\",\n    \"name\": \"PureScript\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pur-7b17a5\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/purescript */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/purescript.mjs\"))\n  },\n  {\n    \"id\": \"python\",\n    \"name\": \"Python\",\n    \"aliases\": [\n      \"py\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_pyt-e86a79\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/python */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/python.mjs\"))\n  },\n  {\n    \"id\": \"qml\",\n    \"name\": \"QML\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_qml_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/qml */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/qml.mjs\"))\n  },\n  {\n    \"id\": \"qmldir\",\n    \"name\": \"QML Directory\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_qml-af16ad\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/qmldir */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/qmldir.mjs\"))\n  },\n  {\n    \"id\": \"qss\",\n    \"name\": \"Qt Style Sheets\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_qss_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/qss */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/qss.mjs\"))\n  },\n  {\n    \"id\": \"r\",\n    \"name\": \"R\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_r_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/r */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/r.mjs\"))\n  },\n  {\n    \"id\": \"racket\",\n    \"name\": \"Racket\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_rac-759dbd\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/racket */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/racket.mjs\"))\n  },\n  {\n    \"id\": \"raku\",\n    \"name\": \"Raku\",\n    \"aliases\": [\n      \"perl6\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_raku_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/raku */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/raku.mjs\"))\n  },\n  {\n    \"id\": \"razor\",\n    \"name\": \"ASP.NET Razor\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_razor_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/razor */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/razor.mjs\"))\n  },\n  {\n    \"id\": \"reg\",\n    \"name\": \"Windows Registry Script\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_reg_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/reg */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/reg.mjs\"))\n  },\n  {\n    \"id\": \"regexp\",\n    \"name\": \"RegExp\",\n    \"aliases\": [\n      \"regex\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_reg-b829db\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/regexp */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/regexp.mjs\"))\n  },\n  {\n    \"id\": \"rel\",\n    \"name\": \"Rel\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_rel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/rel */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/rel.mjs\"))\n  },\n  {\n    \"id\": \"riscv\",\n    \"name\": \"RISC-V\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_riscv_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/riscv */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/riscv.mjs\"))\n  },\n  {\n    \"id\": \"rst\",\n    \"name\": \"reStructuredText\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_rst_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/rst */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/rst.mjs\"))\n  },\n  {\n    \"id\": \"ruby\",\n    \"name\": \"Ruby\",\n    \"aliases\": [\n      \"rb\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ruby_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/ruby */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/ruby.mjs\"))\n  },\n  {\n    \"id\": \"rust\",\n    \"name\": \"Rust\",\n    \"aliases\": [\n      \"rs\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_rust_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/rust */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/rust.mjs\"))\n  },\n  {\n    \"id\": \"sas\",\n    \"name\": \"SAS\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/sas */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/sas.mjs\"))\n  },\n  {\n    \"id\": \"sass\",\n    \"name\": \"Sass\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sass_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/sass */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/sass.mjs\"))\n  },\n  {\n    \"id\": \"scala\",\n    \"name\": \"Scala\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_scala_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/scala */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/scala.mjs\"))\n  },\n  {\n    \"id\": \"scheme\",\n    \"name\": \"Scheme\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sch-2ee3b3\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/scheme */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/scheme.mjs\"))\n  },\n  {\n    \"id\": \"scss\",\n    \"name\": \"SCSS\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_scss_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/scss */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/scss.mjs\"))\n  },\n  {\n    \"id\": \"sdbl\",\n    \"name\": \"1C (Query)\",\n    \"aliases\": [\n      \"1c-query\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sdbl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/sdbl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/sdbl.mjs\"))\n  },\n  {\n    \"id\": \"shaderlab\",\n    \"name\": \"ShaderLab\",\n    \"aliases\": [\n      \"shader\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sha-8444d6\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/shaderlab */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/shaderlab.mjs\"))\n  },\n  {\n    \"id\": \"shellscript\",\n    \"name\": \"Shell\",\n    \"aliases\": [\n      \"bash\",\n      \"sh\",\n      \"shell\",\n      \"zsh\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_she-d268b4\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/shellscript */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/shellscript.mjs\"))\n  },\n  {\n    \"id\": \"shellsession\",\n    \"name\": \"Shell Session\",\n    \"aliases\": [\n      \"console\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_she-bca120\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/shellsession */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/shellsession.mjs\"))\n  },\n  {\n    \"id\": \"smalltalk\",\n    \"name\": \"Smalltalk\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sma-377a62\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/smalltalk */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/smalltalk.mjs\"))\n  },\n  {\n    \"id\": \"solidity\",\n    \"name\": \"Solidity\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sol-5ed025\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/solidity */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/solidity.mjs\"))\n  },\n  {\n    \"id\": \"soy\",\n    \"name\": \"Closure Templates\",\n    \"aliases\": [\n      \"closure-templates\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_soy_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/soy */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/soy.mjs\"))\n  },\n  {\n    \"id\": \"sparql\",\n    \"name\": \"SPARQL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_spa-4b8156\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/sparql */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/sparql.mjs\"))\n  },\n  {\n    \"id\": \"splunk\",\n    \"name\": \"Splunk Query Language\",\n    \"aliases\": [\n      \"spl\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_spl-ac8a7a\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/splunk */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/splunk.mjs\"))\n  },\n  {\n    \"id\": \"sql\",\n    \"name\": \"SQL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sql_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/sql */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/sql.mjs\"))\n  },\n  {\n    \"id\": \"ssh-config\",\n    \"name\": \"SSH Config\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ssh-dc4710\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/ssh-config */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/ssh-config.mjs\"))\n  },\n  {\n    \"id\": \"stata\",\n    \"name\": \"Stata\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_stata_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/stata */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/stata.mjs\"))\n  },\n  {\n    \"id\": \"stylus\",\n    \"name\": \"Stylus\",\n    \"aliases\": [\n      \"styl\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sty-2ed532\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/stylus */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/stylus.mjs\"))\n  },\n  {\n    \"id\": \"svelte\",\n    \"name\": \"Svelte\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sve-8c7eb0\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/svelte */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/svelte.mjs\"))\n  },\n  {\n    \"id\": \"swift\",\n    \"name\": \"Swift\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_swift_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/swift */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/swift.mjs\"))\n  },\n  {\n    \"id\": \"system-verilog\",\n    \"name\": \"SystemVerilog\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sys-f11d65\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/system-verilog */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/system-verilog.mjs\"))\n  },\n  {\n    \"id\": \"systemd\",\n    \"name\": \"Systemd Units\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_sys-4c6b21\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/systemd */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/systemd.mjs\"))\n  },\n  {\n    \"id\": \"talonscript\",\n    \"name\": \"TalonScript\",\n    \"aliases\": [\n      \"talon\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_tal-3b08e9\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/talonscript */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/talonscript.mjs\"))\n  },\n  {\n    \"id\": \"tasl\",\n    \"name\": \"Tasl\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_tasl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/tasl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/tasl.mjs\"))\n  },\n  {\n    \"id\": \"tcl\",\n    \"name\": \"Tcl\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_tcl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/tcl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/tcl.mjs\"))\n  },\n  {\n    \"id\": \"templ\",\n    \"name\": \"Templ\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_templ_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/templ */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/templ.mjs\"))\n  },\n  {\n    \"id\": \"terraform\",\n    \"name\": \"Terraform\",\n    \"aliases\": [\n      \"tf\",\n      \"tfvars\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ter-40f599\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/terraform */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/terraform.mjs\"))\n  },\n  {\n    \"id\": \"tex\",\n    \"name\": \"TeX\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_tex_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/tex */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/tex.mjs\"))\n  },\n  {\n    \"id\": \"toml\",\n    \"name\": \"TOML\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_toml_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/toml */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/toml.mjs\"))\n  },\n  {\n    \"id\": \"ts-tags\",\n    \"name\": \"TypeScript with Tags\",\n    \"aliases\": [\n      \"lit\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ts--8a9d36\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/ts-tags */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/ts-tags.mjs\"))\n  },\n  {\n    \"id\": \"tsv\",\n    \"name\": \"TSV\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_tsv_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/tsv */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/tsv.mjs\"))\n  },\n  {\n    \"id\": \"tsx\",\n    \"name\": \"TSX\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_tsx_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/tsx */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/tsx.mjs\"))\n  },\n  {\n    \"id\": \"turtle\",\n    \"name\": \"Turtle\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_tur-4fc85c\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/turtle */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/turtle.mjs\"))\n  },\n  {\n    \"id\": \"twig\",\n    \"name\": \"Twig\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_twig_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/twig */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/twig.mjs\"))\n  },\n  {\n    \"id\": \"typescript\",\n    \"name\": \"TypeScript\",\n    \"aliases\": [\n      \"ts\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_typ-4a0163\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/typescript */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/typescript.mjs\"))\n  },\n  {\n    \"id\": \"typespec\",\n    \"name\": \"TypeSpec\",\n    \"aliases\": [\n      \"tsp\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_typ-cfb5b2\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/typespec */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/typespec.mjs\"))\n  },\n  {\n    \"id\": \"typst\",\n    \"name\": \"Typst\",\n    \"aliases\": [\n      \"typ\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_typst_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/typst */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/typst.mjs\"))\n  },\n  {\n    \"id\": \"v\",\n    \"name\": \"V\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_v_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/v */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/v.mjs\"))\n  },\n  {\n    \"id\": \"vala\",\n    \"name\": \"Vala\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_vala_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/vala */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/vala.mjs\"))\n  },\n  {\n    \"id\": \"vb\",\n    \"name\": \"Visual Basic\",\n    \"aliases\": [\n      \"cmd\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_vb_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/vb */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/vb.mjs\"))\n  },\n  {\n    \"id\": \"verilog\",\n    \"name\": \"Verilog\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_ver-ba49cd\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/verilog */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/verilog.mjs\"))\n  },\n  {\n    \"id\": \"vhdl\",\n    \"name\": \"VHDL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_vhdl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/vhdl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/vhdl.mjs\"))\n  },\n  {\n    \"id\": \"viml\",\n    \"name\": \"Vim Script\",\n    \"aliases\": [\n      \"vim\",\n      \"vimscript\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_viml_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/viml */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/viml.mjs\"))\n  },\n  {\n    \"id\": \"vue\",\n    \"name\": \"Vue\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_vue_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/vue */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/vue.mjs\"))\n  },\n  {\n    \"id\": \"vue-html\",\n    \"name\": \"Vue HTML\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_vue-ba7b9d\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/vue-html */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/vue-html.mjs\"))\n  },\n  {\n    \"id\": \"vyper\",\n    \"name\": \"Vyper\",\n    \"aliases\": [\n      \"vy\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_vyper_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/vyper */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/vyper.mjs\"))\n  },\n  {\n    \"id\": \"wasm\",\n    \"name\": \"WebAssembly\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_wasm_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/wasm */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/wasm.mjs\"))\n  },\n  {\n    \"id\": \"wenyan\",\n    \"name\": \"Wenyan\",\n    \"aliases\": [\n      \"\\u6587\\u8A00\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_wen-610969\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/wenyan */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/wenyan.mjs\"))\n  },\n  {\n    \"id\": \"wgsl\",\n    \"name\": \"WGSL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_wgsl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/wgsl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/wgsl.mjs\"))\n  },\n  {\n    \"id\": \"wikitext\",\n    \"name\": \"Wikitext\",\n    \"aliases\": [\n      \"mediawiki\",\n      \"wiki\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_wik-2adf7d\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/wikitext */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/wikitext.mjs\"))\n  },\n  {\n    \"id\": \"wolfram\",\n    \"name\": \"Wolfram\",\n    \"aliases\": [\n      \"wl\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_wol-06d2a2\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/wolfram */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/wolfram.mjs\"))\n  },\n  {\n    \"id\": \"xml\",\n    \"name\": \"XML\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_xml_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/xml */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/xml.mjs\"))\n  },\n  {\n    \"id\": \"xsl\",\n    \"name\": \"XSL\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_xsl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/xsl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/xsl.mjs\"))\n  },\n  {\n    \"id\": \"yaml\",\n    \"name\": \"YAML\",\n    \"aliases\": [\n      \"yml\"\n    ],\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_yaml_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/yaml */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/yaml.mjs\"))\n  },\n  {\n    \"id\": \"zenscript\",\n    \"name\": \"ZenScript\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_zen-f996fb\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/zenscript */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/zenscript.mjs\"))\n  },\n  {\n    \"id\": \"zig\",\n    \"name\": \"Zig\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_langs_1_27_0_node_modules_shikijs_langs_dist_zig_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/langs/zig */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+langs@1.27.0/node_modules/@shikijs/langs/dist/zig.mjs\"))\n  }\n];\nconst bundledLanguagesBase = Object.fromEntries(bundledLanguagesInfo.map((i) => [i.id, i.import]));\nconst bundledLanguagesAlias = Object.fromEntries(bundledLanguagesInfo.flatMap((i) => i.aliases?.map((a) => [a, i.import]) || []));\nconst bundledLanguages = {\n  ...bundledLanguagesBase,\n  ...bundledLanguagesAlias\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGlraUAxLjI3LjAvbm9kZV9tb2R1bGVzL3NoaWtpL2Rpc3QvbGFuZ3MubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VkFBdUM7QUFDM0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3VkFBcUM7QUFDekQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvVkFBbUM7QUFDdkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VUFBK0I7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVkFBb0M7QUFDeEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnVkFBaUM7QUFDckQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrVkFBa0M7QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrVkFBa0M7QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VUFBK0I7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2VEFBMEI7QUFDOUMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4VUFBZ0M7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4VUFBZ0M7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4VUFBZ0M7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvVkFBbUM7QUFDdkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VUFBK0I7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VUFBK0I7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVkFBb0M7QUFDeEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4VUFBZ0M7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRVQUErQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1VQUE0QjtBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1VQUE0QjtBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1VQUE0QjtBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRVQUErQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZUQUEwQjtBQUM5QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNVQUE2QjtBQUNqRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1VQUE0QjtBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhVQUFnQztBQUNwRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNVQUE2QjtBQUNqRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRVQUErQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRVQUErQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNWQUFvQztBQUN4RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNVQUE2QjtBQUNqRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRVQUErQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1VQUE0QjtBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9WQUFtQztBQUN2RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1VQUE0QjtBQUNoRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRVQUErQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRVQUErQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNVQUE2QjtBQUNqRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRVQUErQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvV0FBMkM7QUFDL0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtXQUEwQztBQUM5RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb1ZBQW1DO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ1ZBQWlDO0FBQ3JELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ1ZBQWlDO0FBQ3JELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOFVBQWdDO0FBQ3BELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb1ZBQW1DO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb1ZBQW1DO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb1ZBQW1DO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb1ZBQW1DO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOFVBQWdDO0FBQ3BELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ1VBQTJCO0FBQy9DLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOFVBQWdDO0FBQ3BELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb1ZBQW1DO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOFVBQWdDO0FBQ3BELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOFZBQXdDO0FBQzVELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ1VBQTJCO0FBQy9DLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb1ZBQW1DO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOFVBQWdDO0FBQ3BELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VUFBK0I7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VUFBK0I7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnVkFBaUM7QUFDckQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VUFBK0I7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4VUFBZ0M7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4VUFBZ0M7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VUFBK0I7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnVkFBaUM7QUFDckQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4VUFBZ0M7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVkFBb0M7QUFDeEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwVkFBc0M7QUFDMUQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0VUFBK0I7QUFDbkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzVUFBNkI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVUFBNEI7QUFDaEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5VUFBOEI7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdVQUEyQjtBQUMvQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlVQUE4QjtBQUNsRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhVQUFnQztBQUNwRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9WQUFtQztBQUN2RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb1ZBQW1DO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb1ZBQW1DO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNlRBQTBCO0FBQzlDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVVBQThCO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa1ZBQWtDO0FBQ3RELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1ZBQW9DO0FBQ3hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd1ZBQXFDO0FBQ3pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa1ZBQWtDO0FBQ3RELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ1ZBQWlDO0FBQ3JELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNFVBQStCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxv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Q3BELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc1VBQTZCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa1ZBQWtDO0FBQ3RELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVVBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStGIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3NoaWtpQDEuMjcuMC9ub2RlX21vZHVsZXMvc2hpa2kvZGlzdC9sYW5ncy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYnVuZGxlZExhbmd1YWdlc0luZm8gPSBbXG4gIHtcbiAgICBcImlkXCI6IFwiYWJhcFwiLFxuICAgIFwibmFtZVwiOiBcIkFCQVBcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2FiYXAnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImFjdGlvbnNjcmlwdC0zXCIsXG4gICAgXCJuYW1lXCI6IFwiQWN0aW9uU2NyaXB0XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9hY3Rpb25zY3JpcHQtMycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiYWRhXCIsXG4gICAgXCJuYW1lXCI6IFwiQWRhXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9hZGEnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImFuZ3VsYXItaHRtbFwiLFxuICAgIFwibmFtZVwiOiBcIkFuZ3VsYXIgSFRNTFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYW5ndWxhci1odG1sJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJhbmd1bGFyLXRzXCIsXG4gICAgXCJuYW1lXCI6IFwiQW5ndWxhciBUeXBlU2NyaXB0XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9hbmd1bGFyLXRzJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJhcGFjaGVcIixcbiAgICBcIm5hbWVcIjogXCJBcGFjaGUgQ29uZlwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYXBhY2hlJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJhcGV4XCIsXG4gICAgXCJuYW1lXCI6IFwiQXBleFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYXBleCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiYXBsXCIsXG4gICAgXCJuYW1lXCI6IFwiQVBMXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9hcGwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImFwcGxlc2NyaXB0XCIsXG4gICAgXCJuYW1lXCI6IFwiQXBwbGVTY3JpcHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2FwcGxlc2NyaXB0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJhcmFcIixcbiAgICBcIm5hbWVcIjogXCJBcmFcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2FyYScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiYXNjaWlkb2NcIixcbiAgICBcIm5hbWVcIjogXCJBc2NpaURvY1wiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImFkb2NcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9hc2NpaWRvYycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiYXNtXCIsXG4gICAgXCJuYW1lXCI6IFwiQXNzZW1ibHlcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2FzbScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiYXN0cm9cIixcbiAgICBcIm5hbWVcIjogXCJBc3Ryb1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYXN0cm8nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImF3a1wiLFxuICAgIFwibmFtZVwiOiBcIkFXS1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYXdrJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJiYWxsZXJpbmFcIixcbiAgICBcIm5hbWVcIjogXCJCYWxsZXJpbmFcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2JhbGxlcmluYScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiYmF0XCIsXG4gICAgXCJuYW1lXCI6IFwiQmF0Y2ggRmlsZVwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImJhdGNoXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYmF0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJiZWFuY291bnRcIixcbiAgICBcIm5hbWVcIjogXCJCZWFuY291bnRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2JlYW5jb3VudCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiYmVycnlcIixcbiAgICBcIm5hbWVcIjogXCJCZXJyeVwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImJlXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYmVycnknKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImJpYnRleFwiLFxuICAgIFwibmFtZVwiOiBcIkJpYlRlWFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYmlidGV4JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJiaWNlcFwiLFxuICAgIFwibmFtZVwiOiBcIkJpY2VwXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9iaWNlcCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiYmxhZGVcIixcbiAgICBcIm5hbWVcIjogXCJCbGFkZVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYmxhZGUnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImJzbFwiLFxuICAgIFwibmFtZVwiOiBcIjFDIChFbnRlcnByaXNlKVwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcIjFjXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYnNsJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJjXCIsXG4gICAgXCJuYW1lXCI6IFwiQ1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvYycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY2FkZW5jZVwiLFxuICAgIFwibmFtZVwiOiBcIkNhZGVuY2VcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJjZGNcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9jYWRlbmNlJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJjYWlyb1wiLFxuICAgIFwibmFtZVwiOiBcIkNhaXJvXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9jYWlybycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY2xhcml0eVwiLFxuICAgIFwibmFtZVwiOiBcIkNsYXJpdHlcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2NsYXJpdHknKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImNsb2p1cmVcIixcbiAgICBcIm5hbWVcIjogXCJDbG9qdXJlXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiY2xqXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvY2xvanVyZScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY21ha2VcIixcbiAgICBcIm5hbWVcIjogXCJDTWFrZVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvY21ha2UnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImNvYm9sXCIsXG4gICAgXCJuYW1lXCI6IFwiQ09CT0xcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2NvYm9sJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJjb2Rlb3duZXJzXCIsXG4gICAgXCJuYW1lXCI6IFwiQ09ERU9XTkVSU1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvY29kZW93bmVycycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY29kZXFsXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29kZVFMXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwicWxcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9jb2RlcWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImNvZmZlZVwiLFxuICAgIFwibmFtZVwiOiBcIkNvZmZlZVNjcmlwdFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImNvZmZlZXNjcmlwdFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2NvZmZlZScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY29tbW9uLWxpc3BcIixcbiAgICBcIm5hbWVcIjogXCJDb21tb24gTGlzcFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImxpc3BcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9jb21tb24tbGlzcCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY29xXCIsXG4gICAgXCJuYW1lXCI6IFwiQ29xXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9jb3EnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImNwcFwiLFxuICAgIFwibmFtZVwiOiBcIkMrK1wiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImMrK1wiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2NwcCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY3J5c3RhbFwiLFxuICAgIFwibmFtZVwiOiBcIkNyeXN0YWxcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2NyeXN0YWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImNzaGFycFwiLFxuICAgIFwibmFtZVwiOiBcIkMjXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiYyNcIixcbiAgICAgIFwiY3NcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9jc2hhcnAnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImNzc1wiLFxuICAgIFwibmFtZVwiOiBcIkNTU1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvY3NzJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJjc3ZcIixcbiAgICBcIm5hbWVcIjogXCJDU1ZcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2NzdicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY3VlXCIsXG4gICAgXCJuYW1lXCI6IFwiQ1VFXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9jdWUnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImN5cGhlclwiLFxuICAgIFwibmFtZVwiOiBcIkN5cGhlclwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImNxbFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2N5cGhlcicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZFwiLFxuICAgIFwibmFtZVwiOiBcIkRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2QnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImRhcnRcIixcbiAgICBcIm5hbWVcIjogXCJEYXJ0XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9kYXJ0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJkYXhcIixcbiAgICBcIm5hbWVcIjogXCJEQVhcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2RheCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZGVza3RvcFwiLFxuICAgIFwibmFtZVwiOiBcIkRlc2t0b3BcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2Rlc2t0b3AnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImRpZmZcIixcbiAgICBcIm5hbWVcIjogXCJEaWZmXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9kaWZmJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJkb2NrZXJcIixcbiAgICBcIm5hbWVcIjogXCJEb2NrZXJmaWxlXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiZG9ja2VyZmlsZVwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2RvY2tlcicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZG90ZW52XCIsXG4gICAgXCJuYW1lXCI6IFwiZG90RW52XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9kb3RlbnYnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImRyZWFtLW1ha2VyXCIsXG4gICAgXCJuYW1lXCI6IFwiRHJlYW0gTWFrZXJcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2RyZWFtLW1ha2VyJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJlZGdlXCIsXG4gICAgXCJuYW1lXCI6IFwiRWRnZVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZWRnZScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZWxpeGlyXCIsXG4gICAgXCJuYW1lXCI6IFwiRWxpeGlyXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9lbGl4aXInKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImVsbVwiLFxuICAgIFwibmFtZVwiOiBcIkVsbVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZWxtJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJlbWFjcy1saXNwXCIsXG4gICAgXCJuYW1lXCI6IFwiRW1hY3MgTGlzcFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImVsaXNwXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZW1hY3MtbGlzcCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZXJiXCIsXG4gICAgXCJuYW1lXCI6IFwiRVJCXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9lcmInKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImVybGFuZ1wiLFxuICAgIFwibmFtZVwiOiBcIkVybGFuZ1wiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImVybFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2VybGFuZycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZmVubmVsXCIsXG4gICAgXCJuYW1lXCI6IFwiRmVubmVsXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9mZW5uZWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImZpc2hcIixcbiAgICBcIm5hbWVcIjogXCJGaXNoXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9maXNoJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJmbHVlbnRcIixcbiAgICBcIm5hbWVcIjogXCJGbHVlbnRcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJmdGxcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9mbHVlbnQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImZvcnRyYW4tZml4ZWQtZm9ybVwiLFxuICAgIFwibmFtZVwiOiBcIkZvcnRyYW4gKEZpeGVkIEZvcm0pXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiZlwiLFxuICAgICAgXCJmb3JcIixcbiAgICAgIFwiZjc3XCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZm9ydHJhbi1maXhlZC1mb3JtJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJmb3J0cmFuLWZyZWUtZm9ybVwiLFxuICAgIFwibmFtZVwiOiBcIkZvcnRyYW4gKEZyZWUgRm9ybSlcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJmOTBcIixcbiAgICAgIFwiZjk1XCIsXG4gICAgICBcImYwM1wiLFxuICAgICAgXCJmMDhcIixcbiAgICAgIFwiZjE4XCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZm9ydHJhbi1mcmVlLWZvcm0nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImZzaGFycFwiLFxuICAgIFwibmFtZVwiOiBcIkYjXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiZiNcIixcbiAgICAgIFwiZnNcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9mc2hhcnAnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImdkcmVzb3VyY2VcIixcbiAgICBcIm5hbWVcIjogXCJHRFJlc291cmNlXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9nZHJlc291cmNlJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJnZHNjcmlwdFwiLFxuICAgIFwibmFtZVwiOiBcIkdEU2NyaXB0XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9nZHNjcmlwdCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZ2RzaGFkZXJcIixcbiAgICBcIm5hbWVcIjogXCJHRFNoYWRlclwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZ2RzaGFkZXInKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImdlbmllXCIsXG4gICAgXCJuYW1lXCI6IFwiR2VuaWVcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2dlbmllJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJnaGVya2luXCIsXG4gICAgXCJuYW1lXCI6IFwiR2hlcmtpblwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZ2hlcmtpbicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZ2l0LWNvbW1pdFwiLFxuICAgIFwibmFtZVwiOiBcIkdpdCBDb21taXQgTWVzc2FnZVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZ2l0LWNvbW1pdCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZ2l0LXJlYmFzZVwiLFxuICAgIFwibmFtZVwiOiBcIkdpdCBSZWJhc2UgTWVzc2FnZVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZ2l0LXJlYmFzZScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZ2xlYW1cIixcbiAgICBcIm5hbWVcIjogXCJHbGVhbVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZ2xlYW0nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImdsaW1tZXItanNcIixcbiAgICBcIm5hbWVcIjogXCJHbGltbWVyIEpTXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiZ2pzXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZ2xpbW1lci1qcycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZ2xpbW1lci10c1wiLFxuICAgIFwibmFtZVwiOiBcIkdsaW1tZXIgVFNcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJndHNcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9nbGltbWVyLXRzJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJnbHNsXCIsXG4gICAgXCJuYW1lXCI6IFwiR0xTTFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZ2xzbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZ251cGxvdFwiLFxuICAgIFwibmFtZVwiOiBcIkdudXBsb3RcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2dudXBsb3QnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImdvXCIsXG4gICAgXCJuYW1lXCI6IFwiR29cIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2dvJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJncmFwaHFsXCIsXG4gICAgXCJuYW1lXCI6IFwiR3JhcGhRTFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImdxbFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2dyYXBocWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImdyb292eVwiLFxuICAgIFwibmFtZVwiOiBcIkdyb292eVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvZ3Jvb3Z5JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJoYWNrXCIsXG4gICAgXCJuYW1lXCI6IFwiSGFja1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvaGFjaycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiaGFtbFwiLFxuICAgIFwibmFtZVwiOiBcIlJ1YnkgSGFtbFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvaGFtbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiaGFuZGxlYmFyc1wiLFxuICAgIFwibmFtZVwiOiBcIkhhbmRsZWJhcnNcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJoYnNcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9oYW5kbGViYXJzJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJoYXNrZWxsXCIsXG4gICAgXCJuYW1lXCI6IFwiSGFza2VsbFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImhzXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvaGFza2VsbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiaGF4ZVwiLFxuICAgIFwibmFtZVwiOiBcIkhheGVcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2hheGUnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImhjbFwiLFxuICAgIFwibmFtZVwiOiBcIkhhc2hpQ29ycCBIQ0xcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2hjbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiaGpzb25cIixcbiAgICBcIm5hbWVcIjogXCJIanNvblwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvaGpzb24nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImhsc2xcIixcbiAgICBcIm5hbWVcIjogXCJITFNMXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9obHNsJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJodG1sXCIsXG4gICAgXCJuYW1lXCI6IFwiSFRNTFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvaHRtbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiaHRtbC1kZXJpdmF0aXZlXCIsXG4gICAgXCJuYW1lXCI6IFwiSFRNTCAoRGVyaXZhdGl2ZSlcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2h0bWwtZGVyaXZhdGl2ZScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiaHR0cFwiLFxuICAgIFwibmFtZVwiOiBcIkhUVFBcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2h0dHAnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImh4bWxcIixcbiAgICBcIm5hbWVcIjogXCJIWE1MXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9oeG1sJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJoeVwiLFxuICAgIFwibmFtZVwiOiBcIkh5XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9oeScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiaW1iYVwiLFxuICAgIFwibmFtZVwiOiBcIkltYmFcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2ltYmEnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImluaVwiLFxuICAgIFwibmFtZVwiOiBcIklOSVwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcInByb3BlcnRpZXNcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9pbmknKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImphdmFcIixcbiAgICBcIm5hbWVcIjogXCJKYXZhXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9qYXZhJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJqYXZhc2NyaXB0XCIsXG4gICAgXCJuYW1lXCI6IFwiSmF2YVNjcmlwdFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImpzXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvamF2YXNjcmlwdCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiamluamFcIixcbiAgICBcIm5hbWVcIjogXCJKaW5qYVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvamluamEnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImppc29uXCIsXG4gICAgXCJuYW1lXCI6IFwiSmlzb25cIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2ppc29uJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJqc29uXCIsXG4gICAgXCJuYW1lXCI6IFwiSlNPTlwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvanNvbicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwianNvbjVcIixcbiAgICBcIm5hbWVcIjogXCJKU09ONVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvanNvbjUnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImpzb25jXCIsXG4gICAgXCJuYW1lXCI6IFwiSlNPTiB3aXRoIENvbW1lbnRzXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9qc29uYycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwianNvbmxcIixcbiAgICBcIm5hbWVcIjogXCJKU09OIExpbmVzXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9qc29ubCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwianNvbm5ldFwiLFxuICAgIFwibmFtZVwiOiBcIkpzb25uZXRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2pzb25uZXQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImpzc21cIixcbiAgICBcIm5hbWVcIjogXCJKU1NNXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiZnNsXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvanNzbScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwianN4XCIsXG4gICAgXCJuYW1lXCI6IFwiSlNYXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9qc3gnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImp1bGlhXCIsXG4gICAgXCJuYW1lXCI6IFwiSnVsaWFcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJqbFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2p1bGlhJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJrb3RsaW5cIixcbiAgICBcIm5hbWVcIjogXCJLb3RsaW5cIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJrdFwiLFxuICAgICAgXCJrdHNcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9rb3RsaW4nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImt1c3RvXCIsXG4gICAgXCJuYW1lXCI6IFwiS3VzdG9cIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJrcWxcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9rdXN0bycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibGF0ZXhcIixcbiAgICBcIm5hbWVcIjogXCJMYVRlWFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvbGF0ZXgnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImxlYW5cIixcbiAgICBcIm5hbWVcIjogXCJMZWFuIDRcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJsZWFuNFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2xlYW4nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImxlc3NcIixcbiAgICBcIm5hbWVcIjogXCJMZXNzXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9sZXNzJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJsaXF1aWRcIixcbiAgICBcIm5hbWVcIjogXCJMaXF1aWRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2xpcXVpZCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibG9nXCIsXG4gICAgXCJuYW1lXCI6IFwiTG9nIGZpbGVcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2xvZycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibG9nb1wiLFxuICAgIFwibmFtZVwiOiBcIkxvZ29cIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL2xvZ28nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImx1YVwiLFxuICAgIFwibmFtZVwiOiBcIkx1YVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvbHVhJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJsdWF1XCIsXG4gICAgXCJuYW1lXCI6IFwiTHVhdVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvbHVhdScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibWFrZVwiLFxuICAgIFwibmFtZVwiOiBcIk1ha2VmaWxlXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwibWFrZWZpbGVcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9tYWtlJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJtYXJrZG93blwiLFxuICAgIFwibmFtZVwiOiBcIk1hcmtkb3duXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwibWRcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9tYXJrZG93bicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibWFya29cIixcbiAgICBcIm5hbWVcIjogXCJNYXJrb1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvbWFya28nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm1hdGxhYlwiLFxuICAgIFwibmFtZVwiOiBcIk1BVExBQlwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvbWF0bGFiJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJtZGNcIixcbiAgICBcIm5hbWVcIjogXCJNRENcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL21kYycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibWR4XCIsXG4gICAgXCJuYW1lXCI6IFwiTURYXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9tZHgnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm1lcm1haWRcIixcbiAgICBcIm5hbWVcIjogXCJNZXJtYWlkXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwibW1kXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvbWVybWFpZCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibWlwc2FzbVwiLFxuICAgIFwibmFtZVwiOiBcIk1JUFMgQXNzZW1ibHlcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJtaXBzXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvbWlwc2FzbScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibW9qb1wiLFxuICAgIFwibmFtZVwiOiBcIk1vam9cIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL21vam8nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm1vdmVcIixcbiAgICBcIm5hbWVcIjogXCJNb3ZlXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9tb3ZlJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJuYXJyYXRcIixcbiAgICBcIm5hbWVcIjogXCJOYXJyYXQgTGFuZ3VhZ2VcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJuYXJcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9uYXJyYXQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm5leHRmbG93XCIsXG4gICAgXCJuYW1lXCI6IFwiTmV4dGZsb3dcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJuZlwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL25leHRmbG93JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJuZ2lueFwiLFxuICAgIFwibmFtZVwiOiBcIk5naW54XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9uZ2lueCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibmltXCIsXG4gICAgXCJuYW1lXCI6IFwiTmltXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9uaW0nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm5peFwiLFxuICAgIFwibmFtZVwiOiBcIk5peFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3Mvbml4JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJudXNoZWxsXCIsXG4gICAgXCJuYW1lXCI6IFwibnVzaGVsbFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcIm51XCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvbnVzaGVsbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwib2JqZWN0aXZlLWNcIixcbiAgICBcIm5hbWVcIjogXCJPYmplY3RpdmUtQ1wiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcIm9iamNcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9vYmplY3RpdmUtYycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwib2JqZWN0aXZlLWNwcFwiLFxuICAgIFwibmFtZVwiOiBcIk9iamVjdGl2ZS1DKytcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL29iamVjdGl2ZS1jcHAnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm9jYW1sXCIsXG4gICAgXCJuYW1lXCI6IFwiT0NhbWxcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL29jYW1sJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJwYXNjYWxcIixcbiAgICBcIm5hbWVcIjogXCJQYXNjYWxcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3Bhc2NhbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicGVybFwiLFxuICAgIFwibmFtZVwiOiBcIlBlcmxcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3BlcmwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInBocFwiLFxuICAgIFwibmFtZVwiOiBcIlBIUFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvcGhwJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJwbHNxbFwiLFxuICAgIFwibmFtZVwiOiBcIlBML1NRTFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvcGxzcWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInBvXCIsXG4gICAgXCJuYW1lXCI6IFwiR2V0dGV4dCBQT1wiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcInBvdFwiLFxuICAgICAgXCJwb3R4XCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvcG8nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInBvbGFyXCIsXG4gICAgXCJuYW1lXCI6IFwiUG9sYXJcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3BvbGFyJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJwb3N0Y3NzXCIsXG4gICAgXCJuYW1lXCI6IFwiUG9zdENTU1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvcG9zdGNzcycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicG93ZXJxdWVyeVwiLFxuICAgIFwibmFtZVwiOiBcIlBvd2VyUXVlcnlcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3Bvd2VycXVlcnknKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInBvd2Vyc2hlbGxcIixcbiAgICBcIm5hbWVcIjogXCJQb3dlclNoZWxsXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwicHNcIixcbiAgICAgIFwicHMxXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvcG93ZXJzaGVsbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicHJpc21hXCIsXG4gICAgXCJuYW1lXCI6IFwiUHJpc21hXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9wcmlzbWEnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInByb2xvZ1wiLFxuICAgIFwibmFtZVwiOiBcIlByb2xvZ1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvcHJvbG9nJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJwcm90b1wiLFxuICAgIFwibmFtZVwiOiBcIlByb3RvY29sIEJ1ZmZlciAzXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwicHJvdG9idWZcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9wcm90bycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicHVnXCIsXG4gICAgXCJuYW1lXCI6IFwiUHVnXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiamFkZVwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3B1ZycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicHVwcGV0XCIsXG4gICAgXCJuYW1lXCI6IFwiUHVwcGV0XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9wdXBwZXQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInB1cmVzY3JpcHRcIixcbiAgICBcIm5hbWVcIjogXCJQdXJlU2NyaXB0XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9wdXJlc2NyaXB0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJweXRob25cIixcbiAgICBcIm5hbWVcIjogXCJQeXRob25cIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJweVwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3B5dGhvbicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicW1sXCIsXG4gICAgXCJuYW1lXCI6IFwiUU1MXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9xbWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInFtbGRpclwiLFxuICAgIFwibmFtZVwiOiBcIlFNTCBEaXJlY3RvcnlcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3FtbGRpcicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicXNzXCIsXG4gICAgXCJuYW1lXCI6IFwiUXQgU3R5bGUgU2hlZXRzXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9xc3MnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInJcIixcbiAgICBcIm5hbWVcIjogXCJSXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9yJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJyYWNrZXRcIixcbiAgICBcIm5hbWVcIjogXCJSYWNrZXRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3JhY2tldCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicmFrdVwiLFxuICAgIFwibmFtZVwiOiBcIlJha3VcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJwZXJsNlwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3Jha3UnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInJhem9yXCIsXG4gICAgXCJuYW1lXCI6IFwiQVNQLk5FVCBSYXpvclwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvcmF6b3InKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInJlZ1wiLFxuICAgIFwibmFtZVwiOiBcIldpbmRvd3MgUmVnaXN0cnkgU2NyaXB0XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9yZWcnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInJlZ2V4cFwiLFxuICAgIFwibmFtZVwiOiBcIlJlZ0V4cFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcInJlZ2V4XCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvcmVnZXhwJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJyZWxcIixcbiAgICBcIm5hbWVcIjogXCJSZWxcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3JlbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicmlzY3ZcIixcbiAgICBcIm5hbWVcIjogXCJSSVNDLVZcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3Jpc2N2JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJyc3RcIixcbiAgICBcIm5hbWVcIjogXCJyZVN0cnVjdHVyZWRUZXh0XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9yc3QnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInJ1YnlcIixcbiAgICBcIm5hbWVcIjogXCJSdWJ5XCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwicmJcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9ydWJ5JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJydXN0XCIsXG4gICAgXCJuYW1lXCI6IFwiUnVzdFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcInJzXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvcnVzdCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic2FzXCIsXG4gICAgXCJuYW1lXCI6IFwiU0FTXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zYXMnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInNhc3NcIixcbiAgICBcIm5hbWVcIjogXCJTYXNzXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zYXNzJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzY2FsYVwiLFxuICAgIFwibmFtZVwiOiBcIlNjYWxhXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zY2FsYScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic2NoZW1lXCIsXG4gICAgXCJuYW1lXCI6IFwiU2NoZW1lXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zY2hlbWUnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInNjc3NcIixcbiAgICBcIm5hbWVcIjogXCJTQ1NTXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zY3NzJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzZGJsXCIsXG4gICAgXCJuYW1lXCI6IFwiMUMgKFF1ZXJ5KVwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcIjFjLXF1ZXJ5XCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3Mvc2RibCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic2hhZGVybGFiXCIsXG4gICAgXCJuYW1lXCI6IFwiU2hhZGVyTGFiXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwic2hhZGVyXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3Mvc2hhZGVybGFiJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzaGVsbHNjcmlwdFwiLFxuICAgIFwibmFtZVwiOiBcIlNoZWxsXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiYmFzaFwiLFxuICAgICAgXCJzaFwiLFxuICAgICAgXCJzaGVsbFwiLFxuICAgICAgXCJ6c2hcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zaGVsbHNjcmlwdCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic2hlbGxzZXNzaW9uXCIsXG4gICAgXCJuYW1lXCI6IFwiU2hlbGwgU2Vzc2lvblwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcImNvbnNvbGVcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zaGVsbHNlc3Npb24nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInNtYWxsdGFsa1wiLFxuICAgIFwibmFtZVwiOiBcIlNtYWxsdGFsa1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3Mvc21hbGx0YWxrJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzb2xpZGl0eVwiLFxuICAgIFwibmFtZVwiOiBcIlNvbGlkaXR5XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zb2xpZGl0eScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic295XCIsXG4gICAgXCJuYW1lXCI6IFwiQ2xvc3VyZSBUZW1wbGF0ZXNcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJjbG9zdXJlLXRlbXBsYXRlc1wiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3NveScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic3BhcnFsXCIsXG4gICAgXCJuYW1lXCI6IFwiU1BBUlFMXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zcGFycWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInNwbHVua1wiLFxuICAgIFwibmFtZVwiOiBcIlNwbHVuayBRdWVyeSBMYW5ndWFnZVwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcInNwbFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3NwbHVuaycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic3FsXCIsXG4gICAgXCJuYW1lXCI6IFwiU1FMXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zcWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInNzaC1jb25maWdcIixcbiAgICBcIm5hbWVcIjogXCJTU0ggQ29uZmlnXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zc2gtY29uZmlnJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzdGF0YVwiLFxuICAgIFwibmFtZVwiOiBcIlN0YXRhXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zdGF0YScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic3R5bHVzXCIsXG4gICAgXCJuYW1lXCI6IFwiU3R5bHVzXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwic3R5bFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3N0eWx1cycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic3ZlbHRlXCIsXG4gICAgXCJuYW1lXCI6IFwiU3ZlbHRlXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy9zdmVsdGUnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInN3aWZ0XCIsXG4gICAgXCJuYW1lXCI6IFwiU3dpZnRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3N3aWZ0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzeXN0ZW0tdmVyaWxvZ1wiLFxuICAgIFwibmFtZVwiOiBcIlN5c3RlbVZlcmlsb2dcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3N5c3RlbS12ZXJpbG9nJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzeXN0ZW1kXCIsXG4gICAgXCJuYW1lXCI6IFwiU3lzdGVtZCBVbml0c1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3Mvc3lzdGVtZCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidGFsb25zY3JpcHRcIixcbiAgICBcIm5hbWVcIjogXCJUYWxvblNjcmlwdFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcInRhbG9uXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvdGFsb25zY3JpcHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInRhc2xcIixcbiAgICBcIm5hbWVcIjogXCJUYXNsXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy90YXNsJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ0Y2xcIixcbiAgICBcIm5hbWVcIjogXCJUY2xcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3RjbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidGVtcGxcIixcbiAgICBcIm5hbWVcIjogXCJUZW1wbFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvdGVtcGwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInRlcnJhZm9ybVwiLFxuICAgIFwibmFtZVwiOiBcIlRlcnJhZm9ybVwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcInRmXCIsXG4gICAgICBcInRmdmFyc1wiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3RlcnJhZm9ybScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidGV4XCIsXG4gICAgXCJuYW1lXCI6IFwiVGVYXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy90ZXgnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInRvbWxcIixcbiAgICBcIm5hbWVcIjogXCJUT01MXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy90b21sJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ0cy10YWdzXCIsXG4gICAgXCJuYW1lXCI6IFwiVHlwZVNjcmlwdCB3aXRoIFRhZ3NcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJsaXRcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy90cy10YWdzJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ0c3ZcIixcbiAgICBcIm5hbWVcIjogXCJUU1ZcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3RzdicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidHN4XCIsXG4gICAgXCJuYW1lXCI6IFwiVFNYXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy90c3gnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInR1cnRsZVwiLFxuICAgIFwibmFtZVwiOiBcIlR1cnRsZVwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvdHVydGxlJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ0d2lnXCIsXG4gICAgXCJuYW1lXCI6IFwiVHdpZ1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvdHdpZycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidHlwZXNjcmlwdFwiLFxuICAgIFwibmFtZVwiOiBcIlR5cGVTY3JpcHRcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJ0c1wiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3R5cGVzY3JpcHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInR5cGVzcGVjXCIsXG4gICAgXCJuYW1lXCI6IFwiVHlwZVNwZWNcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJ0c3BcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy90eXBlc3BlYycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidHlwc3RcIixcbiAgICBcIm5hbWVcIjogXCJUeXBzdFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcInR5cFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3R5cHN0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ2XCIsXG4gICAgXCJuYW1lXCI6IFwiVlwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvdicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidmFsYVwiLFxuICAgIFwibmFtZVwiOiBcIlZhbGFcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3ZhbGEnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInZiXCIsXG4gICAgXCJuYW1lXCI6IFwiVmlzdWFsIEJhc2ljXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwiY21kXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvdmInKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInZlcmlsb2dcIixcbiAgICBcIm5hbWVcIjogXCJWZXJpbG9nXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy92ZXJpbG9nJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ2aGRsXCIsXG4gICAgXCJuYW1lXCI6IFwiVkhETFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvdmhkbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidmltbFwiLFxuICAgIFwibmFtZVwiOiBcIlZpbSBTY3JpcHRcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJ2aW1cIixcbiAgICAgIFwidmltc2NyaXB0XCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvdmltbCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidnVlXCIsXG4gICAgXCJuYW1lXCI6IFwiVnVlXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy92dWUnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInZ1ZS1odG1sXCIsXG4gICAgXCJuYW1lXCI6IFwiVnVlIEhUTUxcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3Z1ZS1odG1sJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ2eXBlclwiLFxuICAgIFwibmFtZVwiOiBcIlZ5cGVyXCIsXG4gICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgIFwidnlcIlxuICAgIF0sXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy92eXBlcicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwid2FzbVwiLFxuICAgIFwibmFtZVwiOiBcIldlYkFzc2VtYmx5XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy93YXNtJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ3ZW55YW5cIixcbiAgICBcIm5hbWVcIjogXCJXZW55YW5cIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJcXHU2NTg3XFx1OEEwMFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3dlbnlhbicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwid2dzbFwiLFxuICAgIFwibmFtZVwiOiBcIldHU0xcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3dnc2wnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIndpa2l0ZXh0XCIsXG4gICAgXCJuYW1lXCI6IFwiV2lraXRleHRcIixcbiAgICBcImFsaWFzZXNcIjogW1xuICAgICAgXCJtZWRpYXdpa2lcIixcbiAgICAgIFwid2lraVwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3dpa2l0ZXh0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ3b2xmcmFtXCIsXG4gICAgXCJuYW1lXCI6IFwiV29sZnJhbVwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcIndsXCJcbiAgICBdLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3Mvd29sZnJhbScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwieG1sXCIsXG4gICAgXCJuYW1lXCI6IFwiWE1MXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy9sYW5ncy94bWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInhzbFwiLFxuICAgIFwibmFtZVwiOiBcIlhTTFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MveHNsJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ5YW1sXCIsXG4gICAgXCJuYW1lXCI6IFwiWUFNTFwiLFxuICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICBcInltbFwiXG4gICAgXSxcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3lhbWwnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInplbnNjcmlwdFwiLFxuICAgIFwibmFtZVwiOiBcIlplblNjcmlwdFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvbGFuZ3MvemVuc2NyaXB0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ6aWdcIixcbiAgICBcIm5hbWVcIjogXCJaaWdcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL2xhbmdzL3ppZycpXG4gIH1cbl07XG5jb25zdCBidW5kbGVkTGFuZ3VhZ2VzQmFzZSA9IE9iamVjdC5mcm9tRW50cmllcyhidW5kbGVkTGFuZ3VhZ2VzSW5mby5tYXAoKGkpID0+IFtpLmlkLCBpLmltcG9ydF0pKTtcbmNvbnN0IGJ1bmRsZWRMYW5ndWFnZXNBbGlhcyA9IE9iamVjdC5mcm9tRW50cmllcyhidW5kbGVkTGFuZ3VhZ2VzSW5mby5mbGF0TWFwKChpKSA9PiBpLmFsaWFzZXM/Lm1hcCgoYSkgPT4gW2EsIGkuaW1wb3J0XSkgfHwgW10pKTtcbmNvbnN0IGJ1bmRsZWRMYW5ndWFnZXMgPSB7XG4gIC4uLmJ1bmRsZWRMYW5ndWFnZXNCYXNlLFxuICAuLi5idW5kbGVkTGFuZ3VhZ2VzQWxpYXNcbn07XG5cbmV4cG9ydCB7IGJ1bmRsZWRMYW5ndWFnZXMsIGJ1bmRsZWRMYW5ndWFnZXNBbGlhcywgYnVuZGxlZExhbmd1YWdlc0Jhc2UsIGJ1bmRsZWRMYW5ndWFnZXNJbmZvIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/langs.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/themes.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/themes.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bundledThemes: () => (/* binding */ bundledThemes),\n/* harmony export */   bundledThemesInfo: () => (/* binding */ bundledThemesInfo)\n/* harmony export */ });\nconst bundledThemesInfo = [\n  {\n    \"id\": \"andromeeda\",\n    \"displayName\": \"Andromeeda\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_a-4b0020\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/andromeeda */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/andromeeda.mjs\"))\n  },\n  {\n    \"id\": \"aurora-x\",\n    \"displayName\": \"Aurora X\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_a-947540\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/aurora-x */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/aurora-x.mjs\"))\n  },\n  {\n    \"id\": \"ayu-dark\",\n    \"displayName\": \"Ayu Dark\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_a-1d386f\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/ayu-dark */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/ayu-dark.mjs\"))\n  },\n  {\n    \"id\": \"catppuccin-frappe\",\n    \"displayName\": \"Catppuccin Frapp\\xE9\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_c-1f9f9e\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/catppuccin-frappe */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/catppuccin-frappe.mjs\"))\n  },\n  {\n    \"id\": \"catppuccin-latte\",\n    \"displayName\": \"Catppuccin Latte\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_c-8e43e0\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/catppuccin-latte */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/catppuccin-latte.mjs\"))\n  },\n  {\n    \"id\": \"catppuccin-macchiato\",\n    \"displayName\": \"Catppuccin Macchiato\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_c-b5568d\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/catppuccin-macchiato */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/catppuccin-macchiato.mjs\"))\n  },\n  {\n    \"id\": \"catppuccin-mocha\",\n    \"displayName\": \"Catppuccin Mocha\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_c-cc596a\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/catppuccin-mocha */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/catppuccin-mocha.mjs\"))\n  },\n  {\n    \"id\": \"dark-plus\",\n    \"displayName\": \"Dark Plus\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_d-425931\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/dark-plus */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/dark-plus.mjs\"))\n  },\n  {\n    \"id\": \"dracula\",\n    \"displayName\": \"Dracula Theme\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_d-138e38\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/dracula */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/dracula.mjs\"))\n  },\n  {\n    \"id\": \"dracula-soft\",\n    \"displayName\": \"Dracula Theme Soft\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_d-4214f6\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/dracula-soft */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/dracula-soft.mjs\"))\n  },\n  {\n    \"id\": \"everforest-dark\",\n    \"displayName\": \"Everforest Dark\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_e-164cb7\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/everforest-dark */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/everforest-dark.mjs\"))\n  },\n  {\n    \"id\": \"everforest-light\",\n    \"displayName\": \"Everforest Light\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_e-033b9c\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/everforest-light */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/everforest-light.mjs\"))\n  },\n  {\n    \"id\": \"github-dark\",\n    \"displayName\": \"GitHub Dark\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_g-ff3745\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/github-dark */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/github-dark.mjs\"))\n  },\n  {\n    \"id\": \"github-dark-default\",\n    \"displayName\": \"GitHub Dark Default\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_g-d88a89\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/github-dark-default */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/github-dark-default.mjs\"))\n  },\n  {\n    \"id\": \"github-dark-dimmed\",\n    \"displayName\": \"GitHub Dark Dimmed\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_g-e522bb\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/github-dark-dimmed */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/github-dark-dimmed.mjs\"))\n  },\n  {\n    \"id\": \"github-dark-high-contrast\",\n    \"displayName\": \"GitHub Dark High Contrast\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_g-a5aa6d\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/github-dark-high-contrast */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/github-dark-high-contrast.mjs\"))\n  },\n  {\n    \"id\": \"github-light\",\n    \"displayName\": \"GitHub Light\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_g-5373ab\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/github-light */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/github-light.mjs\"))\n  },\n  {\n    \"id\": \"github-light-default\",\n    \"displayName\": \"GitHub Light Default\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_g-b297af\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/github-light-default */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/github-light-default.mjs\"))\n  },\n  {\n    \"id\": \"github-light-high-contrast\",\n    \"displayName\": \"GitHub Light High Contrast\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_g-4597ec\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/github-light-high-contrast */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/github-light-high-contrast.mjs\"))\n  },\n  {\n    \"id\": \"houston\",\n    \"displayName\": \"Houston\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_h-98fb8a\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/houston */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/houston.mjs\"))\n  },\n  {\n    \"id\": \"kanagawa-dragon\",\n    \"displayName\": \"Kanagawa Dragon\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_k-1799e7\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/kanagawa-dragon */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/kanagawa-dragon.mjs\"))\n  },\n  {\n    \"id\": \"kanagawa-lotus\",\n    \"displayName\": \"Kanagawa Lotus\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_k-c0b5a3\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/kanagawa-lotus */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/kanagawa-lotus.mjs\"))\n  },\n  {\n    \"id\": \"kanagawa-wave\",\n    \"displayName\": \"Kanagawa Wave\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_k-fc7905\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/kanagawa-wave */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/kanagawa-wave.mjs\"))\n  },\n  {\n    \"id\": \"laserwave\",\n    \"displayName\": \"LaserWave\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_l-707eba\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/laserwave */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/laserwave.mjs\"))\n  },\n  {\n    \"id\": \"light-plus\",\n    \"displayName\": \"Light Plus\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_l-1cb276\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/light-plus */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/light-plus.mjs\"))\n  },\n  {\n    \"id\": \"material-theme\",\n    \"displayName\": \"Material Theme\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_m-7c0ac5\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/material-theme */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/material-theme.mjs\"))\n  },\n  {\n    \"id\": \"material-theme-darker\",\n    \"displayName\": \"Material Theme Darker\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_m-a98a3d\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/material-theme-darker */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/material-theme-darker.mjs\"))\n  },\n  {\n    \"id\": \"material-theme-lighter\",\n    \"displayName\": \"Material Theme Lighter\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_m-d42999\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/material-theme-lighter */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/material-theme-lighter.mjs\"))\n  },\n  {\n    \"id\": \"material-theme-ocean\",\n    \"displayName\": \"Material Theme Ocean\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_m-82e5e8\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/material-theme-ocean */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/material-theme-ocean.mjs\"))\n  },\n  {\n    \"id\": \"material-theme-palenight\",\n    \"displayName\": \"Material Theme Palenight\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_m-c99494\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/material-theme-palenight */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/material-theme-palenight.mjs\"))\n  },\n  {\n    \"id\": \"min-dark\",\n    \"displayName\": \"Min Dark\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_m-6b51be\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/min-dark */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/min-dark.mjs\"))\n  },\n  {\n    \"id\": \"min-light\",\n    \"displayName\": \"Min Light\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_m-45e179\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/min-light */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/min-light.mjs\"))\n  },\n  {\n    \"id\": \"monokai\",\n    \"displayName\": \"Monokai\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_m-c8fec8\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/monokai */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/monokai.mjs\"))\n  },\n  {\n    \"id\": \"night-owl\",\n    \"displayName\": \"Night Owl\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_n-31642d\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/night-owl */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/night-owl.mjs\"))\n  },\n  {\n    \"id\": \"nord\",\n    \"displayName\": \"Nord\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_n-ba6c59\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/nord */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/nord.mjs\"))\n  },\n  {\n    \"id\": \"one-dark-pro\",\n    \"displayName\": \"One Dark Pro\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_o-f8cbc8\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/one-dark-pro */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/one-dark-pro.mjs\"))\n  },\n  {\n    \"id\": \"one-light\",\n    \"displayName\": \"One Light\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_o-149a23\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/one-light */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/one-light.mjs\"))\n  },\n  {\n    \"id\": \"plastic\",\n    \"displayName\": \"Plastic\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_p-8f7721\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/plastic */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/plastic.mjs\"))\n  },\n  {\n    \"id\": \"poimandres\",\n    \"displayName\": \"Poimandres\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_p-286bd7\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/poimandres */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/poimandres.mjs\"))\n  },\n  {\n    \"id\": \"red\",\n    \"displayName\": \"Red\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_red_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/red */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/red.mjs\"))\n  },\n  {\n    \"id\": \"rose-pine\",\n    \"displayName\": \"Ros\\xE9 Pine\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_r-f96f94\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/rose-pine */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/rose-pine.mjs\"))\n  },\n  {\n    \"id\": \"rose-pine-dawn\",\n    \"displayName\": \"Ros\\xE9 Pine Dawn\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_r-4e4608\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/rose-pine-dawn */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/rose-pine-dawn.mjs\"))\n  },\n  {\n    \"id\": \"rose-pine-moon\",\n    \"displayName\": \"Ros\\xE9 Pine Moon\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_r-f3f430\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/rose-pine-moon */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/rose-pine-moon.mjs\"))\n  },\n  {\n    \"id\": \"slack-dark\",\n    \"displayName\": \"Slack Dark\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_s-8f47b2\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/slack-dark */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/slack-dark.mjs\"))\n  },\n  {\n    \"id\": \"slack-ochin\",\n    \"displayName\": \"Slack Ochin\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_s-1ee5db\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/slack-ochin */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/slack-ochin.mjs\"))\n  },\n  {\n    \"id\": \"snazzy-light\",\n    \"displayName\": \"Snazzy Light\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_s-5c0854\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/snazzy-light */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/snazzy-light.mjs\"))\n  },\n  {\n    \"id\": \"solarized-dark\",\n    \"displayName\": \"Solarized Dark\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_s-91e097\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/solarized-dark */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/solarized-dark.mjs\"))\n  },\n  {\n    \"id\": \"solarized-light\",\n    \"displayName\": \"Solarized Light\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_s-7675c2\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/solarized-light */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/solarized-light.mjs\"))\n  },\n  {\n    \"id\": \"synthwave-84\",\n    \"displayName\": \"Synthwave '84\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_s-36e385\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/synthwave-84 */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/synthwave-84.mjs\"))\n  },\n  {\n    \"id\": \"tokyo-night\",\n    \"displayName\": \"Tokyo Night\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_t-803793\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/tokyo-night */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/tokyo-night.mjs\"))\n  },\n  {\n    \"id\": \"vesper\",\n    \"displayName\": \"Vesper\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_v-1c5649\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/vesper */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/vesper.mjs\"))\n  },\n  {\n    \"id\": \"vitesse-black\",\n    \"displayName\": \"Vitesse Black\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_v-470526\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/vitesse-black */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/vitesse-black.mjs\"))\n  },\n  {\n    \"id\": \"vitesse-dark\",\n    \"displayName\": \"Vitesse Dark\",\n    \"type\": \"dark\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_v-55e2fe\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/vitesse-dark */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/vitesse-dark.mjs\"))\n  },\n  {\n    \"id\": \"vitesse-light\",\n    \"displayName\": \"Vitesse Light\",\n    \"type\": \"light\",\n    \"import\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shikijs_themes_1_27_0_node_modules_shikijs_themes_dist_v-f35b83\").then(__webpack_require__.bind(__webpack_require__, /*! @shikijs/themes/vitesse-light */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+themes@1.27.0/node_modules/@shikijs/themes/dist/vitesse-light.mjs\"))\n  }\n];\nconst bundledThemes = Object.fromEntries(bundledThemesInfo.map((i) => [i.id, i.import]));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGlraUAxLjI3LjAvbm9kZV9tb2R1bGVzL3NoaWtpL2Rpc3QvdGhlbWVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdVZBQW9DO0FBQ3hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtVkFBa0M7QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1WQUFrQztBQUN0RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscVdBQTJDO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtV0FBMEM7QUFDOUQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJXQUE4QztBQUNsRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbVdBQTBDO0FBQzlELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxVkFBbUM7QUFDdkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlWQUFpQztBQUNyRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMlZBQXNDO0FBQzFELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpV0FBeUM7QUFDN0QsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1XQUEwQztBQUM5RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseVZBQXFDO0FBQ3pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5V0FBNkM7QUFDakUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVXQUE0QztBQUNoRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxvQkFBb0IsNlZBQXVDO0FBQzNELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyVkFBc0M7QUFDMUQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZWQUF1QztBQUMzRDtBQUNBO0FBQ0E7O0FBRTRDIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3NoaWtpQDEuMjcuMC9ub2RlX21vZHVsZXMvc2hpa2kvZGlzdC90aGVtZXMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJ1bmRsZWRUaGVtZXNJbmZvID0gW1xuICB7XG4gICAgXCJpZFwiOiBcImFuZHJvbWVlZGFcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiQW5kcm9tZWVkYVwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9hbmRyb21lZWRhJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJhdXJvcmEteFwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJBdXJvcmEgWFwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9hdXJvcmEteCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiYXl1LWRhcmtcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiQXl1IERhcmtcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvYXl1LWRhcmsnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImNhdHBwdWNjaW4tZnJhcHBlXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkNhdHBwdWNjaW4gRnJhcHBcXHhFOVwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9jYXRwcHVjY2luLWZyYXBwZScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY2F0cHB1Y2Npbi1sYXR0ZVwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJDYXRwcHVjY2luIExhdHRlXCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9jYXRwcHVjY2luLWxhdHRlJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJjYXRwcHVjY2luLW1hY2NoaWF0b1wiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJDYXRwcHVjY2luIE1hY2NoaWF0b1wiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9jYXRwcHVjY2luLW1hY2NoaWF0bycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiY2F0cHB1Y2Npbi1tb2NoYVwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJDYXRwcHVjY2luIE1vY2hhXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL2NhdHBwdWNjaW4tbW9jaGEnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImRhcmstcGx1c1wiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJEYXJrIFBsdXNcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvZGFyay1wbHVzJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJkcmFjdWxhXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkRyYWN1bGEgVGhlbWVcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvZHJhY3VsYScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZHJhY3VsYS1zb2Z0XCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkRyYWN1bGEgVGhlbWUgU29mdFwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9kcmFjdWxhLXNvZnQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImV2ZXJmb3Jlc3QtZGFya1wiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJFdmVyZm9yZXN0IERhcmtcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvZXZlcmZvcmVzdC1kYXJrJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJldmVyZm9yZXN0LWxpZ2h0XCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkV2ZXJmb3Jlc3QgTGlnaHRcIixcbiAgICBcInR5cGVcIjogXCJsaWdodFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL2V2ZXJmb3Jlc3QtbGlnaHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImdpdGh1Yi1kYXJrXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkdpdEh1YiBEYXJrXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL2dpdGh1Yi1kYXJrJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJnaXRodWItZGFyay1kZWZhdWx0XCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkdpdEh1YiBEYXJrIERlZmF1bHRcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvZ2l0aHViLWRhcmstZGVmYXVsdCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZ2l0aHViLWRhcmstZGltbWVkXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkdpdEh1YiBEYXJrIERpbW1lZFwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9naXRodWItZGFyay1kaW1tZWQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImdpdGh1Yi1kYXJrLWhpZ2gtY29udHJhc3RcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiR2l0SHViIERhcmsgSGlnaCBDb250cmFzdFwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9naXRodWItZGFyay1oaWdoLWNvbnRyYXN0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJnaXRodWItbGlnaHRcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiR2l0SHViIExpZ2h0XCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9naXRodWItbGlnaHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImdpdGh1Yi1saWdodC1kZWZhdWx0XCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkdpdEh1YiBMaWdodCBEZWZhdWx0XCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9naXRodWItbGlnaHQtZGVmYXVsdCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwiZ2l0aHViLWxpZ2h0LWhpZ2gtY29udHJhc3RcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiR2l0SHViIExpZ2h0IEhpZ2ggQ29udHJhc3RcIixcbiAgICBcInR5cGVcIjogXCJsaWdodFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL2dpdGh1Yi1saWdodC1oaWdoLWNvbnRyYXN0JylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJob3VzdG9uXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkhvdXN0b25cIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvaG91c3RvbicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwia2FuYWdhd2EtZHJhZ29uXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkthbmFnYXdhIERyYWdvblwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9rYW5hZ2F3YS1kcmFnb24nKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImthbmFnYXdhLWxvdHVzXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkthbmFnYXdhIExvdHVzXCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9rYW5hZ2F3YS1sb3R1cycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwia2FuYWdhd2Etd2F2ZVwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJLYW5hZ2F3YSBXYXZlXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL2thbmFnYXdhLXdhdmUnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcImxhc2Vyd2F2ZVwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJMYXNlcldhdmVcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvbGFzZXJ3YXZlJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJsaWdodC1wbHVzXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIkxpZ2h0IFBsdXNcIixcbiAgICBcInR5cGVcIjogXCJsaWdodFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL2xpZ2h0LXBsdXMnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm1hdGVyaWFsLXRoZW1lXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIk1hdGVyaWFsIFRoZW1lXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL21hdGVyaWFsLXRoZW1lJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJtYXRlcmlhbC10aGVtZS1kYXJrZXJcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiTWF0ZXJpYWwgVGhlbWUgRGFya2VyXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL21hdGVyaWFsLXRoZW1lLWRhcmtlcicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibWF0ZXJpYWwtdGhlbWUtbGlnaHRlclwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJNYXRlcmlhbCBUaGVtZSBMaWdodGVyXCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9tYXRlcmlhbC10aGVtZS1saWdodGVyJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJtYXRlcmlhbC10aGVtZS1vY2VhblwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJNYXRlcmlhbCBUaGVtZSBPY2VhblwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9tYXRlcmlhbC10aGVtZS1vY2VhbicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibWF0ZXJpYWwtdGhlbWUtcGFsZW5pZ2h0XCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIk1hdGVyaWFsIFRoZW1lIFBhbGVuaWdodFwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9tYXRlcmlhbC10aGVtZS1wYWxlbmlnaHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm1pbi1kYXJrXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIk1pbiBEYXJrXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL21pbi1kYXJrJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJtaW4tbGlnaHRcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiTWluIExpZ2h0XCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9taW4tbGlnaHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm1vbm9rYWlcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiTW9ub2thaVwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9tb25va2FpJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJuaWdodC1vd2xcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiTmlnaHQgT3dsXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL25pZ2h0LW93bCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwibm9yZFwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJOb3JkXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL25vcmQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcIm9uZS1kYXJrLXByb1wiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJPbmUgRGFyayBQcm9cIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvb25lLWRhcmstcHJvJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJvbmUtbGlnaHRcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiT25lIExpZ2h0XCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9vbmUtbGlnaHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInBsYXN0aWNcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiUGxhc3RpY1wiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9wbGFzdGljJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJwb2ltYW5kcmVzXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIlBvaW1hbmRyZXNcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvcG9pbWFuZHJlcycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicmVkXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIlJlZFwiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9yZWQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInJvc2UtcGluZVwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJSb3NcXHhFOSBQaW5lXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL3Jvc2UtcGluZScpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicm9zZS1waW5lLWRhd25cIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiUm9zXFx4RTkgUGluZSBEYXduXCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9yb3NlLXBpbmUtZGF3bicpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwicm9zZS1waW5lLW1vb25cIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiUm9zXFx4RTkgUGluZSBNb29uXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL3Jvc2UtcGluZS1tb29uJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzbGFjay1kYXJrXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIlNsYWNrIERhcmtcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvc2xhY2stZGFyaycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwic2xhY2stb2NoaW5cIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiU2xhY2sgT2NoaW5cIixcbiAgICBcInR5cGVcIjogXCJsaWdodFwiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL3NsYWNrLW9jaGluJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzbmF6enktbGlnaHRcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiU25henp5IExpZ2h0XCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9zbmF6enktbGlnaHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInNvbGFyaXplZC1kYXJrXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIlNvbGFyaXplZCBEYXJrXCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL3NvbGFyaXplZC1kYXJrJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJzb2xhcml6ZWQtbGlnaHRcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiU29sYXJpemVkIExpZ2h0XCIsXG4gICAgXCJ0eXBlXCI6IFwibGlnaHRcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy9zb2xhcml6ZWQtbGlnaHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInN5bnRod2F2ZS04NFwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJTeW50aHdhdmUgJzg0XCIsXG4gICAgXCJ0eXBlXCI6IFwiZGFya1wiLFxuICAgIFwiaW1wb3J0XCI6ICgpID0+IGltcG9ydCgnQHNoaWtpanMvdGhlbWVzL3N5bnRod2F2ZS04NCcpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidG9reW8tbmlnaHRcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiVG9reW8gTmlnaHRcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvdG9reW8tbmlnaHQnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInZlc3BlclwiLFxuICAgIFwiZGlzcGxheU5hbWVcIjogXCJWZXNwZXJcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvdmVzcGVyJylcbiAgfSxcbiAge1xuICAgIFwiaWRcIjogXCJ2aXRlc3NlLWJsYWNrXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIlZpdGVzc2UgQmxhY2tcIixcbiAgICBcInR5cGVcIjogXCJkYXJrXCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvdml0ZXNzZS1ibGFjaycpXG4gIH0sXG4gIHtcbiAgICBcImlkXCI6IFwidml0ZXNzZS1kYXJrXCIsXG4gICAgXCJkaXNwbGF5TmFtZVwiOiBcIlZpdGVzc2UgRGFya1wiLFxuICAgIFwidHlwZVwiOiBcImRhcmtcIixcbiAgICBcImltcG9ydFwiOiAoKSA9PiBpbXBvcnQoJ0BzaGlraWpzL3RoZW1lcy92aXRlc3NlLWRhcmsnKVxuICB9LFxuICB7XG4gICAgXCJpZFwiOiBcInZpdGVzc2UtbGlnaHRcIixcbiAgICBcImRpc3BsYXlOYW1lXCI6IFwiVml0ZXNzZSBMaWdodFwiLFxuICAgIFwidHlwZVwiOiBcImxpZ2h0XCIsXG4gICAgXCJpbXBvcnRcIjogKCkgPT4gaW1wb3J0KCdAc2hpa2lqcy90aGVtZXMvdml0ZXNzZS1saWdodCcpXG4gIH1cbl07XG5jb25zdCBidW5kbGVkVGhlbWVzID0gT2JqZWN0LmZyb21FbnRyaWVzKGJ1bmRsZWRUaGVtZXNJbmZvLm1hcCgoaSkgPT4gW2kuaWQsIGkuaW1wb3J0XSkpO1xuXG5leHBvcnQgeyBidW5kbGVkVGhlbWVzLCBidW5kbGVkVGhlbWVzSW5mbyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/themes.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/wasm-dynamic-K7LwWlz7.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/wasm-dynamic-K7LwWlz7.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ getWasmInlined)\n/* harmony export */ });\n/* harmony import */ var _shikijs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shikijs/core */ \"(app-pages-browser)/./node_modules/.pnpm/@shikijs+core@1.27.0/node_modules/@shikijs/core/dist/shared/core.DVV8c4RZ.mjs\");\n\n\nconst getWasmInlined = async (info) => {\n  (0,_shikijs_core__WEBPACK_IMPORTED_MODULE_0__.w)('`getWasmInlined` is deprecated. Use `import(\"shiki/wasm\")` instead.');\n  return __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_shiki_1_27_0_node_modules_shiki_dist_wasm_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! shiki/wasm */ \"(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/wasm.mjs\")).then((wasm) => wasm.default(info));\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGlraUAxLjI3LjAvbm9kZV9tb2R1bGVzL3NoaWtpL2Rpc3Qvd2FzbS1keW5hbWljLUs3THdXbHo3LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStDOztBQUUvQztBQUNBLEVBQUUsZ0RBQWM7QUFDaEIsU0FBUywyUkFBb0I7QUFDN0I7O0FBRStCIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3NoaWtpQDEuMjcuMC9ub2RlX21vZHVsZXMvc2hpa2kvZGlzdC93YXNtLWR5bmFtaWMtSzdMd1dsejcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2FybkRlcHJlY2F0ZWQgfSBmcm9tICdAc2hpa2lqcy9jb3JlJztcblxuY29uc3QgZ2V0V2FzbUlubGluZWQgPSBhc3luYyAoaW5mbykgPT4ge1xuICB3YXJuRGVwcmVjYXRlZCgnYGdldFdhc21JbmxpbmVkYCBpcyBkZXByZWNhdGVkLiBVc2UgYGltcG9ydChcInNoaWtpL3dhc21cIilgIGluc3RlYWQuJyk7XG4gIHJldHVybiBpbXBvcnQoJ3NoaWtpL3dhc20nKS50aGVuKCh3YXNtKSA9PiB3YXNtLmRlZmF1bHQoaW5mbykpO1xufTtcblxuZXhwb3J0IHsgZ2V0V2FzbUlubGluZWQgYXMgZyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/shiki@1.27.0/node_modules/shiki/dist/wasm-dynamic-K7LwWlz7.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nfunction parse(value) {\n  const input = String(value || '').trim()\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : []\n}\n\n/**\n * Serialize an array of strings as space separated-tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @returns {string}\n *   Space-separated tokens.\n */\nfunction stringify(values) {\n  return values.join(' ').trim()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zcGFjZS1zZXBhcmF0ZWQtdG9rZW5zQDIuMC4yL25vZGVfbW9kdWxlcy9zcGFjZS1zZXBhcmF0ZWQtdG9rZW5zL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3NwYWNlLXNlcGFyYXRlZC10b2tlbnNAMi4wLjIvbm9kZV9tb2R1bGVzL3NwYWNlLXNlcGFyYXRlZC10b2tlbnMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQYXJzZSBzcGFjZS1zZXBhcmF0ZWQgdG9rZW5zIHRvIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgIFNwYWNlLXNlcGFyYXRlZCB0b2tlbnMuXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn1cbiAqICAgTGlzdCBvZiB0b2tlbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh2YWx1ZSkge1xuICBjb25zdCBpbnB1dCA9IFN0cmluZyh2YWx1ZSB8fCAnJykudHJpbSgpXG4gIHJldHVybiBpbnB1dCA/IGlucHV0LnNwbGl0KC9bIFxcdFxcblxcclxcZl0rL2cpIDogW11cbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhcyBzcGFjZSBzZXBhcmF0ZWQtdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfG51bWJlcj59IHZhbHVlc1xuICogICBMaXN0IG9mIHRva2Vucy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIFNwYWNlLXNlcGFyYXRlZCB0b2tlbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMuam9pbignICcpLnRyaW0oKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/space-separated-tokens@2.0.2/node_modules/space-separated-tokens/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/constant/dangerous.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/constant/dangerous.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dangerous: () => (/* binding */ dangerous)\n/* harmony export */ });\n/**\n * List of legacy (that dont need a trailing `;`) named references which could,\n * depending on what follows them, turn into a different meaning\n *\n * @type {Array<string>}\n */\nconst dangerous = [\n  'cent',\n  'copy',\n  'divide',\n  'gt',\n  'lt',\n  'not',\n  'para',\n  'times'\n]\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvY29uc3RhbnQvZGFuZ2Vyb3VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vc3RyaW5naWZ5LWVudGl0aWVzQDQuMC40L25vZGVfbW9kdWxlcy9zdHJpbmdpZnktZW50aXRpZXMvbGliL2NvbnN0YW50L2Rhbmdlcm91cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpc3Qgb2YgbGVnYWN5ICh0aGF0IGRvbuKAmXQgbmVlZCBhIHRyYWlsaW5nIGA7YCkgbmFtZWQgcmVmZXJlbmNlcyB3aGljaCBjb3VsZCxcbiAqIGRlcGVuZGluZyBvbiB3aGF0IGZvbGxvd3MgdGhlbSwgdHVybiBpbnRvIGEgZGlmZmVyZW50IG1lYW5pbmdcbiAqXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRhbmdlcm91cyA9IFtcbiAgJ2NlbnQnLFxuICAnY29weScsXG4gICdkaXZpZGUnLFxuICAnZ3QnLFxuICAnbHQnLFxuICAnbm90JyxcbiAgJ3BhcmEnLFxuICAndGltZXMnXG5dXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/constant/dangerous.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/core.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/core.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   core: () => (/* binding */ core)\n/* harmony export */ });\n/**\n * @typedef CoreOptions\n * @property {ReadonlyArray<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\nconst defaultSubsetRegex = /[\"&'<>`]/g\nconst surrogatePairsRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\nconst controlCharactersRegex =\n  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n  /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g\nconst regexEscapeRegex = /[|\\\\{}()[\\]^$+*?.]/g\n\n/** @type {WeakMap<ReadonlyArray<string>, RegExp>} */\nconst subsetToRegexCache = new WeakMap()\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nfunction core(value, options) {\n  value = value.replace(\n    options.subset\n      ? charactersToExpressionCached(options.subset)\n      : defaultSubsetRegex,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(surrogatePairsRegex, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(controlCharactersRegex, basic)\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * A wrapper function that caches the result of `charactersToExpression` with a WeakMap.\n * This can improve performance when tooling calls `charactersToExpression` repeatedly\n * with the same subset.\n *\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpressionCached(subset) {\n  let cached = subsetToRegexCache.get(subset)\n\n  if (!cached) {\n    cached = charactersToExpression(subset)\n    subsetToRegexCache.set(subset, cached)\n  }\n\n  return cached\n}\n\n/**\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(regexEscapeRegex, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3RUFBd0U7QUFDdEY7QUFDQTtBQUNBLGFBQWEsbUZBQW1GO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDLFdBQVcsd0NBQXdDO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsS0FBSztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3N0cmluZ2lmeS1lbnRpdGllc0A0LjAuNC9ub2RlX21vZHVsZXMvc3RyaW5naWZ5LWVudGl0aWVzL2xpYi9jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYgQ29yZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7UmVhZG9ubHlBcnJheTxzdHJpbmc+fSBbc3Vic2V0PVtdXVxuICogICBXaGV0aGVyIHRvIG9ubHkgZXNjYXBlIHRoZSBnaXZlbiBzdWJzZXQgb2YgY2hhcmFjdGVycy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VzY2FwZU9ubHk9ZmFsc2VdXG4gKiAgIFdoZXRoZXIgdG8gb25seSBlc2NhcGUgcG9zc2libHkgZGFuZ2Vyb3VzIGNoYXJhY3RlcnMuXG4gKiAgIFRob3NlIGNoYXJhY3RlcnMgYXJlIGBcImAsIGAmYCwgYCdgLCBgPGAsIGA+YCwgYW5kIGBgIGAgYGAuXG4gKlxuICogQHR5cGVkZWYgRm9ybWF0T3B0aW9uc1xuICogQHByb3BlcnR5IHsoY29kZTogbnVtYmVyLCBuZXh0OiBudW1iZXIsIG9wdGlvbnM6IENvcmVXaXRoRm9ybWF0T3B0aW9ucykgPT4gc3RyaW5nfSBmb3JtYXRcbiAqICAgRm9ybWF0IHN0cmF0ZWd5LlxuICpcbiAqIEB0eXBlZGVmIHtDb3JlT3B0aW9ucyAmIEZvcm1hdE9wdGlvbnMgJiBpbXBvcnQoJy4vdXRpbC9mb3JtYXQtc21hcnQuanMnKS5Gb3JtYXRTbWFydE9wdGlvbnN9IENvcmVXaXRoRm9ybWF0T3B0aW9uc1xuICovXG5cbmNvbnN0IGRlZmF1bHRTdWJzZXRSZWdleCA9IC9bXCImJzw+YF0vZ1xuY29uc3Qgc3Vycm9nYXRlUGFpcnNSZWdleCA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2dcbmNvbnN0IGNvbnRyb2xDaGFyYWN0ZXJzUmVnZXggPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleCwgdW5pY29ybi9uby1oZXgtZXNjYXBlXG4gIC9bXFx4MDEtXFx0XFx2XFxmXFx4MEUtXFx4MUZcXHg3RlxceDgxXFx4OERcXHg4RlxceDkwXFx4OURcXHhBMC1cXHVGRkZGXS9nXG5jb25zdCByZWdleEVzY2FwZVJlZ2V4ID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nXG5cbi8qKiBAdHlwZSB7V2Vha01hcDxSZWFkb25seUFycmF5PHN0cmluZz4sIFJlZ0V4cD59ICovXG5jb25zdCBzdWJzZXRUb1JlZ2V4Q2FjaGUgPSBuZXcgV2Vha01hcCgpXG5cbi8qKlxuICogRW5jb2RlIGNlcnRhaW4gY2hhcmFjdGVycyBpbiBgdmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtDb3JlV2l0aEZvcm1hdE9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3JlKHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShcbiAgICBvcHRpb25zLnN1YnNldFxuICAgICAgPyBjaGFyYWN0ZXJzVG9FeHByZXNzaW9uQ2FjaGVkKG9wdGlvbnMuc3Vic2V0KVxuICAgICAgOiBkZWZhdWx0U3Vic2V0UmVnZXgsXG4gICAgYmFzaWNcbiAgKVxuXG4gIGlmIChvcHRpb25zLnN1YnNldCB8fCBvcHRpb25zLmVzY2FwZU9ubHkpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgdmFsdWVcbiAgICAgIC8vIFN1cnJvZ2F0ZSBwYWlycy5cbiAgICAgIC5yZXBsYWNlKHN1cnJvZ2F0ZVBhaXJzUmVnZXgsIHN1cnJvZ2F0ZSlcbiAgICAgIC8vIEJNUCBjb250cm9sIGNoYXJhY3RlcnMgKEMwIGV4Y2VwdCBmb3IgTEYsIENSLCBTUDsgREVMOyBhbmQgc29tZSBtb3JlXG4gICAgICAvLyBub24tQVNDSUkgb25lcykuXG4gICAgICAucmVwbGFjZShjb250cm9sQ2hhcmFjdGVyc1JlZ2V4LCBiYXNpYylcbiAgKVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFpclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFsbFxuICAgKi9cbiAgZnVuY3Rpb24gc3Vycm9nYXRlKHBhaXIsIGluZGV4LCBhbGwpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5mb3JtYXQoXG4gICAgICAocGFpci5jaGFyQ29kZUF0KDApIC0gMHhkODAwKSAqIDB4NDAwICtcbiAgICAgICAgcGFpci5jaGFyQ29kZUF0KDEpIC1cbiAgICAgICAgMHhkYzAwICtcbiAgICAgICAgMHgxMDAwMCxcbiAgICAgIGFsbC5jaGFyQ29kZUF0KGluZGV4ICsgMiksXG4gICAgICBvcHRpb25zXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbGxcbiAgICovXG4gIGZ1bmN0aW9uIGJhc2ljKGNoYXJhY3RlciwgaW5kZXgsIGFsbCkge1xuICAgIHJldHVybiBvcHRpb25zLmZvcm1hdChcbiAgICAgIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApLFxuICAgICAgYWxsLmNoYXJDb2RlQXQoaW5kZXggKyAxKSxcbiAgICAgIG9wdGlvbnNcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBBIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCBjYWNoZXMgdGhlIHJlc3VsdCBvZiBgY2hhcmFjdGVyc1RvRXhwcmVzc2lvbmAgd2l0aCBhIFdlYWtNYXAuXG4gKiBUaGlzIGNhbiBpbXByb3ZlIHBlcmZvcm1hbmNlIHdoZW4gdG9vbGluZyBjYWxscyBgY2hhcmFjdGVyc1RvRXhwcmVzc2lvbmAgcmVwZWF0ZWRseVxuICogd2l0aCB0aGUgc2FtZSBzdWJzZXQuXG4gKlxuICogQHBhcmFtIHtSZWFkb25seUFycmF5PHN0cmluZz59IHN1YnNldFxuICogQHJldHVybnMge1JlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gY2hhcmFjdGVyc1RvRXhwcmVzc2lvbkNhY2hlZChzdWJzZXQpIHtcbiAgbGV0IGNhY2hlZCA9IHN1YnNldFRvUmVnZXhDYWNoZS5nZXQoc3Vic2V0KVxuXG4gIGlmICghY2FjaGVkKSB7XG4gICAgY2FjaGVkID0gY2hhcmFjdGVyc1RvRXhwcmVzc2lvbihzdWJzZXQpXG4gICAgc3Vic2V0VG9SZWdleENhY2hlLnNldChzdWJzZXQsIGNhY2hlZClcbiAgfVxuXG4gIHJldHVybiBjYWNoZWRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWRvbmx5QXJyYXk8c3RyaW5nPn0gc3Vic2V0XG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICovXG5mdW5jdGlvbiBjaGFyYWN0ZXJzVG9FeHByZXNzaW9uKHN1YnNldCkge1xuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IGdyb3VwcyA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBzdWJzZXQubGVuZ3RoKSB7XG4gICAgZ3JvdXBzLnB1c2goc3Vic2V0W2luZGV4XS5yZXBsYWNlKHJlZ2V4RXNjYXBlUmVnZXgsICdcXFxcJCYnKSlcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKCcoPzonICsgZ3JvdXBzLmpvaW4oJ3wnKSArICcpJywgJ2cnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringifyEntities: () => (/* binding */ stringifyEntities),\n/* harmony export */   stringifyEntitiesLight: () => (/* binding */ stringifyEntitiesLight)\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/core.js\");\n/* harmony import */ var _util_format_smart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/format-smart.js */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-smart.js\");\n/* harmony import */ var _util_format_basic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/format-basic.js */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-basic.js\");\n/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\n\n\n\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nfunction stringifyEntities(value, options) {\n  return (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.core)(value, Object.assign({format: _util_format_smart_js__WEBPACK_IMPORTED_MODULE_1__.formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nfunction stringifyEntitiesLight(value, options) {\n  return (0,_core_js__WEBPACK_IMPORTED_MODULE_0__.core)(value, Object.assign({format: _util_format_basic_js__WEBPACK_IMPORTED_MODULE_2__.formatBasic}, options))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLGFBQWEsdUZBQXVGO0FBQ3BHLGFBQWEsaUNBQWlDO0FBQzlDOztBQUU4QjtBQUNvQjtBQUNBOztBQUVsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1AsU0FBUyw4Q0FBSSx1QkFBdUIsUUFBUSw4REFBVyxDQUFDO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUCxTQUFTLDhDQUFJLHVCQUF1QixRQUFRLDhEQUFXLENBQUM7QUFDeEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vc3RyaW5naWZ5LWVudGl0aWVzQDQuMC40L25vZGVfbW9kdWxlcy9zdHJpbmdpZnktZW50aXRpZXMvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9jb3JlLmpzJykuQ29yZU9wdGlvbnMgJiBpbXBvcnQoJy4vdXRpbC9mb3JtYXQtc21hcnQuanMnKS5Gb3JtYXRTbWFydE9wdGlvbnN9IE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS5qcycpLkNvcmVPcHRpb25zfSBMaWdodE9wdGlvbnNcbiAqL1xuXG5pbXBvcnQge2NvcmV9IGZyb20gJy4vY29yZS5qcydcbmltcG9ydCB7Zm9ybWF0U21hcnR9IGZyb20gJy4vdXRpbC9mb3JtYXQtc21hcnQuanMnXG5pbXBvcnQge2Zvcm1hdEJhc2ljfSBmcm9tICcuL3V0aWwvZm9ybWF0LWJhc2ljLmpzJ1xuXG4vKipcbiAqIEVuY29kZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gYHZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgVmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIEVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlFbnRpdGllcyh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gY29yZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbih7Zm9ybWF0OiBmb3JtYXRTbWFydH0sIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIEVuY29kZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gYHZhbHVlYCBhcyBoZXhhZGVjaW1hbHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgIFZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB7TGlnaHRPcHRpb25zfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIEVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlFbnRpdGllc0xpZ2h0KHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBjb3JlKHZhbHVlLCBPYmplY3QuYXNzaWduKHtmb3JtYXQ6IGZvcm1hdEJhc2ljfSwgb3B0aW9ucykpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-basic.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-basic.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatBasic: () => (/* binding */ formatBasic)\n/* harmony export */ });\n/**\n * The smallest way to encode a character.\n *\n * @param {number} code\n * @returns {string}\n */\nfunction formatBasic(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvdXRpbC9mb3JtYXQtYmFzaWMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDTztBQUNQLHFEQUFxRDtBQUNyRCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvdXRpbC9mb3JtYXQtYmFzaWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgc21hbGxlc3Qgd2F5IHRvIGVuY29kZSBhIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJhc2ljKGNvZGUpIHtcbiAgcmV0dXJuICcmI3gnICsgY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICc7J1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-basic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-smart.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-smart.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatSmart: () => (/* binding */ formatSmart)\n/* harmony export */ });\n/* harmony import */ var _to_hexadecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./to-hexadecimal.js */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-hexadecimal.js\");\n/* harmony import */ var _to_decimal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./to-decimal.js */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-decimal.js\");\n/* harmony import */ var _to_named_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./to-named.js */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-named.js\");\n/**\n * @typedef FormatSmartOptions\n * @property {boolean} [useNamedReferences=false]\n *   Prefer named character references (`&amp;`) where possible.\n * @property {boolean} [useShortestReferences=false]\n *   Prefer the shortest possible reference, if that results in less bytes.\n *   **Note**: `useNamedReferences` can be omitted when using `useShortestReferences`.\n * @property {boolean} [omitOptionalSemicolons=false]\n *   Whether to omit semicolons when possible.\n *   **Note**: This creates what HTML calls parse errors but is otherwise still valid HTML  dont use this except when building a minifier.\n *   Omitting semicolons is possible for certain named and numeric references in some cases.\n * @property {boolean} [attribute=false]\n *   Create character references which dont fail in attributes.\n *   **Note**: `attribute` only applies when operating dangerously with\n *   `omitOptionalSemicolons: true`.\n */\n\n\n\n\n\n/**\n * Configurable ways to encode a character yielding pretty or small results.\n *\n * @param {number} code\n * @param {number} next\n * @param {FormatSmartOptions} options\n * @returns {string}\n */\nfunction formatSmart(code, next, options) {\n  let numeric = (0,_to_hexadecimal_js__WEBPACK_IMPORTED_MODULE_0__.toHexadecimal)(code, next, options.omitOptionalSemicolons)\n  /** @type {string|undefined} */\n  let named\n\n  if (options.useNamedReferences || options.useShortestReferences) {\n    named = (0,_to_named_js__WEBPACK_IMPORTED_MODULE_1__.toNamed)(\n      code,\n      next,\n      options.omitOptionalSemicolons,\n      options.attribute\n    )\n  }\n\n  // Use the shortest numeric reference when requested.\n  // A simple algorithm would use decimal for all code points under 100, as\n  // those are shorter than hexadecimal:\n  //\n  // * `&#99;` vs `&#x63;` (decimal shorter)\n  // * `&#100;` vs `&#x64;` (equal)\n  //\n  // However, because we take `next` into consideration when `omit` is used,\n  // And it would be possible that decimals are shorter on bigger values as\n  // well if `next` is hexadecimal but not decimal, we instead compare both.\n  if (\n    (options.useShortestReferences || !named) &&\n    options.useShortestReferences\n  ) {\n    const decimal = (0,_to_decimal_js__WEBPACK_IMPORTED_MODULE_2__.toDecimal)(code, next, options.omitOptionalSemicolons)\n\n    if (decimal.length < numeric.length) {\n      numeric = decimal\n    }\n  }\n\n  return named &&\n    (!options.useShortestReferences || named.length < numeric.length)\n    ? named\n    : numeric\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvdXRpbC9mb3JtYXQtc21hcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsOENBQThDO0FBQzlDLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFaUQ7QUFDUjtBQUNKOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWE7QUFDYjtBQUNPO0FBQ1AsZ0JBQWdCLGlFQUFhO0FBQzdCLGFBQWEsa0JBQWtCO0FBQy9COztBQUVBO0FBQ0EsWUFBWSxxREFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQVM7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vc3RyaW5naWZ5LWVudGl0aWVzQDQuMC40L25vZGVfbW9kdWxlcy9zdHJpbmdpZnktZW50aXRpZXMvbGliL3V0aWwvZm9ybWF0LXNtYXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYgRm9ybWF0U21hcnRPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VOYW1lZFJlZmVyZW5jZXM9ZmFsc2VdXG4gKiAgIFByZWZlciBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyAoYCZhbXA7YCkgd2hlcmUgcG9zc2libGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VTaG9ydGVzdFJlZmVyZW5jZXM9ZmFsc2VdXG4gKiAgIFByZWZlciB0aGUgc2hvcnRlc3QgcG9zc2libGUgcmVmZXJlbmNlLCBpZiB0aGF0IHJlc3VsdHMgaW4gbGVzcyBieXRlcy5cbiAqICAgKipOb3RlKio6IGB1c2VOYW1lZFJlZmVyZW5jZXNgIGNhbiBiZSBvbWl0dGVkIHdoZW4gdXNpbmcgYHVzZVNob3J0ZXN0UmVmZXJlbmNlc2AuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvbWl0T3B0aW9uYWxTZW1pY29sb25zPWZhbHNlXVxuICogICBXaGV0aGVyIHRvIG9taXQgc2VtaWNvbG9ucyB3aGVuIHBvc3NpYmxlLlxuICogICAqKk5vdGUqKjogVGhpcyBjcmVhdGVzIHdoYXQgSFRNTCBjYWxscyDigJxwYXJzZSBlcnJvcnPigJ0gYnV0IGlzIG90aGVyd2lzZSBzdGlsbCB2YWxpZCBIVE1MIOKAlCBkb27igJl0IHVzZSB0aGlzIGV4Y2VwdCB3aGVuIGJ1aWxkaW5nIGEgbWluaWZpZXIuXG4gKiAgIE9taXR0aW5nIHNlbWljb2xvbnMgaXMgcG9zc2libGUgZm9yIGNlcnRhaW4gbmFtZWQgYW5kIG51bWVyaWMgcmVmZXJlbmNlcyBpbiBzb21lIGNhc2VzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRlPWZhbHNlXVxuICogICBDcmVhdGUgY2hhcmFjdGVyIHJlZmVyZW5jZXMgd2hpY2ggZG9u4oCZdCBmYWlsIGluIGF0dHJpYnV0ZXMuXG4gKiAgICoqTm90ZSoqOiBgYXR0cmlidXRlYCBvbmx5IGFwcGxpZXMgd2hlbiBvcGVyYXRpbmcgZGFuZ2Vyb3VzbHkgd2l0aFxuICogICBgb21pdE9wdGlvbmFsU2VtaWNvbG9uczogdHJ1ZWAuXG4gKi9cblxuaW1wb3J0IHt0b0hleGFkZWNpbWFsfSBmcm9tICcuL3RvLWhleGFkZWNpbWFsLmpzJ1xuaW1wb3J0IHt0b0RlY2ltYWx9IGZyb20gJy4vdG8tZGVjaW1hbC5qcydcbmltcG9ydCB7dG9OYW1lZH0gZnJvbSAnLi90by1uYW1lZC5qcydcblxuLyoqXG4gKiBDb25maWd1cmFibGUgd2F5cyB0byBlbmNvZGUgYSBjaGFyYWN0ZXIgeWllbGRpbmcgcHJldHR5IG9yIHNtYWxsIHJlc3VsdHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXh0XG4gKiBAcGFyYW0ge0Zvcm1hdFNtYXJ0T3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFNtYXJ0KGNvZGUsIG5leHQsIG9wdGlvbnMpIHtcbiAgbGV0IG51bWVyaWMgPSB0b0hleGFkZWNpbWFsKGNvZGUsIG5leHQsIG9wdGlvbnMub21pdE9wdGlvbmFsU2VtaWNvbG9ucylcbiAgLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICBsZXQgbmFtZWRcblxuICBpZiAob3B0aW9ucy51c2VOYW1lZFJlZmVyZW5jZXMgfHwgb3B0aW9ucy51c2VTaG9ydGVzdFJlZmVyZW5jZXMpIHtcbiAgICBuYW1lZCA9IHRvTmFtZWQoXG4gICAgICBjb2RlLFxuICAgICAgbmV4dCxcbiAgICAgIG9wdGlvbnMub21pdE9wdGlvbmFsU2VtaWNvbG9ucyxcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlXG4gICAgKVxuICB9XG5cbiAgLy8gVXNlIHRoZSBzaG9ydGVzdCBudW1lcmljIHJlZmVyZW5jZSB3aGVuIHJlcXVlc3RlZC5cbiAgLy8gQSBzaW1wbGUgYWxnb3JpdGhtIHdvdWxkIHVzZSBkZWNpbWFsIGZvciBhbGwgY29kZSBwb2ludHMgdW5kZXIgMTAwLCBhc1xuICAvLyB0aG9zZSBhcmUgc2hvcnRlciB0aGFuIGhleGFkZWNpbWFsOlxuICAvL1xuICAvLyAqIGAmIzk5O2AgdnMgYCYjeDYzO2AgKGRlY2ltYWwgc2hvcnRlcilcbiAgLy8gKiBgJiMxMDA7YCB2cyBgJiN4NjQ7YCAoZXF1YWwpXG4gIC8vXG4gIC8vIEhvd2V2ZXIsIGJlY2F1c2Ugd2UgdGFrZSBgbmV4dGAgaW50byBjb25zaWRlcmF0aW9uIHdoZW4gYG9taXRgIGlzIHVzZWQsXG4gIC8vIEFuZCBpdCB3b3VsZCBiZSBwb3NzaWJsZSB0aGF0IGRlY2ltYWxzIGFyZSBzaG9ydGVyIG9uIGJpZ2dlciB2YWx1ZXMgYXNcbiAgLy8gd2VsbCBpZiBgbmV4dGAgaXMgaGV4YWRlY2ltYWwgYnV0IG5vdCBkZWNpbWFsLCB3ZSBpbnN0ZWFkIGNvbXBhcmUgYm90aC5cbiAgaWYgKFxuICAgIChvcHRpb25zLnVzZVNob3J0ZXN0UmVmZXJlbmNlcyB8fCAhbmFtZWQpICYmXG4gICAgb3B0aW9ucy51c2VTaG9ydGVzdFJlZmVyZW5jZXNcbiAgKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRvRGVjaW1hbChjb2RlLCBuZXh0LCBvcHRpb25zLm9taXRPcHRpb25hbFNlbWljb2xvbnMpXG5cbiAgICBpZiAoZGVjaW1hbC5sZW5ndGggPCBudW1lcmljLmxlbmd0aCkge1xuICAgICAgbnVtZXJpYyA9IGRlY2ltYWxcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZWQgJiZcbiAgICAoIW9wdGlvbnMudXNlU2hvcnRlc3RSZWZlcmVuY2VzIHx8IG5hbWVkLmxlbmd0aCA8IG51bWVyaWMubGVuZ3RoKVxuICAgID8gbmFtZWRcbiAgICA6IG51bWVyaWNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-smart.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-decimal.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-decimal.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toDecimal: () => (/* binding */ toDecimal)\n/* harmony export */ });\nconst decimalRegex = /\\d/\n\n/**\n * Configurable ways to encode characters as decimal references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @returns {string}\n */\nfunction toDecimal(code, next, omit) {\n  const value = '&#' + String(code)\n  return omit && next && !decimalRegex.test(String.fromCharCode(next))\n    ? value\n    : value + ';'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvdXRpbC90by1kZWNpbWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3N0cmluZ2lmeS1lbnRpdGllc0A0LjAuNC9ub2RlX21vZHVsZXMvc3RyaW5naWZ5LWVudGl0aWVzL2xpYi91dGlsL3RvLWRlY2ltYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGVjaW1hbFJlZ2V4ID0gL1xcZC9cblxuLyoqXG4gKiBDb25maWd1cmFibGUgd2F5cyB0byBlbmNvZGUgY2hhcmFjdGVycyBhcyBkZWNpbWFsIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBvbWl0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZWNpbWFsKGNvZGUsIG5leHQsIG9taXQpIHtcbiAgY29uc3QgdmFsdWUgPSAnJiMnICsgU3RyaW5nKGNvZGUpXG4gIHJldHVybiBvbWl0ICYmIG5leHQgJiYgIWRlY2ltYWxSZWdleC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dCkpXG4gICAgPyB2YWx1ZVxuICAgIDogdmFsdWUgKyAnOydcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-decimal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-hexadecimal.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-hexadecimal.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toHexadecimal: () => (/* binding */ toHexadecimal)\n/* harmony export */ });\nconst hexadecimalRegex = /[\\dA-Fa-f]/\n\n/**\n * Configurable ways to encode characters as hexadecimal references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @returns {string}\n */\nfunction toHexadecimal(code, next, omit) {\n  const value = '&#x' + code.toString(16).toUpperCase()\n  return omit && next && !hexadecimalRegex.test(String.fromCharCode(next))\n    ? value\n    : value + ';'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvdXRpbC90by1oZXhhZGVjaW1hbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvdXRpbC90by1oZXhhZGVjaW1hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoZXhhZGVjaW1hbFJlZ2V4ID0gL1tcXGRBLUZhLWZdL1xuXG4vKipcbiAqIENvbmZpZ3VyYWJsZSB3YXlzIHRvIGVuY29kZSBjaGFyYWN0ZXJzIGFzIGhleGFkZWNpbWFsIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBvbWl0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXhhZGVjaW1hbChjb2RlLCBuZXh0LCBvbWl0KSB7XG4gIGNvbnN0IHZhbHVlID0gJyYjeCcgKyBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIHJldHVybiBvbWl0ICYmIG5leHQgJiYgIWhleGFkZWNpbWFsUmVnZXgudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQpKVxuICAgID8gdmFsdWVcbiAgICA6IHZhbHVlICsgJzsnXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-hexadecimal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-named.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-named.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toNamed: () => (/* binding */ toNamed)\n/* harmony export */ });\n/* harmony import */ var character_entities_legacy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! character-entities-legacy */ \"(app-pages-browser)/./node_modules/.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js\");\n/* harmony import */ var character_entities_html4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! character-entities-html4 */ \"(app-pages-browser)/./node_modules/.pnpm/character-entities-html4@2.1.0/node_modules/character-entities-html4/index.js\");\n/* harmony import */ var _constant_dangerous_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant/dangerous.js */ \"(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/constant/dangerous.js\");\n\n\n\n\nconst own = {}.hasOwnProperty\n\n/**\n * `characterEntitiesHtml4` but inverted.\n *\n * @type {Record<string, string>}\n */\nconst characters = {}\n\n/** @type {string} */\nlet key\n\nfor (key in character_entities_html4__WEBPACK_IMPORTED_MODULE_0__.characterEntitiesHtml4) {\n  if (own.call(character_entities_html4__WEBPACK_IMPORTED_MODULE_0__.characterEntitiesHtml4, key)) {\n    characters[character_entities_html4__WEBPACK_IMPORTED_MODULE_0__.characterEntitiesHtml4[key]] = key\n  }\n}\n\nconst notAlphanumericRegex = /[^\\dA-Za-z]/\n\n/**\n * Configurable ways to encode characters as named references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @param {boolean|undefined} attribute\n * @returns {string}\n */\nfunction toNamed(code, next, omit, attribute) {\n  const character = String.fromCharCode(code)\n\n  if (own.call(characters, character)) {\n    const name = characters[character]\n    const value = '&' + name\n\n    if (\n      omit &&\n      character_entities_legacy__WEBPACK_IMPORTED_MODULE_1__.characterEntitiesLegacy.includes(name) &&\n      !_constant_dangerous_js__WEBPACK_IMPORTED_MODULE_2__.dangerous.includes(name) &&\n      (!attribute ||\n        (next &&\n          next !== 61 /* `=` */ &&\n          notAlphanumericRegex.test(String.fromCharCode(next))))\n    ) {\n      return value\n    }\n\n    return value + ';'\n  }\n\n  return ''\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zdHJpbmdpZnktZW50aXRpZXNANC4wLjQvbm9kZV9tb2R1bGVzL3N0cmluZ2lmeS1lbnRpdGllcy9saWIvdXRpbC90by1uYW1lZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlFO0FBQ0Y7QUFDYjs7QUFFbEQsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUEsWUFBWSw0RUFBc0I7QUFDbEMsZUFBZSw0RUFBc0I7QUFDckMsZUFBZSw0RUFBc0I7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDhFQUF1QjtBQUM3QixPQUFPLDZEQUFTO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3N0cmluZ2lmeS1lbnRpdGllc0A0LjAuNC9ub2RlX21vZHVsZXMvc3RyaW5naWZ5LWVudGl0aWVzL2xpYi91dGlsL3RvLW5hbWVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y2hhcmFjdGVyRW50aXRpZXNMZWdhY3l9IGZyb20gJ2NoYXJhY3Rlci1lbnRpdGllcy1sZWdhY3knXG5pbXBvcnQge2NoYXJhY3RlckVudGl0aWVzSHRtbDR9IGZyb20gJ2NoYXJhY3Rlci1lbnRpdGllcy1odG1sNCdcbmltcG9ydCB7ZGFuZ2Vyb3VzfSBmcm9tICcuLi9jb25zdGFudC9kYW5nZXJvdXMuanMnXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKlxuICogYGNoYXJhY3RlckVudGl0aWVzSHRtbDRgIGJ1dCBpbnZlcnRlZC5cbiAqXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuY29uc3QgY2hhcmFjdGVycyA9IHt9XG5cbi8qKiBAdHlwZSB7c3RyaW5nfSAqL1xubGV0IGtleVxuXG5mb3IgKGtleSBpbiBjaGFyYWN0ZXJFbnRpdGllc0h0bWw0KSB7XG4gIGlmIChvd24uY2FsbChjaGFyYWN0ZXJFbnRpdGllc0h0bWw0LCBrZXkpKSB7XG4gICAgY2hhcmFjdGVyc1tjaGFyYWN0ZXJFbnRpdGllc0h0bWw0W2tleV1dID0ga2V5XG4gIH1cbn1cblxuY29uc3Qgbm90QWxwaGFudW1lcmljUmVnZXggPSAvW15cXGRBLVphLXpdL1xuXG4vKipcbiAqIENvbmZpZ3VyYWJsZSB3YXlzIHRvIGVuY29kZSBjaGFyYWN0ZXJzIGFzIG5hbWVkIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBvbWl0XG4gKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b05hbWVkKGNvZGUsIG5leHQsIG9taXQsIGF0dHJpYnV0ZSkge1xuICBjb25zdCBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXG5cbiAgaWYgKG93bi5jYWxsKGNoYXJhY3RlcnMsIGNoYXJhY3RlcikpIHtcbiAgICBjb25zdCBuYW1lID0gY2hhcmFjdGVyc1tjaGFyYWN0ZXJdXG4gICAgY29uc3QgdmFsdWUgPSAnJicgKyBuYW1lXG5cbiAgICBpZiAoXG4gICAgICBvbWl0ICYmXG4gICAgICBjaGFyYWN0ZXJFbnRpdGllc0xlZ2FjeS5pbmNsdWRlcyhuYW1lKSAmJlxuICAgICAgIWRhbmdlcm91cy5pbmNsdWRlcyhuYW1lKSAmJlxuICAgICAgKCFhdHRyaWJ1dGUgfHxcbiAgICAgICAgKG5leHQgJiZcbiAgICAgICAgICBuZXh0ICE9PSA2MSAvKiBgPWAgKi8gJiZcbiAgICAgICAgICBub3RBbHBoYW51bWVyaWNSZWdleC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dCkpKSlcbiAgICApIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSArICc7J1xuICB9XG5cbiAgcmV0dXJuICcnXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/to-named.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/zwitch@2.0.4/node_modules/zwitch/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/zwitch@2.0.4/node_modules/zwitch/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   zwitch: () => (/* binding */ zwitch)\n/* harmony export */ });\n/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and its value is this functions\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but its set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nfunction zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesnt have a `key` property, the special\n   * invalid handler will be called.\n   * If `value` has an unknown `key`, the special unknown handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and its result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but its set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS96d2l0Y2hAMi4wLjQvbm9kZV9tb2R1bGVzL3p3aXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMseUJBQXlCO0FBQ3ZDLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcscUNBQXFDO0FBQ2hEO0FBQ0EsY0FBYztBQUNkO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL3p3aXRjaEAyLjAuNC9ub2RlX21vZHVsZXMvendpdGNoL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGNhbGxiYWNrIEhhbmRsZXJcbiAqICAgSGFuZGxlIGEgdmFsdWUsIHdpdGggYSBjZXJ0YWluIElEIGZpZWxkIHNldCB0byBhIGNlcnRhaW4gdmFsdWUuXG4gKiAgIFRoZSBJRCBmaWVsZCBpcyBwYXNzZWQgdG8gYHp3aXRjaGAsIGFuZCBpdOKAmXMgdmFsdWUgaXMgdGhpcyBmdW5jdGlvbuKAmXNcbiAqICAgcGxhY2Ugb24gdGhlIGBoYW5kbGVyc2AgcmVjb3JkLlxuICogQHBhcmFtIHsuLi5hbnl9IHBhcmFtZXRlcnNcbiAqICAgQXJiaXRyYXJ5IHBhcmFtZXRlcnMgcGFzc2VkIHRvIHRoZSB6d2l0Y2guXG4gKiAgIFRoZSBmaXJzdCB3aWxsIGJlIGFuIG9iamVjdCB3aXRoIGEgY2VydGFpbiBJRCBmaWVsZCBzZXQgdG8gYSBjZXJ0YWluIHZhbHVlLlxuICogQHJldHVybnMge2FueX1cbiAqICAgQW55dGhpbmchXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgVW5rbm93bkhhbmRsZXJcbiAqICAgSGFuZGxlIHZhbHVlcyB0aGF0IGRvIGhhdmUgYSBjZXJ0YWluIElEIGZpZWxkLCBidXQgaXTigJlzIHNldCB0byBhIHZhbHVlXG4gKiAgIHRoYXQgaXMgbm90IGxpc3RlZCBpbiB0aGUgYGhhbmRsZXJzYCByZWNvcmQuXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiAgIEFuIG9iamVjdCB3aXRoIGEgY2VydGFpbiBJRCBmaWVsZCBzZXQgdG8gYW4gdW5rbm93biB2YWx1ZS5cbiAqIEBwYXJhbSB7Li4uYW55fSByZXN0XG4gKiAgIEFyYml0cmFyeSBwYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGUgendpdGNoLlxuICogQHJldHVybnMge2FueX1cbiAqICAgQW55dGhpbmchXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgSW52YWxpZEhhbmRsZXJcbiAqICAgSGFuZGxlIHZhbHVlcyB0aGF0IGRvIG5vdCBoYXZlIGEgY2VydGFpbiBJRCBmaWVsZC5cbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqICAgQW55IHVua25vd24gdmFsdWUuXG4gKiBAcGFyYW0gey4uLmFueX0gcmVzdFxuICogICBBcmJpdHJhcnkgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIHp3aXRjaC5cbiAqIEByZXR1cm5zIHt2b2lkfG51bGx8dW5kZWZpbmVkfG5ldmVyfVxuICogICBUaGlzIHNob3VsZCBjcmFzaCBvciByZXR1cm4gbm90aGluZy5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7SW52YWxpZEhhbmRsZXJ9IFtJbnZhbGlkPUludmFsaWRIYW5kbGVyXVxuICogQHRlbXBsYXRlIHtVbmtub3duSGFuZGxlcn0gW1Vua25vd249VW5rbm93bkhhbmRsZXJdXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIEhhbmRsZXI+fSBbSGFuZGxlcnM9UmVjb3JkPHN0cmluZywgSGFuZGxlcj5dXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gKHJlcXVpcmVkKS5cbiAqIEBwcm9wZXJ0eSB7SW52YWxpZH0gW2ludmFsaWRdXG4gKiAgIEhhbmRsZXIgdG8gdXNlIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAqIEBwcm9wZXJ0eSB7VW5rbm93bn0gW3Vua25vd25dXG4gKiAgIEhhbmRsZXIgdG8gdXNlIGZvciB1bmtub3duIHZhbHVlcy5cbiAqIEBwcm9wZXJ0eSB7SGFuZGxlcnN9IFtoYW5kbGVyc11cbiAqICAgSGFuZGxlcnMgdG8gdXNlLlxuICovXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKlxuICogSGFuZGxlIHZhbHVlcyBiYXNlZCBvbiBhIGZpZWxkLlxuICpcbiAqIEB0ZW1wbGF0ZSB7SW52YWxpZEhhbmRsZXJ9IFtJbnZhbGlkPUludmFsaWRIYW5kbGVyXVxuICogQHRlbXBsYXRlIHtVbmtub3duSGFuZGxlcn0gW1Vua25vd249VW5rbm93bkhhbmRsZXJdXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIEhhbmRsZXI+fSBbSGFuZGxlcnM9UmVjb3JkPHN0cmluZywgSGFuZGxlcj5dXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiAgIEZpZWxkIHRvIHN3aXRjaCBvbi5cbiAqIEBwYXJhbSB7T3B0aW9uczxJbnZhbGlkLCBVbmtub3duLCBIYW5kbGVycz59IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChyZXF1aXJlZCkuXG4gKiBAcmV0dXJucyB7e3Vua25vd246IFVua25vd24sIGludmFsaWQ6IEludmFsaWQsIGhhbmRsZXJzOiBIYW5kbGVycywgKC4uLnBhcmFtZXRlcnM6IFBhcmFtZXRlcnM8SGFuZGxlcnNba2V5b2YgSGFuZGxlcnNdPik6IFJldHVyblR5cGU8SGFuZGxlcnNba2V5b2YgSGFuZGxlcnNdPiwgKC4uLnBhcmFtZXRlcnM6IFBhcmFtZXRlcnM8VW5rbm93bj4pOiBSZXR1cm5UeXBlPFVua25vd24+fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHp3aXRjaChrZXksIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBvcHRpb25zIHx8IHt9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBvbmUgdmFsdWUuXG4gICAqXG4gICAqIEJhc2VkIG9uIHRoZSBib3VuZCBga2V5YCwgYSByZXNwZWN0aXZlIGhhbmRsZXIgd2lsbCBiZSBjYWxsZWQuXG4gICAqIElmIGB2YWx1ZWAgaXMgbm90IGFuIG9iamVjdCwgb3IgZG9lc27igJl0IGhhdmUgYSBga2V5YCBwcm9wZXJ0eSwgdGhlIHNwZWNpYWxcbiAgICog4oCcaW52YWxpZOKAnSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkLlxuICAgKiBJZiBgdmFsdWVgIGhhcyBhbiB1bmtub3duIGBrZXlgLCB0aGUgc3BlY2lhbCDigJx1bmtub3du4oCdIGhhbmRsZXIgd2lsbCBiZVxuICAgKiBjYWxsZWQuXG4gICAqXG4gICAqIEFsbCBhcmd1bWVudHMsIGFuZCB0aGUgY29udGV4dCBvYmplY3QsIGFyZSBwYXNzZWQgdGhyb3VnaCB0byB0aGUgaGFuZGxlcixcbiAgICogYW5kIGl04oCZcyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEB0aGlzIHt1bmtub3dufVxuICAgKiAgIEFueSBjb250ZXh0IG9iamVjdC5cbiAgICogQHBhcmFtIHt1bmtub3dufSBbdmFsdWVdXG4gICAqICAgQW55IHZhbHVlLlxuICAgKiBAcGFyYW0gey4uLnVua25vd259IHBhcmFtZXRlcnNcbiAgICogICBBcmJpdHJhcnkgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIHp3aXRjaC5cbiAgICogQHByb3BlcnR5IHtIYW5kbGVyfSBpbnZhbGlkXG4gICAqICAgSGFuZGxlIGZvciB2YWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBhIGNlcnRhaW4gSUQgZmllbGQuXG4gICAqIEBwcm9wZXJ0eSB7SGFuZGxlcn0gdW5rbm93blxuICAgKiAgIEhhbmRsZSB2YWx1ZXMgdGhhdCBkbyBoYXZlIGEgY2VydGFpbiBJRCBmaWVsZCwgYnV0IGl04oCZcyBzZXQgdG8gYSB2YWx1ZVxuICAgKiAgIHRoYXQgaXMgbm90IGxpc3RlZCBpbiB0aGUgYGhhbmRsZXJzYCByZWNvcmQuXG4gICAqIEBwcm9wZXJ0eSB7SGFuZGxlcnN9IGhhbmRsZXJzXG4gICAqICAgUmVjb3JkIG9mIGhhbmRsZXJzLlxuICAgKiBAcmV0dXJucyB7dW5rbm93bn1cbiAgICogICBBbnl0aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIG9uZSh2YWx1ZSwgLi4ucGFyYW1ldGVycykge1xuICAgIC8qKiBAdHlwZSB7SGFuZGxlcnx1bmRlZmluZWR9ICovXG4gICAgbGV0IGZuID0gb25lLmludmFsaWRcbiAgICBjb25zdCBoYW5kbGVycyA9IG9uZS5oYW5kbGVyc1xuXG4gICAgaWYgKHZhbHVlICYmIG93bi5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEluZGV4YWJsZS5cbiAgICAgIGNvbnN0IGlkID0gU3RyaW5nKHZhbHVlW2tleV0pXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEluZGV4YWJsZS5cbiAgICAgIGZuID0gb3duLmNhbGwoaGFuZGxlcnMsIGlkKSA/IGhhbmRsZXJzW2lkXSA6IG9uZS51bmtub3duXG4gICAgfVxuXG4gICAgaWYgKGZuKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB2YWx1ZSwgLi4ucGFyYW1ldGVycylcbiAgICB9XG4gIH1cblxuICBvbmUuaGFuZGxlcnMgPSBzZXR0aW5ncy5oYW5kbGVycyB8fCB7fVxuICBvbmUuaW52YWxpZCA9IHNldHRpbmdzLmludmFsaWRcbiAgb25lLnVua25vd24gPSBzZXR0aW5ncy51bmtub3duXG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbWF0Y2hlcyFcbiAgcmV0dXJuIG9uZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/zwitch@2.0.4/node_modules/zwitch/index.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fdevlog%2Fpages%2FDevlog.tsx%22%2C%22ids%22%3A%5B%22Devlog%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fmdx%2Fcomponents%2FCode.tsx%22%2C%22ids%22%3A%5B%22Code%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Fmdx%2Finline%2Fcode.tsx%22%2C%22ids%22%3A%5B%22Code%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fkatex%400.16.33%2Fnode_modules%2Fkatex%2Fdist%2Fkatex.min.css%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);