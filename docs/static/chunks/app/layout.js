/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Flayout%2Fcomponents%2FSeasonalIcon.tsx%22%2C%22ids%22%3A%5B%22SeasonalIcon%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2Fgoogle%2Fga.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2Fgoogle%2Fgtm.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2FThirdPartyScriptEmbed.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fscript.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22modules%2Flayout%2Ffonts.ts%5C%22%2C%5C%22import%5C%22%3A%5C%22Red_Hat_Text%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22redHatText%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22modules%2Flayout%2Ffonts.ts%5C%22%2C%5C%22import%5C%22%3A%5C%22Red_Hat_Mono%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22redHatMono%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Flayout%2Fcomponents%2FSeasonalIcon.tsx%22%2C%22ids%22%3A%5B%22SeasonalIcon%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2Fgoogle%2Fga.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2Fgoogle%2Fgtm.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2FThirdPartyScriptEmbed.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fscript.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22modules%2Flayout%2Ffonts.ts%5C%22%2C%5C%22import%5C%22%3A%5C%22Red_Hat_Text%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22redHatText%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22modules%2Flayout%2Ffonts.ts%5C%22%2C%5C%22import%5C%22%3A%5C%22Red_Hat_Mono%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22redHatMono%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./modules/layout/components/SeasonalIcon.tsx */ \"(app-pages-browser)/./modules/layout/components/SeasonalIcon.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/ga.js */ \"(app-pages-browser)/./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/ga.js\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/gtm.js */ \"(app-pages-browser)/./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/gtm.js\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/ThirdPartyScriptEmbed.js */ \"(app-pages-browser)/./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/ThirdPartyScriptEmbed.js\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/script.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/script.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Text\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatText\"} */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\\\"path\\\":\\\"modules/layout/fonts.ts\\\",\\\"import\\\":\\\"Red_Hat_Text\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"redHatText\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Mono\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatMono\"} */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\\\"path\\\":\\\"modules/layout/fonts.ts\\\",\\\"import\\\":\\\"Red_Hat_Mono\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"redHatMono\\\"}\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZzYXRoaXJhJTJGUHJvamVjdHMlMkZncm90dG8lMkZhcHAlMkZnbG9iYWxzLmNzcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRnNhdGhpcmElMkZQcm9qZWN0cyUyRmdyb3R0byUyRm1vZHVsZXMlMkZsYXlvdXQlMkZjb21wb25lbnRzJTJGU2Vhc29uYWxJY29uLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMlNlYXNvbmFsSWNvbiUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRnNhdGhpcmElMkZQcm9qZWN0cyUyRmdyb3R0byUyRm5vZGVfbW9kdWxlcyUyRi5wbnBtJTJGJTQwbmV4dCUyQnRoaXJkLXBhcnRpZXMlNDAxNS4xLjRfbmV4dCU0MDE1LjEuNF9yZWFjdC1kb20lNDAxOS4wLjBfcmVhY3QlNDAxOS4wLjBfX3JlYWN0JTQwMTkuMC4wX19yZWFjdCU0MDE5LjAuMCUyRm5vZGVfbW9kdWxlcyUyRiU0MG5leHQlMkZ0aGlyZC1wYXJ0aWVzJTJGZGlzdCUyRmdvb2dsZSUyRmdhLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGc2F0aGlyYSUyRlByb2plY3RzJTJGZ3JvdHRvJTJGbm9kZV9tb2R1bGVzJTJGLnBucG0lMkYlNDBuZXh0JTJCdGhpcmQtcGFydGllcyU0MDE1LjEuNF9uZXh0JTQwMTUuMS40X3JlYWN0LWRvbSU0MDE5LjAuMF9yZWFjdCU0MDE5LjAuMF9fcmVhY3QlNDAxOS4wLjBfX3JlYWN0JTQwMTkuMC4wJTJGbm9kZV9tb2R1bGVzJTJGJTQwbmV4dCUyRnRoaXJkLXBhcnRpZXMlMkZkaXN0JTJGZ29vZ2xlJTJGZ3RtLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGc2F0aGlyYSUyRlByb2plY3RzJTJGZ3JvdHRvJTJGbm9kZV9tb2R1bGVzJTJGLnBucG0lMkYlNDBuZXh0JTJCdGhpcmQtcGFydGllcyU0MDE1LjEuNF9uZXh0JTQwMTUuMS40X3JlYWN0LWRvbSU0MDE5LjAuMF9yZWFjdCU0MDE5LjAuMF9fcmVhY3QlNDAxOS4wLjBfX3JlYWN0JTQwMTkuMC4wJTJGbm9kZV9tb2R1bGVzJTJGJTQwbmV4dCUyRnRoaXJkLXBhcnRpZXMlMkZkaXN0JTJGVGhpcmRQYXJ0eVNjcmlwdEVtYmVkLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyKiUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRnNhdGhpcmElMkZQcm9qZWN0cyUyRmdyb3R0byUyRm5vZGVfbW9kdWxlcyUyRi5wbnBtJTJGbmV4dCU0MDE1LjEuNF9yZWFjdC1kb20lNDAxOS4wLjBfcmVhY3QlNDAxOS4wLjBfX3JlYWN0JTQwMTkuMC4wJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZzY3JpcHQuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjIqJTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGc2F0aGlyYSUyRlByb2plY3RzJTJGZ3JvdHRvJTJGbm9kZV9tb2R1bGVzJTJGLnBucG0lMkZuZXh0JTQwMTUuMS40X3JlYWN0LWRvbSU0MDE5LjAuMF9yZWFjdCU0MDE5LjAuMF9fcmVhY3QlNDAxOS4wLjAlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZm9udCUyRmdvb2dsZSUyRnRhcmdldC5jc3MlM0YlN0IlNUMlMjJwYXRoJTVDJTIyJTNBJTVDJTIybW9kdWxlcyUyRmxheW91dCUyRmZvbnRzLnRzJTVDJTIyJTJDJTVDJTIyaW1wb3J0JTVDJTIyJTNBJTVDJTIyUmVkX0hhdF9UZXh0JTVDJTIyJTJDJTVDJTIyYXJndW1lbnRzJTVDJTIyJTNBJTVCJTdCJTVDJTIyc3Vic2V0cyU1QyUyMiUzQSU1QiU1QyUyMmxhdGluJTVDJTIyJTVEJTdEJTVEJTJDJTVDJTIydmFyaWFibGVOYW1lJTVDJTIyJTNBJTVDJTIycmVkSGF0VGV4dCU1QyUyMiU3RCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRnNhdGhpcmElMkZQcm9qZWN0cyUyRmdyb3R0byUyRm5vZGVfbW9kdWxlcyUyRi5wbnBtJTJGbmV4dCU0MDE1LjEuNF9yZWFjdC1kb20lNDAxOS4wLjBfcmVhY3QlNDAxOS4wLjBfX3JlYWN0JTQwMTkuMC4wJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmZvbnQlMkZnb29nbGUlMkZ0YXJnZXQuY3NzJTNGJTdCJTVDJTIycGF0aCU1QyUyMiUzQSU1QyUyMm1vZHVsZXMlMkZsYXlvdXQlMkZmb250cy50cyU1QyUyMiUyQyU1QyUyMmltcG9ydCU1QyUyMiUzQSU1QyUyMlJlZF9IYXRfTW9ubyU1QyUyMiUyQyU1QyUyMmFyZ3VtZW50cyU1QyUyMiUzQSU1QiU3QiU1QyUyMnN1YnNldHMlNUMlMjIlM0ElNUIlNUMlMjJsYXRpbiU1QyUyMiU1RCU3RCU1RCUyQyU1QyUyMnZhcmlhYmxlTmFtZSU1QyUyMiUzQSU1QyUyMnJlZEhhdE1vbm8lNUMlMjIlN0QlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw0SkFBbUY7QUFDbkY7QUFDQSxrTkFBZ0o7QUFDaEo7QUFDQSwwY0FBME87QUFDMU87QUFDQSw0Y0FBMk87QUFDM087QUFDQSxrZUFBc1A7QUFDdFA7QUFDQSx3V0FBc0w7QUFDdEw7QUFDQSxrbkJBQW9VO0FBQ3BVO0FBQ0Esa25CQUFvVSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL2FwcC9nbG9iYWxzLmNzc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiU2Vhc29uYWxJY29uXCJdICovIFwiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL21vZHVsZXMvbGF5b3V0L2NvbXBvbmVudHMvU2Vhc29uYWxJY29uLnRzeFwiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9AbmV4dCt0aGlyZC1wYXJ0aWVzQDE1LjEuNF9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0BuZXh0L3RoaXJkLXBhcnRpZXMvZGlzdC9nb29nbGUvZ2EuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vQG5leHQrdGhpcmQtcGFydGllc0AxNS4xLjRfbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AbmV4dC90aGlyZC1wYXJ0aWVzL2Rpc3QvZ29vZ2xlL2d0bS5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9AbmV4dCt0aGlyZC1wYXJ0aWVzQDE1LjEuNF9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0BuZXh0L3RoaXJkLXBhcnRpZXMvZGlzdC9UaGlyZFBhcnR5U2NyaXB0RW1iZWQuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9zY3JpcHQuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcXFwicGF0aFxcXCI6XFxcIm1vZHVsZXMvbGF5b3V0L2ZvbnRzLnRzXFxcIixcXFwiaW1wb3J0XFxcIjpcXFwiUmVkX0hhdF9UZXh0XFxcIixcXFwiYXJndW1lbnRzXFxcIjpbe1xcXCJzdWJzZXRzXFxcIjpbXFxcImxhdGluXFxcIl19XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwicmVkSGF0VGV4dFxcXCJ9XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTUuMS40X3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XFxcInBhdGhcXFwiOlxcXCJtb2R1bGVzL2xheW91dC9mb250cy50c1xcXCIsXFxcImltcG9ydFxcXCI6XFxcIlJlZF9IYXRfTW9ub1xcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdfV0sXFxcInZhcmlhYmxlTmFtZVxcXCI6XFxcInJlZEhhdE1vbm9cXFwifVwiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Flayout%2Fcomponents%2FSeasonalIcon.tsx%22%2C%22ids%22%3A%5B%22SeasonalIcon%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2Fgoogle%2Fga.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2Fgoogle%2Fgtm.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2FThirdPartyScriptEmbed.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fscript.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22modules%2Flayout%2Ffonts.ts%5C%22%2C%5C%22import%5C%22%3A%5C%22Red_Hat_Text%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22redHatText%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22modules%2Flayout%2Ffonts.ts%5C%22%2C%5C%22import%5C%22%3A%5C%22Red_Hat_Mono%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22redHatMono%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/ThirdPartyScriptEmbed.js":
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/ThirdPartyScriptEmbed.js ***!
  \********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = ThirdPartyScriptEmbed;\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\nfunction ThirdPartyScriptEmbed(param) {\n    let { html, height = null, width = null, children, dataNtpc = '' } = param;\n    (0, react_1.useEffect)(()=>{\n        if (dataNtpc) {\n            // performance.mark is being used as a feature use signal. While it is traditionally used for performance\n            // benchmarking it is low overhead and thus considered safe to use in production and it is a widely available\n            // existing API.\n            performance.mark('mark_feature_usage', {\n                detail: {\n                    feature: \"next-third-parties-\".concat(dataNtpc)\n                }\n            });\n        }\n    }, [\n        dataNtpc\n    ]);\n    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, {\n        children: [\n            children,\n            html ? (0, jsx_runtime_1.jsx)(\"div\", {\n                style: {\n                    height: height != null ? \"\".concat(height, \"px\") : 'auto',\n                    width: width != null ? \"\".concat(width, \"px\") : 'auto'\n                },\n                \"data-ntpc\": dataNtpc,\n                dangerouslySetInnerHTML: {\n                    __html: html\n                }\n            }) : null\n        ]\n    });\n}\n_c = ThirdPartyScriptEmbed;\nvar _c;\n$RefreshReg$(_c, \"ThirdPartyScriptEmbed\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmV4dCt0aGlyZC1wYXJ0aWVzQDE1LjEuNF9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0BuZXh0L3RoaXJkLXBhcnRpZXMvZGlzdC9UaGlyZFBhcnR5U2NyaXB0RW1iZWQuanMiLCJtYXBwaW5ncyI6InFEQUFhO0FBRWJBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBZSxHQUFHRztBQUNsQixNQUFNQyxnQkFBZ0JDLG1CQUFPQSxDQUFDLGdMQUFtQjtBQUNqRCxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyw4SkFBTztBQUMvQixTQUFTRixzQkFBc0IsS0FBK0Q7UUFBL0QsRUFBRUksSUFBSSxFQUFFQyxTQUFTLElBQUksRUFBRUMsUUFBUSxJQUFJLEVBQUVDLFFBQVEsRUFBRUMsV0FBVyxFQUFFLEVBQUcsR0FBL0Q7SUFDMUIsSUFBR0wsUUFBUU0sU0FBUyxFQUFFO1FBQ25CLElBQUlELFVBQVU7WUFDVix5R0FBeUc7WUFDekcsNkdBQTZHO1lBQzdHLGdCQUFnQjtZQUNoQkUsWUFBWUMsSUFBSSxDQUFDLHNCQUFzQjtnQkFDbkNDLFFBQVE7b0JBQ0pDLFNBQVMsc0JBQStCLE9BQVRMO2dCQUNuQztZQUNKO1FBQ0o7SUFDSixHQUFHO1FBQUNBO0tBQVM7SUFDYixPQUFRLENBQUMsR0FBR1AsY0FBY2EsSUFBSSxFQUFFYixjQUFjYyxRQUFRLEVBQUU7UUFBRVIsVUFBVTtZQUFDQTtZQUFVSCxPQUFRLENBQUMsR0FBR0gsY0FBY2UsR0FBRyxFQUFFLE9BQU87Z0JBQUVDLE9BQU87b0JBQzlHWixRQUFRQSxVQUFVLE9BQU8sR0FBVSxPQUFQQSxRQUFPLFFBQU07b0JBQ3pDQyxPQUFPQSxTQUFTLE9BQU8sR0FBUyxPQUFOQSxPQUFNLFFBQU07Z0JBQzFDO2dCQUFHLGFBQWFFO2dCQUFVVSx5QkFBeUI7b0JBQUVDLFFBQVFmO2dCQUFLO1lBQUUsS0FBTTtTQUFLO0lBQUM7QUFDaEc7S0FqQlNKIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZXh0K3RoaXJkLXBhcnRpZXNAMTUuMS40X25leHRAMTUuMS40X3JlYWN0LWRvbUAxOS4wLjBfcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvQG5leHQvdGhpcmQtcGFydGllcy9kaXN0L1RoaXJkUGFydHlTY3JpcHRFbWJlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbid1c2UgY2xpZW50Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRoaXJkUGFydHlTY3JpcHRFbWJlZDtcbmNvbnN0IGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gVGhpcmRQYXJ0eVNjcmlwdEVtYmVkKHsgaHRtbCwgaGVpZ2h0ID0gbnVsbCwgd2lkdGggPSBudWxsLCBjaGlsZHJlbiwgZGF0YU50cGMgPSAnJywgfSkge1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgICBpZiAoZGF0YU50cGMpIHtcbiAgICAgICAgICAgIC8vIHBlcmZvcm1hbmNlLm1hcmsgaXMgYmVpbmcgdXNlZCBhcyBhIGZlYXR1cmUgdXNlIHNpZ25hbC4gV2hpbGUgaXQgaXMgdHJhZGl0aW9uYWxseSB1c2VkIGZvciBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gYmVuY2htYXJraW5nIGl0IGlzIGxvdyBvdmVyaGVhZCBhbmQgdGh1cyBjb25zaWRlcmVkIHNhZmUgdG8gdXNlIGluIHByb2R1Y3Rpb24gYW5kIGl0IGlzIGEgd2lkZWx5IGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gZXhpc3RpbmcgQVBJLlxuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnbWFya19mZWF0dXJlX3VzYWdlJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlOiBgbmV4dC10aGlyZC1wYXJ0aWVzLSR7ZGF0YU50cGN9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGF0YU50cGNdKTtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKGpzeF9ydW50aW1lXzEuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtjaGlsZHJlbiwgaHRtbCA/ICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgIT0gbnVsbCA/IGAke2hlaWdodH1weGAgOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCAhPSBudWxsID8gYCR7d2lkdGh9cHhgIDogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIH0sIFwiZGF0YS1udHBjXCI6IGRhdGFOdHBjLCBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGh0bWwgfSB9KSkgOiBudWxsXSB9KSk7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiVGhpcmRQYXJ0eVNjcmlwdEVtYmVkIiwianN4X3J1bnRpbWVfMSIsInJlcXVpcmUiLCJyZWFjdF8xIiwiaHRtbCIsImhlaWdodCIsIndpZHRoIiwiY2hpbGRyZW4iLCJkYXRhTnRwYyIsInVzZUVmZmVjdCIsInBlcmZvcm1hbmNlIiwibWFyayIsImRldGFpbCIsImZlYXR1cmUiLCJqc3hzIiwiRnJhZ21lbnQiLCJqc3giLCJzdHlsZSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/ThirdPartyScriptEmbed.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/ga.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/ga.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GoogleAnalytics = GoogleAnalytics;\nexports.sendGAEvent = sendGAEvent;\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n// TODO: Evaluate import 'client only'\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\nconst script_1 = __importDefault(__webpack_require__(/*! next/script */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/script.js\"));\nlet currDataLayerName = undefined;\nfunction GoogleAnalytics(props) {\n    const { gaId, debugMode, dataLayerName = 'dataLayer', nonce } = props;\n    if (currDataLayerName === undefined) {\n        currDataLayerName = dataLayerName;\n    }\n    (0, react_1.useEffect)(()=>{\n        // performance.mark is being used as a feature use signal. While it is traditionally used for performance\n        // benchmarking it is low overhead and thus considered safe to use in production and it is a widely available\n        // existing API.\n        // The performance measurement will be handled by Chrome Aurora\n        performance.mark('mark_feature_usage', {\n            detail: {\n                feature: 'next-third-parties-ga'\n            }\n        });\n    }, []);\n    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, {\n        children: [\n            (0, jsx_runtime_1.jsx)(script_1.default, {\n                id: \"_next-ga-init\",\n                dangerouslySetInnerHTML: {\n                    __html: \"\\n          window['\".concat(dataLayerName, \"'] = window['\").concat(dataLayerName, \"'] || [];\\n          function gtag(){window['\").concat(dataLayerName, \"'].push(arguments);}\\n          gtag('js', new Date());\\n\\n          gtag('config', '\").concat(gaId, \"' \").concat(debugMode ? \",{ 'debug_mode': true }\" : '', \");\")\n                },\n                nonce: nonce\n            }),\n            (0, jsx_runtime_1.jsx)(script_1.default, {\n                id: \"_next-ga\",\n                src: \"https://www.googletagmanager.com/gtag/js?id=\".concat(gaId),\n                nonce: nonce\n            })\n        ]\n    });\n}\n_c = GoogleAnalytics;\nfunction sendGAEvent() {\n    for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++){\n        _args[_key] = arguments[_key];\n    }\n    if (currDataLayerName === undefined) {\n        console.warn(\"@next/third-parties: GA has not been initialized\");\n        return;\n    }\n    if (window[currDataLayerName]) {\n        window[currDataLayerName].push(arguments);\n    } else {\n        console.warn(\"@next/third-parties: GA dataLayer \".concat(currDataLayerName, \" does not exist\"));\n    }\n}\nvar _c;\n$RefreshReg$(_c, \"GoogleAnalytics\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmV4dCt0aGlyZC1wYXJ0aWVzQDE1LjEuNF9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0BuZXh0L3RoaXJkLXBhcnRpZXMvZGlzdC9nb29nbGUvZ2EuanMiLCJtYXBwaW5ncyI6InFEQUFhO0FBRWIsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBR0U7QUFDMUJGLG1CQUFtQixHQUFHRztBQUN0QixNQUFNQyxnQkFBZ0JDLG1CQUFPQSxDQUFDLGdMQUFtQjtBQUNqRCxzQ0FBc0M7QUFDdEMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsOEpBQU87QUFDL0IsTUFBTUUsV0FBV1osZ0JBQWdCVSxtQkFBT0EsQ0FBQywwSkFBYTtBQUN0RCxJQUFJRyxvQkFBb0JDO0FBQ3hCLFNBQVNQLGdCQUFnQlEsS0FBSztJQUMxQixNQUFNLEVBQUVDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxnQkFBZ0IsV0FBVyxFQUFFQyxLQUFLLEVBQUUsR0FBR0o7SUFDaEUsSUFBSUYsc0JBQXNCQyxXQUFXO1FBQ2pDRCxvQkFBb0JLO0lBQ3hCO0lBQ0MsSUFBR1AsUUFBUVMsU0FBUyxFQUFFO1FBQ25CLHlHQUF5RztRQUN6Ryw2R0FBNkc7UUFDN0csZ0JBQWdCO1FBQ2hCLCtEQUErRDtRQUMvREMsWUFBWUMsSUFBSSxDQUFDLHNCQUFzQjtZQUNuQ0MsUUFBUTtnQkFDSkMsU0FBUztZQUNiO1FBQ0o7SUFDSixHQUFHLEVBQUU7SUFDTCxPQUFRLENBQUMsR0FBR2YsY0FBY2dCLElBQUksRUFBRWhCLGNBQWNpQixRQUFRLEVBQUU7UUFBRUMsVUFBVTtZQUFFLElBQUdsQixjQUFjbUIsR0FBRyxFQUFFaEIsU0FBU2lCLE9BQU8sRUFBRTtnQkFBRUMsSUFBSTtnQkFBaUJDLHlCQUF5QjtvQkFDOUlDLFFBQVEsdUJBQ3FCZCxPQUE3QkEsZUFBYyxpQkFDRUEsT0FEYUEsZUFBYyxpREFJbkNGLE9BSFFFLGVBQWMseUZBR2JELE9BQVRELE1BQUssTUFBK0MsT0FBM0NDLFlBQVksNEJBQTRCLElBQUc7Z0JBQ2hFO2dCQUFHRSxPQUFPQTtZQUFNO1lBQUssSUFBR1YsY0FBY21CLEdBQUcsRUFBRWhCLFNBQVNpQixPQUFPLEVBQUU7Z0JBQUVDLElBQUk7Z0JBQVlHLEtBQUssK0NBQW9ELE9BQUxqQjtnQkFBUUcsT0FBT0E7WUFBTTtTQUFHO0lBQUM7QUFDNUs7S0F4QlNaO0FBeUJULFNBQVNDO0lBQVk7UUFBRzBCLE1BQUgsdUJBQVE7O0lBQ3pCLElBQUlyQixzQkFBc0JDLFdBQVc7UUFDakNxQixRQUFRQyxJQUFJLENBQUU7UUFDZDtJQUNKO0lBQ0EsSUFBSUMsTUFBTSxDQUFDeEIsa0JBQWtCLEVBQUU7UUFDM0J3QixNQUFNLENBQUN4QixrQkFBa0IsQ0FBQ3lCLElBQUksQ0FBQ0M7SUFDbkMsT0FDSztRQUNESixRQUFRQyxJQUFJLENBQUMscUNBQXVELE9BQWxCdkIsbUJBQWtCO0lBQ3hFO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vQG5leHQrdGhpcmQtcGFydGllc0AxNS4xLjRfbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9AbmV4dC90aGlyZC1wYXJ0aWVzL2Rpc3QvZ29vZ2xlL2dhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuJ3VzZSBjbGllbnQnO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Hb29nbGVBbmFseXRpY3MgPSBHb29nbGVBbmFseXRpY3M7XG5leHBvcnRzLnNlbmRHQUV2ZW50ID0gc2VuZEdBRXZlbnQ7XG5jb25zdCBqc3hfcnVudGltZV8xID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuLy8gVE9ETzogRXZhbHVhdGUgaW1wb3J0ICdjbGllbnQgb25seSdcbmNvbnN0IHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG5jb25zdCBzY3JpcHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibmV4dC9zY3JpcHRcIikpO1xubGV0IGN1cnJEYXRhTGF5ZXJOYW1lID0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gR29vZ2xlQW5hbHl0aWNzKHByb3BzKSB7XG4gICAgY29uc3QgeyBnYUlkLCBkZWJ1Z01vZGUsIGRhdGFMYXllck5hbWUgPSAnZGF0YUxheWVyJywgbm9uY2UgfSA9IHByb3BzO1xuICAgIGlmIChjdXJyRGF0YUxheWVyTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN1cnJEYXRhTGF5ZXJOYW1lID0gZGF0YUxheWVyTmFtZTtcbiAgICB9XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KSgoKSA9PiB7XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlLm1hcmsgaXMgYmVpbmcgdXNlZCBhcyBhIGZlYXR1cmUgdXNlIHNpZ25hbC4gV2hpbGUgaXQgaXMgdHJhZGl0aW9uYWxseSB1c2VkIGZvciBwZXJmb3JtYW5jZVxuICAgICAgICAvLyBiZW5jaG1hcmtpbmcgaXQgaXMgbG93IG92ZXJoZWFkIGFuZCB0aHVzIGNvbnNpZGVyZWQgc2FmZSB0byB1c2UgaW4gcHJvZHVjdGlvbiBhbmQgaXQgaXMgYSB3aWRlbHkgYXZhaWxhYmxlXG4gICAgICAgIC8vIGV4aXN0aW5nIEFQSS5cbiAgICAgICAgLy8gVGhlIHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IHdpbGwgYmUgaGFuZGxlZCBieSBDaHJvbWUgQXVyb3JhXG4gICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ21hcmtfZmVhdHVyZV91c2FnZScsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGZlYXR1cmU6ICduZXh0LXRoaXJkLXBhcnRpZXMtZ2EnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4cykoanN4X3J1bnRpbWVfMS5GcmFnbWVudCwgeyBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoc2NyaXB0XzEuZGVmYXVsdCwgeyBpZDogXCJfbmV4dC1nYS1pbml0XCIsIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICAgICAgICAgIF9faHRtbDogYFxuICAgICAgICAgIHdpbmRvd1snJHtkYXRhTGF5ZXJOYW1lfSddID0gd2luZG93Wycke2RhdGFMYXllck5hbWV9J10gfHwgW107XG4gICAgICAgICAgZnVuY3Rpb24gZ3RhZygpe3dpbmRvd1snJHtkYXRhTGF5ZXJOYW1lfSddLnB1c2goYXJndW1lbnRzKTt9XG4gICAgICAgICAgZ3RhZygnanMnLCBuZXcgRGF0ZSgpKTtcblxuICAgICAgICAgIGd0YWcoJ2NvbmZpZycsICcke2dhSWR9JyAke2RlYnVnTW9kZSA/IFwiLHsgJ2RlYnVnX21vZGUnOiB0cnVlIH1cIiA6ICcnfSk7YCxcbiAgICAgICAgICAgICAgICB9LCBub25jZTogbm9uY2UgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoc2NyaXB0XzEuZGVmYXVsdCwgeyBpZDogXCJfbmV4dC1nYVwiLCBzcmM6IGBodHRwczovL3d3dy5nb29nbGV0YWdtYW5hZ2VyLmNvbS9ndGFnL2pzP2lkPSR7Z2FJZH1gLCBub25jZTogbm9uY2UgfSldIH0pKTtcbn1cbmZ1bmN0aW9uIHNlbmRHQUV2ZW50KC4uLl9hcmdzKSB7XG4gICAgaWYgKGN1cnJEYXRhTGF5ZXJOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBAbmV4dC90aGlyZC1wYXJ0aWVzOiBHQSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2luZG93W2N1cnJEYXRhTGF5ZXJOYW1lXSkge1xuICAgICAgICB3aW5kb3dbY3VyckRhdGFMYXllck5hbWVdLnB1c2goYXJndW1lbnRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgQG5leHQvdGhpcmQtcGFydGllczogR0EgZGF0YUxheWVyICR7Y3VyckRhdGFMYXllck5hbWV9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkdvb2dsZUFuYWx5dGljcyIsInNlbmRHQUV2ZW50IiwianN4X3J1bnRpbWVfMSIsInJlcXVpcmUiLCJyZWFjdF8xIiwic2NyaXB0XzEiLCJjdXJyRGF0YUxheWVyTmFtZSIsInVuZGVmaW5lZCIsInByb3BzIiwiZ2FJZCIsImRlYnVnTW9kZSIsImRhdGFMYXllck5hbWUiLCJub25jZSIsInVzZUVmZmVjdCIsInBlcmZvcm1hbmNlIiwibWFyayIsImRldGFpbCIsImZlYXR1cmUiLCJqc3hzIiwiRnJhZ21lbnQiLCJjaGlsZHJlbiIsImpzeCIsImRlZmF1bHQiLCJpZCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwic3JjIiwiX2FyZ3MiLCJjb25zb2xlIiwid2FybiIsIndpbmRvdyIsInB1c2giLCJhcmd1bWVudHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/ga.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/gtm.js":
/*!*********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/gtm.js ***!
  \*********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sendGTMEvent = void 0;\nexports.GoogleTagManager = GoogleTagManager;\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n// TODO: Evaluate import 'client only'\nconst react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\nconst script_1 = __importDefault(__webpack_require__(/*! next/script */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/script.js\"));\nlet currDataLayerName = 'dataLayer';\nfunction GoogleTagManager(props) {\n    const { gtmId, gtmScriptUrl = 'https://www.googletagmanager.com/gtm.js', dataLayerName = 'dataLayer', auth, preview, dataLayer, nonce } = props;\n    currDataLayerName = dataLayerName;\n    const gtmLayer = dataLayerName !== 'dataLayer' ? \"&l=\".concat(dataLayerName) : '';\n    const gtmAuth = auth ? \"&gtm_auth=\".concat(auth) : '';\n    const gtmPreview = preview ? \"&gtm_preview=\".concat(preview, \"&gtm_cookies_win=x\") : '';\n    (0, react_1.useEffect)(()=>{\n        // performance.mark is being used as a feature use signal. While it is traditionally used for performance\n        // benchmarking it is low overhead and thus considered safe to use in production and it is a widely available\n        // existing API.\n        // The performance measurement will be handled by Chrome Aurora\n        performance.mark('mark_feature_usage', {\n            detail: {\n                feature: 'next-third-parties-gtm'\n            }\n        });\n    }, []);\n    return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, {\n        children: [\n            (0, jsx_runtime_1.jsx)(script_1.default, {\n                id: \"_next-gtm-init\",\n                dangerouslySetInnerHTML: {\n                    __html: \"\\n      (function(w,l){\\n        w[l]=w[l]||[];\\n        w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});\\n        \".concat(dataLayer ? \"w[l].push(\".concat(JSON.stringify(dataLayer), \")\") : '', \"\\n      })(window,'\").concat(dataLayerName, \"');\")\n                },\n                nonce: nonce\n            }),\n            (0, jsx_runtime_1.jsx)(script_1.default, {\n                id: \"_next-gtm\",\n                \"data-ntpc\": \"GTM\",\n                src: \"\".concat(gtmScriptUrl, \"?id=\").concat(gtmId).concat(gtmLayer).concat(gtmAuth).concat(gtmPreview),\n                nonce: nonce\n            })\n        ]\n    });\n}\n_c = GoogleTagManager;\nconst sendGTMEvent = (data, dataLayerName)=>{\n    // special case if we are sending events before GTM init and we have custom dataLayerName\n    const dataLayer = dataLayerName || currDataLayerName;\n    // define dataLayer so we can still queue up events before GTM init\n    window[dataLayer] = window[dataLayer] || [];\n    window[dataLayer].push(data);\n};\nexports.sendGTMEvent = sendGTMEvent;\nvar _c;\n$RefreshReg$(_c, \"GoogleTagManager\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmV4dCt0aGlyZC1wYXJ0aWVzQDE1LjEuNF9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0BuZXh0L3RoaXJkLXBhcnRpZXMvZGlzdC9nb29nbGUvZ3RtLmpzIiwibWFwcGluZ3MiOiJxREFBYTtBQUViLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QkEsd0JBQXdCLEdBQUdHO0FBQzNCLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsZ0xBQW1CO0FBQ2pELHNDQUFzQztBQUN0QyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyw4SkFBTztBQUMvQixNQUFNRSxXQUFXWixnQkFBZ0JVLG1CQUFPQSxDQUFDLDBKQUFhO0FBQ3RELElBQUlHLG9CQUFvQjtBQUN4QixTQUFTTCxpQkFBaUJNLEtBQUs7SUFDM0IsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLGVBQWUseUNBQXlDLEVBQUVDLGdCQUFnQixXQUFXLEVBQUVDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLEtBQUssRUFBRyxHQUFHUDtJQUMzSUQsb0JBQW9CSTtJQUNwQixNQUFNSyxXQUFXTCxrQkFBa0IsY0FBYyxNQUFvQixPQUFkQSxpQkFBa0I7SUFDekUsTUFBTU0sVUFBVUwsT0FBTyxhQUFrQixPQUFMQSxRQUFTO0lBQzdDLE1BQU1NLGFBQWFMLFVBQVUsZ0JBQXdCLE9BQVJBLFNBQVEsd0JBQXNCO0lBQzFFLElBQUdSLFFBQVFjLFNBQVMsRUFBRTtRQUNuQix5R0FBeUc7UUFDekcsNkdBQTZHO1FBQzdHLGdCQUFnQjtRQUNoQiwrREFBK0Q7UUFDL0RDLFlBQVlDLElBQUksQ0FBQyxzQkFBc0I7WUFDbkNDLFFBQVE7Z0JBQ0pDLFNBQVM7WUFDYjtRQUNKO0lBQ0osR0FBRyxFQUFFO0lBQ0wsT0FBUSxDQUFDLEdBQUdwQixjQUFjcUIsSUFBSSxFQUFFckIsY0FBY3NCLFFBQVEsRUFBRTtRQUFFQyxVQUFVO1lBQUUsSUFBR3ZCLGNBQWN3QixHQUFHLEVBQUVyQixTQUFTc0IsT0FBTyxFQUFFO2dCQUFFQyxJQUFJO2dCQUFrQkMseUJBQXlCO29CQUMvSUMsUUFBUSxvSUFLVHBCLE9BRFRHLFlBQVksYUFBdUMsT0FBMUJrQixLQUFLQyxTQUFTLENBQUNuQixZQUFXLE9BQUssSUFBRyx1QkFDcEMsT0FBZEgsZUFBYztnQkFDakI7Z0JBQUdJLE9BQU9BO1lBQU07WUFBSyxJQUFHWixjQUFjd0IsR0FBRyxFQUFFckIsU0FBU3NCLE9BQU8sRUFBRTtnQkFBRUMsSUFBSTtnQkFBYSxhQUFhO2dCQUFPSyxLQUFLLEdBQXNCekIsT0FBbkJDLGNBQWEsUUFBY00sT0FBUlAsT0FBbUJRLE9BQVhELFVBQXFCRSxPQUFWRCxTQUFxQixPQUFYQztnQkFBY0gsT0FBT0E7WUFBTTtTQUFHO0lBQUM7QUFDM007S0F6QlNiO0FBMEJULE1BQU1ELGVBQWUsQ0FBQ2tDLE1BQU14QjtJQUN4Qix5RkFBeUY7SUFDekYsTUFBTUcsWUFBWUgsaUJBQWlCSjtJQUNuQyxtRUFBbUU7SUFDbkU2QixNQUFNLENBQUN0QixVQUFVLEdBQUdzQixNQUFNLENBQUN0QixVQUFVLElBQUksRUFBRTtJQUMzQ3NCLE1BQU0sQ0FBQ3RCLFVBQVUsQ0FBQ3VCLElBQUksQ0FBQ0Y7QUFDM0I7QUFDQXBDLG9CQUFvQixHQUFHRSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9AbmV4dCt0aGlyZC1wYXJ0aWVzQDE1LjEuNF9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wX19yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL0BuZXh0L3RoaXJkLXBhcnRpZXMvZGlzdC9nb29nbGUvZ3RtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuJ3VzZSBjbGllbnQnO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZW5kR1RNRXZlbnQgPSB2b2lkIDA7XG5leHBvcnRzLkdvb2dsZVRhZ01hbmFnZXIgPSBHb29nbGVUYWdNYW5hZ2VyO1xuY29uc3QganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbi8vIFRPRE86IEV2YWx1YXRlIGltcG9ydCAnY2xpZW50IG9ubHknXG5jb25zdCByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3Qgc2NyaXB0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5leHQvc2NyaXB0XCIpKTtcbmxldCBjdXJyRGF0YUxheWVyTmFtZSA9ICdkYXRhTGF5ZXInO1xuZnVuY3Rpb24gR29vZ2xlVGFnTWFuYWdlcihwcm9wcykge1xuICAgIGNvbnN0IHsgZ3RtSWQsIGd0bVNjcmlwdFVybCA9ICdodHRwczovL3d3dy5nb29nbGV0YWdtYW5hZ2VyLmNvbS9ndG0uanMnLCBkYXRhTGF5ZXJOYW1lID0gJ2RhdGFMYXllcicsIGF1dGgsIHByZXZpZXcsIGRhdGFMYXllciwgbm9uY2UsIH0gPSBwcm9wcztcbiAgICBjdXJyRGF0YUxheWVyTmFtZSA9IGRhdGFMYXllck5hbWU7XG4gICAgY29uc3QgZ3RtTGF5ZXIgPSBkYXRhTGF5ZXJOYW1lICE9PSAnZGF0YUxheWVyJyA/IGAmbD0ke2RhdGFMYXllck5hbWV9YCA6ICcnO1xuICAgIGNvbnN0IGd0bUF1dGggPSBhdXRoID8gYCZndG1fYXV0aD0ke2F1dGh9YCA6ICcnO1xuICAgIGNvbnN0IGd0bVByZXZpZXcgPSBwcmV2aWV3ID8gYCZndG1fcHJldmlldz0ke3ByZXZpZXd9Jmd0bV9jb29raWVzX3dpbj14YCA6ICcnO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgICAvLyBwZXJmb3JtYW5jZS5tYXJrIGlzIGJlaW5nIHVzZWQgYXMgYSBmZWF0dXJlIHVzZSBzaWduYWwuIFdoaWxlIGl0IGlzIHRyYWRpdGlvbmFsbHkgdXNlZCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgLy8gYmVuY2htYXJraW5nIGl0IGlzIGxvdyBvdmVyaGVhZCBhbmQgdGh1cyBjb25zaWRlcmVkIHNhZmUgdG8gdXNlIGluIHByb2R1Y3Rpb24gYW5kIGl0IGlzIGEgd2lkZWx5IGF2YWlsYWJsZVxuICAgICAgICAvLyBleGlzdGluZyBBUEkuXG4gICAgICAgIC8vIFRoZSBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCB3aWxsIGJlIGhhbmRsZWQgYnkgQ2hyb21lIEF1cm9yYVxuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdtYXJrX2ZlYXR1cmVfdXNhZ2UnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlOiAnbmV4dC10aGlyZC1wYXJ0aWVzLWd0bScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShqc3hfcnVudGltZV8xLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShzY3JpcHRfMS5kZWZhdWx0LCB7IGlkOiBcIl9uZXh0LWd0bS1pbml0XCIsIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICAgICAgICAgIF9faHRtbDogYFxuICAgICAgKGZ1bmN0aW9uKHcsbCl7XG4gICAgICAgIHdbbF09d1tsXXx8W107XG4gICAgICAgIHdbbF0ucHVzaCh7J2d0bS5zdGFydCc6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLGV2ZW50OidndG0uanMnfSk7XG4gICAgICAgICR7ZGF0YUxheWVyID8gYHdbbF0ucHVzaCgke0pTT04uc3RyaW5naWZ5KGRhdGFMYXllcil9KWAgOiAnJ31cbiAgICAgIH0pKHdpbmRvdywnJHtkYXRhTGF5ZXJOYW1lfScpO2AsXG4gICAgICAgICAgICAgICAgfSwgbm9uY2U6IG5vbmNlIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKHNjcmlwdF8xLmRlZmF1bHQsIHsgaWQ6IFwiX25leHQtZ3RtXCIsIFwiZGF0YS1udHBjXCI6IFwiR1RNXCIsIHNyYzogYCR7Z3RtU2NyaXB0VXJsfT9pZD0ke2d0bUlkfSR7Z3RtTGF5ZXJ9JHtndG1BdXRofSR7Z3RtUHJldmlld31gLCBub25jZTogbm9uY2UgfSldIH0pKTtcbn1cbmNvbnN0IHNlbmRHVE1FdmVudCA9IChkYXRhLCBkYXRhTGF5ZXJOYW1lKSA9PiB7XG4gICAgLy8gc3BlY2lhbCBjYXNlIGlmIHdlIGFyZSBzZW5kaW5nIGV2ZW50cyBiZWZvcmUgR1RNIGluaXQgYW5kIHdlIGhhdmUgY3VzdG9tIGRhdGFMYXllck5hbWVcbiAgICBjb25zdCBkYXRhTGF5ZXIgPSBkYXRhTGF5ZXJOYW1lIHx8IGN1cnJEYXRhTGF5ZXJOYW1lO1xuICAgIC8vIGRlZmluZSBkYXRhTGF5ZXIgc28gd2UgY2FuIHN0aWxsIHF1ZXVlIHVwIGV2ZW50cyBiZWZvcmUgR1RNIGluaXRcbiAgICB3aW5kb3dbZGF0YUxheWVyXSA9IHdpbmRvd1tkYXRhTGF5ZXJdIHx8IFtdO1xuICAgIHdpbmRvd1tkYXRhTGF5ZXJdLnB1c2goZGF0YSk7XG59O1xuZXhwb3J0cy5zZW5kR1RNRXZlbnQgPSBzZW5kR1RNRXZlbnQ7XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2VuZEdUTUV2ZW50IiwiR29vZ2xlVGFnTWFuYWdlciIsImpzeF9ydW50aW1lXzEiLCJyZXF1aXJlIiwicmVhY3RfMSIsInNjcmlwdF8xIiwiY3VyckRhdGFMYXllck5hbWUiLCJwcm9wcyIsImd0bUlkIiwiZ3RtU2NyaXB0VXJsIiwiZGF0YUxheWVyTmFtZSIsImF1dGgiLCJwcmV2aWV3IiwiZGF0YUxheWVyIiwibm9uY2UiLCJndG1MYXllciIsImd0bUF1dGgiLCJndG1QcmV2aWV3IiwidXNlRWZmZWN0IiwicGVyZm9ybWFuY2UiLCJtYXJrIiwiZGV0YWlsIiwiZmVhdHVyZSIsImpzeHMiLCJGcmFnbWVudCIsImNoaWxkcmVuIiwianN4IiwiZGVmYXVsdCIsImlkIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJKU09OIiwic3RyaW5naWZ5Iiwic3JjIiwiZGF0YSIsIndpbmRvdyIsInB1c2giXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@next+third-parties@15.1.4_next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0__react@19.0.0/node_modules/@next/third-parties/dist/google/gtm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/image.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/image.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWOztBQUU3QyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsJztcbmV4cG9ydCAqIGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/script.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/script.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport default from dynamic */ _client_script__WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var _client_script__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/script */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/script.js\");\n/* harmony import */ var _client_script__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_script__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_script__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_script__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=script.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL3NjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMkM7QUFDVjs7QUFFakMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9zY3JpcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4uL2NsaWVudC9zY3JpcHQnO1xuZXhwb3J0ICogZnJvbSAnLi4vY2xpZW50L3NjcmlwdCc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcmlwdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/script.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={413:(e,r,t)=>{var n=t(916);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},916:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(413);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs0MTM6KGUscix0KT0+e3ZhciBuPXQoOTE2KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDkxNjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNDEzKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/picomatch/index.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/picomatch/index.js ***!
  \***************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUssMENBQTBDLE9BQU8s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Y3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17MTcwOih0LGUsdSk9Pntjb25zdCBuPXUoNTEwKTtjb25zdCBpc1dpbmRvd3M9KCk9PntpZih0eXBlb2YgbmF2aWdhdG9yIT09XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yLnBsYXRmb3JtKXtjb25zdCB0PW5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJ3aW4zMlwifHx0PT09XCJ3aW5kb3dzXCJ9aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLnBsYXRmb3JtKXtyZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIn1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIHBpY29tYXRjaCh0LGUsdT1mYWxzZSl7aWYoZSYmKGUud2luZG93cz09PW51bGx8fGUud2luZG93cz09PXVuZGVmaW5lZCkpe2U9ey4uLmUsd2luZG93czppc1dpbmRvd3MoKX19cmV0dXJuIG4odCxlLHUpfU9iamVjdC5hc3NpZ24ocGljb21hdGNoLG4pO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDE1NDp0PT57Y29uc3QgZT1cIlxcXFxcXFxcL1wiO2NvbnN0IHU9YFteJHtlfV1gO2NvbnN0IG49XCJcXFxcLlwiO2NvbnN0IG89XCJcXFxcK1wiO2NvbnN0IHM9XCJcXFxcP1wiO2NvbnN0IHI9XCJcXFxcL1wiO2NvbnN0IGE9XCIoPz0uKVwiO2NvbnN0IGk9XCJbXi9dXCI7Y29uc3QgYz1gKD86JHtyfXwkKWA7Y29uc3QgcD1gKD86Xnwke3J9KWA7Y29uc3QgbD1gJHtufXsxLDJ9JHtjfWA7Y29uc3QgZj1gKD8hJHtufSlgO2NvbnN0IEE9YCg/ISR7cH0ke2x9KWA7Y29uc3QgXz1gKD8hJHtufXswLDF9JHtjfSlgO2NvbnN0IFI9YCg/ISR7bH0pYDtjb25zdCBFPWBbXi4ke3J9XWA7Y29uc3QgaD1gJHtpfSo/YDtjb25zdCBnPVwiL1wiO2NvbnN0IGI9e0RPVF9MSVRFUkFMOm4sUExVU19MSVRFUkFMOm8sUU1BUktfTElURVJBTDpzLFNMQVNIX0xJVEVSQUw6cixPTkVfQ0hBUjphLFFNQVJLOmksRU5EX0FOQ0hPUjpjLERPVFNfU0xBU0g6bCxOT19ET1Q6ZixOT19ET1RTOkEsTk9fRE9UX1NMQVNIOl8sTk9fRE9UU19TTEFTSDpSLFFNQVJLX05PX0RPVDpFLFNUQVI6aCxTVEFSVF9BTkNIT1I6cCxTRVA6Z307Y29uc3QgQz17Li4uYixTTEFTSF9MSVRFUkFMOmBbJHtlfV1gLFFNQVJLOnUsU1RBUjpgJHt1fSo/YCxET1RTX1NMQVNIOmAke259ezEsMn0oPzpbJHtlfV18JClgLE5PX0RPVDpgKD8hJHtufSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7ZX1dKSR7bn17MSwyfSg/Olske2V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtufXswLDF9KD86WyR7ZX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske2V9XSlgLEVORF9BTkNIT1I6YCg/Olske2V9XXwkKWAsU0VQOlwiXFxcXFwifTtjb25zdCB5PXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O3QuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTp5LFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksZXh0Z2xvYkNoYXJzKHQpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke3QuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKHQpe3JldHVybiB0PT09dHJ1ZT9DOmJ9fX0sNjk3Oih0LGUsdSk9Pntjb25zdCBuPXUoMTU0KTtjb25zdCBvPXUoOTYpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6cixSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzphLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjppLFJFUExBQ0VNRU5UUzpjfT1uO2NvbnN0IGV4cGFuZFJhbmdlPSh0LGUpPT57aWYodHlwZW9mIGUuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmV4cGFuZFJhbmdlKC4uLnQsZSl9dC5zb3J0KCk7Y29uc3QgdT1gWyR7dC5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cCh1KX1jYXRjaChlKXtyZXR1cm4gdC5tYXAoKHQ9Pm8uZXNjYXBlUmVnZXgodCkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHV9O2NvbnN0IHN5bnRheEVycm9yPSh0LGUpPT5gTWlzc2luZyAke3R9OiBcIiR7ZX1cIiAtIHVzZSBcIlxcXFxcXFxcJHtlfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KHQsZSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX10PWNbdF18fHQ7Y29uc3QgdT17Li4uZX07Y29uc3QgcD10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7bGV0IGw9dC5sZW5ndGg7aWYobD5wKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3B9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnUucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgXz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgUj1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IEU9bi5leHRnbG9iQ2hhcnMoUik7Y29uc3R7RE9UX0xJVEVSQUw6aCxQTFVTX0xJVEVSQUw6ZyxTTEFTSF9MSVRFUkFMOmIsT05FX0NIQVI6QyxET1RTX1NMQVNIOnksTk9fRE9UOiQsTk9fRE9UX1NMQVNIOngsTk9fRE9UU19TTEFTSDpTLFFNQVJLOkgsUU1BUktfTk9fRE9UOnYsU1RBUjpkLFNUQVJUX0FOQ0hPUjpMfT1SO2NvbnN0IGdsb2JzdGFyPXQ9PmAoJHtffSg/Oig/ISR7TH0ke3QuZG90P3k6aH0pLikqPylgO2NvbnN0IFQ9dS5kb3Q/XCJcIjokO2NvbnN0IE89dS5kb3Q/SDp2O2xldCBrPXUuYmFzaD09PXRydWU/Z2xvYnN0YXIodSk6ZDtpZih1LmNhcHR1cmUpe2s9YCgke2t9KWB9aWYodHlwZW9mIHUubm9leHQ9PT1cImJvb2xlYW5cIil7dS5ub2V4dGdsb2I9dS5ub2V4dH1jb25zdCBtPXtpbnB1dDp0LGluZGV4Oi0xLHN0YXJ0OjAsZG90OnUuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O3Q9by5yZW1vdmVQcmVmaXgodCxtKTtsPXQubGVuZ3RoO2NvbnN0IHc9W107Y29uc3QgTj1bXTtjb25zdCBJPVtdO2xldCBCPWY7bGV0IEc7Y29uc3QgZW9zPSgpPT5tLmluZGV4PT09bC0xO2NvbnN0IEQ9bS5wZWVrPShlPTEpPT50W20uaW5kZXgrZV07Y29uc3QgTT1tLmFkdmFuY2U9KCk9PnRbKyttLmluZGV4XXx8XCJcIjtjb25zdCByZW1haW5pbmc9KCk9PnQuc2xpY2UobS5pbmRleCsxKTtjb25zdCBjb25zdW1lPSh0PVwiXCIsZT0wKT0+e20uY29uc3VtZWQrPXQ7bS5pbmRleCs9ZX07Y29uc3QgYXBwZW5kPXQ9PnttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtjb25zdW1lKHQudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgdD0xO3doaWxlKEQoKT09PVwiIVwiJiYoRCgyKSE9PVwiKFwifHxEKDMpPT09XCI/XCIpKXtNKCk7bS5zdGFydCsrO3QrK31pZih0JTI9PT0wKXtyZXR1cm4gZmFsc2V9bS5uZWdhdGVkPXRydWU7bS5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9dD0+e21bdF0rKztJLnB1c2godCl9O2NvbnN0IGRlY3JlbWVudD10PT57bVt0XS0tO0kucG9wKCl9O2NvbnN0IHB1c2g9dD0+e2lmKEIudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgZT1tLmJyYWNlcz4wJiYodC50eXBlPT09XCJjb21tYVwifHx0LnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHU9dC5leHRnbG9iPT09dHJ1ZXx8dy5sZW5ndGgmJih0LnR5cGU9PT1cInBpcGVcInx8dC50eXBlPT09XCJwYXJlblwiKTtpZih0LnR5cGUhPT1cInNsYXNoXCImJnQudHlwZSE9PVwicGFyZW5cIiYmIWUmJiF1KXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cInN0YXJcIjtCLnZhbHVlPVwiKlwiO0Iub3V0cHV0PWs7bS5vdXRwdXQrPUIub3V0cHV0fX1pZih3Lmxlbmd0aCYmdC50eXBlIT09XCJwYXJlblwiKXt3W3cubGVuZ3RoLTFdLmlubmVyKz10LnZhbHVlfWlmKHQudmFsdWV8fHQub3V0cHV0KWFwcGVuZCh0KTtpZihCJiZCLnR5cGU9PT1cInRleHRcIiYmdC50eXBlPT09XCJ0ZXh0XCIpe0Iub3V0cHV0PShCLm91dHB1dHx8Qi52YWx1ZSkrdC52YWx1ZTtCLnZhbHVlKz10LnZhbHVlO3JldHVybn10LnByZXY9QjtBLnB1c2godCk7Qj10fTtjb25zdCBleHRnbG9iT3Blbj0odCxlKT0+e2NvbnN0IG49ey4uLkVbZV0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1CO24ucGFyZW5zPW0ucGFyZW5zO24ub3V0cHV0PW0ub3V0cHV0O2NvbnN0IG89KHUuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6dCx2YWx1ZTplLG91dHB1dDptLm91dHB1dD9cIlwiOkN9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6TSgpLG91dHB1dDpvfSk7dy5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9dD0+e2xldCBuPXQuY2xvc2UrKHUuY2FwdHVyZT9cIilcIjpcIlwiKTtsZXQgbztpZih0LnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgcz1rO2lmKHQuaW5uZXImJnQuaW5uZXIubGVuZ3RoPjEmJnQuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtzPWdsb2JzdGFyKHUpfWlmKHMhPT1rfHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe249dC5jbG9zZT1gKSQpKSR7c31gfWlmKHQuaW5uZXIuaW5jbHVkZXMoXCIqXCIpJiYobz1yZW1haW5pbmcoKSkmJi9eXFwuW15cXFxcLy5dKyQvLnRlc3Qobykpe2NvbnN0IHU9cGFyc2Uobyx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KS5vdXRwdXQ7bj10LmNsb3NlPWApJHt1fSkke3N9KWB9aWYodC5wcmV2LnR5cGU9PT1cImJvc1wiKXttLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpufSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZih1LmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdCh0KSl7bGV0IG49ZmFsc2U7bGV0IHM9dC5yZXBsYWNlKGksKCh0LGUsdSxvLHMscik9PntpZihvPT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gdH1pZihvPT09XCI/XCIpe2lmKGUpe3JldHVybiBlK28rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKHI9PT0wKXtyZXR1cm4gTysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIEgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIuXCIpe3JldHVybiBoLnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiKlwiKXtpZihlKXtyZXR1cm4gZStvKyhzP2s6XCJcIil9cmV0dXJuIGt9cmV0dXJuIGU/dDpgXFxcXCR7dH1gfSkpO2lmKG49PT10cnVlKXtpZih1LnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLCh0PT50Lmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6dD9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT10JiZ1LmNvbnRhaW5zPT09dHJ1ZSl7bS5vdXRwdXQ9dDtyZXR1cm4gbX1tLm91dHB1dD1vLndyYXBPdXRwdXQocyxtLGUpO3JldHVybiBtfXdoaWxlKCFlb3MoKSl7Rz1NKCk7aWYoRz09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEc9PT1cIlxcXFxcIil7Y29uc3QgdD1EKCk7aWYodD09PVwiL1wiJiZ1LmJhc2ghPT10cnVlKXtjb250aW51ZX1pZih0PT09XCIuXCJ8fHQ9PT1cIjtcIil7Y29udGludWV9aWYoIXQpe0crPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWNvbnN0IGU9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZihlJiZlWzBdLmxlbmd0aD4yKXtuPWVbMF0ubGVuZ3RoO20uaW5kZXgrPW47aWYobiUyIT09MCl7Rys9XCJcXFxcXCJ9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtHPU0oKX1lbHNle0crPU0oKX1pZihtLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9fWlmKG0uYnJhY2tldHM+MCYmKEchPT1cIl1cInx8Qi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7aWYodS5wb3NpeCE9PWZhbHNlJiZHPT09XCI6XCIpe2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZih0LmluY2x1ZGVzKFwiW1wiKSl7Qi5wb3NpeD10cnVlO2lmKHQuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCB0PUIudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IGU9Qi52YWx1ZS5zbGljZSgwLHQpO2NvbnN0IHU9Qi52YWx1ZS5zbGljZSh0KzIpO2NvbnN0IG49clt1XTtpZihuKXtCLnZhbHVlPWUrbjttLmJhY2t0cmFjaz10cnVlO00oKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihCKT09PTEpe2Yub3V0cHV0PUN9Y29udGludWV9fX19aWYoRz09PVwiW1wiJiZEKCkhPT1cIjpcInx8Rz09PVwiLVwiJiZEKCk9PT1cIl1cIil7Rz1gXFxcXCR7R31gfWlmKEc9PT1cIl1cIiYmKEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe0c9YFxcXFwke0d9YH1pZih1LnBvc2l4PT09dHJ1ZSYmRz09PVwiIVwiJiZCLnZhbHVlPT09XCJbXCIpe0c9XCJeXCJ9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihtLnF1b3Rlcz09PTEmJkchPT0nXCInKXtHPW8uZXNjYXBlUmVnZXgoRyk7Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09J1wiJyl7bS5xdW90ZXM9bS5xdW90ZXM9PT0xPzA6MTtpZih1LmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KX1jb250aW51ZX1pZihHPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiKVwiKXtpZihtLnBhcmVucz09PTAmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCB0PXdbdy5sZW5ndGgtMV07aWYodCYmbS5wYXJlbnM9PT10LnBhcmVucysxKXtleHRnbG9iQ2xvc2Uody5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6RyxvdXRwdXQ6bS5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEc9PT1cIltcIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZih1Lm5vYnJhY2tldCE9PXRydWUmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1HPWBcXFxcJHtHfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCJdXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8QiYmQi50eXBlPT09XCJicmFja2V0XCImJkIudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9aWYobS5icmFja2V0cz09PTApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYoQi5wb3NpeCE9PXRydWUmJnRbMF09PT1cIl5cIiYmIXQuaW5jbHVkZXMoXCIvXCIpKXtHPWAvJHtHfWB9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtpZih1LmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHxvLmhhc1JlZ2V4Q2hhcnModCkpe2NvbnRpbnVlfWNvbnN0IGU9by5lc2NhcGVSZWdleChCLnZhbHVlKTttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLnZhbHVlLmxlbmd0aCk7aWYodS5saXRlcmFsQnJhY2tldHM9PT10cnVlKXttLm91dHB1dCs9ZTtCLnZhbHVlPWU7Y29udGludWV9Qi52YWx1ZT1gKCR7X30ke2V9fCR7Qi52YWx1ZX0pYDttLm91dHB1dCs9Qi52YWx1ZTtjb250aW51ZX1pZihHPT09XCJ7XCImJnUubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCB0PXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDptLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6bS50b2tlbnMubGVuZ3RofTtOLnB1c2godCk7cHVzaCh0KTtjb250aW51ZX1pZihHPT09XCJ9XCIpe2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtpZih1Lm5vYnJhY2U9PT10cnVlfHwhdCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpHfSk7Y29udGludWV9bGV0IGU9XCIpXCI7aWYodC5kb3RzPT09dHJ1ZSl7Y29uc3QgdD1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7QS5wb3AoKTtpZih0W2VdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKHRbZV0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQodFtlXS52YWx1ZSl9fWU9ZXhwYW5kUmFuZ2Uobix1KTttLmJhY2t0cmFjaz10cnVlfWlmKHQuY29tbWEhPT10cnVlJiZ0LmRvdHMhPT10cnVlKXtjb25zdCB1PW0ub3V0cHV0LnNsaWNlKDAsdC5vdXRwdXRJbmRleCk7Y29uc3Qgbj1tLnRva2Vucy5zbGljZSh0LnRva2Vuc0luZGV4KTt0LnZhbHVlPXQub3V0cHV0PVwiXFxcXHtcIjtHPWU9XCJcXFxcfVwiO20ub3V0cHV0PXU7Zm9yKGNvbnN0IHQgb2Ygbil7bS5vdXRwdXQrPXQub3V0cHV0fHx0LnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDplfSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO04ucG9wKCk7Y29udGludWV9aWYoRz09PVwifFwiKXtpZih3Lmxlbmd0aD4wKXt3W3cubGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIsXCIpe2xldCB0PUc7Y29uc3QgZT1OW04ubGVuZ3RoLTFdO2lmKGUmJklbSS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXtlLmNvbW1hPXRydWU7dD1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpHLG91dHB1dDp0fSk7Y29udGludWV9aWYoRz09PVwiL1wiKXtpZihCLnR5cGU9PT1cImRvdFwiJiZtLmluZGV4PT09bS5zdGFydCsxKXttLnN0YXJ0PW0uaW5kZXgrMTttLmNvbnN1bWVkPVwiXCI7bS5vdXRwdXQ9XCJcIjtBLnBvcCgpO0I9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpHLG91dHB1dDpifSk7Y29udGludWV9aWYoRz09PVwiLlwiKXtpZihtLmJyYWNlcz4wJiZCLnR5cGU9PT1cImRvdFwiKXtpZihCLnZhbHVlPT09XCIuXCIpQi5vdXRwdXQ9aDtjb25zdCB0PU5bTi5sZW5ndGgtMV07Qi50eXBlPVwiZG90c1wiO0Iub3V0cHV0Kz1HO0IudmFsdWUrPUc7dC5kb3RzPXRydWU7Y29udGludWV9aWYobS5icmFjZXMrbS5wYXJlbnM9PT0wJiZCLnR5cGUhPT1cImJvc1wiJiZCLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9aWYoRz09PVwiP1wiKXtjb25zdCB0PUImJkIudmFsdWU9PT1cIihcIjtpZighdCYmdS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsRyk7Y29udGludWV9aWYoQiYmQi50eXBlPT09XCJwYXJlblwiKXtjb25zdCB0PUQoKTtsZXQgZT1HO2lmKEIudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QodCl8fHQ9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7ZT1gXFxcXCR7R31gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKHUuZG90IT09dHJ1ZSYmKEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0OnZ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDpIfSk7Y29udGludWV9aWYoRz09PVwiIVwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiKXtpZihEKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEQoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEcpO2NvbnRpbnVlfX1pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmbS5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihHPT09XCIrXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsRyk7Y29udGludWV9aWYoQiYmQi52YWx1ZT09PVwiKFwifHx1LnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6RyxvdXRwdXQ6Z30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwifHxCLnR5cGU9PT1cImJyYWNlXCIpfHxtLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkd9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOmd9KTtjb250aW51ZX1pZihHPT09XCJAXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHIT09XCIqXCIpe2lmKEc9PT1cIiRcInx8Rz09PVwiXlwiKXtHPWBcXFxcJHtHfWB9Y29uc3QgdD1hLmV4ZWMocmVtYWluaW5nKCkpO2lmKHQpe0crPXRbMF07bS5pbmRleCs9dFswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiZ2xvYnN0YXJcInx8Qi5zdGFyPT09dHJ1ZSkpe0IudHlwZT1cInN0YXJcIjtCLnN0YXI9dHJ1ZTtCLnZhbHVlKz1HO0Iub3V0cHV0PWs7bS5iYWNrdHJhY2s9dHJ1ZTttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1sZXQgZT1yZW1haW5pbmcoKTtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdChlKSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsRyk7Y29udGludWV9aWYoQi50eXBlPT09XCJzdGFyXCIpe2lmKHUubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj1CLnByZXY7Y29uc3Qgbz1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgcj1vJiYoby50eXBlPT09XCJzdGFyXCJ8fG8udHlwZT09PVwiZ2xvYnN0YXJcIik7aWYodS5iYXNoPT09dHJ1ZSYmKCFzfHxlWzBdJiZlWzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBhPW0uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgaT13Lmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFhJiYhaSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUoZS5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3QgdT10W20uaW5kZXgrNF07aWYodSYmdSE9PVwiL1wiKXticmVha31lPWUuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFyJiZlb3MoKSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KSsodS5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO0IudmFsdWUrPUc7bS5nbG9ic3Rhcj10cnVlO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe2NvbnN0IHQ9ZVsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWAke2dsb2JzdGFyKHUpfSR7Yn18JHtifSR7dH0pYDtCLnZhbHVlKz1HO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1gKD86Xnwke2J9fCR7Z2xvYnN0YXIodSl9JHtifSlgO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfW0ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KTtCLnZhbHVlKz1HO20ub3V0cHV0Kz1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0Omt9O2lmKHUuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoQi50eXBlPT09XCJib3NcInx8Qi50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1UK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCIpJiZ1LnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9RztwdXNoKG4pO2NvbnRpbnVlfWlmKG0uaW5kZXg9PT1tLnN0YXJ0fHxCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiZG90XCIpe2lmKEIudHlwZT09PVwiZG90XCIpe20ub3V0cHV0Kz14O0Iub3V0cHV0Kz14fWVsc2UgaWYodS5kb3Q9PT10cnVlKXttLm91dHB1dCs9UztCLm91dHB1dCs9U31lbHNle20ub3V0cHV0Kz1UO0Iub3V0cHV0Kz1UfWlmKEQoKSE9PVwiKlwiKXttLm91dHB1dCs9QztCLm91dHB1dCs9Q319cHVzaChuKX13aGlsZShtLmJyYWNrZXRzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUobS5wYXJlbnM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUobS5icmFjZXM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYodS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKEIudHlwZT09PVwic3RhclwifHxCLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke2J9P2B9KX1pZihtLmJhY2t0cmFjaz09PXRydWUpe20ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IHQgb2YgbS50b2tlbnMpe20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2lmKHQuc3VmZml4KXttLm91dHB1dCs9dC5zdWZmaXh9fX1yZXR1cm4gbX07cGFyc2UuZmFzdHBhdGhzPSh0LGUpPT57Y29uc3QgdT17Li4uZX07Y29uc3Qgcj10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7Y29uc3QgYT10Lmxlbmd0aDtpZihhPnIpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2F9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cn1gKX10PWNbdF18fHQ7Y29uc3R7RE9UX0xJVEVSQUw6aSxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6bCxET1RTX1NMQVNIOmYsTk9fRE9UOkEsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6UixTVEFSOkUsU1RBUlRfQU5DSE9SOmh9PW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgZz11LmRvdD9fOkE7Y29uc3QgYj11LmRvdD9SOkE7Y29uc3QgQz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeT17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0ICQ9dS5iYXNoPT09dHJ1ZT9cIi4qP1wiOkU7aWYodS5jYXB0dXJlKXskPWAoJHskfSlgfWNvbnN0IGdsb2JzdGFyPXQ9PntpZih0Lm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiAkO3JldHVybmAoJHtDfSg/Oig/ISR7aH0ke3QuZG90P2Y6aX0pLikqPylgfTtjb25zdCBjcmVhdGU9dD0+e3N3aXRjaCh0KXtjYXNlXCIqXCI6cmV0dXJuYCR7Z30ke2x9JHskfWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtpfSR7bH0keyR9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtnfSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIiovKlwiOnJldHVybmAke2d9JHskfSR7cH0ke2x9JHtifSR7JH1gO2Nhc2VcIioqXCI6cmV0dXJuIGcrZ2xvYnN0YXIodSk7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHtsfSR7JH1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtpfSR7bH0keyR9YDtkZWZhdWx0Ontjb25zdCBlPS9eKC4qPylcXC4oXFx3KykkLy5leGVjKHQpO2lmKCFlKXJldHVybjtjb25zdCB1PWNyZWF0ZShlWzFdKTtpZighdSlyZXR1cm47cmV0dXJuIHUraStlWzJdfX19O2NvbnN0IHg9by5yZW1vdmVQcmVmaXgodCx5KTtsZXQgUz1jcmVhdGUoeCk7aWYoUyYmdS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7Uys9YCR7cH0/YH1yZXR1cm4gU307dC5leHBvcnRzPXBhcnNlfSw1MTA6KHQsZSx1KT0+e2NvbnN0IG49dSg3MTYpO2NvbnN0IG89dSg2OTcpO2NvbnN0IHM9dSg5Nik7Y29uc3Qgcj11KDE1NCk7Y29uc3QgaXNPYmplY3Q9dD0+dCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtjb25zdCBwaWNvbWF0Y2g9KHQsZSx1PWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49dC5tYXAoKHQ9PnBpY29tYXRjaCh0LGUsdSkpKTtjb25zdCBhcnJheU1hdGNoZXI9dD0+e2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHU9ZSh0KTtpZih1KXJldHVybiB1fXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KHQpJiZ0LnRva2VucyYmdC5pbnB1dDtpZih0PT09XCJcInx8dHlwZW9mIHQhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLndpbmRvd3M7Y29uc3Qgcj1uP3BpY29tYXRjaC5jb21waWxlUmUodCxlKTpwaWNvbWF0Y2gubWFrZVJlKHQsZSxmYWxzZSx0cnVlKTtjb25zdCBhPXIuc3RhdGU7ZGVsZXRlIHIuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYoby5pZ25vcmUpe2NvbnN0IHQ9ey4uLmUsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2goby5pZ25vcmUsdCx1KX1jb25zdCBtYXRjaGVyPSh1LG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDppLG1hdGNoOmMsb3V0cHV0OnB9PXBpY29tYXRjaC50ZXN0KHUscixlLHtnbG9iOnQscG9zaXg6c30pO2NvbnN0IGw9e2dsb2I6dCxzdGF0ZTphLHJlZ2V4OnIscG9zaXg6cyxpbnB1dDp1LG91dHB1dDpwLG1hdGNoOmMsaXNNYXRjaDppfTtpZih0eXBlb2Ygby5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7by5vblJlc3VsdChsKX1pZihpPT09ZmFsc2Upe2wuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKGlzSWdub3JlZCh1KSl7aWYodHlwZW9mIG8ub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe28ub25JZ25vcmUobCl9bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYodHlwZW9mIG8ub25NYXRjaD09PVwiZnVuY3Rpb25cIil7by5vbk1hdGNoKGwpfXJldHVybiBuP2w6dHJ1ZX07aWYodSl7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0odCxlLHUse2dsb2I6bixwb3NpeDpvfT17fSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZih0PT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHI9dXx8e307Y29uc3QgYT1yLmZvcm1hdHx8KG8/cy50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgaT10PT09bjtsZXQgYz1pJiZhP2EodCk6dDtpZihpPT09ZmFsc2Upe2M9YT9hKHQpOnQ7aT1jPT09bn1pZihpPT09ZmFsc2V8fHIuY2FwdHVyZT09PXRydWUpe2lmKHIubWF0Y2hCYXNlPT09dHJ1ZXx8ci5iYXNlbmFtZT09PXRydWUpe2k9cGljb21hdGNoLm1hdGNoQmFzZSh0LGUsdSxvKX1lbHNle2k9ZS5leGVjKGMpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGkpLG1hdGNoOmksb3V0cHV0OmN9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPSh0LGUsdSk9Pntjb25zdCBuPWUgaW5zdGFuY2VvZiBSZWdFeHA/ZTpwaWNvbWF0Y2gubWFrZVJlKGUsdSk7cmV0dXJuIG4udGVzdChzLmJhc2VuYW1lKHQpKX07cGljb21hdGNoLmlzTWF0Y2g9KHQsZSx1KT0+cGljb21hdGNoKGUsdSkodCk7cGljb21hdGNoLnBhcnNlPSh0LGUpPT57aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PnBpY29tYXRjaC5wYXJzZSh0LGUpKSk7cmV0dXJuIG8odCx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KHQsZSk9Pm4odCxlKTtwaWNvbWF0Y2guY29tcGlsZVJlPSh0LGUsdT1mYWxzZSxuPWZhbHNlKT0+e2lmKHU9PT10cnVlKXtyZXR1cm4gdC5vdXRwdXR9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8uY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCByPW8uY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgYT1gJHtzfSg/OiR7dC5vdXRwdXR9KSR7cn1gO2lmKHQmJnQubmVnYXRlZD09PXRydWUpe2E9YF4oPyEke2F9KS4qJGB9Y29uc3QgaT1waWNvbWF0Y2gudG9SZWdleChhLGUpO2lmKG49PT10cnVlKXtpLnN0YXRlPXR9cmV0dXJuIGl9O3BpY29tYXRjaC5tYWtlUmU9KHQsZT17fSx1PWZhbHNlLG49ZmFsc2UpPT57aWYoIXR8fHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1sZXQgcz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07aWYoZS5mYXN0cGF0aHMhPT1mYWxzZSYmKHRbMF09PT1cIi5cInx8dFswXT09PVwiKlwiKSl7cy5vdXRwdXQ9by5mYXN0cGF0aHModCxlKX1pZighcy5vdXRwdXQpe3M9byh0LGUpfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHMsZSx1LG4pfTtwaWNvbWF0Y2gudG9SZWdleD0odCxlKT0+e3RyeXtjb25zdCB1PWV8fHt9O3JldHVybiBuZXcgUmVnRXhwKHQsdS5mbGFnc3x8KHUubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaCh0KXtpZihlJiZlLmRlYnVnPT09dHJ1ZSl0aHJvdyB0O3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPXI7dC5leHBvcnRzPXBpY29tYXRjaH0sNzE2Oih0LGUsdSk9Pntjb25zdCBuPXUoOTYpO2NvbnN0e0NIQVJfQVNURVJJU0s6byxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpyLENIQVJfQ09NTUE6YSxDSEFSX0RPVDppLENIQVJfRVhDTEFNQVRJT05fTUFSSzpjLENIQVJfRk9SV0FSRF9TTEFTSDpwLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpsLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpfLENIQVJfUVVFU1RJT05fTUFSSzpSLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6RSxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmgsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpnfT11KDE1NCk7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPXQ9PnQ9PT1wfHx0PT09cjtjb25zdCBkZXB0aD10PT57aWYodC5pc1ByZWZpeCE9PXRydWUpe3QuZGVwdGg9dC5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPSh0LGUpPT57Y29uc3QgdT1lfHx7fTtjb25zdCBiPXQubGVuZ3RoLTE7Y29uc3QgQz11LnBhcnRzPT09dHJ1ZXx8dS5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IHk9W107Y29uc3QgJD1bXTtjb25zdCB4PVtdO2xldCBTPXQ7bGV0IEg9LTE7bGV0IHY9MDtsZXQgZD0wO2xldCBMPWZhbHNlO2xldCBUPWZhbHNlO2xldCBPPWZhbHNlO2xldCBrPWZhbHNlO2xldCBtPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBJPWZhbHNlO2xldCBCPWZhbHNlO2xldCBHPWZhbHNlO2xldCBEPTA7bGV0IE07bGV0IFA7bGV0IEs9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Yjtjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57TT1QO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxiKXtQPWFkdmFuY2UoKTtsZXQgdDtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7aWYoUD09PWwpe3c9dHJ1ZX1jb250aW51ZX1pZih3PT09dHJ1ZXx8UD09PWwpe0QrKzt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWwpe0QrKztjb250aW51ZX1pZih3IT09dHJ1ZSYmUD09PWkmJihQPWFkdmFuY2UoKSk9PT1pKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHchPT10cnVlJiZQPT09YSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09RSl7RC0tO2lmKEQ9PT0wKXt3PWZhbHNlO0w9Sy5pc0JyYWNlPXRydWU7Rz10cnVlO2JyZWFrfX19aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1wKXt5LnB1c2goSCk7JC5wdXNoKEspO0s9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKEc9PT10cnVlKWNvbnRpbnVlO2lmKE09PT1pJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfWQ9SCsxO2NvbnRpbnVlfWlmKHUubm9leHQhPT10cnVlKXtjb25zdCB0PVA9PT1ffHxQPT09c3x8UD09PW98fFA9PT1SfHxQPT09YztpZih0PT09dHJ1ZSYmcGVlaygpPT09Zil7Tz1LLmlzR2xvYj10cnVlO2s9Sy5pc0V4dGdsb2I9dHJ1ZTtHPXRydWU7aWYoUD09PWMmJkg9PT12KXtCPXRydWV9aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoUD09PW8pe2lmKE09PT1vKW09Sy5pc0dsb2JzdGFyPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PVIpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJih0PWFkdmFuY2UoKSkpe2lmKHQ9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYodD09PWcpe1Q9Sy5pc0JyYWNrZXQ9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodS5ub25lZ2F0ZSE9PXRydWUmJlA9PT1jJiZIPT09dil7ST1LLm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYodS5ub3BhcmVuIT09dHJ1ZSYmUD09PWYpe089Sy5pc0dsb2I9dHJ1ZTtpZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09Zil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTz09PXRydWUpe0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHUubm9leHQ9PT10cnVlKXtrPWZhbHNlO089ZmFsc2V9bGV0IFU9UztsZXQgWD1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtYPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7ZC09dn1pZihVJiZPPT09dHJ1ZSYmZD4wKXtVPVMuc2xpY2UoMCxkKTtGPVMuc2xpY2UoZCl9ZWxzZSBpZihPPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYodS51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJk49PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpYLGlucHV0OnQsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6TCxpc0JyYWNrZXQ6VCxpc0dsb2I6Tyxpc0V4dGdsb2I6ayxpc0dsb2JzdGFyOm0sbmVnYXRlZDpJLG5lZ2F0ZWRFeHRnbG9iOkJ9O2lmKHUudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoUCkpeyQucHVzaChLKX1RLnRva2Vucz0kfWlmKHUucGFydHM9PT10cnVlfHx1LnRva2Vucz09PXRydWUpe2xldCBlO2ZvcihsZXQgbj0wO248eS5sZW5ndGg7bisrKXtjb25zdCBvPWU/ZSsxOnY7Y29uc3Qgcz15W25dO2NvbnN0IHI9dC5zbGljZShvLHMpO2lmKHUudG9rZW5zKXtpZihuPT09MCYmdiE9PTApeyRbbl0uaXNQcmVmaXg9dHJ1ZTskW25dLnZhbHVlPVh9ZWxzZXskW25dLnZhbHVlPXJ9ZGVwdGgoJFtuXSk7US5tYXhEZXB0aCs9JFtuXS5kZXB0aH1pZihuIT09MHx8ciE9PVwiXCIpe3gucHVzaChyKX1lPXN9aWYoZSYmZSsxPHQubGVuZ3RoKXtjb25zdCBuPXQuc2xpY2UoZSsxKTt4LnB1c2gobik7aWYodS50b2tlbnMpeyRbJC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCgkWyQubGVuZ3RoLTFdKTtRLm1heERlcHRoKz0kWyQubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9eTtRLnBhcnRzPXh9cmV0dXJuIFF9O3QuZXhwb3J0cz1zY2FufSw5NjoodCxlLHUpPT57Y29uc3R7UkVHRVhfQkFDS1NMQVNIOm4sUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6cyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDpyfT11KDE1NCk7ZS5pc09iamVjdD10PT50IT09bnVsbCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtlLmhhc1JlZ2V4Q2hhcnM9dD0+cy50ZXN0KHQpO2UuaXNSZWdleENoYXI9dD0+dC5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnModCk7ZS5lc2NhcGVSZWdleD10PT50LnJlcGxhY2UocixcIlxcXFwkMVwiKTtlLnRvUG9zaXhTbGFzaGVzPXQ9PnQucmVwbGFjZShuLFwiL1wiKTtlLnJlbW92ZUJhY2tzbGFzaGVzPXQ9PnQucmVwbGFjZShvLCh0PT50PT09XCJcXFxcXCI/XCJcIjp0KSk7ZS5lc2NhcGVMYXN0PSh0LHUsbik9Pntjb25zdCBvPXQubGFzdEluZGV4T2YodSxuKTtpZihvPT09LTEpcmV0dXJuIHQ7aWYodFtvLTFdPT09XCJcXFxcXCIpcmV0dXJuIGUuZXNjYXBlTGFzdCh0LHUsby0xKTtyZXR1cm5gJHt0LnNsaWNlKDAsbyl9XFxcXCR7dC5zbGljZShvKX1gfTtlLnJlbW92ZVByZWZpeD0odCxlPXt9KT0+e2xldCB1PXQ7aWYodS5zdGFydHNXaXRoKFwiLi9cIikpe3U9dS5zbGljZSgyKTtlLnByZWZpeD1cIi4vXCJ9cmV0dXJuIHV9O2Uud3JhcE91dHB1dD0odCxlPXt9LHU9e30pPT57Y29uc3Qgbj11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke3R9KSR7b31gO2lmKGUubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfTtlLmJhc2VuYW1lPSh0LHt3aW5kb3dzOmV9PXt9KT0+e2NvbnN0IHU9dC5zcGxpdChlPy9bXFxcXC9dLzpcIi9cIik7Y29uc3Qgbj11W3UubGVuZ3RoLTFdO2lmKG49PT1cIlwiKXtyZXR1cm4gdVt1Lmxlbmd0aC0yXX1yZXR1cm4gbn19fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHUpe3ZhciBuPWVbdV07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3VdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXt0W3VdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSBlW3VdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTcwKTttb2R1bGUuZXhwb3J0cz11fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"f8499bf7071a\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9hcHAvZ2xvYmFscy5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJmODQ5OWJmNzA3MWFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/icons/cave.png":
/*!**************************************!*\
  !*** ./public/assets/icons/cave.png ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\"src\":\"/_next/static/media/cave.75f27db0.png\",\"height\":512,\"width\":512,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcave.75f27db0.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvaWNvbnMvY2F2ZS5wbmciLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLENBQUMsNExBQTRMIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vcHVibGljL2Fzc2V0cy9pY29ucy9jYXZlLnBuZyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XCJzcmNcIjpcIi9fbmV4dC9zdGF0aWMvbWVkaWEvY2F2ZS43NWYyN2RiMC5wbmdcIixcImhlaWdodFwiOjUxMixcIndpZHRoXCI6NTEyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmNhdmUuNzVmMjdkYjAucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/icons/cave.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/icons/farmland.png":
/*!******************************************!*\
  !*** ./public/assets/icons/farmland.png ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\"src\":\"/_next/static/media/farmland.0f564f76.png\",\"height\":512,\"width\":512,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffarmland.0f564f76.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvaWNvbnMvZmFybWxhbmQucG5nIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxDQUFDLG9NQUFvTSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL3B1YmxpYy9hc3NldHMvaWNvbnMvZmFybWxhbmQucG5nIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9mYXJtbGFuZC4wZjU2NGY3Ni5wbmdcIixcImhlaWdodFwiOjUxMixcIndpZHRoXCI6NTEyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmZhcm1sYW5kLjBmNTY0Zjc2LnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/icons/farmland.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/icons/ice.png":
/*!*************************************!*\
  !*** ./public/assets/icons/ice.png ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\"src\":\"/_next/static/media/ice.c4f0c603.png\",\"height\":512,\"width\":512,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fice.c4f0c603.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvaWNvbnMvaWNlLnBuZyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsQ0FBQywwTEFBMEwiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9wdWJsaWMvYXNzZXRzL2ljb25zL2ljZS5wbmciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2ljZS5jNGYwYzYwMy5wbmdcIixcImhlaWdodFwiOjUxMixcIndpZHRoXCI6NTEyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmljZS5jNGYwYzYwMy5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/icons/ice.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/icons/mountain.png":
/*!******************************************!*\
  !*** ./public/assets/icons/mountain.png ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\"src\":\"/_next/static/media/mountain.e8242137.png\",\"height\":512,\"width\":512,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmountain.e8242137.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvaWNvbnMvbW91bnRhaW4ucG5nIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxDQUFDLG9NQUFvTSIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL3B1YmxpYy9hc3NldHMvaWNvbnMvbW91bnRhaW4ucG5nIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9tb3VudGFpbi5lODI0MjEzNy5wbmdcIixcImhlaWdodFwiOjUxMixcIndpZHRoXCI6NTEyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRm1vdW50YWluLmU4MjQyMTM3LnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/icons/mountain.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/icons/nature.png":
/*!****************************************!*\
  !*** ./public/assets/icons/nature.png ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\"src\":\"/_next/static/media/nature.9684cc51.png\",\"height\":512,\"width\":512,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fnature.9684cc51.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvaWNvbnMvbmF0dXJlLnBuZyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsQ0FBQyxnTUFBZ00iLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9wdWJsaWMvYXNzZXRzL2ljb25zL25hdHVyZS5wbmciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL25hdHVyZS45Njg0Y2M1MS5wbmdcIixcImhlaWdodFwiOjUxMixcIndpZHRoXCI6NTEyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRm5hdHVyZS45Njg0Y2M1MS5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/icons/nature.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/icons/snow.png":
/*!**************************************!*\
  !*** ./public/assets/icons/snow.png ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\"src\":\"/_next/static/media/snow.48cfb1f9.png\",\"height\":512,\"width\":512,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fsnow.48cfb1f9.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvaWNvbnMvc25vdy5wbmciLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLENBQUMsNExBQTRMIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vcHVibGljL2Fzc2V0cy9pY29ucy9zbm93LnBuZyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XCJzcmNcIjpcIi9fbmV4dC9zdGF0aWMvbWVkaWEvc25vdy40OGNmYjFmOS5wbmdcIixcImhlaWdodFwiOjUxMixcIndpZHRoXCI6NTEyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRnNub3cuNDhjZmIxZjkucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/icons/snow.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./modules/layout/components/SeasonalIcon.tsx":
/*!****************************************************!*\
  !*** ./modules/layout/components/SeasonalIcon.tsx ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SeasonalIcon: () => (/* binding */ SeasonalIcon)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/image.js\");\n/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! animejs */ \"(app-pages-browser)/./node_modules/.pnpm/animejs@4.1.4/node_modules/animejs/lib/anime.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _public_assets_icons_farmland_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/public/assets/icons/farmland.png */ \"(app-pages-browser)/./public/assets/icons/farmland.png\");\n/* harmony import */ var _public_assets_icons_nature_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/public/assets/icons/nature.png */ \"(app-pages-browser)/./public/assets/icons/nature.png\");\n/* harmony import */ var _public_assets_icons_snow_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/public/assets/icons/snow.png */ \"(app-pages-browser)/./public/assets/icons/snow.png\");\n/* harmony import */ var _public_assets_icons_mountain_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/public/assets/icons/mountain.png */ \"(app-pages-browser)/./public/assets/icons/mountain.png\");\n/* harmony import */ var _public_assets_icons_ice_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/public/assets/icons/ice.png */ \"(app-pages-browser)/./public/assets/icons/ice.png\");\n/* harmony import */ var _public_assets_icons_cave_png__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/public/assets/icons/cave.png */ \"(app-pages-browser)/./public/assets/icons/cave.png\");\n/* __next_internal_client_entry_do_not_use__ SeasonalIcon auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst icons = [\n    _public_assets_icons_farmland_png__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    _public_assets_icons_nature_png__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n    _public_assets_icons_snow_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n    _public_assets_icons_mountain_png__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n    _public_assets_icons_ice_png__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n    _public_assets_icons_cave_png__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n];\nconst getRandomIndex = (excludeIndex)=>{\n    if (icons.length <= 1) return 0;\n    let nextIndex = Math.floor(Math.random() * icons.length);\n    while(nextIndex === excludeIndex){\n        nextIndex = Math.floor(Math.random() * icons.length);\n    }\n    return nextIndex;\n};\nconst SeasonalIcon = (props)=>{\n    _s();\n    const iconWrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const [currentIconIndex, setCurrentIconIndex] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        \"SeasonalIcon.useState\": ()=>Math.floor(Math.random() * icons.length)\n    }[\"SeasonalIcon.useState\"]);\n    const changeIcon = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"SeasonalIcon.useCallback[changeIcon]\": (withAnimation)=>{\n            setCurrentIconIndex({\n                \"SeasonalIcon.useCallback[changeIcon]\": (prevIndex)=>{\n                    const nextIndex = getRandomIndex(prevIndex);\n                    if (withAnimation && iconWrapperRef.current) {\n                        (0,animejs__WEBPACK_IMPORTED_MODULE_9__.animate)(iconWrapperRef.current, {\n                            scale: [\n                                1,\n                                0.82,\n                                1.06,\n                                1\n                            ],\n                            rotate: [\n                                \"0deg\",\n                                \"180deg\",\n                                \"360deg\"\n                            ],\n                            duration: 650,\n                            easing: \"easeInOutQuart\"\n                        });\n                    }\n                    return nextIndex;\n                }\n            }[\"SeasonalIcon.useCallback[changeIcon]\"]);\n        }\n    }[\"SeasonalIcon.useCallback[changeIcon]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"SeasonalIcon.useEffect\": ()=>{\n            const minuteTimer = window.setInterval({\n                \"SeasonalIcon.useEffect.minuteTimer\": ()=>{\n                    changeIcon(true);\n                }\n            }[\"SeasonalIcon.useEffect.minuteTimer\"], 60000);\n            return ({\n                \"SeasonalIcon.useEffect\": ()=>{\n                    window.clearInterval(minuteTimer);\n                }\n            })[\"SeasonalIcon.useEffect\"];\n        }\n    }[\"SeasonalIcon.useEffect\"], [\n        changeIcon\n    ]);\n    const currentIcon = icons[currentIconIndex];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        type: \"button\",\n        ref: iconWrapperRef,\n        onClick: ()=>changeIcon(true),\n        \"aria-label\": \"Randomize logo icon\",\n        className: \"shrink-0\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            src: currentIcon,\n            width: 100,\n            height: 100,\n            ...props\n        }, void 0, false, {\n            fileName: \"/Users/sathira/Projects/grotto/modules/layout/components/SeasonalIcon.tsx\",\n            lineNumber: 81,\n            columnNumber: 4\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/sathira/Projects/grotto/modules/layout/components/SeasonalIcon.tsx\",\n        lineNumber: 74,\n        columnNumber: 3\n    }, undefined);\n};\n_s(SeasonalIcon, \"VI6W0558tKJLOeIoQlMwoRvtdTg=\");\n_c = SeasonalIcon;\nvar _c;\n$RefreshReg$(_c, \"SeasonalIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL21vZHVsZXMvbGF5b3V0L2NvbXBvbmVudHMvU2Vhc29uYWxJY29uLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUMrQjtBQUNHO0FBQytCO0FBRUY7QUFDSjtBQUNKO0FBQ1E7QUFDVjtBQUNFO0FBT3ZELE1BQU1ZLFFBQVE7SUFDYk4seUVBQWFBO0lBQ2JDLHVFQUFXQTtJQUNYQyxxRUFBU0E7SUFDVEMseUVBQWFBO0lBQ2JDLG9FQUFRQTtJQUNSQyxxRUFBU0E7Q0FDVDtBQUVELE1BQU1FLGlCQUFpQixDQUFDQztJQUN2QixJQUFJRixNQUFNRyxNQUFNLElBQUksR0FBRyxPQUFPO0lBRTlCLElBQUlDLFlBQVlDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLUCxNQUFNRyxNQUFNO0lBQ3ZELE1BQU9DLGNBQWNGLGFBQWM7UUFDbENFLFlBQVlDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLUCxNQUFNRyxNQUFNO0lBQ3BEO0lBRUEsT0FBT0M7QUFDUjtBQUVPLE1BQU1JLGVBQWUsQ0FBQ0M7O0lBQzVCLE1BQU1DLGlCQUFpQmxCLDZDQUFNQSxDQUFvQjtJQUNqRCxNQUFNLENBQUNtQixrQkFBa0JDLG9CQUFvQixHQUFHbkIsK0NBQVFBO2lDQUFDLElBQ3hEWSxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBS1AsTUFBTUcsTUFBTTs7SUFHeEMsTUFBTVUsYUFBYXZCLGtEQUFXQTtnREFBQyxDQUFDd0I7WUFDL0JGO3dEQUFvQixDQUFDRztvQkFDcEIsTUFBTVgsWUFBWUgsZUFBZWM7b0JBRWpDLElBQUlELGlCQUFpQkosZUFBZU0sT0FBTyxFQUFFO3dCQUM1QzNCLGdEQUFPQSxDQUFDcUIsZUFBZU0sT0FBTyxFQUFFOzRCQUMvQkMsT0FBTztnQ0FBQztnQ0FBRztnQ0FBTTtnQ0FBTTs2QkFBRTs0QkFDekJDLFFBQVE7Z0NBQUM7Z0NBQVE7Z0NBQVU7NkJBQVM7NEJBQ3BDQyxVQUFVOzRCQUNWQyxRQUFRO3dCQUNUO29CQUNEO29CQUVBLE9BQU9oQjtnQkFDUjs7UUFDRDsrQ0FBRyxFQUFFO0lBRUxiLGdEQUFTQTtrQ0FBQztZQUNULE1BQU04QixjQUFjQyxPQUFPQyxXQUFXO3NEQUFDO29CQUN0Q1YsV0FBVztnQkFDWjtxREFBRztZQUVIOzBDQUFPO29CQUNOUyxPQUFPRSxhQUFhLENBQUNIO2dCQUN0Qjs7UUFDRDtpQ0FBRztRQUFDUjtLQUFXO0lBRWYsTUFBTVksY0FBY3pCLEtBQUssQ0FBQ1csaUJBQWlCO0lBRTNDLHFCQUNDLDhEQUFDZTtRQUNBQyxNQUFLO1FBQ0xDLEtBQUtsQjtRQUNMbUIsU0FBUyxJQUFNaEIsV0FBVztRQUMxQmlCLGNBQVc7UUFDWEMsV0FBVTtrQkFFViw0RUFBQzNDLGtEQUFLQTtZQUFDNEMsS0FBS1A7WUFBYVEsT0FBTztZQUFLQyxRQUFRO1lBQU0sR0FBR3pCLEtBQUs7Ozs7Ozs7Ozs7O0FBRzlELEVBQUU7R0E5Q1dEO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbW9kdWxlcy9sYXlvdXQvY29tcG9uZW50cy9TZWFzb25hbEljb24udHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XG5pbXBvcnQgeyBhbmltYXRlIH0gZnJvbSBcImFuaW1lanNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IEZhcm1sYW5kSW1hZ2UgZnJvbSBcIkAvcHVibGljL2Fzc2V0cy9pY29ucy9mYXJtbGFuZC5wbmdcIjtcbmltcG9ydCBOYXR1cmVJbWFnZSBmcm9tIFwiQC9wdWJsaWMvYXNzZXRzL2ljb25zL25hdHVyZS5wbmdcIjtcbmltcG9ydCBTbm93SW1hZ2UgZnJvbSBcIkAvcHVibGljL2Fzc2V0cy9pY29ucy9zbm93LnBuZ1wiO1xuaW1wb3J0IE1vdW50YWluSW1hZ2UgZnJvbSBcIkAvcHVibGljL2Fzc2V0cy9pY29ucy9tb3VudGFpbi5wbmdcIjtcbmltcG9ydCBJY2VJbWFnZSBmcm9tIFwiQC9wdWJsaWMvYXNzZXRzL2ljb25zL2ljZS5wbmdcIjtcbmltcG9ydCBDYXZlSW1hZ2UgZnJvbSBcIkAvcHVibGljL2Fzc2V0cy9pY29ucy9jYXZlLnBuZ1wiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuXHRjbGFzc05hbWU/OiBzdHJpbmc7XG5cdGFsdDogc3RyaW5nO1xufVxuXG5jb25zdCBpY29ucyA9IFtcblx0RmFybWxhbmRJbWFnZSxcblx0TmF0dXJlSW1hZ2UsXG5cdFNub3dJbWFnZSxcblx0TW91bnRhaW5JbWFnZSxcblx0SWNlSW1hZ2UsXG5cdENhdmVJbWFnZSxcbl07XG5cbmNvbnN0IGdldFJhbmRvbUluZGV4ID0gKGV4Y2x1ZGVJbmRleDogbnVtYmVyKSA9PiB7XG5cdGlmIChpY29ucy5sZW5ndGggPD0gMSkgcmV0dXJuIDA7XG5cblx0bGV0IG5leHRJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGljb25zLmxlbmd0aCk7XG5cdHdoaWxlIChuZXh0SW5kZXggPT09IGV4Y2x1ZGVJbmRleCkge1xuXHRcdG5leHRJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGljb25zLmxlbmd0aCk7XG5cdH1cblxuXHRyZXR1cm4gbmV4dEluZGV4O1xufTtcblxuZXhwb3J0IGNvbnN0IFNlYXNvbmFsSWNvbiA9IChwcm9wczogUHJvcHMpID0+IHtcblx0Y29uc3QgaWNvbldyYXBwZXJSZWYgPSB1c2VSZWY8SFRNTEJ1dHRvbkVsZW1lbnQ+KG51bGwpO1xuXHRjb25zdCBbY3VycmVudEljb25JbmRleCwgc2V0Q3VycmVudEljb25JbmRleF0gPSB1c2VTdGF0ZSgoKSA9PlxuXHRcdE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGljb25zLmxlbmd0aCksXG5cdCk7XG5cblx0Y29uc3QgY2hhbmdlSWNvbiA9IHVzZUNhbGxiYWNrKCh3aXRoQW5pbWF0aW9uOiBib29sZWFuKSA9PiB7XG5cdFx0c2V0Q3VycmVudEljb25JbmRleCgocHJldkluZGV4KSA9PiB7XG5cdFx0XHRjb25zdCBuZXh0SW5kZXggPSBnZXRSYW5kb21JbmRleChwcmV2SW5kZXgpO1xuXG5cdFx0XHRpZiAod2l0aEFuaW1hdGlvbiAmJiBpY29uV3JhcHBlclJlZi5jdXJyZW50KSB7XG5cdFx0XHRcdGFuaW1hdGUoaWNvbldyYXBwZXJSZWYuY3VycmVudCwge1xuXHRcdFx0XHRcdHNjYWxlOiBbMSwgMC44MiwgMS4wNiwgMV0sXG5cdFx0XHRcdFx0cm90YXRlOiBbXCIwZGVnXCIsIFwiMTgwZGVnXCIsIFwiMzYwZGVnXCJdLFxuXHRcdFx0XHRcdGR1cmF0aW9uOiA2NTAsXG5cdFx0XHRcdFx0ZWFzaW5nOiBcImVhc2VJbk91dFF1YXJ0XCIsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV4dEluZGV4O1xuXHRcdH0pO1xuXHR9LCBbXSk7XG5cblx0dXNlRWZmZWN0KCgpID0+IHtcblx0XHRjb25zdCBtaW51dGVUaW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRjaGFuZ2VJY29uKHRydWUpO1xuXHRcdH0sIDYwXzAwMCk7XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0d2luZG93LmNsZWFySW50ZXJ2YWwobWludXRlVGltZXIpO1xuXHRcdH07XG5cdH0sIFtjaGFuZ2VJY29uXSk7XG5cblx0Y29uc3QgY3VycmVudEljb24gPSBpY29uc1tjdXJyZW50SWNvbkluZGV4XTtcblxuXHRyZXR1cm4gKFxuXHRcdDxidXR0b25cblx0XHRcdHR5cGU9XCJidXR0b25cIlxuXHRcdFx0cmVmPXtpY29uV3JhcHBlclJlZn1cblx0XHRcdG9uQ2xpY2s9eygpID0+IGNoYW5nZUljb24odHJ1ZSl9XG5cdFx0XHRhcmlhLWxhYmVsPVwiUmFuZG9taXplIGxvZ28gaWNvblwiXG5cdFx0XHRjbGFzc05hbWU9XCJzaHJpbmstMFwiXG5cdFx0PlxuXHRcdFx0PEltYWdlIHNyYz17Y3VycmVudEljb259IHdpZHRoPXsxMDB9IGhlaWdodD17MTAwfSB7Li4ucHJvcHN9IC8+XG5cdFx0PC9idXR0b24+XG5cdCk7XG59O1xuIl0sIm5hbWVzIjpbIkltYWdlIiwiYW5pbWF0ZSIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJGYXJtbGFuZEltYWdlIiwiTmF0dXJlSW1hZ2UiLCJTbm93SW1hZ2UiLCJNb3VudGFpbkltYWdlIiwiSWNlSW1hZ2UiLCJDYXZlSW1hZ2UiLCJpY29ucyIsImdldFJhbmRvbUluZGV4IiwiZXhjbHVkZUluZGV4IiwibGVuZ3RoIiwibmV4dEluZGV4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiU2Vhc29uYWxJY29uIiwicHJvcHMiLCJpY29uV3JhcHBlclJlZiIsImN1cnJlbnRJY29uSW5kZXgiLCJzZXRDdXJyZW50SWNvbkluZGV4IiwiY2hhbmdlSWNvbiIsIndpdGhBbmltYXRpb24iLCJwcmV2SW5kZXgiLCJjdXJyZW50Iiwic2NhbGUiLCJyb3RhdGUiLCJkdXJhdGlvbiIsImVhc2luZyIsIm1pbnV0ZVRpbWVyIiwid2luZG93Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY3VycmVudEljb24iLCJidXR0b24iLCJ0eXBlIiwicmVmIiwib25DbGljayIsImFyaWEtbGFiZWwiLCJjbGFzc05hbWUiLCJzcmMiLCJ3aWR0aCIsImhlaWdodCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./modules/layout/components/SeasonalIcon.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/image-component.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/image-component.js ***!
  \*************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-loader.js\"));\nconst _usemergedref = __webpack_require__(/*! ./use-merged-ref */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/use-merged-ref.js\");\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":true,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"};\nif (typeof window === 'undefined') {\n    ;\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img['data-loaded-src'] === src) {\n        return;\n    }\n    img['data-loaded-src'] = src;\n    const p = 'decode' in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== 'empty') {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event('load');\n            Object.defineProperty(event, 'target', {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;\n            if (img.getAttribute('data-nimg') === 'fill') {\n                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === '100vw') {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        'absolute',\n                        'fixed',\n                        'relative'\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(',') + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute('height');\n            const widthModified = img.width.toString() !== img.getAttribute('width');\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;\n    const ownRef = (0, _react.useCallback)((img)=>{\n        if (!img) {\n            return;\n        }\n        if (onError) {\n            // If the image has an error before react hydrates, then the error is lost.\n            // The workaround is to wait until the image is mounted which is after hydration,\n            // then we set the src again to trigger the error handler (if there was an error).\n            // eslint-disable-next-line no-self-assign\n            img.src = img.src;\n        }\n        if (true) {\n            if (!src) {\n                console.error('Image is missing required \"src\" property:', img);\n            }\n            if (img.getAttribute('alt') === null) {\n                console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n            }\n        }\n        if (img.complete) {\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        }\n    }, [\n        src,\n        placeholder,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        onError,\n        unoptimized,\n        sizesInput\n    ]);\n    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? 'fill' : '1',\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: ref,\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== 'empty') {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: 'image',\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        var _c_qualities;\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes,\n            qualities\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O3lDQTBXYUE7OztlQUFBQTs7Ozs7OzZFQS9WTjsrRUFDYzsyRUFDSjt5Q0FDVzt5Q0FZTzs2REFDQTtzQ0FDVjt3REFDSztrRkFHSjswQ0FDRztBQUU3Qiw0Q0FBNEM7QUFDNUMsTUFBTUMsWUFBWUMsNE9BQTZCO0FBRS9DLElBQUksT0FBT0csV0FBVyxhQUFhOztJQUMvQkMsV0FBbUJDLHFCQUFxQixHQUFHO0FBQy9DO0FBbUJBLDBFQUEwRTtBQUMxRSxpREFBaUQ7QUFDakQsU0FBU0MsY0FDUEMsR0FBMkIsRUFDM0JDLFdBQTZCLEVBQzdCQyxTQUFxRCxFQUNyREMsb0JBQTJFLEVBQzNFQyxlQUFxQyxFQUNyQ0MsV0FBb0IsRUFDcEJDLFVBQThCO0lBRTlCLE1BQU1DLE1BQU1QLE9BQUFBLE9BQUFBLEtBQUFBLElBQUFBLElBQUtPLEdBQUc7SUFDcEIsSUFBSSxDQUFDUCxPQUFPQSxHQUFHLENBQUMsa0JBQWtCLEtBQUtPLEtBQUs7UUFDMUM7SUFDRjtJQUNBUCxHQUFHLENBQUMsa0JBQWtCLEdBQUdPO0lBQ3pCLE1BQU1DLElBQUksWUFBWVIsTUFBTUEsSUFBSVMsTUFBTSxLQUFLQyxRQUFRQyxPQUFPO0lBQzFESCxFQUFFSSxLQUFLLENBQUMsS0FBTyxHQUFHQyxJQUFJLENBQUM7UUFDckIsSUFBSSxDQUFDYixJQUFJYyxhQUFhLElBQUksQ0FBQ2QsSUFBSWUsV0FBVyxFQUFFO1lBQzFDLHdDQUF3QztZQUN4Qyx1QkFBdUI7WUFDdkIsc0NBQXNDO1lBQ3RDLHNCQUFzQjtZQUN0Qix1QkFBdUI7WUFDdkI7UUFDRjtRQUNBLElBQUlkLGdCQUFnQixTQUFTO1lBQzNCRyxn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Q3RCQyxpQkFBaUJBO2dCQUNqQmtFLGdCQUFnQkE7Z0JBQ2hCaEUsWUFBWTRGLE1BQU1sQyxLQUFLO2dCQUN2QmUsS0FBS2pCOztZQUdSMkQsUUFBUUksUUFBUSxpQkFDZixxQkFBQzNDLGNBQUFBO2dCQUNDQyxhQUFhQTtnQkFDYkMsZUFBZUE7aUJBRWY7OztBQUdWIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9zcmMvY2xpZW50L2ltYWdlLWNvbXBvbmVudC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwge1xuICB1c2VSZWYsXG4gIHVzZUVmZmVjdCxcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQsXG4gIHVzZU1lbW8sXG4gIHVzZVN0YXRlLFxuICBmb3J3YXJkUmVmLFxuICB1c2UsXG59IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCBIZWFkIGZyb20gJy4uL3NoYXJlZC9saWIvaGVhZCdcbmltcG9ydCB7IGdldEltZ1Byb3BzIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzJ1xuaW1wb3J0IHR5cGUge1xuICBJbWFnZVByb3BzLFxuICBJbWdQcm9wcyxcbiAgT25Mb2FkLFxuICBPbkxvYWRpbmdDb21wbGV0ZSxcbiAgUGxhY2Vob2xkZXJWYWx1ZSxcbn0gZnJvbSAnLi4vc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzJ1xuaW1wb3J0IHR5cGUge1xuICBJbWFnZUNvbmZpZ0NvbXBsZXRlLFxuICBJbWFnZUxvYWRlclByb3BzLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZydcbmltcG9ydCB7IGltYWdlQ29uZmlnRGVmYXVsdCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgSW1hZ2VDb25maWdDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi91dGlscy93YXJuLW9uY2UnXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcblxuLy8gQHRzLWlnbm9yZSAtIFRoaXMgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBhbGlhc1xuaW1wb3J0IGRlZmF1bHRMb2FkZXIgZnJvbSAnbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyJ1xuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmIH0gZnJvbSAnLi91c2UtbWVyZ2VkLXJlZidcblxuLy8gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGRlZmluZSBwbHVnaW5cbmNvbnN0IGNvbmZpZ0VudiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTIGFzIGFueSBhcyBJbWFnZUNvbmZpZ0NvbXBsZXRlXG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICA7KGdsb2JhbFRoaXMgYXMgYW55KS5fX05FWFRfSU1BR0VfSU1QT1JURUQgPSB0cnVlXG59XG5cbmV4cG9ydCB0eXBlIHsgSW1hZ2VMb2FkZXJQcm9wcyB9XG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlciA9IChwOiBJbWFnZUxvYWRlclByb3BzKSA9PiBzdHJpbmdcblxudHlwZSBJbWdFbGVtZW50V2l0aERhdGFQcm9wID0gSFRNTEltYWdlRWxlbWVudCAmIHtcbiAgJ2RhdGEtbG9hZGVkLXNyYyc6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG50eXBlIEltYWdlRWxlbWVudFByb3BzID0gSW1nUHJvcHMgJiB7XG4gIHVub3B0aW1pemVkOiBib29sZWFuXG4gIHBsYWNlaG9sZGVyOiBQbGFjZWhvbGRlclZhbHVlXG4gIG9uTG9hZFJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxPbkxvYWQgfCB1bmRlZmluZWQ+XG4gIG9uTG9hZGluZ0NvbXBsZXRlUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZGluZ0NvbXBsZXRlIHwgdW5kZWZpbmVkPlxuICBzZXRCbHVyQ29tcGxldGU6IChiOiBib29sZWFuKSA9PiB2b2lkXG4gIHNldFNob3dBbHRUZXh0OiAoYjogYm9vbGVhbikgPT4gdm9pZFxuICBzaXplc0lucHV0OiBzdHJpbmcgfCB1bmRlZmluZWRcbn1cblxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTc3NzgzMy8yNjY1MzUgZm9yIHdoeSB3ZSB1c2UgdGhpcyByZWZcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRpbmcoXG4gIGltZzogSW1nRWxlbWVudFdpdGhEYXRhUHJvcCxcbiAgcGxhY2Vob2xkZXI6IFBsYWNlaG9sZGVyVmFsdWUsXG4gIG9uTG9hZFJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxPbkxvYWQgfCB1bmRlZmluZWQ+LFxuICBvbkxvYWRpbmdDb21wbGV0ZVJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxPbkxvYWRpbmdDb21wbGV0ZSB8IHVuZGVmaW5lZD4sXG4gIHNldEJsdXJDb21wbGV0ZTogKGI6IGJvb2xlYW4pID0+IHZvaWQsXG4gIHVub3B0aW1pemVkOiBib29sZWFuLFxuICBzaXplc0lucHV0OiBzdHJpbmcgfCB1bmRlZmluZWRcbikge1xuICBjb25zdCBzcmMgPSBpbWc/LnNyY1xuICBpZiAoIWltZyB8fCBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID09PSBzcmMpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpbWdbJ2RhdGEtbG9hZGVkLXNyYyddID0gc3JjXG4gIGNvbnN0IHAgPSAnZGVjb2RlJyBpbiBpbWcgPyBpbWcuZGVjb2RlKCkgOiBQcm9taXNlLnJlc29sdmUoKVxuICBwLmNhdGNoKCgpID0+IHt9KS50aGVuKCgpID0+IHtcbiAgICBpZiAoIWltZy5wYXJlbnRFbGVtZW50IHx8ICFpbWcuaXNDb25uZWN0ZWQpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaW4gY2FzZSBvZiByYWNlIGNvbmRpdGlvbjpcbiAgICAgIC8vIC0gb25sb2FkKCkgaXMgY2FsbGVkXG4gICAgICAvLyAtIGRlY29kZSgpIGlzIGNhbGxlZCBidXQgaW5jb21wbGV0ZVxuICAgICAgLy8gLSB1bm1vdW50IGlzIGNhbGxlZFxuICAgICAgLy8gLSBkZWNvZGUoKSBjb21wbGV0ZXNcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAocGxhY2Vob2xkZXIgIT09ICdlbXB0eScpIHtcbiAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKVxuICAgIH1cbiAgICBpZiAob25Mb2FkUmVmPy5jdXJyZW50KSB7XG4gICAgICAvLyBTaW5jZSB3ZSBkb24ndCBoYXZlIHRoZSBTeW50aGV0aWNFdmVudCBoZXJlLFxuICAgICAgLy8gd2UgbXVzdCBjcmVhdGUgb25lIHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2V2ZW50cy5odG1sXG4gICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnbG9hZCcpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsICd0YXJnZXQnLCB7IHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IGltZyB9KVxuICAgICAgbGV0IHByZXZlbnRlZCA9IGZhbHNlXG4gICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlXG4gICAgICBvbkxvYWRSZWYuY3VycmVudCh7XG4gICAgICAgIC4uLmV2ZW50LFxuICAgICAgICBuYXRpdmVFdmVudDogZXZlbnQsXG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IGltZyxcbiAgICAgICAgdGFyZ2V0OiBpbWcsXG4gICAgICAgIGlzRGVmYXVsdFByZXZlbnRlZDogKCkgPT4gcHJldmVudGVkLFxuICAgICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogKCkgPT4gc3RvcHBlZCxcbiAgICAgICAgcGVyc2lzdDogKCkgPT4ge30sXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB7XG4gICAgICAgICAgcHJldmVudGVkID0gdHJ1ZVxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgc3RvcHBlZCA9IHRydWVcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlUmVmPy5jdXJyZW50KSB7XG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KGltZylcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IG9yaWdTcmMgPSBuZXcgVVJMKHNyYywgJ2h0dHA6Ly9uJykuc2VhcmNoUGFyYW1zLmdldCgndXJsJykgfHwgc3JjXG4gICAgICBpZiAoaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1uaW1nJykgPT09ICdmaWxsJykge1xuICAgICAgICBpZiAoIXVub3B0aW1pemVkICYmICghc2l6ZXNJbnB1dCB8fCBzaXplc0lucHV0ID09PSAnMTAwdncnKSkge1xuICAgICAgICAgIGxldCB3aWR0aFZpZXdwb3J0UmF0aW8gPVxuICAgICAgICAgICAgaW1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgICBpZiAod2lkdGhWaWV3cG9ydFJhdGlvIDwgMC42KSB7XG4gICAgICAgICAgICBpZiAoc2l6ZXNJbnB1dCA9PT0gJzEwMHZ3Jykge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke29yaWdTcmN9XCIgaGFzIFwiZmlsbFwiIHByb3AgYW5kIFwic2l6ZXNcIiBwcm9wIG9mIFwiMTAwdndcIiwgYnV0IGltYWdlIGlzIG5vdCByZW5kZXJlZCBhdCBmdWxsIHZpZXdwb3J0IHdpZHRoLiBQbGVhc2UgYWRqdXN0IFwic2l6ZXNcIiB0byBpbXByb3ZlIHBhZ2UgcGVyZm9ybWFuY2UuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3NpemVzYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke29yaWdTcmN9XCIgaGFzIFwiZmlsbFwiIGJ1dCBpcyBtaXNzaW5nIFwic2l6ZXNcIiBwcm9wLiBQbGVhc2UgYWRkIGl0IHRvIGltcHJvdmUgcGFnZSBwZXJmb3JtYW5jZS4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2Ujc2l6ZXNgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaW1nLnBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgY29uc3QgdmFsaWQgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJywgJ3JlbGF0aXZlJ11cbiAgICAgICAgICBpZiAoIXZhbGlkLmluY2x1ZGVzKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYW5kIHBhcmVudCBlbGVtZW50IHdpdGggaW52YWxpZCBcInBvc2l0aW9uXCIuIFByb3ZpZGVkIFwiJHtwb3NpdGlvbn1cIiBzaG91bGQgYmUgb25lIG9mICR7dmFsaWRcbiAgICAgICAgICAgICAgICAubWFwKFN0cmluZylcbiAgICAgICAgICAgICAgICAuam9pbignLCcpfS5gXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbWcuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke29yaWdTcmN9XCIgaGFzIFwiZmlsbFwiIGFuZCBhIGhlaWdodCB2YWx1ZSBvZiAwLiBUaGlzIGlzIGxpa2VseSBiZWNhdXNlIHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgaW1hZ2UgaGFzIG5vdCBiZWVuIHN0eWxlZCB0byBoYXZlIGEgc2V0IGhlaWdodC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhlaWdodE1vZGlmaWVkID1cbiAgICAgICAgaW1nLmhlaWdodC50b1N0cmluZygpICE9PSBpbWcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxuICAgICAgY29uc3Qgd2lkdGhNb2RpZmllZCA9IGltZy53aWR0aC50b1N0cmluZygpICE9PSBpbWcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpXG4gICAgICBpZiAoXG4gICAgICAgIChoZWlnaHRNb2RpZmllZCAmJiAhd2lkdGhNb2RpZmllZCkgfHxcbiAgICAgICAgKCFoZWlnaHRNb2RpZmllZCAmJiB3aWR0aE1vZGlmaWVkKVxuICAgICAgKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgZWl0aGVyIHdpZHRoIG9yIGhlaWdodCBtb2RpZmllZCwgYnV0IG5vdCB0aGUgb3RoZXIuIElmIHlvdSB1c2UgQ1NTIHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB5b3VyIGltYWdlLCBhbHNvIGluY2x1ZGUgdGhlIHN0eWxlcyAnd2lkdGg6IFwiYXV0b1wiJyBvciAnaGVpZ2h0OiBcImF1dG9cIicgdG8gbWFpbnRhaW4gdGhlIGFzcGVjdCByYXRpby5gXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldER5bmFtaWNQcm9wcyhcbiAgZmV0Y2hQcmlvcml0eT86IHN0cmluZ1xuKTogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGlmIChCb29sZWFuKHVzZSkpIHtcbiAgICAvLyBJbiBSZWFjdCAxOS4wLjAgb3IgbmV3ZXIsIHdlIG11c3QgdXNlIGNhbWVsQ2FzZVxuICAgIC8vIHByb3AgdG8gYXZvaWQgXCJXYXJuaW5nOiBJbnZhbGlkIERPTSBwcm9wZXJ0eVwiLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNTkyN1xuICAgIHJldHVybiB7IGZldGNoUHJpb3JpdHkgfVxuICB9XG4gIC8vIEluIFJlYWN0IDE4LjIuMCBvciBvbGRlciwgd2UgbXVzdCB1c2UgbG93ZXJjYXNlIHByb3BcbiAgLy8gdG8gYXZvaWQgXCJXYXJuaW5nOiBJbnZhbGlkIERPTSBwcm9wZXJ0eVwiLlxuICByZXR1cm4geyBmZXRjaHByaW9yaXR5OiBmZXRjaFByaW9yaXR5IH1cbn1cblxuY29uc3QgSW1hZ2VFbGVtZW50ID0gZm9yd2FyZFJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbCwgSW1hZ2VFbGVtZW50UHJvcHM+KFxuICAoXG4gICAge1xuICAgICAgc3JjLFxuICAgICAgc3JjU2V0LFxuICAgICAgc2l6ZXMsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGRlY29kaW5nLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgc3R5bGUsXG4gICAgICBmZXRjaFByaW9yaXR5LFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBsb2FkaW5nLFxuICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICBmaWxsLFxuICAgICAgb25Mb2FkUmVmLFxuICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICBzZXRTaG93QWx0VGV4dCxcbiAgICAgIHNpemVzSW5wdXQsXG4gICAgICBvbkxvYWQsXG4gICAgICBvbkVycm9yLFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGNvbnN0IG93blJlZiA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGltZzogSW1nRWxlbWVudFdpdGhEYXRhUHJvcCB8IG51bGwpID0+IHtcbiAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYW4gZXJyb3IgYmVmb3JlIHJlYWN0IGh5ZHJhdGVzLCB0aGVuIHRoZSBlcnJvciBpcyBsb3N0LlxuICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIHdhaXQgdW50aWwgdGhlIGltYWdlIGlzIG1vdW50ZWQgd2hpY2ggaXMgYWZ0ZXIgaHlkcmF0aW9uLFxuICAgICAgICAgIC8vIHRoZW4gd2Ugc2V0IHRoZSBzcmMgYWdhaW4gdG8gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciAoaWYgdGhlcmUgd2FzIGFuIGVycm9yKS5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICBpbWcuc3JjID0gaW1nLnNyY1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEltYWdlIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJzcmNcIiBwcm9wZXJ0eTpgLCBpbWcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKCdhbHQnKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgYEltYWdlIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJhbHRcIiBwcm9wZXJ0eS4gUGxlYXNlIGFkZCBBbHRlcm5hdGl2ZSBUZXh0IHRvIGRlc2NyaWJlIHRoZSBpbWFnZSBmb3Igc2NyZWVuIHJlYWRlcnMgYW5kIHNlYXJjaCBlbmdpbmVzLmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgIGhhbmRsZUxvYWRpbmcoXG4gICAgICAgICAgICBpbWcsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBzaXplc0lucHV0XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBzcmMsXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBvbkxvYWRSZWYsXG4gICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICBzaXplc0lucHV0LFxuICAgICAgXVxuICAgIClcblxuICAgIGNvbnN0IHJlZiA9IHVzZU1lcmdlZFJlZihmb3J3YXJkZWRSZWYsIG93blJlZilcblxuICAgIHJldHVybiAoXG4gICAgICA8aW1nXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICB7Li4uZ2V0RHluYW1pY1Byb3BzKGZldGNoUHJpb3JpdHkpfVxuICAgICAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYGxvYWRpbmdgIGJlZm9yZSBgc3JjYCBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gcHJvcHMgaW4gb3JkZXIgd2hpY2ggY2F1c2VzIFNhZmFyaS9GaXJlZm94IHRvIG5vdCBsYXp5IGxvYWQgcHJvcGVybHkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzI1ODgzXG4gICAgICAgIGxvYWRpbmc9e2xvYWRpbmd9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIGRlY29kaW5nPXtkZWNvZGluZ31cbiAgICAgICAgZGF0YS1uaW1nPXtmaWxsID8gJ2ZpbGwnIDogJzEnfVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYHNyY2AgdGhlIGxhc3QgYXR0cmlidXRlIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBhdHRyaWJ1dGVzIGluIG9yZGVyLiBJZiB3ZSBrZWVwIGBzcmNgIHRoZSBmaXJzdCBvbmUsIFNhZmFyaSB3aWxsXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHN0YXJ0IHRvIGZldGNoIGBzcmNgLCBiZWZvcmUgYHNpemVzYCBhbmQgYHNyY1NldGAgYXJlIGV2ZW5cbiAgICAgICAgLy8gdXBkYXRlZCBieSBSZWFjdC4gVGhhdCBjYXVzZXMgbXVsdGlwbGUgdW5uZWNlc3NhcnkgcmVxdWVzdHMgaWYgYHNyY1NldGBcbiAgICAgICAgLy8gYW5kIGBzaXplc2AgYXJlIGRlZmluZWQuXG4gICAgICAgIC8vIFRoaXMgYnVnIGNhbm5vdCBiZSByZXByb2R1Y2VkIGluIENocm9tZSBvciBGaXJlZm94LlxuICAgICAgICBzaXplcz17c2l6ZXN9XG4gICAgICAgIHNyY1NldD17c3JjU2V0fVxuICAgICAgICBzcmM9e3NyY31cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIG9uTG9hZD17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBJbWdFbGVtZW50V2l0aERhdGFQcm9wXG4gICAgICAgICAgaGFuZGxlTG9hZGluZyhcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIHNpemVzSW5wdXRcbiAgICAgICAgICApXG4gICAgICAgIH19XG4gICAgICAgIG9uRXJyb3I9eyhldmVudCkgPT4ge1xuICAgICAgICAgIC8vIGlmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBlbnN1cmUgXCJhbHRcIiBpcyB2aXNpYmxlXG4gICAgICAgICAgc2V0U2hvd0FsdFRleHQodHJ1ZSlcbiAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09ICdlbXB0eScpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBzdGlsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgKVxuICB9XG4pXG5cbmZ1bmN0aW9uIEltYWdlUHJlbG9hZCh7XG4gIGlzQXBwUm91dGVyLFxuICBpbWdBdHRyaWJ1dGVzLFxufToge1xuICBpc0FwcFJvdXRlcjogYm9vbGVhblxuICBpbWdBdHRyaWJ1dGVzOiBJbWdQcm9wc1xufSkge1xuICBjb25zdCBvcHRzID0ge1xuICAgIGFzOiAnaW1hZ2UnLFxuICAgIGltYWdlU3JjU2V0OiBpbWdBdHRyaWJ1dGVzLnNyY1NldCxcbiAgICBpbWFnZVNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgIGNyb3NzT3JpZ2luOiBpbWdBdHRyaWJ1dGVzLmNyb3NzT3JpZ2luLFxuICAgIHJlZmVycmVyUG9saWN5OiBpbWdBdHRyaWJ1dGVzLnJlZmVycmVyUG9saWN5LFxuICAgIC4uLmdldER5bmFtaWNQcm9wcyhpbWdBdHRyaWJ1dGVzLmZldGNoUHJpb3JpdHkpLFxuICB9XG5cbiAgaWYgKGlzQXBwUm91dGVyICYmIFJlYWN0RE9NLnByZWxvYWQpIHtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjY5NDBcbiAgICBSZWFjdERPTS5wcmVsb2FkKFxuICAgICAgaW1nQXR0cmlidXRlcy5zcmMsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IHVwZ3JhZGUgdG8gYEB0eXBlcy9yZWFjdC1kb21AMTguMy54YFxuICAgICAgb3B0c1xuICAgIClcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8SGVhZD5cbiAgICAgIDxsaW5rXG4gICAgICAgIGtleT17XG4gICAgICAgICAgJ19fbmltZy0nICtcbiAgICAgICAgICBpbWdBdHRyaWJ1dGVzLnNyYyArXG4gICAgICAgICAgaW1nQXR0cmlidXRlcy5zcmNTZXQgK1xuICAgICAgICAgIGltZ0F0dHJpYnV0ZXMuc2l6ZXNcbiAgICAgICAgfVxuICAgICAgICByZWw9XCJwcmVsb2FkXCJcbiAgICAgICAgLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgICAgICAvLyBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBgaW1hZ2VzcmNzZXRgLCBhbmQgaW4gdGhvc2UgY2FzZXNcbiAgICAgICAgLy8gaXQgd291bGQgY2F1c2UgdGhlIGluY29ycmVjdCBpbWFnZSB0byBiZSBwcmVsb2FkZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI2F0dHItbGluay1pbWFnZXNyY3NldFxuICAgICAgICBocmVmPXtpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjfVxuICAgICAgICB7Li4ub3B0c31cbiAgICAgIC8+XG4gICAgPC9IZWFkPlxuICApXG59XG5cbi8qKlxuICogVGhlIGBJbWFnZWAgY29tcG9uZW50IGlzIHVzZWQgdG8gb3B0aW1pemUgaW1hZ2VzLlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgZG9jczogYEltYWdlYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9pbWFnZSlcbiAqL1xuZXhwb3J0IGNvbnN0IEltYWdlID0gZm9yd2FyZFJlZjxIVE1MSW1hZ2VFbGVtZW50IHwgbnVsbCwgSW1hZ2VQcm9wcz4oXG4gIChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gICAgY29uc3QgcGFnZXNSb3V0ZXIgPSB1c2VDb250ZXh0KFJvdXRlckNvbnRleHQpXG4gICAgLy8gV2UncmUgaW4gdGhlIGFwcCBkaXJlY3RvcnkgaWYgdGhlcmUgaXMgbm8gcGFnZXMgcm91dGVyLlxuICAgIGNvbnN0IGlzQXBwUm91dGVyID0gIXBhZ2VzUm91dGVyXG5cbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gdXNlQ29udGV4dChJbWFnZUNvbmZpZ0NvbnRleHQpXG4gICAgY29uc3QgY29uZmlnID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgaW1hZ2VDb25maWdEZWZhdWx0XG4gICAgICBjb25zdCBhbGxTaXplcyA9IFsuLi5jLmRldmljZVNpemVzLCAuLi5jLmltYWdlU2l6ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgY29uc3QgcXVhbGl0aWVzID0gYy5xdWFsaXRpZXM/LnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgcmV0dXJuIHsgLi4uYywgYWxsU2l6ZXMsIGRldmljZVNpemVzLCBxdWFsaXRpZXMgfVxuICAgIH0sIFtjb25maWdDb250ZXh0XSlcblxuICAgIGNvbnN0IHsgb25Mb2FkLCBvbkxvYWRpbmdDb21wbGV0ZSB9ID0gcHJvcHNcbiAgICBjb25zdCBvbkxvYWRSZWYgPSB1c2VSZWYob25Mb2FkKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIG9uTG9hZFJlZi5jdXJyZW50ID0gb25Mb2FkXG4gICAgfSwgW29uTG9hZF0pXG5cbiAgICBjb25zdCBvbkxvYWRpbmdDb21wbGV0ZVJlZiA9IHVzZVJlZihvbkxvYWRpbmdDb21wbGV0ZSlcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50ID0gb25Mb2FkaW5nQ29tcGxldGVcbiAgICB9LCBbb25Mb2FkaW5nQ29tcGxldGVdKVxuXG4gICAgY29uc3QgW2JsdXJDb21wbGV0ZSwgc2V0Qmx1ckNvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzaG93QWx0VGV4dCwgc2V0U2hvd0FsdFRleHRdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgICBjb25zdCB7IHByb3BzOiBpbWdBdHRyaWJ1dGVzLCBtZXRhOiBpbWdNZXRhIH0gPSBnZXRJbWdQcm9wcyhwcm9wcywge1xuICAgICAgZGVmYXVsdExvYWRlcixcbiAgICAgIGltZ0NvbmY6IGNvbmZpZyxcbiAgICAgIGJsdXJDb21wbGV0ZSxcbiAgICAgIHNob3dBbHRUZXh0LFxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAge1xuICAgICAgICAgIDxJbWFnZUVsZW1lbnRcbiAgICAgICAgICAgIHsuLi5pbWdBdHRyaWJ1dGVzfVxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQ9e2ltZ01ldGEudW5vcHRpbWl6ZWR9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17aW1nTWV0YS5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIGZpbGw9e2ltZ01ldGEuZmlsbH1cbiAgICAgICAgICAgIG9uTG9hZFJlZj17b25Mb2FkUmVmfVxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWY9e29uTG9hZGluZ0NvbXBsZXRlUmVmfVxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlPXtzZXRCbHVyQ29tcGxldGV9XG4gICAgICAgICAgICBzZXRTaG93QWx0VGV4dD17c2V0U2hvd0FsdFRleHR9XG4gICAgICAgICAgICBzaXplc0lucHV0PXtwcm9wcy5zaXplc31cbiAgICAgICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgICAge2ltZ01ldGEucHJpb3JpdHkgPyAoXG4gICAgICAgICAgPEltYWdlUHJlbG9hZFxuICAgICAgICAgICAgaXNBcHBSb3V0ZXI9e2lzQXBwUm91dGVyfVxuICAgICAgICAgICAgaW1nQXR0cmlidXRlcz17aW1nQXR0cmlidXRlc31cbiAgICAgICAgICAvPlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvPlxuICAgIClcbiAgfVxuKVxuIl0sIm5hbWVzIjpbIkltYWdlIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwid2luZG93IiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJwbGFjZWhvbGRlciIsIm9uTG9hZFJlZiIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzaXplc0lucHV0Iiwic3JjIiwicCIsImRlY29kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJ0aGVuIiwicGFyZW50RWxlbWVudCIsImlzQ29ubmVjdGVkIiwiY3VycmVudCIsImV2ZW50IiwiRXZlbnQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwidmFsdWUiLCJwcmV2ZW50ZWQiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJOT0RFX0VOViIsIm9yaWdTcmMiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJ3aWR0aFZpZXdwb3J0UmF0aW8iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJ3YXJuT25jZSIsInBvc2l0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZhbGlkIiwiaW5jbHVkZXMiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiaGVpZ2h0IiwiaGVpZ2h0TW9kaWZpZWQiLCJ0b1N0cmluZyIsIndpZHRoTW9kaWZpZWQiLCJnZXREeW5hbWljUHJvcHMiLCJmZXRjaFByaW9yaXR5IiwiQm9vbGVhbiIsInVzZSIsImZldGNocHJpb3JpdHkiLCJJbWFnZUVsZW1lbnQiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZGVkUmVmIiwic3JjU2V0Iiwic2l6ZXMiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwibG9hZGluZyIsImZpbGwiLCJzZXRTaG93QWx0VGV4dCIsIm9uTG9hZCIsIm9uRXJyb3IiLCJyZXN0Iiwib3duUmVmIiwidXNlQ2FsbGJhY2siLCJjb25zb2xlIiwiZXJyb3IiLCJjb21wbGV0ZSIsInJlZiIsInVzZU1lcmdlZFJlZiIsImRhdGEtbmltZyIsIkltYWdlUHJlbG9hZCIsImlzQXBwUm91dGVyIiwiaW1nQXR0cmlidXRlcyIsIm9wdHMiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJSZWFjdERPTSIsInByZWxvYWQiLCJIZWFkIiwibGluayIsInJlbCIsImhyZWYiLCJ1bmRlZmluZWQiLCJwcm9wcyIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJjb25maWdDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiY29uZmlnIiwidXNlTWVtbyIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsImRldmljZVNpemVzIiwic29ydCIsImEiLCJiIiwicXVhbGl0aWVzIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJibHVyQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwibWV0YSIsImltZ01ldGEiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwicHJpb3JpdHkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/request-idle-callback.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/request-idle-callback.js ***!
  \*******************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFnQmFBLGtCQUFrQjtlQUFsQkE7O0lBaEJBQyxtQkFBbUI7ZUFBbkJBOzs7QUFBTixNQUFNQSxzQkFDVixPQUFPQyxTQUFTLGVBQ2ZBLEtBQUtELG1CQUFtQixJQUN4QkMsS0FBS0QsbUJBQW1CLENBQUNFLElBQUksQ0FBQ0MsV0FDaEMsU0FBVUMsRUFBdUI7SUFDL0IsSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDckJKLEdBQUc7WUFDREssWUFBWTtZQUNaQyxlQUFlO2dCQUNiLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBQUEsQ0FBSTtZQUM1QztRQUNGO0lBQ0YsR0FBRztBQUNMO0FBRUssTUFBTU4scUJBQ1YsT0FBT0UsU0FBUyxlQUNmQSxLQUFLRixrQkFBa0IsSUFDdkJFLEtBQUtGLGtCQUFrQixDQUFDRyxJQUFJLENBQUNDLFdBQy9CLFNBQVVVLEVBQVU7SUFDbEIsT0FBT0MsYUFBYUQ7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL3NyYy9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID1cbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjayAmJlxuICAgIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjay5iaW5kKHdpbmRvdykpIHx8XG4gIGZ1bmN0aW9uIChjYjogSWRsZVJlcXVlc3RDYWxsYmFjayk6IG51bWJlciB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2Ioe1xuICAgICAgICBkaWRUaW1lb3V0OiBmYWxzZSxcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCA1MCAtIChEYXRlLm5vdygpIC0gc3RhcnQpKVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9LCAxKVxuICB9XG5cbmV4cG9ydCBjb25zdCBjYW5jZWxJZGxlQ2FsbGJhY2sgPVxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmXG4gICAgc2VsZi5jYW5jZWxJZGxlQ2FsbGJhY2sgJiZcbiAgICBzZWxmLmNhbmNlbElkbGVDYWxsYmFjay5iaW5kKHdpbmRvdykpIHx8XG4gIGZ1bmN0aW9uIChpZDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChpZClcbiAgfVxuIl0sIm5hbWVzIjpbImNhbmNlbElkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/script.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/script.js ***!
  \****************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    handleClientScriptLoad: function() {\n        return handleClientScriptLoad;\n    },\n    initScriptLoader: function() {\n        return initScriptLoader;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _setattributesfromprops = __webpack_require__(/*! ./set-attributes-from-props */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/set-attributes-from-props.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/request-idle-callback.js\");\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst insertStylesheets = (stylesheets)=>{\n    // Case 1: Styles for afterInteractive/lazyOnload with appDir injected via handleClientScriptLoad\n    //\n    // Using ReactDOM.preinit to feature detect appDir and inject styles\n    // Stylesheets might have already been loaded if initialized with Script component\n    // Re-inject styles here to handle scripts loaded via handleClientScriptLoad\n    // ReactDOM.preinit handles dedup and ensures the styles are loaded only once\n    if (_reactdom.default.preinit) {\n        stylesheets.forEach((stylesheet)=>{\n            _reactdom.default.preinit(stylesheet, {\n                as: 'style'\n            });\n        });\n        return;\n    }\n    // Case 2: Styles for afterInteractive/lazyOnload with pages injected via handleClientScriptLoad\n    //\n    // We use this function to load styles when appdir is not detected\n    // TODO: Use React float APIs to load styles once available for pages dir\n    if (typeof window !== 'undefined') {\n        let head = document.head;\n        stylesheets.forEach((stylesheet)=>{\n            let link = document.createElement('link');\n            link.type = 'text/css';\n            link.rel = 'stylesheet';\n            link.href = stylesheet;\n            head.appendChild(link);\n        });\n    }\n};\nconst loadScript = (props)=>{\n    const { src, id, onLoad = ()=>{}, onReady = null, dangerouslySetInnerHTML, children = '', strategy = 'afterInteractive', onError, stylesheets } = props;\n    const cacheKey = id || src;\n    // Script has already loaded\n    if (cacheKey && LoadCache.has(cacheKey)) {\n        return;\n    }\n    // Contents of this script are already loading/loaded\n    if (ScriptCache.has(src)) {\n        LoadCache.add(cacheKey);\n        // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n        // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n        ScriptCache.get(src).then(onLoad, onError);\n        return;\n    }\n    /** Execute after the script first loaded */ const afterLoad = ()=>{\n        // Run onReady for the first time after load event\n        if (onReady) {\n            onReady();\n        }\n        // add cacheKey to LoadCache when load successfully\n        LoadCache.add(cacheKey);\n    };\n    const el = document.createElement('script');\n    const loadPromise = new Promise((resolve, reject)=>{\n        el.addEventListener('load', function(e) {\n            resolve();\n            if (onLoad) {\n                onLoad.call(this, e);\n            }\n            afterLoad();\n        });\n        el.addEventListener('error', function(e) {\n            reject(e);\n        });\n    }).catch(function(e) {\n        if (onError) {\n            onError(e);\n        }\n    });\n    if (dangerouslySetInnerHTML) {\n        // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n        el.innerHTML = dangerouslySetInnerHTML.__html || '';\n        afterLoad();\n    } else if (children) {\n        el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n        afterLoad();\n    } else if (src) {\n        el.src = src;\n        // do not add cacheKey into LoadCache for remote script here\n        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n        ScriptCache.set(src, loadPromise);\n    }\n    (0, _setattributesfromprops.setAttributesFromProps)(el, props);\n    if (strategy === 'worker') {\n        el.setAttribute('type', 'text/partytown');\n    }\n    el.setAttribute('data-nscript', strategy);\n    // Load styles associated with this script\n    if (stylesheets) {\n        insertStylesheets(stylesheets);\n    }\n    document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n    const { strategy = 'afterInteractive' } = props;\n    if (strategy === 'lazyOnload') {\n        window.addEventListener('load', ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    } else {\n        loadScript(props);\n    }\n}\nfunction loadLazyScript(props) {\n    if (document.readyState === 'complete') {\n        (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n    } else {\n        window.addEventListener('load', ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    }\n}\nfunction addBeforeInteractiveToCache() {\n    const scripts = [\n        ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n        ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]')\n    ];\n    scripts.forEach((script)=>{\n        const cacheKey = script.id || script.getAttribute('src');\n        LoadCache.add(cacheKey);\n    });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n    scriptLoaderItems.forEach(handleClientScriptLoad);\n    addBeforeInteractiveToCache();\n}\n/**\n * Load a third-party scripts in an optimized way.\n *\n * Read more: [Next.js Docs: `next/script`](https://nextjs.org/docs/app/api-reference/components/script)\n */ function Script(props) {\n    const { id, src = '', onLoad = ()=>{}, onReady = null, strategy = 'afterInteractive', onError, stylesheets, ...restProps } = props;\n    // Context is available only during SSR\n    const { updateScripts, scripts, getIsSsr, appDir, nonce } = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    /**\n   * - First mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n   *      Once the script is loaded, the onLoad and onReady will be called by then\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   *\n   * - Second mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. The script is already loaded, loadScript bails out\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   */ const hasOnReadyEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        const cacheKey = id || src;\n        if (!hasOnReadyEffectCalled.current) {\n            // Run onReady if script has loaded before but component is re-mounted\n            if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n                onReady();\n            }\n            hasOnReadyEffectCalled.current = true;\n        }\n    }, [\n        onReady,\n        id,\n        src\n    ]);\n    const hasLoadScriptEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        if (!hasLoadScriptEffectCalled.current) {\n            if (strategy === 'afterInteractive') {\n                loadScript(props);\n            } else if (strategy === 'lazyOnload') {\n                loadLazyScript(props);\n            }\n            hasLoadScriptEffectCalled.current = true;\n        }\n    }, [\n        props,\n        strategy\n    ]);\n    if (strategy === 'beforeInteractive' || strategy === 'worker') {\n        if (updateScripts) {\n            scripts[strategy] = (scripts[strategy] || []).concat([\n                {\n                    id,\n                    src,\n                    onLoad,\n                    onReady,\n                    onError,\n                    ...restProps\n                }\n            ]);\n            updateScripts(scripts);\n        } else if (getIsSsr && getIsSsr()) {\n            // Script has already loaded during SSR\n            LoadCache.add(id || src);\n        } else if (getIsSsr && !getIsSsr()) {\n            loadScript(props);\n        }\n    }\n    // For the app directory, we need React Float to preload these scripts.\n    if (appDir) {\n        // Injecting stylesheets here handles beforeInteractive and worker scripts correctly\n        // For other strategies injecting here ensures correct stylesheet order\n        // ReactDOM.preinit handles loading the styles in the correct order,\n        // also ensures the stylesheet is loaded only once and in a consistent manner\n        //\n        // Case 1: Styles for beforeInteractive/worker with appDir - handled here\n        // Case 2: Styles for beforeInteractive/worker with pages dir - Not handled yet\n        // Case 3: Styles for afterInteractive/lazyOnload with appDir - handled here\n        // Case 4: Styles for afterInteractive/lazyOnload with pages dir - handled in insertStylesheets function\n        if (stylesheets) {\n            stylesheets.forEach((styleSrc)=>{\n                _reactdom.default.preinit(styleSrc, {\n                    as: 'style'\n                });\n            });\n        }\n        // Before interactive scripts need to be loaded by Next.js' runtime instead\n        // of native <script> tags, because they no longer have `defer`.\n        if (strategy === 'beforeInteractive') {\n            if (!src) {\n                // For inlined scripts, we put the content in `children`.\n                if (restProps.dangerouslySetInnerHTML) {\n                    // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n                    restProps.children = restProps.dangerouslySetInnerHTML.__html;\n                    delete restProps.dangerouslySetInnerHTML;\n                }\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            0,\n                            {\n                                ...restProps,\n                                id\n                            }\n                        ]) + \")\"\n                    }\n                });\n            } else {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: 'script',\n                    integrity: restProps.integrity,\n                    nonce,\n                    crossOrigin: restProps.crossOrigin\n                } : {\n                    as: 'script',\n                    nonce,\n                    crossOrigin: restProps.crossOrigin\n                });\n                return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            src,\n                            {\n                                ...restProps,\n                                id\n                            }\n                        ]) + \")\"\n                    }\n                });\n            }\n        } else if (strategy === 'afterInteractive') {\n            if (src) {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: 'script',\n                    integrity: restProps.integrity,\n                    nonce,\n                    crossOrigin: restProps.crossOrigin\n                } : {\n                    as: 'script',\n                    nonce,\n                    crossOrigin: restProps.crossOrigin\n                });\n            }\n        }\n    }\n    return null;\n}\n_c = Script;\nObject.defineProperty(Script, '__nextScript', {\n    value: true\n});\nconst _default = Script;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=script.js.map\nvar _c;\n$RefreshReg$(_c, \"Script\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3NjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUF5WEEsT0FBcUI7ZUFBckI7O0lBN05nQkEsc0JBQXNCO2VBQXRCQTs7SUFnQ0FDLGdCQUFnQjtlQUFoQkE7Ozs7OzsrRUExTEs7NkVBQzBDOzZEQUU1QjtvREFDSTtpREFDSDtBQUVwQyxNQUFNQyxjQUFjLElBQUlDO0FBQ3hCLE1BQU1DLFlBQVksSUFBSUM7QUFpQnRCLE1BQU1DLG9CQUFvQixDQUFDQztJQUN6QixpR0FBaUc7SUFDakcsRUFBRTtJQUNGLG9FQUFvRTtJQUNwRSxrRkFBa0Y7SUFDbEYsNEVBQTRFO0lBQzVFLDZFQUE2RTtJQUM3RSxJQUFJQyxVQUFBQSxPQUFRLENBQUNDLE9BQU8sRUFBRTtRQUNwQkYsWUFBWUcsT0FBTyxDQUFDLENBQUNDO1lBQ25CSCxVQUFBQSxPQUFRLENBQUNDLE9BQU8sQ0FBQ0UsWUFBWTtnQkFBRUMsSUFBSTtZQUFRO1FBQzdDO1FBRUE7SUFDRjtJQUVBLGdHQUFnRztJQUNoRyxFQUFFO0lBQ0Ysa0VBQWtFO0lBQ2xFLHlFQUF5RTtJQUN6RSxJQUFJLE9BQU9DLFdBQVcsYUFBYTtRQUNqQyxJQUFJQyxPQUFPQyxTQUFTRCxJQUFJO1FBQ3hCUCxZQUFZRyxPQUFPLENBQUMsQ0FBQ0M7WUFDbkIsSUFBSUssT0FBT0QsU0FBU0UsYUFBYSxDQUFDO1lBRWxDRCxLQUFLRSxJQUFJLEdBQUc7WUFDWkYsS0FBS0csR0FBRyxHQUFHO1lBQ1hILEtBQUtJLElBQUksR0FBR1Q7WUFFWkcsS0FBS08sV0FBVyxDQUFDTDtRQUNuQjtJQUNGO0FBQ0Y7QUFFQSxNQUFNTSxhQUFhLENBQUNDO0lBQ2xCLE1BQU0sRUFDSkMsR0FBRyxFQUNIQyxFQUFF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QUFVa0IsV0FBVztnQkFDcEMsSUFDQTtvQkFBRXpFLElBQUk7b0JBQVUyRDtvQkFBT2MsYUFBYWxCLFVBQVVrQixXQUFXO2dCQUFDO1lBRWxFO1FBQ0Y7SUFDRjtJQUVBLE9BQU87QUFDVDtLQS9LU25CO0FBaUxUb0IsT0FBT0MsY0FBYyxDQUFDckIsUUFBUSxnQkFBZ0I7SUFBRXNCLE9BQU87QUFBSztNQUU1RCxXQUFldEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL3NyYy9jbGllbnQvc2NyaXB0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZUNvbnRleHQsIHVzZVJlZiwgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgU2NyaXB0SFRNTEF0dHJpYnV0ZXMgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBzZXRBdHRyaWJ1dGVzRnJvbVByb3BzIH0gZnJvbSAnLi9zZXQtYXR0cmlidXRlcy1mcm9tLXByb3BzJ1xuaW1wb3J0IHsgcmVxdWVzdElkbGVDYWxsYmFjayB9IGZyb20gJy4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrJ1xuXG5jb25zdCBTY3JpcHRDYWNoZSA9IG5ldyBNYXAoKVxuY29uc3QgTG9hZENhY2hlID0gbmV3IFNldCgpXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NyaXB0UHJvcHMgZXh0ZW5kcyBTY3JpcHRIVE1MQXR0cmlidXRlczxIVE1MU2NyaXB0RWxlbWVudD4ge1xuICBzdHJhdGVneT86ICdhZnRlckludGVyYWN0aXZlJyB8ICdsYXp5T25sb2FkJyB8ICdiZWZvcmVJbnRlcmFjdGl2ZScgfCAnd29ya2VyJ1xuICBpZD86IHN0cmluZ1xuICBvbkxvYWQ/OiAoZTogYW55KSA9PiB2b2lkXG4gIG9uUmVhZHk/OiAoKSA9PiB2b2lkIHwgbnVsbFxuICBvbkVycm9yPzogKGU6IGFueSkgPT4gdm9pZFxuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZVxuICBzdHlsZXNoZWV0cz86IHN0cmluZ1tdXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBTY3JpcHRQcm9wc2AgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IHR5cGUgUHJvcHMgPSBTY3JpcHRQcm9wc1xuXG5jb25zdCBpbnNlcnRTdHlsZXNoZWV0cyA9IChzdHlsZXNoZWV0czogc3RyaW5nW10pID0+IHtcbiAgLy8gQ2FzZSAxOiBTdHlsZXMgZm9yIGFmdGVySW50ZXJhY3RpdmUvbGF6eU9ubG9hZCB3aXRoIGFwcERpciBpbmplY3RlZCB2aWEgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZFxuICAvL1xuICAvLyBVc2luZyBSZWFjdERPTS5wcmVpbml0IHRvIGZlYXR1cmUgZGV0ZWN0IGFwcERpciBhbmQgaW5qZWN0IHN0eWxlc1xuICAvLyBTdHlsZXNoZWV0cyBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiBsb2FkZWQgaWYgaW5pdGlhbGl6ZWQgd2l0aCBTY3JpcHQgY29tcG9uZW50XG4gIC8vIFJlLWluamVjdCBzdHlsZXMgaGVyZSB0byBoYW5kbGUgc2NyaXB0cyBsb2FkZWQgdmlhIGhhbmRsZUNsaWVudFNjcmlwdExvYWRcbiAgLy8gUmVhY3RET00ucHJlaW5pdCBoYW5kbGVzIGRlZHVwIGFuZCBlbnN1cmVzIHRoZSBzdHlsZXMgYXJlIGxvYWRlZCBvbmx5IG9uY2VcbiAgaWYgKFJlYWN0RE9NLnByZWluaXQpIHtcbiAgICBzdHlsZXNoZWV0cy5mb3JFYWNoKChzdHlsZXNoZWV0OiBzdHJpbmcpID0+IHtcbiAgICAgIFJlYWN0RE9NLnByZWluaXQoc3R5bGVzaGVldCwgeyBhczogJ3N0eWxlJyB9KVxuICAgIH0pXG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIENhc2UgMjogU3R5bGVzIGZvciBhZnRlckludGVyYWN0aXZlL2xhenlPbmxvYWQgd2l0aCBwYWdlcyBpbmplY3RlZCB2aWEgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZFxuICAvL1xuICAvLyBXZSB1c2UgdGhpcyBmdW5jdGlvbiB0byBsb2FkIHN0eWxlcyB3aGVuIGFwcGRpciBpcyBub3QgZGV0ZWN0ZWRcbiAgLy8gVE9ETzogVXNlIFJlYWN0IGZsb2F0IEFQSXMgdG8gbG9hZCBzdHlsZXMgb25jZSBhdmFpbGFibGUgZm9yIHBhZ2VzIGRpclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgaGVhZCA9IGRvY3VtZW50LmhlYWRcbiAgICBzdHlsZXNoZWV0cy5mb3JFYWNoKChzdHlsZXNoZWV0OiBzdHJpbmcpID0+IHtcbiAgICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG5cbiAgICAgIGxpbmsudHlwZSA9ICd0ZXh0L2NzcydcbiAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnXG4gICAgICBsaW5rLmhyZWYgPSBzdHlsZXNoZWV0XG5cbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQobGluaylcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGxvYWRTY3JpcHQgPSAocHJvcHM6IFNjcmlwdFByb3BzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHtcbiAgICBzcmMsXG4gICAgaWQsXG4gICAgb25Mb2FkID0gKCkgPT4ge30sXG4gICAgb25SZWFkeSA9IG51bGwsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsXG4gICAgY2hpbGRyZW4gPSAnJyxcbiAgICBzdHJhdGVneSA9ICdhZnRlckludGVyYWN0aXZlJyxcbiAgICBvbkVycm9yLFxuICAgIHN0eWxlc2hlZXRzLFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBjYWNoZUtleSA9IGlkIHx8IHNyY1xuXG4gIC8vIFNjcmlwdCBoYXMgYWxyZWFkeSBsb2FkZWRcbiAgaWYgKGNhY2hlS2V5ICYmIExvYWRDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBDb250ZW50cyBvZiB0aGlzIHNjcmlwdCBhcmUgYWxyZWFkeSBsb2FkaW5nL2xvYWRlZFxuICBpZiAoU2NyaXB0Q2FjaGUuaGFzKHNyYykpIHtcbiAgICBMb2FkQ2FjaGUuYWRkKGNhY2hlS2V5KVxuICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgbXVsdGlwbGUgYG5leHQvc2NyaXB0YCBjb21wb25lbnRzIGFsbCBoYXZlIHNhbWUgXCJzcmNcIiwgYnV0IGhhcyBkaWZmZXJlbnQgXCJvbkxvYWRcIlxuICAgIC8vIFRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoZSBzYW1lIHJlbW90ZSBzY3JpcHQgd2lsbCBvbmx5IGxvYWQgb25jZSwgYnV0IFwib25Mb2FkXCIgYXJlIGV4ZWN1dGVkIGluIG9yZGVyXG4gICAgU2NyaXB0Q2FjaGUuZ2V0KHNyYykudGhlbihvbkxvYWQsIG9uRXJyb3IpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiogRXhlY3V0ZSBhZnRlciB0aGUgc2NyaXB0IGZpcnN0IGxvYWRlZCAqL1xuICBjb25zdCBhZnRlckxvYWQgPSAoKSA9PiB7XG4gICAgLy8gUnVuIG9uUmVhZHkgZm9yIHRoZSBmaXJzdCB0aW1lIGFmdGVyIGxvYWQgZXZlbnRcbiAgICBpZiAob25SZWFkeSkge1xuICAgICAgb25SZWFkeSgpXG4gICAgfVxuICAgIC8vIGFkZCBjYWNoZUtleSB0byBMb2FkQ2FjaGUgd2hlbiBsb2FkIHN1Y2Nlc3NmdWxseVxuICAgIExvYWRDYWNoZS5hZGQoY2FjaGVLZXkpXG4gIH1cblxuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG5cbiAgY29uc3QgbG9hZFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXNvbHZlKClcbiAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgb25Mb2FkLmNhbGwodGhpcywgZSlcbiAgICAgIH1cbiAgICAgIGFmdGVyTG9hZCgpXG4gICAgfSlcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICByZWplY3QoZSlcbiAgICB9KVxuICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgIGlmIChvbkVycm9yKSB7XG4gICAgICBvbkVycm9yKGUpXG4gICAgfVxuICB9KVxuXG4gIGlmIChkYW5nZXJvdXNseVNldElubmVySFRNTCkge1xuICAgIC8vIENhc3Rpbmcgc2luY2UgbGliLmRvbS5kLnRzIGRvZXNuJ3QgaGF2ZSBUcnVzdGVkSFRNTCB5ZXQuXG4gICAgZWwuaW5uZXJIVE1MID0gKGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCBhcyBzdHJpbmcpIHx8ICcnXG5cbiAgICBhZnRlckxvYWQoKVxuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgZWwudGV4dENvbnRlbnQgPVxuICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGNoaWxkcmVuXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgICA/IGNoaWxkcmVuLmpvaW4oJycpXG4gICAgICAgICAgOiAnJ1xuXG4gICAgYWZ0ZXJMb2FkKClcbiAgfSBlbHNlIGlmIChzcmMpIHtcbiAgICBlbC5zcmMgPSBzcmNcbiAgICAvLyBkbyBub3QgYWRkIGNhY2hlS2V5IGludG8gTG9hZENhY2hlIGZvciByZW1vdGUgc2NyaXB0IGhlcmVcbiAgICAvLyBjYWNoZUtleSB3aWxsIGJlIGFkZGVkIHRvIExvYWRDYWNoZSB3aGVuIGl0IGlzIGFjdHVhbGx5IGxvYWRlZCAoc2VlIGxvYWRQcm9taXNlIGFib3ZlKVxuXG4gICAgU2NyaXB0Q2FjaGUuc2V0KHNyYywgbG9hZFByb21pc2UpXG4gIH1cblxuICBzZXRBdHRyaWJ1dGVzRnJvbVByb3BzKGVsLCBwcm9wcylcblxuICBpZiAoc3RyYXRlZ3kgPT09ICd3b3JrZXInKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvcGFydHl0b3duJylcbiAgfVxuXG4gIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1uc2NyaXB0Jywgc3RyYXRlZ3kpXG5cbiAgLy8gTG9hZCBzdHlsZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2NyaXB0XG4gIGlmIChzdHlsZXNoZWV0cykge1xuICAgIGluc2VydFN0eWxlc2hlZXRzKHN0eWxlc2hlZXRzKVxuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUNsaWVudFNjcmlwdExvYWQocHJvcHM6IFNjcmlwdFByb3BzKSB7XG4gIGNvbnN0IHsgc3RyYXRlZ3kgPSAnYWZ0ZXJJbnRlcmFjdGl2ZScgfSA9IHByb3BzXG4gIGlmIChzdHJhdGVneSA9PT0gJ2xhenlPbmxvYWQnKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IGxvYWRTY3JpcHQocHJvcHMpKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgbG9hZFNjcmlwdChwcm9wcylcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2FkTGF6eVNjcmlwdChwcm9wczogU2NyaXB0UHJvcHMpIHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IGxvYWRTY3JpcHQocHJvcHMpKVxuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBsb2FkU2NyaXB0KHByb3BzKSlcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEJlZm9yZUludGVyYWN0aXZlVG9DYWNoZSgpIHtcbiAgY29uc3Qgc2NyaXB0cyA9IFtcbiAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PVwiYmVmb3JlSW50ZXJhY3RpdmVcIl0nKSxcbiAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PVwiYmVmb3JlUGFnZVJlbmRlclwiXScpLFxuICBdXG4gIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KSA9PiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBzY3JpcHQuaWQgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgICBMb2FkQ2FjaGUuYWRkKGNhY2hlS2V5KVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFNjcmlwdExvYWRlcihzY3JpcHRMb2FkZXJJdGVtczogU2NyaXB0UHJvcHNbXSkge1xuICBzY3JpcHRMb2FkZXJJdGVtcy5mb3JFYWNoKGhhbmRsZUNsaWVudFNjcmlwdExvYWQpXG4gIGFkZEJlZm9yZUludGVyYWN0aXZlVG9DYWNoZSgpXG59XG5cbi8qKlxuICogTG9hZCBhIHRoaXJkLXBhcnR5IHNjcmlwdHMgaW4gYW4gb3B0aW1pemVkIHdheS5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGBuZXh0L3NjcmlwdGBdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvc2NyaXB0KVxuICovXG5mdW5jdGlvbiBTY3JpcHQocHJvcHM6IFNjcmlwdFByb3BzKTogSlNYLkVsZW1lbnQgfCBudWxsIHtcbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIHNyYyA9ICcnLFxuICAgIG9uTG9hZCA9ICgpID0+IHt9LFxuICAgIG9uUmVhZHkgPSBudWxsLFxuICAgIHN0cmF0ZWd5ID0gJ2FmdGVySW50ZXJhY3RpdmUnLFxuICAgIG9uRXJyb3IsXG4gICAgc3R5bGVzaGVldHMsXG4gICAgLi4ucmVzdFByb3BzXG4gIH0gPSBwcm9wc1xuXG4gIC8vIENvbnRleHQgaXMgYXZhaWxhYmxlIG9ubHkgZHVyaW5nIFNTUlxuICBjb25zdCB7IHVwZGF0ZVNjcmlwdHMsIHNjcmlwdHMsIGdldElzU3NyLCBhcHBEaXIsIG5vbmNlIH0gPVxuICAgIHVzZUNvbnRleHQoSGVhZE1hbmFnZXJDb250ZXh0KVxuXG4gIC8qKlxuICAgKiAtIEZpcnN0IG1vdW50OlxuICAgKiAgIDEuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXNcbiAgICogICAyLiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGJ1dCB0aGUgc2NyaXB0IGhhc24ndCBsb2FkZWQgeWV0IChub3QgaW4gTG9hZENhY2hlKVxuICAgKiAgICAgIG9uUmVhZHkgaXMgc2tpcHBlZCwgc2V0IGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCB0byB0cnVlXG4gICAqICAgMy4gVGhlIHVzZUVmZmVjdCBmb3IgbG9hZFNjcmlwdCBleGVjdXRlc1xuICAgKiAgIDQuIGhhc0xvYWRTY3JpcHRFZmZlY3RDYWxsZWQuY3VycmVudCBpcyBmYWxzZSwgbG9hZFNjcmlwdCBleGVjdXRlc1xuICAgKiAgICAgIE9uY2UgdGhlIHNjcmlwdCBpcyBsb2FkZWQsIHRoZSBvbkxvYWQgYW5kIG9uUmVhZHkgd2lsbCBiZSBjYWxsZWQgYnkgdGhlblxuICAgKiAgIFtJZiBzdHJpY3QgbW9kZSBpcyBlbmFibGVkIC8gaXMgd3JhcHBlZCBpbiA8T2ZmU2NyZWVuIC8+IGNvbXBvbmVudF1cbiAgICogICA1LiBUaGUgdXNlRWZmZWN0IGZvciBvblJlYWR5IGV4ZWN1dGVzIGFnYWluXG4gICAqICAgNi4gaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxuICAgKiAgIDcuIFRoZSB1c2VFZmZlY3QgZm9yIGxvYWRTY3JpcHQgZXhlY3V0ZXMgYWdhaW5cbiAgICogICA4LiBoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgdHJ1ZSwgc28gZW50aXJlIGVmZmVjdCBpcyBza2lwcGVkXG4gICAqXG4gICAqIC0gU2Vjb25kIG1vdW50OlxuICAgKiAgIDEuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXNcbiAgICogICAyLiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGJ1dCB0aGUgc2NyaXB0IGhhcyBhbHJlYWR5IGxvYWRlZCAoZm91bmQgaW4gTG9hZENhY2hlKVxuICAgKiAgICAgIG9uUmVhZHkgaXMgY2FsbGVkLCBzZXQgaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IHRvIHRydWVcbiAgICogICAzLiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzXG4gICAqICAgNC4gVGhlIHNjcmlwdCBpcyBhbHJlYWR5IGxvYWRlZCwgbG9hZFNjcmlwdCBiYWlscyBvdXRcbiAgICogICBbSWYgc3RyaWN0IG1vZGUgaXMgZW5hYmxlZCAvIGlzIHdyYXBwZWQgaW4gPE9mZlNjcmVlbiAvPiBjb21wb25lbnRdXG4gICAqICAgNS4gVGhlIHVzZUVmZmVjdCBmb3Igb25SZWFkeSBleGVjdXRlcyBhZ2FpblxuICAgKiAgIDYuIGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCBpcyB0cnVlLCBzbyBlbnRpcmUgZWZmZWN0IGlzIHNraXBwZWRcbiAgICogICA3LiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzIGFnYWluXG4gICAqICAgOC4gaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxuICAgKi9cbiAgY29uc3QgaGFzT25SZWFkeUVmZmVjdENhbGxlZCA9IHVzZVJlZihmYWxzZSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gaWQgfHwgc3JjXG4gICAgaWYgKCFoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQpIHtcbiAgICAgIC8vIFJ1biBvblJlYWR5IGlmIHNjcmlwdCBoYXMgbG9hZGVkIGJlZm9yZSBidXQgY29tcG9uZW50IGlzIHJlLW1vdW50ZWRcbiAgICAgIGlmIChvblJlYWR5ICYmIGNhY2hlS2V5ICYmIExvYWRDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgIG9uUmVhZHkoKVxuICAgICAgfVxuXG4gICAgICBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgPSB0cnVlXG4gICAgfVxuICB9LCBbb25SZWFkeSwgaWQsIHNyY10pXG5cbiAgY29uc3QgaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZCA9IHVzZVJlZihmYWxzZSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50KSB7XG4gICAgICBpZiAoc3RyYXRlZ3kgPT09ICdhZnRlckludGVyYWN0aXZlJykge1xuICAgICAgICBsb2FkU2NyaXB0KHByb3BzKVxuICAgICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gJ2xhenlPbmxvYWQnKSB7XG4gICAgICAgIGxvYWRMYXp5U2NyaXB0KHByb3BzKVxuICAgICAgfVxuXG4gICAgICBoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkLmN1cnJlbnQgPSB0cnVlXG4gICAgfVxuICB9LCBbcHJvcHMsIHN0cmF0ZWd5XSlcblxuICBpZiAoc3RyYXRlZ3kgPT09ICdiZWZvcmVJbnRlcmFjdGl2ZScgfHwgc3RyYXRlZ3kgPT09ICd3b3JrZXInKSB7XG4gICAgaWYgKHVwZGF0ZVNjcmlwdHMpIHtcbiAgICAgIHNjcmlwdHNbc3RyYXRlZ3ldID0gKHNjcmlwdHNbc3RyYXRlZ3ldIHx8IFtdKS5jb25jYXQoW1xuICAgICAgICB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgc3JjLFxuICAgICAgICAgIG9uTG9hZCxcbiAgICAgICAgICBvblJlYWR5LFxuICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgLi4ucmVzdFByb3BzLFxuICAgICAgICB9LFxuICAgICAgXSlcbiAgICAgIHVwZGF0ZVNjcmlwdHMoc2NyaXB0cylcbiAgICB9IGVsc2UgaWYgKGdldElzU3NyICYmIGdldElzU3NyKCkpIHtcbiAgICAgIC8vIFNjcmlwdCBoYXMgYWxyZWFkeSBsb2FkZWQgZHVyaW5nIFNTUlxuICAgICAgTG9hZENhY2hlLmFkZChpZCB8fCBzcmMpXG4gICAgfSBlbHNlIGlmIChnZXRJc1NzciAmJiAhZ2V0SXNTc3IoKSkge1xuICAgICAgbG9hZFNjcmlwdChwcm9wcylcbiAgICB9XG4gIH1cblxuICAvLyBGb3IgdGhlIGFwcCBkaXJlY3RvcnksIHdlIG5lZWQgUmVhY3QgRmxvYXQgdG8gcHJlbG9hZCB0aGVzZSBzY3JpcHRzLlxuICBpZiAoYXBwRGlyKSB7XG4gICAgLy8gSW5qZWN0aW5nIHN0eWxlc2hlZXRzIGhlcmUgaGFuZGxlcyBiZWZvcmVJbnRlcmFjdGl2ZSBhbmQgd29ya2VyIHNjcmlwdHMgY29ycmVjdGx5XG4gICAgLy8gRm9yIG90aGVyIHN0cmF0ZWdpZXMgaW5qZWN0aW5nIGhlcmUgZW5zdXJlcyBjb3JyZWN0IHN0eWxlc2hlZXQgb3JkZXJcbiAgICAvLyBSZWFjdERPTS5wcmVpbml0IGhhbmRsZXMgbG9hZGluZyB0aGUgc3R5bGVzIGluIHRoZSBjb3JyZWN0IG9yZGVyLFxuICAgIC8vIGFsc28gZW5zdXJlcyB0aGUgc3R5bGVzaGVldCBpcyBsb2FkZWQgb25seSBvbmNlIGFuZCBpbiBhIGNvbnNpc3RlbnQgbWFubmVyXG4gICAgLy9cbiAgICAvLyBDYXNlIDE6IFN0eWxlcyBmb3IgYmVmb3JlSW50ZXJhY3RpdmUvd29ya2VyIHdpdGggYXBwRGlyIC0gaGFuZGxlZCBoZXJlXG4gICAgLy8gQ2FzZSAyOiBTdHlsZXMgZm9yIGJlZm9yZUludGVyYWN0aXZlL3dvcmtlciB3aXRoIHBhZ2VzIGRpciAtIE5vdCBoYW5kbGVkIHlldFxuICAgIC8vIENhc2UgMzogU3R5bGVzIGZvciBhZnRlckludGVyYWN0aXZlL2xhenlPbmxvYWQgd2l0aCBhcHBEaXIgLSBoYW5kbGVkIGhlcmVcbiAgICAvLyBDYXNlIDQ6IFN0eWxlcyBmb3IgYWZ0ZXJJbnRlcmFjdGl2ZS9sYXp5T25sb2FkIHdpdGggcGFnZXMgZGlyIC0gaGFuZGxlZCBpbiBpbnNlcnRTdHlsZXNoZWV0cyBmdW5jdGlvblxuICAgIGlmIChzdHlsZXNoZWV0cykge1xuICAgICAgc3R5bGVzaGVldHMuZm9yRWFjaCgoc3R5bGVTcmMpID0+IHtcbiAgICAgICAgUmVhY3RET00ucHJlaW5pdChzdHlsZVNyYywgeyBhczogJ3N0eWxlJyB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBCZWZvcmUgaW50ZXJhY3RpdmUgc2NyaXB0cyBuZWVkIHRvIGJlIGxvYWRlZCBieSBOZXh0LmpzJyBydW50aW1lIGluc3RlYWRcbiAgICAvLyBvZiBuYXRpdmUgPHNjcmlwdD4gdGFncywgYmVjYXVzZSB0aGV5IG5vIGxvbmdlciBoYXZlIGBkZWZlcmAuXG4gICAgaWYgKHN0cmF0ZWd5ID09PSAnYmVmb3JlSW50ZXJhY3RpdmUnKSB7XG4gICAgICBpZiAoIXNyYykge1xuICAgICAgICAvLyBGb3IgaW5saW5lZCBzY3JpcHRzLCB3ZSBwdXQgdGhlIGNvbnRlbnQgaW4gYGNoaWxkcmVuYC5cbiAgICAgICAgaWYgKHJlc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkge1xuICAgICAgICAgIC8vIENhc3Rpbmcgc2luY2UgbGliLmRvbS5kLnRzIGRvZXNuJ3QgaGF2ZSBUcnVzdGVkSFRNTCB5ZXQuXG4gICAgICAgICAgcmVzdFByb3BzLmNoaWxkcmVuID0gcmVzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXG4gICAgICAgICAgICAuX19odG1sIGFzIHN0cmluZ1xuICAgICAgICAgIGRlbGV0ZSByZXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPHNjcmlwdFxuICAgICAgICAgICAgbm9uY2U9e25vbmNlfVxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tcbiAgICAgICAgICAgICAgX19odG1sOiBgKHNlbGYuX19uZXh0X3M9c2VsZi5fX25leHRfc3x8W10pLnB1c2goJHtKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICB7IC4uLnJlc3RQcm9wcywgaWQgfSxcbiAgICAgICAgICAgICAgXSl9KWAsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgUmVhY3RET00ucHJlbG9hZChcbiAgICAgICAgICBzcmMsXG4gICAgICAgICAgcmVzdFByb3BzLmludGVncml0eVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXM6ICdzY3JpcHQnLFxuICAgICAgICAgICAgICAgIGludGVncml0eTogcmVzdFByb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcmVzdFByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHsgYXM6ICdzY3JpcHQnLCBub25jZSwgY3Jvc3NPcmlnaW46IHJlc3RQcm9wcy5jcm9zc09yaWdpbiB9XG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8c2NyaXB0XG4gICAgICAgICAgICBub25jZT17bm9uY2V9XG4gICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17e1xuICAgICAgICAgICAgICBfX2h0bWw6IGAoc2VsZi5fX25leHRfcz1zZWxmLl9fbmV4dF9zfHxbXSkucHVzaCgke0pTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgeyAuLi5yZXN0UHJvcHMsIGlkIH0sXG4gICAgICAgICAgICAgIF0pfSlgLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gJ2FmdGVySW50ZXJhY3RpdmUnKSB7XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgUmVhY3RET00ucHJlbG9hZChcbiAgICAgICAgICBzcmMsXG4gICAgICAgICAgcmVzdFByb3BzLmludGVncml0eVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXM6ICdzY3JpcHQnLFxuICAgICAgICAgICAgICAgIGludGVncml0eTogcmVzdFByb3BzLmludGVncml0eSxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbjogcmVzdFByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHsgYXM6ICdzY3JpcHQnLCBub25jZSwgY3Jvc3NPcmlnaW46IHJlc3RQcm9wcy5jcm9zc09yaWdpbiB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NyaXB0LCAnX19uZXh0U2NyaXB0JywgeyB2YWx1ZTogdHJ1ZSB9KVxuXG5leHBvcnQgZGVmYXVsdCBTY3JpcHRcbiJdLCJuYW1lcyI6WyJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwiaW5pdFNjcmlwdExvYWRlciIsIlNjcmlwdENhY2hlIiwiTWFwIiwiTG9hZENhY2hlIiwiU2V0IiwiaW5zZXJ0U3R5bGVzaGVldHMiLCJzdHlsZXNoZWV0cyIsIlJlYWN0RE9NIiwicHJlaW5pdCIsImZvckVhY2giLCJzdHlsZXNoZWV0IiwiYXMiLCJ3aW5kb3ciLCJoZWFkIiwiZG9jdW1lbnQiLCJsaW5rIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJyZWwiLCJocmVmIiwiYXBwZW5kQ2hpbGQiLCJsb2FkU2NyaXB0IiwicHJvcHMiLCJzcmMiLCJpZCIsIm9uTG9hZCIsIm9uUmVhZHkiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImNoaWxkcmVuIiwic3RyYXRlZ3kiLCJvbkVycm9yIiwiY2FjaGVLZXkiLCJoYXMiLCJhZGQiLCJnZXQiLCJ0aGVuIiwiYWZ0ZXJMb2FkIiwiZWwiLCJsb2FkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJjYWxsIiwiY2F0Y2giLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJ0ZXh0Q29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJzZXQiLCJzZXRBdHRyaWJ1dGVzRnJvbVByb3BzIiwic2V0QXR0cmlidXRlIiwiYm9keSIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJsb2FkTGF6eVNjcmlwdCIsInJlYWR5U3RhdGUiLCJhZGRCZWZvcmVJbnRlcmFjdGl2ZVRvQ2FjaGUiLCJzY3JpcHRzIiwicXVlcnlTZWxlY3RvckFsbCIsInNjcmlwdCIsImdldEF0dHJpYnV0ZSIsInNjcmlwdExvYWRlckl0ZW1zIiwiU2NyaXB0IiwicmVzdFByb3BzIiwidXBkYXRlU2NyaXB0cyIsImdldElzU3NyIiwiYXBwRGlyIiwibm9uY2UiLCJ1c2VDb250ZXh0IiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiaGFzT25SZWFkeUVmZmVjdENhbGxlZCIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkIiwiY29uY2F0Iiwic3R5bGVTcmMiLCJKU09OIiwic3RyaW5naWZ5IiwicHJlbG9hZCIsImludGVncml0eSIsImNyb3NzT3JpZ2luIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/script.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/set-attributes-from-props.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/set-attributes-from-props.js ***!
  \***********************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"setAttributesFromProps\", ({\n    enumerable: true,\n    get: function() {\n        return setAttributesFromProps;\n    }\n}));\nconst DOMAttributeNames = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv',\n    noModule: 'noModule'\n};\nconst ignoreProps = [\n    'onLoad',\n    'onReady',\n    'dangerouslySetInnerHTML',\n    'children',\n    'onError',\n    'strategy',\n    'stylesheets'\n];\nfunction isBooleanScriptAttribute(attr) {\n    return [\n        'async',\n        'defer',\n        'noModule'\n    ].includes(attr);\n}\nfunction setAttributesFromProps(el, props) {\n    for (const [p, value] of Object.entries(props)){\n        if (!props.hasOwnProperty(p)) continue;\n        if (ignoreProps.includes(p)) continue;\n        // we don't render undefined props to the DOM\n        if (value === undefined) {\n            continue;\n        }\n        const attr = DOMAttributeNames[p] || p.toLowerCase();\n        if (el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr)) {\n            // Correctly assign boolean script attributes\n            // https://github.com/vercel/next.js/pull/20748\n            ;\n            el[attr] = !!value;\n        } else {\n            el.setAttribute(attr, String(value));\n        }\n        // Remove falsy non-zero boolean attributes so they are correctly interpreted\n        // (e.g. if we set them to false, this coerces to the string \"false\", which the browser interprets as true)\n        if (value === false || el.tagName === 'SCRIPT' && isBooleanScriptAttribute(attr) && (!value || value === 'false')) {\n            // Call setAttribute before, as we need to set and unset the attribute to override force async:\n            // https://html.spec.whatwg.org/multipage/scripting.html#script-force-async\n            el.setAttribute(attr, '');\n            el.removeAttribute(attr);\n        }\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=set-attributes-from-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3NldC1hdHRyaWJ1dGVzLWZyb20tcHJvcHMuanMiLCJtYXBwaW5ncyI6Ijs7OzswREF3QmdCQTs7O2VBQUFBOzs7QUF4QmhCLE1BQU1DLG9CQUE0QztJQUNoREMsZUFBZTtJQUNmQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsV0FBVztJQUNYQyxVQUFVO0FBQ1o7QUFFQSxNQUFNQyxjQUFjO0lBQ2xCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxTQUFTQyx5QkFDUEMsSUFBWTtJQUVaLE9BQU87UUFBQztRQUFTO1FBQVM7S0FBVyxDQUFDQyxRQUFRLENBQUNEO0FBQ2pEO0FBRU8sU0FBU1QsdUJBQXVCVyxFQUFlLEVBQUVDLEtBQWE7SUFDbkUsS0FBSyxNQUFNLENBQUNDLEdBQUdDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDSixPQUFRO1FBQzlDLElBQUksQ0FBQ0EsTUFBTUssY0FBYyxDQUFDSixJQUFJO1FBQzlCLElBQUlOLFlBQVlHLFFBQVEsQ0FBQ0csSUFBSTtRQUU3Qiw2Q0FBNkM7UUFDN0MsSUFBSUMsVUFBVUksV0FBVztZQUN2QjtRQUNGO1FBRUEsTUFBTVQsT0FBT1IsaUJBQWlCLENBQUNZLEVBQUUsSUFBSUEsRUFBRU0sV0FBVztRQUVsRCxJQUFJUixHQUFHUyxPQUFPLEtBQUssWUFBWVoseUJBQXlCQyxPQUFPO1lBQzdELDZDQUE2QztZQUM3QywrQ0FBK0M7O1lBQzdDRSxFQUF3QixDQUFDRixLQUFLLEdBQUcsQ0FBQyxDQUFDSztRQUN2QyxPQUFPO1lBQ0xILEdBQUdVLFlBQVksQ0FBQ1osTUFBTWEsT0FBT1I7UUFDL0I7UUFFQSw2RUFBNkU7UUFDN0UsMkdBQTJHO1FBQzNHLElBQ0VBLFVBQVUsU0FDVEgsR0FBR1MsT0FBTyxLQUFLLFlBQ2RaLHlCQUF5QkMsU0FDeEIsRUFBQ0ssU0FBU0EsVUFBVSxRQUFNLEVBQzdCO1lBQ0EsK0ZBQStGO1lBQy9GLDJFQUEyRTtZQUMzRUgsR0FBR1UsWUFBWSxDQUFDWixNQUFNO1lBQ3RCRSxHQUFHWSxlQUFlLENBQUNkO1FBQ3JCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvc3JjL2NsaWVudC9zZXQtYXR0cmlidXRlcy1mcm9tLXByb3BzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IERPTUF0dHJpYnV0ZU5hbWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICBjbGFzc05hbWU6ICdjbGFzcycsXG4gIGh0bWxGb3I6ICdmb3InLFxuICBodHRwRXF1aXY6ICdodHRwLWVxdWl2JyxcbiAgbm9Nb2R1bGU6ICdub01vZHVsZScsXG59XG5cbmNvbnN0IGlnbm9yZVByb3BzID0gW1xuICAnb25Mb2FkJyxcbiAgJ29uUmVhZHknLFxuICAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICAnY2hpbGRyZW4nLFxuICAnb25FcnJvcicsXG4gICdzdHJhdGVneScsXG4gICdzdHlsZXNoZWV0cycsXG5dXG5cbmZ1bmN0aW9uIGlzQm9vbGVhblNjcmlwdEF0dHJpYnV0ZShcbiAgYXR0cjogc3RyaW5nXG4pOiBhdHRyIGlzICdhc3luYycgfCAnZGVmZXInIHwgJ25vTW9kdWxlJyB7XG4gIHJldHVybiBbJ2FzeW5jJywgJ2RlZmVyJywgJ25vTW9kdWxlJ10uaW5jbHVkZXMoYXR0cilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNGcm9tUHJvcHMoZWw6IEhUTUxFbGVtZW50LCBwcm9wczogb2JqZWN0KSB7XG4gIGZvciAoY29uc3QgW3AsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcbiAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZVxuICAgIGlmIChpZ25vcmVQcm9wcy5pbmNsdWRlcyhwKSkgY29udGludWVcblxuICAgIC8vIHdlIGRvbid0IHJlbmRlciB1bmRlZmluZWQgcHJvcHMgdG8gdGhlIERPTVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IGF0dHIgPSBET01BdHRyaWJ1dGVOYW1lc1twXSB8fCBwLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChlbC50YWdOYW1lID09PSAnU0NSSVBUJyAmJiBpc0Jvb2xlYW5TY3JpcHRBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgIC8vIENvcnJlY3RseSBhc3NpZ24gYm9vbGVhbiBzY3JpcHQgYXR0cmlidXRlc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL3B1bGwvMjA3NDhcbiAgICAgIDsoZWwgYXMgSFRNTFNjcmlwdEVsZW1lbnQpW2F0dHJdID0gISF2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgU3RyaW5nKHZhbHVlKSlcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZmFsc3kgbm9uLXplcm8gYm9vbGVhbiBhdHRyaWJ1dGVzIHNvIHRoZXkgYXJlIGNvcnJlY3RseSBpbnRlcnByZXRlZFxuICAgIC8vIChlLmcuIGlmIHdlIHNldCB0aGVtIHRvIGZhbHNlLCB0aGlzIGNvZXJjZXMgdG8gdGhlIHN0cmluZyBcImZhbHNlXCIsIHdoaWNoIHRoZSBicm93c2VyIGludGVycHJldHMgYXMgdHJ1ZSlcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgIChlbC50YWdOYW1lID09PSAnU0NSSVBUJyAmJlxuICAgICAgICBpc0Jvb2xlYW5TY3JpcHRBdHRyaWJ1dGUoYXR0cikgJiZcbiAgICAgICAgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykpXG4gICAgKSB7XG4gICAgICAvLyBDYWxsIHNldEF0dHJpYnV0ZSBiZWZvcmUsIGFzIHdlIG5lZWQgdG8gc2V0IGFuZCB1bnNldCB0aGUgYXR0cmlidXRlIHRvIG92ZXJyaWRlIGZvcmNlIGFzeW5jOlxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2NyaXB0LWZvcmNlLWFzeW5jXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cilcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJzZXRBdHRyaWJ1dGVzRnJvbVByb3BzIiwiRE9NQXR0cmlidXRlTmFtZXMiLCJhY2NlcHRDaGFyc2V0IiwiY2xhc3NOYW1lIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsIm5vTW9kdWxlIiwiaWdub3JlUHJvcHMiLCJpc0Jvb2xlYW5TY3JpcHRBdHRyaWJ1dGUiLCJhdHRyIiwiaW5jbHVkZXMiLCJlbCIsInByb3BzIiwicCIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImhhc093blByb3BlcnR5IiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJ0YWdOYW1lIiwic2V0QXR0cmlidXRlIiwiU3RyaW5nIiwicmVtb3ZlQXR0cmlidXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/set-attributes-from-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/use-merged-ref.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/use-merged-ref.js ***!
  \************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(()=>{});\n    const cleanupB = (0, _react.useRef)(()=>{});\n    return (0, _react.useMemo)(()=>{\n        if (!refA || !refB) {\n            return refA || refB;\n        }\n        return (current)=>{\n            if (current === null) {\n                cleanupA.current();\n                cleanupB.current();\n            } else {\n                cleanupA.current = applyRef(refA, current);\n                cleanupB.current = applyRef(refB, current);\n            }\n        };\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1tZXJnZWQtcmVmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Z0RBU2dCQTs7O2VBQUFBOzs7bUNBVDBCO0FBU25DLFNBQVNBLGFBQ2RDLElBQW1CLEVBQ25CQyxJQUFtQjtJQUVuQixNQUFNQyxXQUFXQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUFtQixLQUFPO0lBQzNDLE1BQU1DLFdBQVdELENBQUFBLEdBQUFBLE9BQUFBLE1BQUFBLEVBQW1CLEtBQU87SUFFM0MsT0FBT0UsQ0FBQUEsR0FBQUEsT0FBQUEsT0FBQUEsRUFBUTtRQUNiLElBQUksQ0FBQ0wsUUFBUSxDQUFDQyxNQUFNO1lBQ2xCLE9BQU9ELFFBQVFDO1FBQ2pCO1FBRUEsT0FBTyxDQUFDSztZQUNOLElBQUlBLFlBQVksTUFBTTtnQkFDcEJKLFNBQVNJLE9BQU87Z0JBQ2hCRixTQUFTRSxPQUFPO1lBQ2xCLE9BQU87Z0JBQ0xKLFNBQVNJLE9BQU8sR0FBR0MsU0FBU1AsTUFBTU07Z0JBQ2xDRixTQUFTRSxPQUFPLEdBQUdDLFNBQVNOLE1BQU1LO1lBQ3BDO1FBQ0Y7SUFDRixHQUFHO1FBQUNOO1FBQU1DO0tBQUs7QUFDakI7QUFFQSxTQUFTTSxTQUNQUCxJQUFnQyxFQUNoQ00sT0FBaUI7SUFFakIsSUFBSSxPQUFPTixTQUFTLFlBQVk7UUFDOUIsTUFBTVEsVUFBVVIsS0FBS007UUFDckIsSUFBSSxPQUFPRSxZQUFZLFlBQVk7WUFDakMsT0FBT0E7UUFDVCxPQUFPO1lBQ0wsT0FBTyxJQUFNUixLQUFLO1FBQ3BCO0lBQ0YsT0FBTztRQUNMQSxLQUFLTSxPQUFPLEdBQUdBO1FBQ2YsT0FBTztZQUNMTixLQUFLTSxPQUFPLEdBQUc7UUFDakI7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9zcmMvY2xpZW50L3VzZS1tZXJnZWQtcmVmLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZU1lbW8sIHVzZVJlZiwgdHlwZSBSZWYgfSBmcm9tICdyZWFjdCdcblxuLy8gVGhpcyBpcyBhIGNvbXBhdGliaWxpdHkgaG9vayB0byBzdXBwb3J0IFJlYWN0IDE4IGFuZCAxOSByZWZzLlxuLy8gSW4gMTksIGEgY2xlYW51cCBmdW5jdGlvbiBmcm9tIHJlZnMgbWF5IGJlIHJldHVybmVkLlxuLy8gSW4gMTgsIHJldHVybmluZyBhIGNsZWFudXAgZnVuY3Rpb24gY3JlYXRlcyBhIHdhcm5pbmcuXG4vLyBTaW5jZSB3ZSB0YWtlIHVzZXJzcGFjZSByZWZzLCB3ZSBkb24ndCBrbm93IGFoZWFkIG9mIHRpbWUgaWYgYSBjbGVhbnVwIGZ1bmN0aW9uIHdpbGwgYmUgcmV0dXJuZWQuXG4vLyBUaGlzIGltcGxlbWVudHMgY2xlYW51cCBmdW5jdGlvbnMgd2l0aCB0aGUgb2xkIGJlaGF2aW9yIGluIDE4LlxuLy8gV2Uga25vdyByZWZzIGFyZSBhbHdheXMgY2FsbGVkIGFsdGVybmF0aW5nIHdpdGggYG51bGxgIGFuZCB0aGVuIGBUYC5cbi8vIFNvIGEgY2FsbCB3aXRoIGBudWxsYCBtZWFucyB3ZSBuZWVkIHRvIGNhbGwgdGhlIHByZXZpb3VzIGNsZWFudXAgZnVuY3Rpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZjxURWxlbWVudD4oXG4gIHJlZkE6IFJlZjxURWxlbWVudD4sXG4gIHJlZkI6IFJlZjxURWxlbWVudD5cbik6IFJlZjxURWxlbWVudD4ge1xuICBjb25zdCBjbGVhbnVwQSA9IHVzZVJlZjwoKSA9PiB2b2lkPigoKSA9PiB7fSlcbiAgY29uc3QgY2xlYW51cEIgPSB1c2VSZWY8KCkgPT4gdm9pZD4oKCkgPT4ge30pXG5cbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghcmVmQSB8fCAhcmVmQikge1xuICAgICAgcmV0dXJuIHJlZkEgfHwgcmVmQlxuICAgIH1cblxuICAgIHJldHVybiAoY3VycmVudDogVEVsZW1lbnQgfCBudWxsKTogdm9pZCA9PiB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBjbGVhbnVwQS5jdXJyZW50KClcbiAgICAgICAgY2xlYW51cEIuY3VycmVudCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhbnVwQS5jdXJyZW50ID0gYXBwbHlSZWYocmVmQSwgY3VycmVudClcbiAgICAgICAgY2xlYW51cEIuY3VycmVudCA9IGFwcGx5UmVmKHJlZkIsIGN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbcmVmQSwgcmVmQl0pXG59XG5cbmZ1bmN0aW9uIGFwcGx5UmVmPFRFbGVtZW50PihcbiAgcmVmQTogTm9uTnVsbGFibGU8UmVmPFRFbGVtZW50Pj4sXG4gIGN1cnJlbnQ6IFRFbGVtZW50XG4pIHtcbiAgaWYgKHR5cGVvZiByZWZBID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY2xlYW51cCA9IHJlZkEoY3VycmVudClcbiAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjbGVhbnVwXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoKSA9PiByZWZBKG51bGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlZkEuY3VycmVudCA9IGN1cnJlbnRcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVmQS5jdXJyZW50ID0gbnVsbFxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInVzZU1lcmdlZFJlZiIsInJlZkEiLCJyZWZCIiwiY2xlYW51cEEiLCJ1c2VSZWYiLCJjbGVhbnVwQiIsInVzZU1lbW8iLCJjdXJyZW50IiwiYXBwbHlSZWYiLCJjbGVhbnVwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \****************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = 'AmpStateContext';\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzRFQUZLO0FBRVgsTUFBTUEsa0JBQXNDQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQW9CLEVBQW1CO0lBQ3pDSCxnQkFBZ0JNLFdBQVcsR0FBRztBQUNoQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9zaGFyZWQvbGliL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEFtcFN0YXRlQ29udGV4dDogUmVhY3QuQ29udGV4dDxhbnk+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgQW1wU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0FtcFN0YXRlQ29udGV4dCdcbn1cbiJdLCJuYW1lcyI6WyJBbXBTdGF0ZUNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkaXNwbGF5TmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/amp-mode.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/amp-mode.js ***!
  \**********************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWTtJQUFBLE1BQzFCQyxXQUFXLEtBQUssRUFDaEJDLFNBQVMsS0FBSyxFQUNkQyxXQUFXLEtBQUssRUFDakIsR0FKMkIsbUJBSXhCLENBQUMsSUFKdUI7SUFLMUIsT0FBT0YsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9hbXAtbW9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNJbkFtcE1vZGUoe1xuICBhbXBGaXJzdCA9IGZhbHNlLFxuICBoeWJyaWQgPSBmYWxzZSxcbiAgaGFzUXVlcnkgPSBmYWxzZSxcbn0gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW1wRmlyc3QgfHwgKGh5YnJpZCAmJiBoYXNRdWVyeSlcbn1cbiJdLCJuYW1lcyI6WyJpc0luQW1wTW9kZSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/get-img-props.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/get-img-props.js ***!
  \***************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    'lazy',\n    'eager',\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === 'undefined') {\n        return x;\n    }\n    if (typeof x === 'number') {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: 'w'\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: 'w'\n        };\n    }\n    if (typeof width !== 'number') {\n        return {\n            widths: deviceSizes,\n            kind: 'w'\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: 'x'\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === 'w' ? '100vw' : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === 'w' ? w : i + 1) + kind).join(', '),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if ('allSizes' in c) {\n        config = c;\n    } else {\n        var _c_qualities;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes,\n            qualities\n        };\n    }\n    if (typeof defaultLoader === 'undefined') {\n        throw new Error('images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config');\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = '__next_img_default' in loader;\n    if (isDefaultLoader) {\n        if (config.loader === 'custom') {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === 'fill') {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: '100%',\n                height: 'auto'\n            },\n            responsive: {\n                width: '100%',\n                height: 'auto'\n            }\n        };\n        const layoutToSizes = {\n            responsive: '100vw',\n            fill: '100vw'\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = '';\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === 'string' ? src : staticSrc;\n    let isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');\n    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && !config.dangerouslyAllowSVG && src.split('?', 1)[0].endsWith('.svg')) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === 'export' && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== 'absolute') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== '100%') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== '100%') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === 'undefined') {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === 'undefined') {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/^[\\x00-\\x20]/.test(src)) {\n                    throw new Error('Image with src \"' + src + '\" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.');\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/[\\x00-\\x20]$/.test(src)) {\n                    throw new Error('Image with src \"' + src + '\" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(',') + \".\");\n        }\n        if (priority && loading === 'lazy') {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== 'empty') {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === 'blur' && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                'jpeg',\n                'png',\n                'webp',\n                'avif'\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(',') + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if ('ref' in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if (typeof window !== 'undefined' && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || '';\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: 'largest-contentful-paint',\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: 'absolute',\n        height: '100%',\n        width: '100%',\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: 'transparent'\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || '',\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || 'cover',\n        backgroundPosition: imgStyle.objectPosition || '50% 50%',\n        backgroundRepeat: 'no-repeat',\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === 'blur' && (blurDataURL == null ? void 0 : blurDataURL.startsWith('/'))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (typeof window !== 'undefined') {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? 'lazy' : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding,\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7K0NBOE9nQkE7OztlQUFBQTs7O3NDQTlPUzswQ0FDTzt5Q0FDRztBQStFbkMsTUFBTUMsdUJBQXVCO0lBQUM7SUFBUTtJQUFTQztDQUFVO0FBa0J6RCxTQUFTQyxnQkFDUEMsR0FBb0M7SUFFcEMsT0FBUUEsSUFBc0JDLE9BQU8sS0FBS0g7QUFDNUM7QUFFQSxTQUFTSSxrQkFDUEYsR0FBb0M7SUFFcEMsT0FBUUEsSUFBd0JBLEdBQUcsS0FBS0Y7QUFDMUM7QUFFQSxTQUFTSyxlQUFlSCxHQUEwQjtJQUNoRCxPQUNFLENBQUMsQ0FBQ0EsT0FDRixPQUFPQSxRQUFRLFlBQ2RELENBQUFBLGdCQUFnQkMsUUFDZkUsa0JBQWtCRixJQUFBQSxDQUFtQjtBQUUzQztBQUVBLE1BQU1JLFVBQVUsSUFBSUM7QUFJcEIsSUFBSUM7QUFFSixTQUFTQyxPQUFPQyxDQUFVO0lBQ3hCLElBQUksT0FBT0EsTUFBTSxhQUFhO1FBQzVCLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN6QixPQUFPQyxPQUFPQyxRQUFRLENBQUNGLEtBQUtBLElBQUlHO0lBQ2xDO0lBQ0EsSUFBSSxPQUFPSCxNQUFNLFlBQVksV0FBV0ksSUFBSSxDQUFDSixJQUFJO1FBQy9DLE9BQU9LLFNBQVNMLEdBQUc7SUFDckI7SUFDQSxPQUFPRztBQUNUO0FBRUEsU0FBU0csVUFDUCxLQUFzQyxFQUN0Q0MsS0FBeUIsRUFDekJDLEtBQXlCO0lBRnpCLE1BQUVDLFdBQVcsRUFBRUMsUUFBUSxFQUFlLEdBQXRDO0lBSUEsSUFBSUYsT0FBTztRQUNULHlEQUF5RDtRQUN6RCxNQUFNRyxrQkFBa0I7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ckksT0FBT3lJLGNBQWN6SSxLQUFLO1FBQzFCMEIsUUFBUStHLGNBQWMvRyxNQUFNO1FBQzVCMUMsS0FBS3FELGVBQWVvRyxjQUFjekosR0FBRztJQUN2QztJQUNBLE1BQU1nSyxPQUFPO1FBQUV6SDtRQUFhUTtRQUFVUztRQUFhTDtJQUFLO0lBQ3hELE9BQU87UUFBRTRHO1FBQU9DO0lBQUs7QUFDdkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi91dGlscy93YXJuLW9uY2UnXG5pbXBvcnQgeyBnZXRJbWFnZUJsdXJTdmcgfSBmcm9tICcuL2ltYWdlLWJsdXItc3ZnJ1xuaW1wb3J0IHsgaW1hZ2VDb25maWdEZWZhdWx0IH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlQ29uZmlnQ29tcGxldGUsXG4gIEltYWdlTG9hZGVyUHJvcHMsXG4gIEltYWdlTG9hZGVyUHJvcHNXaXRoQ29uZmlnLFxufSBmcm9tICcuL2ltYWdlLWNvbmZpZydcblxuaW1wb3J0IHR5cGUgeyBKU1ggfSBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNJbWFnZURhdGEge1xuICBzcmM6IHN0cmluZ1xuICBoZWlnaHQ6IG51bWJlclxuICB3aWR0aDogbnVtYmVyXG4gIGJsdXJEYXRhVVJMPzogc3RyaW5nXG4gIGJsdXJXaWR0aD86IG51bWJlclxuICBibHVySGVpZ2h0PzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljUmVxdWlyZSB7XG4gIGRlZmF1bHQ6IFN0YXRpY0ltYWdlRGF0YVxufVxuXG5leHBvcnQgdHlwZSBTdGF0aWNJbXBvcnQgPSBTdGF0aWNSZXF1aXJlIHwgU3RhdGljSW1hZ2VEYXRhXG5cbmV4cG9ydCB0eXBlIEltYWdlUHJvcHMgPSBPbWl0PFxuICBKU1guSW50cmluc2ljRWxlbWVudHNbJ2ltZyddLFxuICAnc3JjJyB8ICdzcmNTZXQnIHwgJ3JlZicgfCAnYWx0JyB8ICd3aWR0aCcgfCAnaGVpZ2h0JyB8ICdsb2FkaW5nJ1xuPiAmIHtcbiAgc3JjOiBzdHJpbmcgfCBTdGF0aWNJbXBvcnRcbiAgYWx0OiBzdHJpbmdcbiAgd2lkdGg/OiBudW1iZXIgfCBgJHtudW1iZXJ9YFxuICBoZWlnaHQ/OiBudW1iZXIgfCBgJHtudW1iZXJ9YFxuICBmaWxsPzogYm9vbGVhblxuICBsb2FkZXI/OiBJbWFnZUxvYWRlclxuICBxdWFsaXR5PzogbnVtYmVyIHwgYCR7bnVtYmVyfWBcbiAgcHJpb3JpdHk/OiBib29sZWFuXG4gIGxvYWRpbmc/OiBMb2FkaW5nVmFsdWVcbiAgcGxhY2Vob2xkZXI/OiBQbGFjZWhvbGRlclZhbHVlXG4gIGJsdXJEYXRhVVJMPzogc3RyaW5nXG4gIHVub3B0aW1pemVkPzogYm9vbGVhblxuICBvdmVycmlkZVNyYz86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvbkxvYWRgIGluc3RlYWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9pbWFnZSNvbmxvYWRcbiAgICovXG4gIG9uTG9hZGluZ0NvbXBsZXRlPzogT25Mb2FkaW5nQ29tcGxldGVcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgZmlsbGAgcHJvcCBpbnN0ZWFkIG9mIGBsYXlvdXQ9XCJmaWxsXCJgIG9yIGNoYW5nZSBpbXBvcnQgdG8gYG5leHQvbGVnYWN5L2ltYWdlYC5cbiAgICogQHNlZSBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvbGVnYWN5L2ltYWdlXG4gICAqL1xuICBsYXlvdXQ/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgc3R5bGVgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9iamVjdEZpdD86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzdHlsZWAgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb2JqZWN0UG9zaXRpb24/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgcHJvcCBkb2VzIG5vdCBkbyBhbnl0aGluZy5cbiAgICovXG4gIGxhenlCb3VuZGFyeT86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBwcm9wIGRvZXMgbm90IGRvIGFueXRoaW5nLlxuICAgKi9cbiAgbGF6eVJvb3Q/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgSW1nUHJvcHMgPSBPbWl0PEltYWdlUHJvcHMsICdzcmMnIHwgJ2xvYWRlcic+ICYge1xuICBsb2FkaW5nOiBMb2FkaW5nVmFsdWVcbiAgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZFxuICBoZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZFxuICBzdHlsZTogTm9uTnVsbGFibGU8SlNYLkludHJpbnNpY0VsZW1lbnRzWydpbWcnXVsnc3R5bGUnXT5cbiAgc2l6ZXM6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzcmNTZXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzcmM6IHN0cmluZ1xufVxuXG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFsnbGF6eScsICdlYWdlcicsIHVuZGVmaW5lZF0gYXMgY29uc3RcbnR5cGUgTG9hZGluZ1ZhbHVlID0gKHR5cGVvZiBWQUxJRF9MT0FESU5HX1ZBTFVFUylbbnVtYmVyXVxudHlwZSBJbWFnZUNvbmZpZyA9IEltYWdlQ29uZmlnQ29tcGxldGUgJiB7XG4gIGFsbFNpemVzOiBudW1iZXJbXVxuICBvdXRwdXQ/OiAnc3RhbmRhbG9uZScgfCAnZXhwb3J0J1xufVxuXG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlciA9IChwOiBJbWFnZUxvYWRlclByb3BzKSA9PiBzdHJpbmdcblxuLy8gRG8gbm90IGV4cG9ydCAtIHRoaXMgaXMgYW4gaW50ZXJuYWwgdHlwZSBvbmx5XG4vLyBiZWNhdXNlIGBuZXh0LmNvbmZpZy5qc2AgaXMgb25seSBtZWFudCBmb3IgdGhlXG4vLyBidWlsdC1pbiBsb2FkZXJzLCBub3QgZm9yIGEgY3VzdG9tIGxvYWRlcigpIHByb3AuXG50eXBlIEltYWdlTG9hZGVyV2l0aENvbmZpZyA9IChwOiBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZykgPT4gc3RyaW5nXG5cbmV4cG9ydCB0eXBlIFBsYWNlaG9sZGVyVmFsdWUgPSAnYmx1cicgfCAnZW1wdHknIHwgYGRhdGE6aW1hZ2UvJHtzdHJpbmd9YFxuZXhwb3J0IHR5cGUgT25Mb2FkID0gUmVhY3QuUmVhY3RFdmVudEhhbmRsZXI8SFRNTEltYWdlRWxlbWVudD4gfCB1bmRlZmluZWRcbmV4cG9ydCB0eXBlIE9uTG9hZGluZ0NvbXBsZXRlID0gKGltZzogSFRNTEltYWdlRWxlbWVudCkgPT4gdm9pZFxuXG5mdW5jdGlvbiBpc1N0YXRpY1JlcXVpcmUoXG4gIHNyYzogU3RhdGljUmVxdWlyZSB8IFN0YXRpY0ltYWdlRGF0YVxuKTogc3JjIGlzIFN0YXRpY1JlcXVpcmUge1xuICByZXR1cm4gKHNyYyBhcyBTdGF0aWNSZXF1aXJlKS5kZWZhdWx0ICE9PSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoXG4gIHNyYzogU3RhdGljUmVxdWlyZSB8IFN0YXRpY0ltYWdlRGF0YVxuKTogc3JjIGlzIFN0YXRpY0ltYWdlRGF0YSB7XG4gIHJldHVybiAoc3JjIGFzIFN0YXRpY0ltYWdlRGF0YSkuc3JjICE9PSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNJbXBvcnQoc3JjOiBzdHJpbmcgfCBTdGF0aWNJbXBvcnQpOiBzcmMgaXMgU3RhdGljSW1wb3J0IHtcbiAgcmV0dXJuIChcbiAgICAhIXNyYyAmJlxuICAgIHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmXG4gICAgKGlzU3RhdGljUmVxdWlyZShzcmMgYXMgU3RhdGljSW1wb3J0KSB8fFxuICAgICAgaXNTdGF0aWNJbWFnZURhdGEoc3JjIGFzIFN0YXRpY0ltcG9ydCkpXG4gIClcbn1cblxuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXA8XG4gIHN0cmluZyxcbiAgeyBzcmM6IHN0cmluZzsgcHJpb3JpdHk6IGJvb2xlYW47IHBsYWNlaG9sZGVyOiBQbGFjZWhvbGRlclZhbHVlIH1cbj4oKVxubGV0IHBlcmZPYnNlcnZlcjogUGVyZm9ybWFuY2VPYnNlcnZlciB8IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBnZXRJbnQoeDogdW5rbm93bik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4geFxuICB9XG4gIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHgpID8geCA6IE5hTlxuICB9XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgL15bMC05XSskLy50ZXN0KHgpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKVxuICB9XG4gIHJldHVybiBOYU5cbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhzKFxuICB7IGRldmljZVNpemVzLCBhbGxTaXplcyB9OiBJbWFnZUNvbmZpZyxcbiAgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgc2l6ZXM6IHN0cmluZyB8IHVuZGVmaW5lZFxuKTogeyB3aWR0aHM6IG51bWJlcltdOyBraW5kOiAndycgfCAneCcgfSB7XG4gIGlmIChzaXplcykge1xuICAgIC8vIEZpbmQgYWxsIHRoZSBcInZ3XCIgcGVyY2VudCBzaXplcyB1c2VkIGluIHRoZSBzaXplcyBwcm9wXG4gICAgY29uc3Qgdmlld3BvcnRXaWR0aFJlID0gLyhefFxccykoMT9cXGQ/XFxkKXZ3L2dcbiAgICBjb25zdCBwZXJjZW50U2l6ZXMgPSBbXVxuICAgIGZvciAobGV0IG1hdGNoOyAobWF0Y2ggPSB2aWV3cG9ydFdpZHRoUmUuZXhlYyhzaXplcykpOyBtYXRjaCkge1xuICAgICAgcGVyY2VudFNpemVzLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0pKVxuICAgIH1cbiAgICBpZiAocGVyY2VudFNpemVzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc21hbGxlc3RSYXRpbyA9IE1hdGgubWluKC4uLnBlcmNlbnRTaXplcykgKiAwLjAxXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aHM6IGFsbFNpemVzLmZpbHRlcigocykgPT4gcyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW8pLFxuICAgICAgICBraW5kOiAndycsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHdpZHRoczogYWxsU2l6ZXMsIGtpbmQ6ICd3JyB9XG4gIH1cbiAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4geyB3aWR0aHM6IGRldmljZVNpemVzLCBraW5kOiAndycgfVxuICB9XG5cbiAgY29uc3Qgd2lkdGhzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICAvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgLy8gPiBhcmUgYWN0dWFsbHkgM3ggaW4gdGhlIGdyZWVuIGNvbG9yLCBidXQgb25seSAxLjV4IGluIHRoZSByZWQgYW5kXG4gICAgICAvLyA+IGJsdWUgY29sb3JzLiBTaG93aW5nIGEgM3ggcmVzb2x1dGlvbiBpbWFnZSBpbiB0aGUgYXBwIHZzIGEgMnhcbiAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAvLyA+IHRha2VzIHNpZ25pZmljYW50bHkgbW9yZSBkYXRhLiBFdmVuIHRydWUgM3ggcmVzb2x1dGlvbiBzY3JlZW5zIGFyZVxuICAgICAgLy8gPiB3YXN0ZWZ1bCBhcyB0aGUgaHVtYW4gZXllIGNhbm5vdCBzZWUgdGhhdCBsZXZlbCBvZiBkZXRhaWwgd2l0aG91dFxuICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAvLyBodHRwczovL2Jsb2cudHdpdHRlci5jb20vZW5naW5lZXJpbmcvZW5fdXMvdG9waWNzL2luZnJhc3RydWN0dXJlLzIwMTkvY2FwcGluZy1pbWFnZS1maWRlbGl0eS1vbi11bHRyYS1oaWdoLXJlc29sdXRpb24tZGV2aWNlcy5odG1sXG4gICAgICBbd2lkdGgsIHdpZHRoICogMiAvKiwgd2lkdGggKiAzKi9dLm1hcChcbiAgICAgICAgKHcpID0+IGFsbFNpemVzLmZpbmQoKHApID0+IHAgPj0gdykgfHwgYWxsU2l6ZXNbYWxsU2l6ZXMubGVuZ3RoIC0gMV1cbiAgICAgIClcbiAgICApLFxuICBdXG4gIHJldHVybiB7IHdpZHRocywga2luZDogJ3gnIH1cbn1cblxudHlwZSBHZW5JbWdBdHRyc0RhdGEgPSB7XG4gIGNvbmZpZzogSW1hZ2VDb25maWdcbiAgc3JjOiBzdHJpbmdcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgbG9hZGVyOiBJbWFnZUxvYWRlcldpdGhDb25maWdcbiAgd2lkdGg/OiBudW1iZXJcbiAgcXVhbGl0eT86IG51bWJlclxuICBzaXplcz86IHN0cmluZ1xufVxuXG50eXBlIEdlbkltZ0F0dHJzUmVzdWx0ID0ge1xuICBzcmM6IHN0cmluZ1xuICBzcmNTZXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzaXplczogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW1nQXR0cnMoe1xuICBjb25maWcsXG4gIHNyYyxcbiAgdW5vcHRpbWl6ZWQsXG4gIHdpZHRoLFxuICBxdWFsaXR5LFxuICBzaXplcyxcbiAgbG9hZGVyLFxufTogR2VuSW1nQXR0cnNEYXRhKTogR2VuSW1nQXR0cnNSZXN1bHQge1xuICBpZiAodW5vcHRpbWl6ZWQpIHtcbiAgICByZXR1cm4geyBzcmMsIHNyY1NldDogdW5kZWZpbmVkLCBzaXplczogdW5kZWZpbmVkIH1cbiAgfVxuXG4gIGNvbnN0IHsgd2lkdGhzLCBraW5kIH0gPSBnZXRXaWR0aHMoY29uZmlnLCB3aWR0aCwgc2l6ZXMpXG4gIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMVxuXG4gIHJldHVybiB7XG4gICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXG4gICAgc3JjU2V0OiB3aWR0aHNcbiAgICAgIC5tYXAoXG4gICAgICAgICh3LCBpKSA9PlxuICAgICAgICAgIGAke2xvYWRlcih7IGNvbmZpZywgc3JjLCBxdWFsaXR5LCB3aWR0aDogdyB9KX0gJHtcbiAgICAgICAgICAgIGtpbmQgPT09ICd3JyA/IHcgOiBpICsgMVxuICAgICAgICAgIH0ke2tpbmR9YFxuICAgICAgKVxuICAgICAgLmpvaW4oJywgJyksXG5cbiAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYHNyY2AgdGhlIGxhc3QgYXR0cmlidXRlIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgLy8gdXBkYXRlZCBieSBSZWFjdC4gVGhhdCBjYXVzZXMgbXVsdGlwbGUgdW5uZWNlc3NhcnkgcmVxdWVzdHMgaWYgYHNyY1NldGBcbiAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICBzcmM6IGxvYWRlcih7IGNvbmZpZywgc3JjLCBxdWFsaXR5LCB3aWR0aDogd2lkdGhzW2xhc3RdIH0pLFxuICB9XG59XG5cbi8qKlxuICogQSBzaGFyZWQgZnVuY3Rpb24sIHVzZWQgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciwgdG8gZ2VuZXJhdGUgdGhlIHByb3BzIGZvciA8aW1nPi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEltZ1Byb3BzKFxuICB7XG4gICAgc3JjLFxuICAgIHNpemVzLFxuICAgIHVub3B0aW1pemVkID0gZmFsc2UsXG4gICAgcHJpb3JpdHkgPSBmYWxzZSxcbiAgICBsb2FkaW5nLFxuICAgIGNsYXNzTmFtZSxcbiAgICBxdWFsaXR5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBmaWxsID0gZmFsc2UsXG4gICAgc3R5bGUsXG4gICAgb3ZlcnJpZGVTcmMsXG4gICAgb25Mb2FkLFxuICAgIG9uTG9hZGluZ0NvbXBsZXRlLFxuICAgIHBsYWNlaG9sZGVyID0gJ2VtcHR5JyxcbiAgICBibHVyRGF0YVVSTCxcbiAgICBmZXRjaFByaW9yaXR5LFxuICAgIGRlY29kaW5nID0gJ2FzeW5jJyxcbiAgICBsYXlvdXQsXG4gICAgb2JqZWN0Rml0LFxuICAgIG9iamVjdFBvc2l0aW9uLFxuICAgIGxhenlCb3VuZGFyeSxcbiAgICBsYXp5Um9vdCxcbiAgICAuLi5yZXN0XG4gIH06IEltYWdlUHJvcHMsXG4gIF9zdGF0ZToge1xuICAgIGRlZmF1bHRMb2FkZXI6IEltYWdlTG9hZGVyV2l0aENvbmZpZ1xuICAgIGltZ0NvbmY6IEltYWdlQ29uZmlnQ29tcGxldGVcbiAgICBzaG93QWx0VGV4dD86IGJvb2xlYW5cbiAgICBibHVyQ29tcGxldGU/OiBib29sZWFuXG4gIH1cbik6IHtcbiAgcHJvcHM6IEltZ1Byb3BzXG4gIG1ldGE6IHtcbiAgICB1bm9wdGltaXplZDogYm9vbGVhblxuICAgIHByaW9yaXR5OiBib29sZWFuXG4gICAgcGxhY2Vob2xkZXI6IE5vbk51bGxhYmxlPEltYWdlUHJvcHNbJ3BsYWNlaG9sZGVyJ10+XG4gICAgZmlsbDogYm9vbGVhblxuICB9XG59IHtcbiAgY29uc3QgeyBpbWdDb25mLCBzaG93QWx0VGV4dCwgYmx1ckNvbXBsZXRlLCBkZWZhdWx0TG9hZGVyIH0gPSBfc3RhdGVcbiAgbGV0IGNvbmZpZzogSW1hZ2VDb25maWdcbiAgbGV0IGMgPSBpbWdDb25mIHx8IGltYWdlQ29uZmlnRGVmYXVsdFxuICBpZiAoJ2FsbFNpemVzJyBpbiBjKSB7XG4gICAgY29uZmlnID0gYyBhcyBJbWFnZUNvbmZpZ1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFsbFNpemVzID0gWy4uLmMuZGV2aWNlU2l6ZXMsIC4uLmMuaW1hZ2VTaXplc10uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgIGNvbnN0IHF1YWxpdGllcyA9IGMucXVhbGl0aWVzPy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICBjb25maWcgPSB7IC4uLmMsIGFsbFNpemVzLCBkZXZpY2VTaXplcywgcXVhbGl0aWVzIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmYXVsdExvYWRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnaW1hZ2VzLmxvYWRlckZpbGUgZGV0ZWN0ZWQgYnV0IHRoZSBmaWxlIGlzIG1pc3NpbmcgZGVmYXVsdCBleHBvcnQuXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLWltYWdlcy1jb25maWcnXG4gICAgKVxuICB9XG4gIGxldCBsb2FkZXI6IEltYWdlTG9hZGVyV2l0aENvbmZpZyA9IHJlc3QubG9hZGVyIHx8IGRlZmF1bHRMb2FkZXJcblxuICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIG9uIDxpbWc+IGVsZW1lbnRcbiAgZGVsZXRlIHJlc3QubG9hZGVyXG4gIGRlbGV0ZSAocmVzdCBhcyBhbnkpLnNyY1NldFxuXG4gIC8vIFRoaXMgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgdXNlclxuICAvLyBkaWRuJ3QgZGVmaW5lIGEgXCJsb2FkZXJcIiBwcm9wIG9yIFwibG9hZGVyXCIgY29uZmlnLlxuICBjb25zdCBpc0RlZmF1bHRMb2FkZXIgPSAnX19uZXh0X2ltZ19kZWZhdWx0JyBpbiBsb2FkZXJcblxuICBpZiAoaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgaWYgKGNvbmZpZy5sb2FkZXIgPT09ICdjdXN0b20nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgXCJsb2FkZXJcIiBwcm9wLmAgK1xuICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJgXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSB1c2VyIGRlZmluZWQgYSBcImxvYWRlclwiIHByb3Agb3IgY29uZmlnLlxuICAgIC8vIFNpbmNlIHRoZSBjb25maWcgb2JqZWN0IGlzIGludGVybmFsIG9ubHksIHdlXG4gICAgLy8gbXVzdCBub3QgcGFzcyBpdCB0byB0aGUgdXNlci1kZWZpbmVkIFwibG9hZGVyXCIuXG4gICAgY29uc3QgY3VzdG9tSW1hZ2VMb2FkZXIgPSBsb2FkZXIgYXMgSW1hZ2VMb2FkZXJcbiAgICBsb2FkZXIgPSAob2JqKSA9PiB7XG4gICAgICBjb25zdCB7IGNvbmZpZzogXywgLi4ub3B0cyB9ID0gb2JqXG4gICAgICByZXR1cm4gY3VzdG9tSW1hZ2VMb2FkZXIob3B0cylcbiAgICB9XG4gIH1cblxuICBpZiAobGF5b3V0KSB7XG4gICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnKSB7XG4gICAgICBmaWxsID0gdHJ1ZVxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRUb1N0eWxlOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkPiA9IHtcbiAgICAgIGludHJpbnNpYzogeyBtYXhXaWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdhdXRvJyB9LFxuICAgICAgcmVzcG9uc2l2ZTogeyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdhdXRvJyB9LFxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRUb1NpemVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0ge1xuICAgICAgcmVzcG9uc2l2ZTogJzEwMHZ3JyxcbiAgICAgIGZpbGw6ICcxMDB2dycsXG4gICAgfVxuICAgIGNvbnN0IGxheW91dFN0eWxlID0gbGF5b3V0VG9TdHlsZVtsYXlvdXRdXG4gICAgaWYgKGxheW91dFN0eWxlKSB7XG4gICAgICBzdHlsZSA9IHsgLi4uc3R5bGUsIC4uLmxheW91dFN0eWxlIH1cbiAgICB9XG4gICAgY29uc3QgbGF5b3V0U2l6ZXMgPSBsYXlvdXRUb1NpemVzW2xheW91dF1cbiAgICBpZiAobGF5b3V0U2l6ZXMgJiYgIXNpemVzKSB7XG4gICAgICBzaXplcyA9IGxheW91dFNpemVzXG4gICAgfVxuICB9XG5cbiAgbGV0IHN0YXRpY1NyYyA9ICcnXG4gIGxldCB3aWR0aEludCA9IGdldEludCh3aWR0aClcbiAgbGV0IGhlaWdodEludCA9IGdldEludChoZWlnaHQpXG4gIGxldCBibHVyV2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZFxuICBsZXQgYmx1ckhlaWdodDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgY29uc3Qgc3RhdGljSW1hZ2VEYXRhID0gaXNTdGF0aWNSZXF1aXJlKHNyYykgPyBzcmMuZGVmYXVsdCA6IHNyY1xuXG4gICAgaWYgKCFzdGF0aWNJbWFnZURhdGEuc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzdGF0aWNJbWFnZURhdGFcbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgfVxuICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIGhlaWdodCBhbmQgd2lkdGguIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc3RhdGljSW1hZ2VEYXRhXG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cblxuICAgIGJsdXJXaWR0aCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVyV2lkdGhcbiAgICBibHVySGVpZ2h0ID0gc3RhdGljSW1hZ2VEYXRhLmJsdXJIZWlnaHRcbiAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTFxuICAgIHN0YXRpY1NyYyA9IHN0YXRpY0ltYWdlRGF0YS5zcmNcblxuICAgIGlmICghZmlsbCkge1xuICAgICAgaWYgKCF3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgIHdpZHRoSW50ID0gc3RhdGljSW1hZ2VEYXRhLndpZHRoXG4gICAgICAgIGhlaWdodEludCA9IHN0YXRpY0ltYWdlRGF0YS5oZWlnaHRcbiAgICAgIH0gZWxzZSBpZiAod2lkdGhJbnQgJiYgIWhlaWdodEludCkge1xuICAgICAgICBjb25zdCByYXRpbyA9IHdpZHRoSW50IC8gc3RhdGljSW1hZ2VEYXRhLndpZHRoXG4gICAgICAgIGhlaWdodEludCA9IE1hdGgucm91bmQoc3RhdGljSW1hZ2VEYXRhLmhlaWdodCAqIHJhdGlvKVxuICAgICAgfSBlbHNlIGlmICghd2lkdGhJbnQgJiYgaGVpZ2h0SW50KSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gaGVpZ2h0SW50IC8gc3RhdGljSW1hZ2VEYXRhLmhlaWdodFxuICAgICAgICB3aWR0aEludCA9IE1hdGgucm91bmQoc3RhdGljSW1hZ2VEYXRhLndpZHRoICogcmF0aW8pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNyYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gc3JjIDogc3RhdGljU3JjXG5cbiAgbGV0IGlzTGF6eSA9XG4gICAgIXByaW9yaXR5ICYmIChsb2FkaW5nID09PSAnbGF6eScgfHwgdHlwZW9mIGxvYWRpbmcgPT09ICd1bmRlZmluZWQnKVxuICBpZiAoIXNyYyB8fCBzcmMuc3RhcnRzV2l0aCgnZGF0YTonKSB8fCBzcmMuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gICAgaXNMYXp5ID0gZmFsc2VcbiAgfVxuICBpZiAoY29uZmlnLnVub3B0aW1pemVkKSB7XG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gIH1cbiAgaWYgKFxuICAgIGlzRGVmYXVsdExvYWRlciAmJlxuICAgICFjb25maWcuZGFuZ2Vyb3VzbHlBbGxvd1NWRyAmJlxuICAgIHNyYy5zcGxpdCgnPycsIDEpWzBdLmVuZHNXaXRoKCcuc3ZnJylcbiAgKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXG4gICAgLy8gdGhyb3VnaCB0aGUgYnVpbHQtaW4gSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cbiAgICB1bm9wdGltaXplZCA9IHRydWVcbiAgfVxuXG4gIGNvbnN0IHF1YWxpdHlJbnQgPSBnZXRJbnQocXVhbGl0eSlcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChjb25maWcub3V0cHV0ID09PSAnZXhwb3J0JyAmJiBpc0RlZmF1bHRMb2FkZXIgJiYgIXVub3B0aW1pemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSBPcHRpbWl6YXRpb24gdXNpbmcgdGhlIGRlZmF1bHQgbG9hZGVyIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggXFxgeyBvdXRwdXQ6ICdleHBvcnQnIH1cXGAuXG4gIFBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAtIFJlbW92ZSBcXGB7IG91dHB1dDogJ2V4cG9ydCcgfVxcYCBhbmQgcnVuIFwibmV4dCBzdGFydFwiIHRvIHJ1biBzZXJ2ZXIgbW9kZSBpbmNsdWRpbmcgdGhlIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgLSBDb25maWd1cmUgXFxgeyBpbWFnZXM6IHsgdW5vcHRpbWl6ZWQ6IHRydWUgfSB9XFxgIGluIFxcYG5leHQuY29uZmlnLmpzXFxgIHRvIGRpc2FibGUgdGhlIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZXhwb3J0LWltYWdlLWFwaWBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIC8vIFJlYWN0IGRvZXNuJ3Qgc2hvdyB0aGUgc3RhY2sgdHJhY2UgYW5kIHRoZXJlJ3NcbiAgICAgIC8vIG5vIGBzcmNgIHRvIGhlbHAgaWRlbnRpZnkgd2hpY2ggaW1hZ2UsIHNvIHdlXG4gICAgICAvLyBpbnN0ZWFkIGNvbnNvbGUuZXJyb3IocmVmKSBkdXJpbmcgbW91bnQuXG4gICAgICB1bm9wdGltaXplZCA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJ3aWR0aFwiIGFuZCBcImZpbGxcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcImhlaWdodFwiIGFuZCBcImZpbGxcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZT8ucG9zaXRpb24gJiYgc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcImZpbGxcIiBhbmQgXCJzdHlsZS5wb3NpdGlvblwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgcG9zaXRpb24gYWJzb2x1dGUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGU/LndpZHRoICYmIHN0eWxlLndpZHRoICE9PSAnMTAwJScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcImZpbGxcIiBhbmQgXCJzdHlsZS53aWR0aFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2Ugd2lkdGggMTAwJSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZT8uaGVpZ2h0ICYmIHN0eWxlLmhlaWdodCAhPT0gJzEwMCUnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJmaWxsXCIgYW5kIFwic3R5bGUuaGVpZ2h0XCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSBoZWlnaHQgMTAwJSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJ3aWR0aFwiIHByb3BlcnR5LmBcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4od2lkdGhJbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJ3aWR0aFwiIHByb3BlcnR5LiBFeHBlY3RlZCBhIG51bWVyaWMgdmFsdWUgaW4gcGl4ZWxzIGJ1dCByZWNlaXZlZCBcIiR7d2lkdGh9XCIuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodEludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyBtaXNzaW5nIHJlcXVpcmVkIFwiaGVpZ2h0XCIgcHJvcGVydHkuYFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTihoZWlnaHRJbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCIke2hlaWdodH1cIi5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICAgIGlmICgvXltcXHgwMC1cXHgyMF0vLnRlc3Qoc3JjKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGNhbm5vdCBzdGFydCB3aXRoIGEgc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXIuIFVzZSBzcmMudHJpbVN0YXJ0KCkgdG8gcmVtb3ZlIGl0IG9yIGVuY29kZVVSSUNvbXBvbmVudChzcmMpIHRvIGtlZXAgaXQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICBpZiAoL1tcXHgwMC1cXHgyMF0kLy50ZXN0KHNyYykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBjYW5ub3QgZW5kIHdpdGggYSBzcGFjZSBvciBjb250cm9sIGNoYXJhY3Rlci4gVXNlIHNyYy50cmltRW5kKCkgdG8gcmVtb3ZlIGl0IG9yIGVuY29kZVVSSUNvbXBvbmVudChzcmMpIHRvIGtlZXAgaXQuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIVZBTElEX0xPQURJTkdfVkFMVUVTLmluY2x1ZGVzKGxvYWRpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwibG9hZGluZ1wiIHByb3BlcnR5LiBQcm92aWRlZCBcIiR7bG9hZGluZ31cIiBzaG91bGQgYmUgb25lIG9mICR7VkFMSURfTE9BRElOR19WQUxVRVMubWFwKFxuICAgICAgICAgIFN0cmluZ1xuICAgICAgICApLmpvaW4oJywnKX0uYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAocHJpb3JpdHkgJiYgbG9hZGluZyA9PT0gJ2xhenknKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPSdsYXp5J1wiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLmBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKFxuICAgICAgcGxhY2Vob2xkZXIgIT09ICdlbXB0eScgJiZcbiAgICAgIHBsYWNlaG9sZGVyICE9PSAnYmx1cicgJiZcbiAgICAgICFwbGFjZWhvbGRlci5zdGFydHNXaXRoKCdkYXRhOmltYWdlLycpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBpbnZhbGlkIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSBcIiR7cGxhY2Vob2xkZXJ9XCIuYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAocGxhY2Vob2xkZXIgIT09ICdlbXB0eScpIHtcbiAgICAgIGlmICh3aWR0aEludCAmJiBoZWlnaHRJbnQgJiYgd2lkdGhJbnQgKiBoZWlnaHRJbnQgPCAxNjAwKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHNtYWxsZXIgdGhhbiA0MHg0MC4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGxhY2Vob2xkZXIgPT09ICdibHVyJyAmJiAhYmx1ckRhdGFVUkwpIHtcbiAgICAgIGNvbnN0IFZBTElEX0JMVVJfRVhUID0gWydqcGVnJywgJ3BuZycsICd3ZWJwJywgJ2F2aWYnXSAvLyBzaG91bGQgbWF0Y2ggbmV4dC1pbWFnZS1sb2FkZXJcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSBidXQgaXMgbWlzc2luZyB0aGUgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LlxuICAgICAgICBQb3NzaWJsZSBzb2x1dGlvbnM6XG4gICAgICAgICAgLSBBZGQgYSBcImJsdXJEYXRhVVJMXCIgcHJvcGVydHksIHRoZSBjb250ZW50cyBzaG91bGQgYmUgYSBzbWFsbCBEYXRhIFVSTCB0byByZXByZXNlbnQgdGhlIGltYWdlXG4gICAgICAgICAgLSBDaGFuZ2UgdGhlIFwic3JjXCIgcHJvcGVydHkgdG8gYSBzdGF0aWMgaW1wb3J0IHdpdGggb25lIG9mIHRoZSBzdXBwb3J0ZWQgZmlsZSB0eXBlczogJHtWQUxJRF9CTFVSX0VYVC5qb2luKFxuICAgICAgICAgICAgJywnXG4gICAgICAgICAgKX0gKGFuaW1hdGVkIGltYWdlcyBub3Qgc3VwcG9ydGVkKVxuICAgICAgICAgIC0gUmVtb3ZlIHRoZSBcInBsYWNlaG9sZGVyXCIgcHJvcGVydHksIGVmZmVjdGl2ZWx5IG5vIGJsdXIgZWZmZWN0XG4gICAgICAgIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcGxhY2Vob2xkZXItYmx1ci1kYXRhLXVybGBcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCdyZWYnIGluIHJlc3QpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyB1c2luZyB1bnN1cHBvcnRlZCBcInJlZlwiIHByb3BlcnR5LiBDb25zaWRlciB1c2luZyB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoIXVub3B0aW1pemVkICYmICFpc0RlZmF1bHRMb2FkZXIpIHtcbiAgICAgIGNvbnN0IHVybFN0ciA9IGxvYWRlcih7XG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgc3JjLFxuICAgICAgICB3aWR0aDogd2lkdGhJbnQgfHwgNDAwLFxuICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50IHx8IDc1LFxuICAgICAgfSlcbiAgICAgIGxldCB1cmw6IFVSTCB8IHVuZGVmaW5lZFxuICAgICAgdHJ5IHtcbiAgICAgICAgdXJsID0gbmV3IFVSTCh1cmxTdHIpXG4gICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgKHVybCAmJiB1cmwucGF0aG5hbWUgPT09IHNyYyAmJiAhdXJsLnNlYXJjaCkpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGEgXCJsb2FkZXJcIiBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IGltcGxlbWVudCB3aWR0aC4gUGxlYXNlIGltcGxlbWVudCBpdCBvciB1c2UgdGhlIFwidW5vcHRpbWl6ZWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmAgK1xuICAgICAgICAgICAgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS1taXNzaW5nLWxvYWRlci13aWR0aGBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbkxvYWRpbmdDb21wbGV0ZSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHVzaW5nIGRlcHJlY2F0ZWQgXCJvbkxvYWRpbmdDb21wbGV0ZVwiIHByb3BlcnR5LiBQbGVhc2UgdXNlIHRoZSBcIm9uTG9hZFwiIHByb3BlcnR5IGluc3RlYWQuYFxuICAgICAgKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2xlZ2FjeUtleSwgbGVnYWN5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgIGxheW91dCxcbiAgICAgIG9iamVjdEZpdCxcbiAgICAgIG9iamVjdFBvc2l0aW9uLFxuICAgICAgbGF6eUJvdW5kYXJ5LFxuICAgICAgbGF6eVJvb3QsXG4gICAgfSkpIHtcbiAgICAgIGlmIChsZWdhY3lWYWx1ZSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgbGVnYWN5IHByb3AgXCIke2xlZ2FjeUtleX1cIi4gRGlkIHlvdSBmb3JnZXQgdG8gcnVuIHRoZSBjb2RlbW9kP2AgK1xuICAgICAgICAgICAgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11cGdyYWRlLXRvLTEzYFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICFwZXJmT2JzZXJ2ZXIgJiZcbiAgICAgIHdpbmRvdy5QZXJmb3JtYW5jZU9ic2VydmVyXG4gICAgKSB7XG4gICAgICBwZXJmT2JzZXJ2ZXIgPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcigoZW50cnlMaXN0KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cnlMaXN0LmdldEVudHJpZXMoKSkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBtaXNzaW5nIFwiTGFyZ2VzdENvbnRlbnRmdWxQYWludFwiIGNsYXNzIHdpdGggXCJlbGVtZW50XCIgcHJvcFxuICAgICAgICAgIGNvbnN0IGltZ1NyYyA9IGVudHJ5Py5lbGVtZW50Py5zcmMgfHwgJydcbiAgICAgICAgICBjb25zdCBsY3BJbWFnZSA9IGFsbEltZ3MuZ2V0KGltZ1NyYylcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBsY3BJbWFnZSAmJlxuICAgICAgICAgICAgIWxjcEltYWdlLnByaW9yaXR5ICYmXG4gICAgICAgICAgICBsY3BJbWFnZS5wbGFjZWhvbGRlciA9PT0gJ2VtcHR5JyAmJlxuICAgICAgICAgICAgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdkYXRhOicpICYmXG4gICAgICAgICAgICAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmRldi9sY3AvI21lYXN1cmUtbGNwLWluLWphdmFzY3JpcHRcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke2xjcEltYWdlLnNyY31cIiB3YXMgZGV0ZWN0ZWQgYXMgdGhlIExhcmdlc3QgQ29udGVudGZ1bCBQYWludCAoTENQKS4gUGxlYXNlIGFkZCB0aGUgXCJwcmlvcml0eVwiIHByb3BlcnR5IGlmIHRoaXMgaW1hZ2UgaXMgYWJvdmUgdGhlIGZvbGQuYCArXG4gICAgICAgICAgICAgICAgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3ByaW9yaXR5YFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICB0eXBlOiAnbGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50JyxcbiAgICAgICAgICBidWZmZXJlZDogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGNyYXNoIHRoZSBhcHBcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGltZ1N0eWxlID0gT2JqZWN0LmFzc2lnbihcbiAgICBmaWxsXG4gICAgICA/IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgICAgb2JqZWN0UG9zaXRpb24sXG4gICAgICAgIH1cbiAgICAgIDoge30sXG4gICAgc2hvd0FsdFRleHQgPyB7fSA6IHsgY29sb3I6ICd0cmFuc3BhcmVudCcgfSxcbiAgICBzdHlsZVxuICApXG5cbiAgY29uc3QgYmFja2dyb3VuZEltYWdlID1cbiAgICAhYmx1ckNvbXBsZXRlICYmIHBsYWNlaG9sZGVyICE9PSAnZW1wdHknXG4gICAgICA/IHBsYWNlaG9sZGVyID09PSAnYmx1cidcbiAgICAgICAgPyBgdXJsKFwiZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJHtnZXRJbWFnZUJsdXJTdmcoe1xuICAgICAgICAgICAgd2lkdGhJbnQsXG4gICAgICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgICAgICBibHVyV2lkdGgsXG4gICAgICAgICAgICBibHVySGVpZ2h0LFxuICAgICAgICAgICAgYmx1ckRhdGFVUkw6IGJsdXJEYXRhVVJMIHx8ICcnLCAvLyBhc3N1bWUgbm90IHVuZGVmaW5lZFxuICAgICAgICAgICAgb2JqZWN0Rml0OiBpbWdTdHlsZS5vYmplY3RGaXQsXG4gICAgICAgICAgfSl9XCIpYFxuICAgICAgICA6IGB1cmwoXCIke3BsYWNlaG9sZGVyfVwiKWAgLy8gYXNzdW1lIGBkYXRhOmltYWdlL2BcbiAgICAgIDogbnVsbFxuXG4gIGxldCBwbGFjZWhvbGRlclN0eWxlID0gYmFja2dyb3VuZEltYWdlXG4gICAgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplOiBpbWdTdHlsZS5vYmplY3RGaXQgfHwgJ2NvdmVyJyxcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBpbWdTdHlsZS5vYmplY3RQb3NpdGlvbiB8fCAnNTAlIDUwJScsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6ICduby1yZXBlYXQnLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICB9XG4gICAgOiB7fVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmIChcbiAgICAgIHBsYWNlaG9sZGVyU3R5bGUuYmFja2dyb3VuZEltYWdlICYmXG4gICAgICBwbGFjZWhvbGRlciA9PT0gJ2JsdXInICYmXG4gICAgICBibHVyRGF0YVVSTD8uc3RhcnRzV2l0aCgnLycpXG4gICAgKSB7XG4gICAgICAvLyBEdXJpbmcgYG5leHQgZGV2YCwgd2UgZG9uJ3Qgd2FudCB0byBnZW5lcmF0ZSBibHVyIHBsYWNlaG9sZGVycyB3aXRoIHdlYnBhY2tcbiAgICAgIC8vIGJlY2F1c2UgaXQgY2FuIGRlbGF5IHN0YXJ0aW5nIHRoZSBkZXYgc2VydmVyLiBJbnN0ZWFkLCBgbmV4dC1pbWFnZS1sb2FkZXIuanNgXG4gICAgICAvLyB3aWxsIGlubGluZSBhIHNwZWNpYWwgdXJsIHRvIGxhemlseSBnZW5lcmF0ZSB0aGUgYmx1ciBwbGFjZWhvbGRlciBhdCByZXF1ZXN0IHRpbWUuXG4gICAgICBwbGFjZWhvbGRlclN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoXCIke2JsdXJEYXRhVVJMfVwiKWBcbiAgICB9XG4gIH1cblxuICBjb25zdCBpbWdBdHRyaWJ1dGVzID0gZ2VuZXJhdGVJbWdBdHRycyh7XG4gICAgY29uZmlnLFxuICAgIHNyYyxcbiAgICB1bm9wdGltaXplZCxcbiAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICBzaXplcyxcbiAgICBsb2FkZXIsXG4gIH0pXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxldCBmdWxsVXJsOiBVUkxcbiAgICAgIHRyeSB7XG4gICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYywgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICB9XG4gICAgICBhbGxJbWdzLnNldChmdWxsVXJsLmhyZWYsIHsgc3JjLCBwcmlvcml0eSwgcGxhY2Vob2xkZXIgfSlcbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm9wczogSW1nUHJvcHMgPSB7XG4gICAgLi4ucmVzdCxcbiAgICBsb2FkaW5nOiBpc0xhenkgPyAnbGF6eScgOiBsb2FkaW5nLFxuICAgIGZldGNoUHJpb3JpdHksXG4gICAgd2lkdGg6IHdpZHRoSW50LFxuICAgIGhlaWdodDogaGVpZ2h0SW50LFxuICAgIGRlY29kaW5nLFxuICAgIGNsYXNzTmFtZSxcbiAgICBzdHlsZTogeyAuLi5pbWdTdHlsZSwgLi4ucGxhY2Vob2xkZXJTdHlsZSB9LFxuICAgIHNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgIHNyY1NldDogaW1nQXR0cmlidXRlcy5zcmNTZXQsXG4gICAgc3JjOiBvdmVycmlkZVNyYyB8fCBpbWdBdHRyaWJ1dGVzLnNyYyxcbiAgfVxuICBjb25zdCBtZXRhID0geyB1bm9wdGltaXplZCwgcHJpb3JpdHksIHBsYWNlaG9sZGVyLCBmaWxsIH1cbiAgcmV0dXJuIHsgcHJvcHMsIG1ldGEgfVxufVxuIl0sIm5hbWVzIjpbImdldEltZ1Byb3BzIiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJ1bmRlZmluZWQiLCJpc1N0YXRpY1JlcXVpcmUiLCJzcmMiLCJkZWZhdWx0IiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImFsbEltZ3MiLCJNYXAiLCJwZXJmT2JzZXJ2ZXIiLCJnZXRJbnQiLCJ4IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJOYU4iLCJ0ZXN0IiwicGFyc2VJbnQiLCJnZXRXaWR0aHMiLCJ3aWR0aCIsInNpemVzIiwiZGV2aWNlU2l6ZXMiLCJhbGxTaXplcyIsInZpZXdwb3J0V2lkdGhSZSIsInBlcmNlbnRTaXplcyIsIm1hdGNoIiwiZXhlYyIsInB1c2giLCJsZW5ndGgiLCJzbWFsbGVzdFJhdGlvIiwiTWF0aCIsIm1pbiIsIndpZHRocyIsImZpbHRlciIsInMiLCJraW5kIiwiU2V0IiwibWFwIiwidyIsImZpbmQiLCJwIiwiZ2VuZXJhdGVJbWdBdHRycyIsImNvbmZpZyIsInVub3B0aW1pemVkIiwicXVhbGl0eSIsImxvYWRlciIsInNyY1NldCIsImxhc3QiLCJpIiwiam9pbiIsIl9zdGF0ZSIsInByaW9yaXR5IiwibG9hZGluZyIsImNsYXNzTmFtZSIsImhlaWdodCIsImZpbGwiLCJzdHlsZSIsIm92ZXJyaWRlU3JjIiwib25Mb2FkIiwib25Mb2FkaW5nQ29tcGxldGUiLCJwbGFjZWhvbGRlciIsImJsdXJEYXRhVVJMIiwiZmV0Y2hQcmlvcml0eSIsImRlY29kaW5nIiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsInJlc3QiLCJpbWdDb25mIiwic2hvd0FsdFRleHQiLCJibHVyQ29tcGxldGUiLCJkZWZhdWx0TG9hZGVyIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJxdWFsaXRpZXMiLCJFcnJvciIsImlzRGVmYXVsdExvYWRlciIsImN1c3RvbUltYWdlTG9hZGVyIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwicmF0aW8iLCJyb3VuZCIsImlzTGF6eSIsInN0YXJ0c1dpdGgiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwic3BsaXQiLCJlbmRzV2l0aCIsInF1YWxpdHlJbnQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJvdXRwdXQiLCJwb3NpdGlvbiIsImlzTmFOIiwiaW5jbHVkZXMiLCJTdHJpbmciLCJ3YXJuT25jZSIsIlZBTElEX0JMVVJfRVhUIiwidXJsU3RyIiwidXJsIiwiVVJMIiwiZXJyIiwicGF0aG5hbWUiLCJzZWFyY2giLCJsZWdhY3lLZXkiLCJsZWdhY3lWYWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ3aW5kb3ciLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwiZW50cnlMaXN0IiwiZW50cnkiLCJnZXRFbnRyaWVzIiwiaW1nU3JjIiwiZWxlbWVudCIsImxjcEltYWdlIiwiZ2V0Iiwib2JzZXJ2ZSIsInR5cGUiLCJidWZmZXJlZCIsImNvbnNvbGUiLCJlcnJvciIsImltZ1N0eWxlIiwiYXNzaWduIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJnZXRJbWFnZUJsdXJTdmciLCJwbGFjZWhvbGRlclN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiaW1nQXR0cmlidXRlcyIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJocmVmIiwic2V0IiwicHJvcHMiLCJtZXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/head.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/head.js ***!
  \******************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    defaultHead: function() {\n        return defaultHead;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        }, \"charset\")\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }, \"viewport\"));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === 'string' || typeof child === 'number') {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    'name',\n    'httpEquiv',\n    'charSet',\n    'itemProp'\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf('$') + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case 'title':\n            case 'base':\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case 'meta':\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === 'charSet') {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {\n                const srcMessage = c.props['src'] ? '<script> tag with src=\"' + c.props['src'] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props['href'] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQXVNQSxPQUFtQjtlQUFuQjs7SUExTGdCQSxXQUFXO2VBQVhBOzs7Ozs7NkVBWDRCO2lGQUN6QjtxREFDYTs2REFDRztxQ0FDUDtzQ0FDSDtBQU1sQixTQUFTQSxZQUFZQyxTQUFpQjtJQUFqQkEsSUFBQUEsY0FBQUEsS0FBQUEsR0FBQUEsWUFBWTtJQUN0QyxNQUFNQyxPQUFPO3NCQUFDLHFCQUFDQyxRQUFBQTtZQUFLQyxTQUFRO1dBQVk7S0FBYTtJQUNyRCxJQUFJLENBQUNILFdBQVc7UUFDZEMsS0FBS0csSUFBSSxlQUNQLHFCQUFDRixRQUFBQTtZQUFLRyxNQUFLO1lBQVdDLFNBQVE7V0FBeUI7SUFFM0Q7SUFDQSxPQUFPTDtBQUNUO0FBRUEsU0FBU00saUJBQ1BDLElBQW9DLEVBQ3BDQyxLQUEyQztJQUUzQyw4RkFBOEY7SUFDOUYsSUFBSSxPQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxVQUFVO1FBQzFELE9BQU9EO0lBQ1Q7SUFDQSxrQ0FBa0M7SUFDbEMsSUFBSUMsTUFBTUMsSUFBSSxLQUFLQyxPQUFBQSxPQUFLLENBQUNDLFFBQVEsRUFBRTtRQUNqQyxPQUFPSixLQUFLSyxNQUFNLENBQ2hCLE9BQ0FGLE9BQUssQ0FBQ0csUUFBUSxDQUFDQyxPQUFPLENBQUNOLE1BQU1PLEtBQUssQ0FBQ0MsUUFBUSxFQUFFQyxNQUFNLENBQ2pELENBRUVDLGNBQ0FDO1lBRUEsSUFDRSxPQUFPQSxrQkFBa0IsWUFDekIsT0FBT0Esa0JBQWtCLFVBQ3pCO2dCQUNBLE9BQU9EO1lBQ1Q7WUFDQSxPQUFPQSxhQUFhTixNQUFNLENBQUNPO1FBQzdCLEdBQ0EsRUFBRTtJQUdS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QUFBQSxFQUNHLG1EQUFnREQsYUFBVztZQUVoRSxPQUFPLElBQUlYLEVBQUV0QyxJQUFJLEtBQUssVUFBVXNDLEVBQUVoQyxLQUFLLENBQUMsTUFBTSxLQUFLLGNBQWM7Z0JBQy9ENEMsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBQUEsRUFDRyx3RkFBcUZaLEVBQUVoQyxLQUFLLENBQUMsT0FBTyxHQUFDO1lBRTFHO1FBQ0Y7UUFDQSxxQkFBT0wsT0FBQUEsT0FBSyxDQUFDK0MsWUFBWSxDQUFDVixHQUFHO1lBQUVqQjtRQUFJO0lBQ3JDO0FBQ0o7QUFFQTs7O0NBR0MsR0FDRCxjQUFjLEtBQTJDO0lBQTNDLE1BQUVkLFFBQVEsRUFBaUMsR0FBM0M7SUFDWixNQUFNNkMsV0FBV0MsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0MseUJBQUFBLGVBQWU7SUFDM0MsTUFBTUMsY0FBY0YsQ0FBQUEsR0FBQUEsT0FBQUEsVUFBQUEsRUFBV0csaUNBQUFBLGtCQUFrQjtJQUNqRCxxQkFDRSxxQkFBQ0MsWUFBQUEsT0FBTTtRQUNMQyx5QkFBeUJ6QjtRQUN6QnNCLGFBQWFBO1FBQ2JqRSxXQUFXcUUsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBWVA7a0JBRXRCN0M7O0FBR1A7S0FaUzRDO01BY1QsV0FBZUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9oZWFkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgRWZmZWN0IGZyb20gJy4vc2lkZS1lZmZlY3QnXG5pbXBvcnQgeyBBbXBTdGF0ZUNvbnRleHQgfSBmcm9tICcuL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGlzSW5BbXBNb2RlIH0gZnJvbSAnLi9hbXAtbW9kZSdcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi91dGlscy93YXJuLW9uY2UnXG5cbnR5cGUgV2l0aEluQW1wTW9kZSA9IHtcbiAgaW5BbXBNb2RlPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlID0gZmFsc2UpOiBKU1guRWxlbWVudFtdIHtcbiAgY29uc3QgaGVhZCA9IFs8bWV0YSBjaGFyU2V0PVwidXRmLThcIiBrZXk9XCJjaGFyc2V0XCIgLz5dXG4gIGlmICghaW5BbXBNb2RlKSB7XG4gICAgaGVhZC5wdXNoKFxuICAgICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aFwiIGtleT1cInZpZXdwb3J0XCIgLz5cbiAgICApXG4gIH1cbiAgcmV0dXJuIGhlYWRcbn1cblxuZnVuY3Rpb24gb25seVJlYWN0RWxlbWVudChcbiAgbGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBjaGlsZDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVtYmVyIHwgc3RyaW5nXG4pOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4ge1xuICAvLyBSZWFjdCBjaGlsZHJlbiBjYW4gYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiIGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlbSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gIGlmIChjaGlsZC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQHR5cGVzL3JlYWN0IGRvZXMgbm90IHJlbW92ZSBmcmFnbWVudHMgYnV0IHRoaXMgY291bGQgYWxzbyByZXR1cm4gUmVhY3RQb3J0YWxbXVxuICAgICAgUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgICAgKFxuICAgICAgICAgIGZyYWdtZW50TGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgICAgICAgIGZyYWdtZW50Q2hpbGQ6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bWJlciB8IHN0cmluZ1xuICAgICAgICApOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4gPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpXG4gICAgICAgIH0sXG4gICAgICAgIFtdXG4gICAgICApXG4gICAgKVxuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChjaGlsZClcbn1cblxuY29uc3QgTUVUQVRZUEVTID0gWyduYW1lJywgJ2h0dHBFcXVpdicsICdjaGFyU2V0JywgJ2l0ZW1Qcm9wJ11cblxuLypcbiByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIGZpbHRlcmluZyBoZWFkIGNoaWxkIGVsZW1lbnRzXG4gd2hpY2ggc2hvdWxkbid0IGJlIGR1cGxpY2F0ZWQsIGxpa2UgPHRpdGxlLz5cbiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgZGVkdXBsaWNhdGVkIGBrZXlgIHByb3BlcnRpZXNcbiovXG5mdW5jdGlvbiB1bmlxdWUoKSB7XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgY29uc3QgdGFncyA9IG5ldyBTZXQoKVxuICBjb25zdCBtZXRhVHlwZXMgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YUNhdGVnb3JpZXM6IHsgW21ldGF0eXBlOiBzdHJpbmddOiBTZXQ8c3RyaW5nPiB9ID0ge31cblxuICByZXR1cm4gKGg6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+KSA9PiB7XG4gICAgbGV0IGlzVW5pcXVlID0gdHJ1ZVxuICAgIGxldCBoYXNLZXkgPSBmYWxzZVxuXG4gICAgaWYgKGgua2V5ICYmIHR5cGVvZiBoLmtleSAhPT0gJ251bWJlcicgJiYgaC5rZXkuaW5kZXhPZignJCcpID4gMCkge1xuICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSlcbiAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdzLmFkZChoLnR5cGUpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gTUVUQVRZUEVTLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YXR5cGUgPSBNRVRBVFlQRVNbaV1cbiAgICAgICAgICBpZiAoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKSBjb250aW51ZVxuXG4gICAgICAgICAgaWYgKG1ldGF0eXBlID09PSAnY2hhclNldCcpIHtcbiAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeSA9IGgucHJvcHNbbWV0YXR5cGVdXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKVxuICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gJ25hbWUnIHx8ICFoYXNLZXkpICYmIGNhdGVnb3JpZXMuaGFzKGNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBpc1VuaXF1ZVxuICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkQ2hpbGRyZW5FbGVtZW50cyBMaXN0IG9mIGNoaWxkcmVuIG9mIDxIZWFkPlxuICovXG5mdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzPFQgZXh0ZW5kcyB7fSAmIFdpdGhJbkFtcE1vZGU+KFxuICBoZWFkQ2hpbGRyZW5FbGVtZW50czogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICBwcm9wczogVFxuKSB7XG4gIGNvbnN0IHsgaW5BbXBNb2RlIH0gPSBwcm9wc1xuICByZXR1cm4gaGVhZENoaWxkcmVuRWxlbWVudHNcbiAgICAucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKVxuICAgIC5yZXZlcnNlKClcbiAgICAuY29uY2F0KGRlZmF1bHRIZWFkKGluQW1wTW9kZSkucmV2ZXJzZSgpKVxuICAgIC5maWx0ZXIodW5pcXVlKCkpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKGM6IFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+LCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGlcbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmXG4gICAgICAgICFpbkFtcE1vZGVcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYy50eXBlID09PSAnbGluaycgJiZcbiAgICAgICAgICBjLnByb3BzWydocmVmJ10gJiZcbiAgICAgICAgICAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICBbJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzJywgJ2h0dHBzOi8vdXNlLnR5cGVraXQubmV0LyddLnNvbWUoXG4gICAgICAgICAgICAodXJsKSA9PiBjLnByb3BzWydocmVmJ10uc3RhcnRzV2l0aCh1cmwpXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHsgLi4uKGMucHJvcHMgfHwge30pIH1cbiAgICAgICAgICBuZXdQcm9wc1snZGF0YS1ocmVmJ10gPSBuZXdQcm9wc1snaHJlZiddXG4gICAgICAgICAgbmV3UHJvcHNbJ2hyZWYnXSA9IHVuZGVmaW5lZFxuXG4gICAgICAgICAgLy8gQWRkIHRoaXMgYXR0cmlidXRlIHRvIG1ha2UgaXQgZWFzeSB0byBpZGVudGlmeSBvcHRpbWl6ZWQgdGFnc1xuICAgICAgICAgIG5ld1Byb3BzWydkYXRhLW9wdGltaXplZC1mb250cyddID0gdHJ1ZVxuXG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCBuZXdQcm9wcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIC8vIG9taXQgSlNPTi1MRCBzdHJ1Y3R1cmVkIGRhdGEgc25pcHBldHMgZnJvbSB0aGUgd2FybmluZ1xuICAgICAgICBpZiAoYy50eXBlID09PSAnc2NyaXB0JyAmJiBjLnByb3BzWyd0eXBlJ10gIT09ICdhcHBsaWNhdGlvbi9sZCtqc29uJykge1xuICAgICAgICAgIGNvbnN0IHNyY01lc3NhZ2UgPSBjLnByb3BzWydzcmMnXVxuICAgICAgICAgICAgPyBgPHNjcmlwdD4gdGFnIHdpdGggc3JjPVwiJHtjLnByb3BzWydzcmMnXX1cImBcbiAgICAgICAgICAgIDogYGlubGluZSA8c2NyaXB0PmBcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIGBEbyBub3QgYWRkIDxzY3JpcHQ+IHRhZ3MgdXNpbmcgbmV4dC9oZWFkIChzZWUgJHtzcmNNZXNzYWdlfSkuIFVzZSBuZXh0L3NjcmlwdCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXNjcmlwdC10YWdzLWluLWhlYWQtY29tcG9uZW50YFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT09ICdsaW5rJyAmJiBjLnByb3BzWydyZWwnXSA9PT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBgRG8gbm90IGFkZCBzdHlsZXNoZWV0cyB1c2luZyBuZXh0L2hlYWQgKHNlZSA8bGluayByZWw9XCJzdHlsZXNoZWV0XCI+IHRhZyB3aXRoIGhyZWY9XCIke2MucHJvcHNbJ2hyZWYnXX1cIikuIFVzZSBEb2N1bWVudCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXN0eWxlc2hlZXRzLWluLWhlYWQtY29tcG9uZW50YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCB7IGtleSB9KVxuICAgIH0pXG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIEhlYWQoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBjb25zdCBhbXBTdGF0ZSA9IHVzZUNvbnRleHQoQW1wU3RhdGVDb250ZXh0KVxuICBjb25zdCBoZWFkTWFuYWdlciA9IHVzZUNvbnRleHQoSGVhZE1hbmFnZXJDb250ZXh0KVxuICByZXR1cm4gKFxuICAgIDxFZmZlY3RcbiAgICAgIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlPXtyZWR1Y2VDb21wb25lbnRzfVxuICAgICAgaGVhZE1hbmFnZXI9e2hlYWRNYW5hZ2VyfVxuICAgICAgaW5BbXBNb2RlPXtpc0luQW1wTW9kZShhbXBTdGF0ZSl9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvRWZmZWN0PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRcbiJdLCJuYW1lcyI6WyJkZWZhdWx0SGVhZCIsImluQW1wTW9kZSIsImhlYWQiLCJtZXRhIiwiY2hhclNldCIsInB1c2giLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJ0eXBlIiwiUmVhY3QiLCJGcmFnbWVudCIsImNvbmNhdCIsIkNoaWxkcmVuIiwidG9BcnJheSIsInByb3BzIiwiY2hpbGRyZW4iLCJyZWR1Y2UiLCJmcmFnbWVudExpc3QiLCJmcmFnbWVudENoaWxkIiwiTUVUQVRZUEVTIiwidW5pcXVlIiwia2V5cyIsIlNldCIsInRhZ3MiLCJtZXRhVHlwZXMiLCJtZXRhQ2F0ZWdvcmllcyIsImgiLCJpc1VuaXF1ZSIsImhhc0tleSIsImtleSIsImluZGV4T2YiLCJzbGljZSIsImhhcyIsImFkZCIsImkiLCJsZW4iLCJsZW5ndGgiLCJtZXRhdHlwZSIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcnkiLCJjYXRlZ29yaWVzIiwicmVkdWNlQ29tcG9uZW50cyIsImhlYWRDaGlsZHJlbkVsZW1lbnRzIiwicmV2ZXJzZSIsImZpbHRlciIsIm1hcCIsImMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJfX05FWFRfT1BUSU1JWkVfRk9OVFMiLCJzb21lIiwidXJsIiwic3RhcnRzV2l0aCIsIm5ld1Byb3BzIiwidW5kZWZpbmVkIiwiY2xvbmVFbGVtZW50Iiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiSGVhZCIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsIkFtcFN0YXRlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiRWZmZWN0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJpc0luQW1wTW9kZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \****************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : '';\n    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCLEtBYy9CO0lBZCtCLE1BQzlCQyxRQUFRLEVBQ1JDLFNBQVMsRUFDVEMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsU0FBUyxFQVFWLEdBZCtCO0lBZTlCLE1BQU1DLE1BQU07SUFDWixNQUFNQyxXQUFXTCxZQUFZQSxZQUFZLEtBQUtGO0lBQzlDLE1BQU1RLFlBQVlMLGFBQWFBLGFBQWEsS0FBS0Y7SUFFakQsTUFBTVEsVUFDSkYsWUFBWUMsWUFBYSxrQkFBZUQsV0FBUyxNQUFHQyxZQUFVLE1BQUs7SUFDckUsTUFBTUUsc0JBQXNCRCxVQUN4QixTQUNBSixjQUFjLFlBQ1osYUFDQUEsY0FBYyxVQUNaLG1CQUNBO0lBRVIsT0FBUSwrQ0FBNENJLFVBQVEsOEZBQTJGSCxNQUFJLG9RQUFpUUEsTUFBSSxnR0FBNkZJLHNCQUFvQix3Q0FBcUNOLGNBQVk7QUFDcGtCIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIHNoYXJlZCBmdW5jdGlvbiwgdXNlZCBvbiBib3RoIGNsaWVudCBhbmQgc2VydmVyLCB0byBnZW5lcmF0ZSBhIFNWRyBibHVyIHBsYWNlaG9sZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1hZ2VCbHVyU3ZnKHtcbiAgd2lkdGhJbnQsXG4gIGhlaWdodEludCxcbiAgYmx1cldpZHRoLFxuICBibHVySGVpZ2h0LFxuICBibHVyRGF0YVVSTCxcbiAgb2JqZWN0Rml0LFxufToge1xuICB3aWR0aEludD86IG51bWJlclxuICBoZWlnaHRJbnQ/OiBudW1iZXJcbiAgYmx1cldpZHRoPzogbnVtYmVyXG4gIGJsdXJIZWlnaHQ/OiBudW1iZXJcbiAgYmx1ckRhdGFVUkw6IHN0cmluZ1xuICBvYmplY3RGaXQ/OiBzdHJpbmdcbn0pOiBzdHJpbmcge1xuICBjb25zdCBzdGQgPSAyMFxuICBjb25zdCBzdmdXaWR0aCA9IGJsdXJXaWR0aCA/IGJsdXJXaWR0aCAqIDQwIDogd2lkdGhJbnRcbiAgY29uc3Qgc3ZnSGVpZ2h0ID0gYmx1ckhlaWdodCA/IGJsdXJIZWlnaHQgKiA0MCA6IGhlaWdodEludFxuXG4gIGNvbnN0IHZpZXdCb3ggPVxuICAgIHN2Z1dpZHRoICYmIHN2Z0hlaWdodCA/IGB2aWV3Qm94PScwIDAgJHtzdmdXaWR0aH0gJHtzdmdIZWlnaHR9J2AgOiAnJ1xuICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gdmlld0JveFxuICAgID8gJ25vbmUnXG4gICAgOiBvYmplY3RGaXQgPT09ICdjb250YWluJ1xuICAgICAgPyAneE1pZFlNaWQnXG4gICAgICA6IG9iamVjdEZpdCA9PT0gJ2NvdmVyJ1xuICAgICAgICA/ICd4TWlkWU1pZCBzbGljZSdcbiAgICAgICAgOiAnbm9uZSdcblxuICByZXR1cm4gYCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnICR7dmlld0JveH0lM0UlM0NmaWx0ZXIgaWQ9J2InIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQiclM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JyR7c3RkfScvJTNFJTNDZmVDb2xvck1hdHJpeCB2YWx1ZXM9JzEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEwMCAtMScgcmVzdWx0PSdzJy8lM0UlM0NmZUZsb29kIHg9JzAnIHk9JzAnIHdpZHRoPScxMDAlMjUnIGhlaWdodD0nMTAwJTI1Jy8lM0UlM0NmZUNvbXBvc2l0ZSBvcGVyYXRvcj0nb3V0JyBpbj0ncycvJTNFJTNDZmVDb21wb3NpdGUgaW4yPSdTb3VyY2VHcmFwaGljJy8lM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JyR7c3RkfScvJTNFJTNDL2ZpbHRlciUzRSUzQ2ltYWdlIHdpZHRoPScxMDAlMjUnIGhlaWdodD0nMTAwJTI1JyB4PScwJyB5PScwJyBwcmVzZXJ2ZUFzcGVjdFJhdGlvPScke3ByZXNlcnZlQXNwZWN0UmF0aW99JyBzdHlsZT0nZmlsdGVyOiB1cmwoJTIzYik7JyBocmVmPScke2JsdXJEYXRhVVJMfScvJTNFJTNDL3N2ZyUzRWBcbn1cbiJdLCJuYW1lcyI6WyJnZXRJbWFnZUJsdXJTdmciLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJibHVyRGF0YVVSTCIsIm9iamVjdEZpdCIsInN0ZCIsInN2Z1dpZHRoIiwic3ZnSGVpZ2h0Iiwidmlld0JveCIsInByZXNlcnZlQXNwZWN0UmF0aW8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \*************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = 'ImageConfigContext';\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzRFQUpLO3lDQUVpQjtBQUU1QixNQUFNQSxxQkFDWEMsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNKLG1CQUFtQk8sV0FBVyxHQUFHO0FBQ25DIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBJbWFnZUNvbmZpZ0NvbXBsZXRlIH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBpbWFnZUNvbmZpZ0RlZmF1bHQgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcblxuZXhwb3J0IGNvbnN0IEltYWdlQ29uZmlnQ29udGV4dCA9XG4gIFJlYWN0LmNyZWF0ZUNvbnRleHQ8SW1hZ2VDb25maWdDb21wbGV0ZT4oaW1hZ2VDb25maWdEZWZhdWx0KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBJbWFnZUNvbmZpZ0NvbnRleHQuZGlzcGxheU5hbWUgPSAnSW1hZ2VDb25maWdDb250ZXh0J1xufVxuIl0sIm5hbWVzIjpbIkltYWdlQ29uZmlnQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsImltYWdlQ29uZmlnRGVmYXVsdCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config.js ***!
  \**************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    'default',\n    'imgix',\n    'cloudinary',\n    'akamai',\n    'custom'\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: '/_next/image',\n    loader: 'default',\n    loaderFile: '',\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        'image/webp'\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: 'attachment',\n    localPatterns: undefined,\n    remotePatterns: [],\n    qualities: undefined,\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQWFBLGFBQWE7ZUFBYkE7O0lBaUlBQyxrQkFBa0I7ZUFBbEJBOzs7QUFqSU4sTUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQTJITSxNQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGVBQWVDO0lBQ2ZDLGdCQUFnQixFQUFFO0lBQ2xCQyxXQUFXRjtJQUNYRyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFZBTElEX0xPQURFUlMgPSBbXG4gICdkZWZhdWx0JyxcbiAgJ2ltZ2l4JyxcbiAgJ2Nsb3VkaW5hcnknLFxuICAnYWthbWFpJyxcbiAgJ2N1c3RvbScsXG5dIGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIExvYWRlclZhbHVlID0gKHR5cGVvZiBWQUxJRF9MT0FERVJTKVtudW1iZXJdXG5cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyUHJvcHMgPSB7XG4gIHNyYzogc3RyaW5nXG4gIHdpZHRoOiBudW1iZXJcbiAgcXVhbGl0eT86IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZyA9IEltYWdlTG9hZGVyUHJvcHMgJiB7XG4gIGNvbmZpZzogUmVhZG9ubHk8SW1hZ2VDb25maWc+XG59XG5cbmV4cG9ydCB0eXBlIExvY2FsUGF0dGVybiA9IHtcbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIG9yIHdpbGRjYXJkLlxuICAgKiBTaW5nbGUgYCpgIG1hdGNoZXMgYSBzaW5nbGUgcGF0aCBzZWdtZW50LlxuICAgKiBEb3VibGUgYCoqYCBtYXRjaGVzIGFueSBudW1iZXIgb2YgcGF0aCBzZWdtZW50cy5cbiAgICovXG4gIHBhdGhuYW1lPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIHF1ZXJ5IHN0cmluZyBzdWNoIGFzIGA/dj0xYCBvclxuICAgKiBlbXB0eSBzdHJpbmcgbWVhbmluZyBubyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBzZWFyY2g/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgUmVtb3RlUGF0dGVybiA9IHtcbiAgLyoqXG4gICAqIE11c3QgYmUgYGh0dHBgIG9yIGBodHRwc2AuXG4gICAqL1xuICBwcm90b2NvbD86ICdodHRwJyB8ICdodHRwcydcblxuICAvKipcbiAgICogQ2FuIGJlIGxpdGVyYWwgb3Igd2lsZGNhcmQuXG4gICAqIFNpbmdsZSBgKmAgbWF0Y2hlcyBhIHNpbmdsZSBzdWJkb21haW4uXG4gICAqIERvdWJsZSBgKipgIG1hdGNoZXMgYW55IG51bWJlciBvZiBzdWJkb21haW5zLlxuICAgKi9cbiAgaG9zdG5hbWU6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBDYW4gYmUgbGl0ZXJhbCBwb3J0IHN1Y2ggYXMgYDgwODBgIG9yIGVtcHR5IHN0cmluZ1xuICAgKiBtZWFuaW5nIG5vIHBvcnQuXG4gICAqL1xuICBwb3J0Pzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIG9yIHdpbGRjYXJkLlxuICAgKiBTaW5nbGUgYCpgIG1hdGNoZXMgYSBzaW5nbGUgcGF0aCBzZWdtZW50LlxuICAgKiBEb3VibGUgYCoqYCBtYXRjaGVzIGFueSBudW1iZXIgb2YgcGF0aCBzZWdtZW50cy5cbiAgICovXG4gIHBhdGhuYW1lPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIENhbiBiZSBsaXRlcmFsIHF1ZXJ5IHN0cmluZyBzdWNoIGFzIGA/dj0xYCBvclxuICAgKiBlbXB0eSBzdHJpbmcgbWVhbmluZyBubyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBzZWFyY2g/OiBzdHJpbmdcbn1cblxudHlwZSBJbWFnZUZvcm1hdCA9ICdpbWFnZS9hdmlmJyB8ICdpbWFnZS93ZWJwJ1xuXG4vKipcbiAqIEltYWdlIGNvbmZpZ3VyYXRpb25zXG4gKlxuICogQHNlZSBbSW1hZ2UgY29uZmlndXJhdGlvbiBvcHRpb25zXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjY29uZmlndXJhdGlvbi1vcHRpb25zKVxuICovXG5leHBvcnQgdHlwZSBJbWFnZUNvbmZpZ0NvbXBsZXRlID0ge1xuICAvKiogQHNlZSBbRGV2aWNlIHNpemVzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNkZXZpY2Utc2l6ZXMpICovXG4gIGRldmljZVNpemVzOiBudW1iZXJbXVxuXG4gIC8qKiBAc2VlIFtJbWFnZSBzaXppbmcgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vb3B0aW1pemluZy9pbWFnZXMjaW1hZ2Utc2l6aW5nKSAqL1xuICBpbWFnZVNpemVzOiBudW1iZXJbXVxuXG4gIC8qKiBAc2VlIFtJbWFnZSBsb2FkZXJzIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9sZWdhY3kvaW1hZ2UjbG9hZGVyKSAqL1xuICBsb2FkZXI6IExvYWRlclZhbHVlXG5cbiAgLyoqIEBzZWUgW0ltYWdlIGxvYWRlciBjb25maWd1cmF0aW9uXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvbGVnYWN5L2ltYWdlI2xvYWRlci1jb25maWd1cmF0aW9uKSAqL1xuICBwYXRoOiBzdHJpbmdcblxuICAvKiogQHNlZSBbSW1hZ2UgbG9hZGVyIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNsb2FkZXItY29uZmlndXJhdGlvbikgKi9cbiAgbG9hZGVyRmlsZTogc3RyaW5nXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgcmVtb3RlUGF0dGVybnNgIGluc3RlYWQuXG4gICAqL1xuICBkb21haW5zOiBzdHJpbmdbXVxuXG4gIC8qKiBAc2VlIFtEaXNhYmxlIHN0YXRpYyBpbWFnZSBpbXBvcnQgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2Rpc2FibGUtc3RhdGljLWltcG9ydHMpICovXG4gIGRpc2FibGVTdGF0aWNJbWFnZXM6IGJvb2xlYW5cblxuICAvKiogQHNlZSBbQ2FjaGUgYmVoYXZpb3JdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNjYWNoaW5nLWJlaGF2aW9yKSAqL1xuICBtaW5pbXVtQ2FjaGVUVEw6IG51bWJlclxuXG4gIC8qKiBAc2VlIFtBY2NlcHRhYmxlIGZvcm1hdHNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNhY2NlcHRhYmxlLWZvcm1hdHMpICovXG4gIGZvcm1hdHM6IEltYWdlRm9ybWF0W11cblxuICAvKiogQHNlZSBbRGFuZ2Vyb3VzbHkgQWxsb3cgU1ZHXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGFuZ2Vyb3VzbHktYWxsb3ctc3ZnKSAqL1xuICBkYW5nZXJvdXNseUFsbG93U1ZHOiBib29sZWFuXG5cbiAgLyoqIEBzZWUgW0Rhbmdlcm91c2x5IEFsbG93IFNWR10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI2Rhbmdlcm91c2x5LWFsbG93LXN2ZykgKi9cbiAgY29udGVudFNlY3VyaXR5UG9saWN5OiBzdHJpbmdcblxuICAvKiogQHNlZSBbRGFuZ2Vyb3VzbHkgQWxsb3cgU1ZHXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjZGFuZ2Vyb3VzbHktYWxsb3ctc3ZnKSAqL1xuICBjb250ZW50RGlzcG9zaXRpb25UeXBlOiAnaW5saW5lJyB8ICdhdHRhY2htZW50J1xuXG4gIC8qKiBAc2VlIFtSZW1vdGUgUGF0dGVybnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNyZW1vdGVwYXR0ZXJucykgKi9cbiAgcmVtb3RlUGF0dGVybnM6IFJlbW90ZVBhdHRlcm5bXVxuXG4gIC8qKiBAc2VlIFtSZW1vdGUgUGF0dGVybnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNsb2NhbFBhdHRlcm5zKSAqL1xuICBsb2NhbFBhdHRlcm5zOiBMb2NhbFBhdHRlcm5bXSB8IHVuZGVmaW5lZFxuXG4gIC8qKiBAc2VlIFtRdWFsaXRpZXNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNxdWFsaXRpZXMpICovXG4gIHF1YWxpdGllczogbnVtYmVyW10gfCB1bmRlZmluZWRcblxuICAvKiogQHNlZSBbVW5vcHRpbWl6ZWRdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSN1bm9wdGltaXplZCkgKi9cbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgSW1hZ2VDb25maWcgPSBQYXJ0aWFsPEltYWdlQ29uZmlnQ29tcGxldGU+XG5cbmV4cG9ydCBjb25zdCBpbWFnZUNvbmZpZ0RlZmF1bHQ6IEltYWdlQ29uZmlnQ29tcGxldGUgPSB7XG4gIGRldmljZVNpemVzOiBbNjQwLCA3NTAsIDgyOCwgMTA4MCwgMTIwMCwgMTkyMCwgMjA0OCwgMzg0MF0sXG4gIGltYWdlU2l6ZXM6IFsxNiwgMzIsIDQ4LCA2NCwgOTYsIDEyOCwgMjU2LCAzODRdLFxuICBwYXRoOiAnL19uZXh0L2ltYWdlJyxcbiAgbG9hZGVyOiAnZGVmYXVsdCcsXG4gIGxvYWRlckZpbGU6ICcnLFxuICBkb21haW5zOiBbXSxcbiAgZGlzYWJsZVN0YXRpY0ltYWdlczogZmFsc2UsXG4gIG1pbmltdW1DYWNoZVRUTDogNjAsXG4gIGZvcm1hdHM6IFsnaW1hZ2Uvd2VicCddLFxuICBkYW5nZXJvdXNseUFsbG93U1ZHOiBmYWxzZSxcbiAgY29udGVudFNlY3VyaXR5UG9saWN5OiBgc2NyaXB0LXNyYyAnbm9uZSc7IGZyYW1lLXNyYyAnbm9uZSc7IHNhbmRib3g7YCxcbiAgY29udGVudERpc3Bvc2l0aW9uVHlwZTogJ2F0dGFjaG1lbnQnLFxuICBsb2NhbFBhdHRlcm5zOiB1bmRlZmluZWQsIC8vIGRlZmF1bHQ6IGFsbG93IGFsbCBsb2NhbCBpbWFnZXNcbiAgcmVtb3RlUGF0dGVybnM6IFtdLCAvLyBkZWZhdWx0OiBhbGxvdyBubyByZW1vdGUgaW1hZ2VzXG4gIHF1YWxpdGllczogdW5kZWZpbmVkLCAvLyBkZWZhdWx0OiBhbGxvdyBhbGwgcXVhbGl0aWVzXG4gIHVub3B0aW1pemVkOiBmYWxzZSxcbn1cbiJdLCJuYW1lcyI6WyJWQUxJRF9MT0FERVJTIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwicGF0aCIsImxvYWRlciIsImxvYWRlckZpbGUiLCJkb21haW5zIiwiZGlzYWJsZVN0YXRpY0ltYWdlcyIsIm1pbmltdW1DYWNoZVRUTCIsImZvcm1hdHMiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiY29udGVudFNlY3VyaXR5UG9saWN5IiwiY29udGVudERpc3Bvc2l0aW9uVHlwZSIsImxvY2FsUGF0dGVybnMiLCJ1bmRlZmluZWQiLCJyZW1vdGVQYXR0ZXJucyIsInF1YWxpdGllcyIsInVub3B0aW1pemVkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-external.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-external.js ***!
  \****************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    getImageProps: function() {\n        return getImageProps;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":true,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n}\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpQ0EsT0FBb0I7ZUFBcEI7O0lBakJnQkEsYUFBYTtlQUFiQTs7Ozt5Q0FiWTs0Q0FDTjtrRkFHSTtBQVNuQixTQUFTQSxjQUFjQyxRQUFvQjtJQUNoRCxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxhQUFBQSxXQUFBQSxFQUFZRixVQUFVO1FBQ3RDRyxlQUFBQSxhQUFBQSxPQUFhO1FBQ2IsNENBQTRDO1FBQzVDQyxTQUFTQyw0T0FBNkI7SUFDeEM7SUFDQSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNWLE9BQVE7UUFDaEQsSUFBSVEsVUFBVUcsV0FBVztZQUN2QixPQUFPWCxLQUFLLENBQUNPLElBQTBCO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPO1FBQUVQO0lBQU07QUFDakI7TUFFQSxXQUFlWSxnQkFBQUEsS0FBSyIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEltYWdlQ29uZmlnQ29tcGxldGUsIEltYWdlTG9hZGVyUHJvcHMgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcbmltcG9ydCB0eXBlIHsgSW1hZ2VQcm9wcywgSW1hZ2VMb2FkZXIsIFN0YXRpY0ltYWdlRGF0YSB9IGZyb20gJy4vZ2V0LWltZy1wcm9wcydcblxuaW1wb3J0IHsgZ2V0SW1nUHJvcHMgfSBmcm9tICcuL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgeyBJbWFnZSB9IGZyb20gJy4uLy4uL2NsaWVudC9pbWFnZS1jb21wb25lbnQnXG5cbi8vIEB0cy1pZ25vcmUgLSBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgYWxpYXNcbmltcG9ydCBkZWZhdWx0TG9hZGVyIGZyb20gJ25leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWxvYWRlcidcblxuLyoqXG4gKiBGb3IgbW9yZSBhZHZhbmNlZCB1c2UgY2FzZXMsIHlvdSBjYW4gY2FsbCBgZ2V0SW1hZ2VQcm9wcygpYFxuICogdG8gZ2V0IHRoZSBwcm9wcyB0aGF0IHdvdWxkIGJlIHBhc3NlZCB0byB0aGUgdW5kZXJseWluZyBgPGltZz5gIGVsZW1lbnQsXG4gKiBhbmQgaW5zdGVhZCBwYXNzIHRvIHRoZW0gdG8gYW5vdGhlciBjb21wb25lbnQsIHN0eWxlLCBjYW52YXMsIGV0Yy5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIGRvY3M6IGBnZXRJbWFnZVByb3BzYF0oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9pbWFnZSNnZXRpbWFnZXByb3BzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1hZ2VQcm9wcyhpbWdQcm9wczogSW1hZ2VQcm9wcykge1xuICBjb25zdCB7IHByb3BzIH0gPSBnZXRJbWdQcm9wcyhpbWdQcm9wcywge1xuICAgIGRlZmF1bHRMb2FkZXIsXG4gICAgLy8gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGRlZmluZSBwbHVnaW5cbiAgICBpbWdDb25mOiBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUyBhcyBhbnkgYXMgSW1hZ2VDb25maWdDb21wbGV0ZSxcbiAgfSlcbiAgLy8gTm9ybWFsbHkgd2UgZG9uJ3QgY2FyZSBhYm91dCB1bmRlZmluZWQgcHJvcHMgYmVjYXVzZSB3ZSBwYXNzIHRvIEpTWCxcbiAgLy8gYnV0IHRoaXMgZXhwb3J0ZWQgZnVuY3Rpb24gY291bGQgYmUgdXNlZCBieSB0aGUgZW5kIHVzZXIgZm9yIGFueXRoaW5nXG4gIC8vIHNvIHdlIGRlbGV0ZSB1bmRlZmluZWQgcHJvcHMgdG8gY2xlYW4gaXQgdXAgYSBsaXR0bGUuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgcHJvcHNba2V5IGFzIGtleW9mIHR5cGVvZiBwcm9wc11cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgcHJvcHMgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVxuXG5leHBvcnQgdHlwZSB7IEltYWdlUHJvcHMsIEltYWdlTG9hZGVyUHJvcHMsIEltYWdlTG9hZGVyLCBTdGF0aWNJbWFnZURhdGEgfVxuIl0sIm5hbWVzIjpbImdldEltYWdlUHJvcHMiLCJpbWdQcm9wcyIsInByb3BzIiwiZ2V0SW1nUHJvcHMiLCJkZWZhdWx0TG9hZGVyIiwiaW1nQ29uZiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSU1BR0VfT1BUUyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInVuZGVmaW5lZCIsIkltYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-loader.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-loader.js ***!
  \**************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst DEFAULT_Q = 75;\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    var _config_qualities;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push('src');\n        if (!width) missingValues.push('width');\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(', ') + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith('//')) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (src.startsWith('/') && config.localPatterns) {\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasLocalMatch } = __webpack_require__(/*! ./match-local-pattern */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/match-local-pattern.js\");\n                if (!hasLocalMatch(config.localPatterns, src)) {\n                    throw new Error(\"Invalid src prop (\" + src + \") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns\");\n                }\n            }\n        }\n        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasRemoteMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n        if (quality && config.qualities && !config.qualities.includes(quality)) {\n            throw new Error(\"Invalid quality prop (\" + quality + \") on `next/image` does not match `images.qualities` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-qualities\");\n        }\n    }\n    const q = quality || ((_config_qualities = config.qualities) == null ? void 0 : _config_qualities.reduce((prev, cur)=>Math.abs(cur - DEFAULT_Q) < Math.abs(prev - DEFAULT_Q) ? cur : prev)) || DEFAULT_Q;\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + q + (src.startsWith('/_next/static/media/') && false ? 0 : '');\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F1R0E7OztlQUFBOzs7QUFyR0EsTUFBTUEsWUFBWTtBQUVsQixTQUFTQyxjQUFjLEtBS007SUFMTixNQUNyQkMsTUFBTSxFQUNOQyxHQUFHLEVBQ0hDLEtBQUssRUFDTEMsT0FBTyxFQUNvQixHQUxOO1FBbUZuQkg7SUE3RUYsSUFBSUksSUFBb0IsRUFBbUI7UUFDekMsTUFBTUcsZ0JBQWdCLEVBQUU7UUFFeEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ04sS0FBS00sY0FBY0MsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQ04sT0FBT0ssY0FBY0MsSUFBSSxDQUFDO1FBRS9CLElBQUlELGNBQWNFLE1BQU0sR0FBRyxHQUFHO1lBQzVCLE1BQU0sSUFBSUMsTUFDUCxzQ0FBbUNILGNBQWNJLElBQUksQ0FDcEQsUUFDQSxnR0FBK0ZDLEtBQUtDLFNBQVMsQ0FDN0c7Z0JBQUVaO2dCQUFLQztnQkFBT0M7WUFBUTtRQUc1QjtRQUVBLElBQUlGLElBQUlhLFVBQVUsQ0FBQyxPQUFPO1lBQ3hCLE1BQU0sSUFBSUosTUFDUCwwQkFBdUJULE1BQUk7UUFFaEM7UUFFQSxJQUFJQSxJQUFJYSxVQUFVLENBQUMsUUFBUWQsT0FBT2UsYUFBYSxFQUFFO1lBQy9DLElBQ0VYLElBRW1DLEVBQ25DO2dCQUNBLHVFQUF1RTtnQkFDdkUsTUFBTSxFQUFFYSxhQUFhLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsd0xBQXVCO2dCQUN6RCxJQUFJLENBQUNELGNBQWNqQixPQUFPZSxhQUFhLEVBQUVkLE1BQU07b0JBQzdDLE1BQU0sSUFBSVMsTUFDUCx1QkFBb0JULE1BQUksa0dBQ3RCO2dCQUVQO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ0EsSUFBSWEsVUFBVSxDQUFDLFFBQVNkLENBQUFBLE9BQU9tQixPQUFPLElBQUluQixPQUFPb0IsY0FBQUEsR0FBaUI7WUFDckUsSUFBSUM7WUFDSixJQUFJO2dCQUNGQSxZQUFZLElBQUlDLElBQUlyQjtZQUN0QixFQUFFLE9BQU9zQixLQUFLO2dCQUNaQyxRQUFRQyxLQUFLLENBQUNGO2dCQUNkLE1BQU0sSUFBSWIsTUFDUCwwQkFBdUJULE1BQUk7WUFFaEM7WUFFQSxJQUNFRyxJQUVtQyxFQUNuQztnQkFDQSx1RUFBdUU7Z0JBQ3ZFLE1BQU0sRUFBRXNCLGNBQWMsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQywwTEFBd0I7Z0JBQzNELElBQUksQ0FBQ1EsZUFBZTFCLE9BQU9tQixPQUFPLEVBQUVuQixPQUFPb0IsY0FBYyxFQUFFQyxZQUFZO29CQUNyRSxNQUFNLElBQUlYLE1BQ1AsdUJBQW9CVCxNQUFJLGtDQUFpQ29CLFVBQVVNLFFBQVEsR0FBQyxnRUFDMUU7Z0JBRVA7WUFDRjtRQUNGO1FBRUEsSUFBSXhCLFdBQVdILE9BQU80QixTQUFTLElBQUksQ0FBQzVCLE9BQU80QixTQUFTLENBQUNDLFFBQVEsQ0FBQzFCLFVBQVU7WUFDdEUsTUFBTSxJQUFJTyxNQUNQLDJCQUF3QlAsVUFBUSw4RkFDOUI7UUFFUDtJQUNGO0lBRUEsTUFBTTJCLElBQ0ozQixXQUFBQSxDQUFBQSxDQUNBSCxvQkFBQUEsT0FBTzRCLFNBQVMscUJBQWhCNUIsa0JBQWtCK0IsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE1BQzlCQyxLQUFLQyxHQUFHLENBQUNGLE1BQU1uQyxhQUFhb0MsS0FBS0MsR0FBRyxDQUFDSCxPQUFPbEMsYUFBYW1DLE1BQU1ELEtBQUFBLEtBRWpFbEM7SUFFRixPQUFVRSxPQUFPb0MsSUFBSSxHQUFDLFVBQU9DLG1CQUFtQnBDLE9BQUssUUFBS0MsUUFBTSxRQUFLNEIsSUFDbkU3QixDQUFBQSxJQUFJYSxVQUFVLENBQUMsMkJBQTJCVixLQUE4QixHQUNuRSxDQUFxQyxHQUN0QyxHQUFDO0FBRVQ7QUFFQSwrREFBK0Q7QUFDL0QsMkRBQTJEO0FBQzNETCxjQUFjd0Msa0JBQWtCLEdBQUc7TUFFbkMsV0FBZXhDIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcblxuY29uc3QgREVGQVVMVF9RID0gNzVcblxuZnVuY3Rpb24gZGVmYXVsdExvYWRlcih7XG4gIGNvbmZpZyxcbiAgc3JjLFxuICB3aWR0aCxcbiAgcXVhbGl0eSxcbn06IEltYWdlTG9hZGVyUHJvcHNXaXRoQ29uZmlnKTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW11cblxuICAgIC8vIHRoZXNlIHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgIGlmICghc3JjKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3NyYycpXG4gICAgaWYgKCF3aWR0aCkgbWlzc2luZ1ZhbHVlcy5wdXNoKCd3aWR0aCcpXG5cbiAgICBpZiAobWlzc2luZ1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOZXh0IEltYWdlIE9wdGltaXphdGlvbiByZXF1aXJlcyAke21pc3NpbmdWYWx1ZXMuam9pbihcbiAgICAgICAgICAnLCAnXG4gICAgICAgICl9IHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHsgc3JjLCB3aWR0aCwgcXVhbGl0eSB9XG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnLy8nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIHByb3RvY29sLXJlbGF0aXZlIFVSTCAoLy8pIG11c3QgYmUgY2hhbmdlZCB0byBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnLycpICYmIGNvbmZpZy5sb2NhbFBhdHRlcm5zKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgLy8gbWljcm9tYXRjaCBpc24ndCBjb21wYXRpYmxlIHdpdGggZWRnZSBydW50aW1lXG4gICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gJ2VkZ2UnXG4gICAgICApIHtcbiAgICAgICAgLy8gV2UgdXNlIGR5bmFtaWMgcmVxdWlyZSBiZWNhdXNlIHRoaXMgc2hvdWxkIG9ubHkgZXJyb3IgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgY29uc3QgeyBoYXNMb2NhbE1hdGNoIH0gPSByZXF1aXJlKCcuL21hdGNoLWxvY2FsLXBhdHRlcm4nKVxuICAgICAgICBpZiAoIWhhc0xvY2FsTWF0Y2goY29uZmlnLmxvY2FsUGF0dGVybnMsIHNyYykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBzcmMgcHJvcCAoJHtzcmN9KSBvbiBcXGBuZXh0L2ltYWdlXFxgIGRvZXMgbm90IG1hdGNoIFxcYGltYWdlcy5sb2NhbFBhdHRlcm5zXFxgIGNvbmZpZ3VyZWQgaW4geW91ciBcXGBuZXh0LmNvbmZpZy5qc1xcYFxcbmAgK1xuICAgICAgICAgICAgICBgU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11bmNvbmZpZ3VyZWQtbG9jYWxwYXR0ZXJuc2BcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNyYy5zdGFydHNXaXRoKCcvJykgJiYgKGNvbmZpZy5kb21haW5zIHx8IGNvbmZpZy5yZW1vdGVQYXR0ZXJucykpIHtcbiAgICAgIGxldCBwYXJzZWRTcmM6IFVSTFxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkU3JjID0gbmV3IFVSTChzcmMpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgLy8gbWljcm9tYXRjaCBpc24ndCBjb21wYXRpYmxlIHdpdGggZWRnZSBydW50aW1lXG4gICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gJ2VkZ2UnXG4gICAgICApIHtcbiAgICAgICAgLy8gV2UgdXNlIGR5bmFtaWMgcmVxdWlyZSBiZWNhdXNlIHRoaXMgc2hvdWxkIG9ubHkgZXJyb3IgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgY29uc3QgeyBoYXNSZW1vdGVNYXRjaCB9ID0gcmVxdWlyZSgnLi9tYXRjaC1yZW1vdGUtcGF0dGVybicpXG4gICAgICAgIGlmICghaGFzUmVtb3RlTWF0Y2goY29uZmlnLmRvbWFpbnMsIGNvbmZpZy5yZW1vdGVQYXR0ZXJucywgcGFyc2VkU3JjKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHNyYyBwcm9wICgke3NyY30pIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGhvc3RuYW1lIFwiJHtwYXJzZWRTcmMuaG9zdG5hbWV9XCIgaXMgbm90IGNvbmZpZ3VyZWQgdW5kZXIgaW1hZ2VzIGluIHlvdXIgXFxgbmV4dC5jb25maWcuanNcXGBcXG5gICtcbiAgICAgICAgICAgICAgYFNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdW5jb25maWd1cmVkLWhvc3RgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHF1YWxpdHkgJiYgY29uZmlnLnF1YWxpdGllcyAmJiAhY29uZmlnLnF1YWxpdGllcy5pbmNsdWRlcyhxdWFsaXR5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBxdWFsaXR5IHByb3AgKCR7cXVhbGl0eX0pIG9uIFxcYG5leHQvaW1hZ2VcXGAgZG9lcyBub3QgbWF0Y2ggXFxgaW1hZ2VzLnF1YWxpdGllc1xcYCBjb25maWd1cmVkIGluIHlvdXIgXFxgbmV4dC5jb25maWcuanNcXGBcXG5gICtcbiAgICAgICAgICBgU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11bmNvbmZpZ3VyZWQtcXVhbGl0aWVzYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHEgPVxuICAgIHF1YWxpdHkgfHxcbiAgICBjb25maWcucXVhbGl0aWVzPy5yZWR1Y2UoKHByZXYsIGN1cikgPT5cbiAgICAgIE1hdGguYWJzKGN1ciAtIERFRkFVTFRfUSkgPCBNYXRoLmFicyhwcmV2IC0gREVGQVVMVF9RKSA/IGN1ciA6IHByZXZcbiAgICApIHx8XG4gICAgREVGQVVMVF9RXG5cbiAgcmV0dXJuIGAke2NvbmZpZy5wYXRofT91cmw9JHtlbmNvZGVVUklDb21wb25lbnQoc3JjKX0mdz0ke3dpZHRofSZxPSR7cX0ke1xuICAgIHNyYy5zdGFydHNXaXRoKCcvX25leHQvc3RhdGljL21lZGlhLycpICYmIHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgICAgPyBgJmRwbD0ke3Byb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRH1gXG4gICAgICA6ICcnXG4gIH1gXG59XG5cbi8vIFdlIHVzZSB0aGlzIHRvIGRldGVybWluZSBpZiB0aGUgaW1wb3J0IGlzIHRoZSBkZWZhdWx0IGxvYWRlclxuLy8gb3IgYSBjdXN0b20gbG9hZGVyIGRlZmluZWQgYnkgdGhlIHVzZXIgaW4gbmV4dC5jb25maWcuanNcbmRlZmF1bHRMb2FkZXIuX19uZXh0X2ltZ19kZWZhdWx0ID0gdHJ1ZVxuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0TG9hZGVyXG4iXSwibmFtZXMiOlsiREVGQVVMVF9RIiwiZGVmYXVsdExvYWRlciIsImNvbmZpZyIsInNyYyIsIndpZHRoIiwicXVhbGl0eSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1pc3NpbmdWYWx1ZXMiLCJwdXNoIiwibGVuZ3RoIiwiRXJyb3IiLCJqb2luIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0YXJ0c1dpdGgiLCJsb2NhbFBhdHRlcm5zIiwiTkVYVF9SVU5USU1FIiwiaGFzTG9jYWxNYXRjaCIsInJlcXVpcmUiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJwYXJzZWRTcmMiLCJVUkwiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJoYXNSZW1vdGVNYXRjaCIsImhvc3RuYW1lIiwicXVhbGl0aWVzIiwiaW5jbHVkZXMiLCJxIiwicmVkdWNlIiwicHJldiIsImN1ciIsIk1hdGgiLCJhYnMiLCJwYXRoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiTkVYVF9ERVBMT1lNRU5UX0lEIiwiX19uZXh0X2ltZ19kZWZhdWx0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/match-local-pattern.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/match-local-pattern.js ***!
  \*********************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasLocalMatch: function() {\n        return hasLocalMatch;\n    },\n    matchLocalPattern: function() {\n        return matchLocalPattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchLocalPattern(pattern, url) {\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasLocalMatch(localPatterns, urlPathAndQuery) {\n    if (!localPatterns) {\n        // if the user didn't define \"localPatterns\", we allow all local images\n        return true;\n    }\n    const url = new URL(urlPathAndQuery, 'http://n');\n    return localPatterns.some((p)=>matchLocalPattern(p, url));\n} //# sourceMappingURL=match-local-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWtCZ0JBLGFBQWE7ZUFBYkE7O0lBZEFDLGlCQUFpQjtlQUFqQkE7Ozt1Q0FITztBQUdoQixTQUFTQSxrQkFBa0JDLE9BQXFCLEVBQUVDLEdBQVE7SUFDL0QsSUFBSUQsUUFBUUUsTUFBTSxLQUFLQyxXQUFXO1FBQ2hDLElBQUlILFFBQVFFLE1BQU0sS0FBS0QsSUFBSUMsTUFBTSxFQUFFO1lBQ2pDLE9BQU87UUFDVDtJQUNGO1FBRVlGO0lBQVosSUFBSSxDQUFDSSxDQUFBQSxHQUFBQSxXQUFBQSxNQUFBQSxFQUFPSixDQUFBQSxvQkFBQUEsUUFBUUssUUFBQUEsS0FBUSxPQUFoQkwsb0JBQW9CLE1BQU07UUFBRU0sS0FBSztJQUFLLEdBQUdDLElBQUksQ0FBQ04sSUFBSUksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNQLGNBQ2RVLGFBQXlDLEVBQ3pDQyxlQUF1QjtJQUV2QixJQUFJLENBQUNELGVBQWU7UUFDbEIsdUVBQXVFO1FBQ3ZFLE9BQU87SUFDVDtJQUNBLE1BQU1QLE1BQU0sSUFBSVMsSUFBSUQsaUJBQWlCO0lBQ3JDLE9BQU9ELGNBQWNHLElBQUksQ0FBQyxDQUFDQyxJQUFNYixrQkFBa0JhLEdBQUdYO0FBQ3hEIiwic291cmNlcyI6WyIvVXNlcnMvc3JjL3NoYXJlZC9saWIvbWF0Y2gtbG9jYWwtcGF0dGVybi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IExvY2FsUGF0dGVybiB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgbWFrZVJlIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaCdcblxuLy8gTW9kaWZ5aW5nIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGFsc28gbW9kaWZ5IHdyaXRlSW1hZ2VzTWFuaWZlc3QoKVxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoTG9jYWxQYXR0ZXJuKHBhdHRlcm46IExvY2FsUGF0dGVybiwgdXJsOiBVUkwpOiBib29sZWFuIHtcbiAgaWYgKHBhdHRlcm4uc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocGF0dGVybi5zZWFyY2ggIT09IHVybC5zZWFyY2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmICghbWFrZVJlKHBhdHRlcm4ucGF0aG5hbWUgPz8gJyoqJywgeyBkb3Q6IHRydWUgfSkudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzTG9jYWxNYXRjaChcbiAgbG9jYWxQYXR0ZXJuczogTG9jYWxQYXR0ZXJuW10gfCB1bmRlZmluZWQsXG4gIHVybFBhdGhBbmRRdWVyeTogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgaWYgKCFsb2NhbFBhdHRlcm5zKSB7XG4gICAgLy8gaWYgdGhlIHVzZXIgZGlkbid0IGRlZmluZSBcImxvY2FsUGF0dGVybnNcIiwgd2UgYWxsb3cgYWxsIGxvY2FsIGltYWdlc1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmxQYXRoQW5kUXVlcnksICdodHRwOi8vbicpXG4gIHJldHVybiBsb2NhbFBhdHRlcm5zLnNvbWUoKHApID0+IG1hdGNoTG9jYWxQYXR0ZXJuKHAsIHVybCkpXG59XG4iXSwibmFtZXMiOlsiaGFzTG9jYWxNYXRjaCIsIm1hdGNoTG9jYWxQYXR0ZXJuIiwicGF0dGVybiIsInVybCIsInNlYXJjaCIsInVuZGVmaW5lZCIsIm1ha2VSZSIsInBhdGhuYW1lIiwiZG90IiwidGVzdCIsImxvY2FsUGF0dGVybnMiLCJ1cmxQYXRoQW5kUXVlcnkiLCJVUkwiLCJzb21lIiwicCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/match-local-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \**********************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasRemoteMatch: function() {\n        return hasRemoteMatch;\n    },\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    // Should be the same as writeImagesManifest()\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasRemoteMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUF5Q2dCQSxjQUFjO2VBQWRBOztJQXJDQUMsa0JBQWtCO2VBQWxCQTs7O3VDQUhPO0FBR2hCLFNBQVNBLG1CQUFtQkMsT0FBc0IsRUFBRUMsR0FBUTtJQUNqRSxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDbEMsTUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNwQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM5QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUM3QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNsQyxNQUFNLElBQUlLLE1BQ1AsK0NBQTRDQyxLQUFLQyxTQUFTLENBQUNWO0lBRWhFLE9BQU87UUFDTCxJQUFJLENBQUNXLENBQUFBLEdBQUFBLFdBQUFBLE1BQUFBLEVBQU9YLFFBQVFPLFFBQVEsRUFBRUssSUFBSSxDQUFDWCxJQUFJTSxRQUFRLEdBQUc7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJUCxRQUFRYSxNQUFNLEtBQUtWLFdBQVc7UUFDaEMsSUFBSUgsUUFBUWEsTUFBTSxLQUFLWixJQUFJWSxNQUFNLEVBQUU7WUFDakMsT0FBTztRQUNUO0lBQ0Y7UUFHWWI7SUFEWiw4Q0FBOEM7SUFDOUMsSUFBSSxDQUFDVyxDQUFBQSxHQUFBQSxXQUFBQSxNQUFBQSxFQUFPWCxDQUFBQSxvQkFBQUEsUUFBUWMsUUFBQUEsS0FBUSxPQUFoQmQsb0JBQW9CLE1BQU07UUFBRWUsS0FBSztJQUFLLEdBQUdILElBQUksQ0FBQ1gsSUFBSWEsUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNoQixlQUNka0IsT0FBaUIsRUFDakJDLGNBQStCLEVBQy9CaEIsR0FBUTtJQUVSLE9BQ0VlLFFBQVFFLElBQUksQ0FBQyxDQUFDQyxTQUFXbEIsSUFBSU0sUUFBUSxLQUFLWSxXQUMxQ0YsZUFBZUMsSUFBSSxDQUFDLENBQUNFLElBQU1yQixtQkFBbUJxQixHQUFHbkI7QUFFckQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFJlbW90ZVBhdHRlcm4gfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcbmltcG9ydCB7IG1ha2VSZSB9IGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9waWNvbWF0Y2gnXG5cbi8vIE1vZGlmeWluZyB0aGlzIGZ1bmN0aW9uIHNob3VsZCBhbHNvIG1vZGlmeSB3cml0ZUltYWdlc01hbmlmZXN0KClcbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFJlbW90ZVBhdHRlcm4ocGF0dGVybjogUmVtb3RlUGF0dGVybiwgdXJsOiBVUkwpOiBib29sZWFuIHtcbiAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGFjdHVhbFByb3RvID0gdXJsLnByb3RvY29sLnNsaWNlKDAsIC0xKVxuICAgIGlmIChwYXR0ZXJuLnByb3RvY29sICE9PSBhY3R1YWxQcm90bykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVybC5wb3J0KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAocGF0dGVybi5ob3N0bmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFBhdHRlcm4gc2hvdWxkIGRlZmluZSBob3N0bmFtZSBidXQgZm91bmRcXG4ke0pTT04uc3RyaW5naWZ5KHBhdHRlcm4pfWBcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgaWYgKCFtYWtlUmUocGF0dGVybi5ob3N0bmFtZSkudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAocGF0dGVybi5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwYXR0ZXJuLnNlYXJjaCAhPT0gdXJsLnNlYXJjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gU2hvdWxkIGJlIHRoZSBzYW1lIGFzIHdyaXRlSW1hZ2VzTWFuaWZlc3QoKVxuICBpZiAoIW1ha2VSZShwYXR0ZXJuLnBhdGhuYW1lID8/ICcqKicsIHsgZG90OiB0cnVlIH0pLnRlc3QodXJsLnBhdGhuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1JlbW90ZU1hdGNoKFxuICBkb21haW5zOiBzdHJpbmdbXSxcbiAgcmVtb3RlUGF0dGVybnM6IFJlbW90ZVBhdHRlcm5bXSxcbiAgdXJsOiBVUkxcbik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGRvbWFpbnMuc29tZSgoZG9tYWluKSA9PiB1cmwuaG9zdG5hbWUgPT09IGRvbWFpbikgfHxcbiAgICByZW1vdGVQYXR0ZXJucy5zb21lKChwKSA9PiBtYXRjaFJlbW90ZVBhdHRlcm4ocCwgdXJsKSlcbiAgKVxufVxuIl0sIm5hbWVzIjpbImhhc1JlbW90ZU1hdGNoIiwibWF0Y2hSZW1vdGVQYXR0ZXJuIiwicGF0dGVybiIsInVybCIsInByb3RvY29sIiwidW5kZWZpbmVkIiwiYWN0dWFsUHJvdG8iLCJzbGljZSIsInBvcnQiLCJob3N0bmFtZSIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ha2VSZSIsInRlc3QiLCJzZWFyY2giLCJwYXRobmFtZSIsImRvdCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInNvbWUiLCJkb21haW4iLCJwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \*******************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = 'RouterContext';\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzRFQUhLO0FBR1gsTUFBTUEsZ0JBQWdCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBb0IsRUFBbUI7SUFDekNILGNBQWNNLFdBQVcsR0FBRztBQUM5QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcblxuZXhwb3J0IGNvbnN0IFJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5leHRSb3V0ZXIgfCBudWxsPihudWxsKVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1JvdXRlckNvbnRleHQnXG59XG4iXSwibmFtZXMiOlsiUm91dGVyQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/side-effect.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/side-effect.js ***!
  \*************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\nconst isServer = typeof window === 'undefined';\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    var _headManager_mountedInstances;\n                    headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect({\n        \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n            return ({\n                \"SideEffect.useClientOnlyLayoutEffect\": ()=>{\n                    if (headManager) {\n                        headManager._pendingUpdate = emitChange;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyLayoutEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyLayoutEffect\"]);\n    useClientOnlyEffect({\n        \"SideEffect.useClientOnlyEffect\": ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n            return ({\n                \"SideEffect.useClientOnlyEffect\": ()=>{\n                    if (headManager && headManager._pendingUpdate) {\n                        headManager._pendingUpdate();\n                        headManager._pendingUpdate = null;\n                    }\n                }\n            })[\"SideEffect.useClientOnlyEffect\"];\n        }\n    }[\"SideEffect.useClientOnlyEffect\"]);\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7bUNBbkJ1QztBQWUvRCxNQUFNQyxXQUFXLE9BQU9DLFdBQVc7QUFDbkMsTUFBTUMsNEJBQTRCRixXQUFXLEtBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxNQUFNQyxzQkFBc0JKLFdBQVcsS0FBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLG9CQUFvQkMsS0FBc0I7O0lBQ3ZELE1BQU0sRUFBRUMsV0FBVyxFQUFFQyx1QkFBdUIsRUFBRSxHQUFHRjtJQUVqRCxTQUFTRztRQUNQLElBQUlGLGVBQWVBLFlBQVlHLGdCQUFnQixFQUFFO1lBQy9DLE1BQU1DLGVBQWVDLE9BQUFBLFFBQVEsQ0FBQ0MsT0FBTyxDQUNuQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBMEJNLE1BQU0sQ0FDckVDO1lBR0pWLFlBQVlXLFVBQVUsQ0FBQ1Ysd0JBQXdCRyxjQUFjTDtRQUMvRDtJQUNGO0lBRUEsSUFBSU4sVUFBVTtZQUNaTztRQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQUFBLEtBQWdCLGdCQUE3QkgsOEJBQStCWSxHQUFHLENBQUNiLE1BQU1jLFFBQVE7UUFDakRYO0lBQ0Y7O2dEQUUwQjtnQkFDeEJGO1lBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtZQUNqRDt3REFBTzt3QkFDTGI7b0JBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBQUEsS0FBZ0IsZ0JBQTdCSCw4QkFBK0JjLE1BQU0sQ0FBQ2YsTUFBTWMsUUFBUTtnQkFDdEQ7O1FBQ0Y7O0lBRUEsa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjs7Z0RBQ3pEO1lBQ3hCLElBQUliLGFBQWE7Z0JBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7WUFDL0I7WUFDQTt3REFBTztvQkFDTCxJQUFJRixhQUFhO3dCQUNmQSxZQUFZZSxjQUFjLEdBQUdiO29CQUMvQjtnQkFDRjs7UUFDRjs7OzBDQUVvQjtZQUNsQixJQUFJRixlQUFlQSxZQUFZZSxjQUFjLEVBQUU7Z0JBQzdDZixZQUFZZSxjQUFjO2dCQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1lBQy9CO1lBQ0E7a0RBQU87b0JBQ0wsSUFBSWYsZUFBZUEsWUFBWWUsY0FBYyxFQUFFO3dCQUM3Q2YsWUFBWWUsY0FBYzt3QkFDMUJmLFlBQVllLGNBQWMsR0FBRztvQkFDL0I7Z0JBQ0Y7O1FBQ0Y7O0lBRUEsT0FBTztBQUNUOzs7UUFyQ0VwQjtRQVlBQTtRQVdBRTs7O0tBMUNzQkwiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zcmMvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDaGlsZHJlbiwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHR5cGUgSlNYIH0gZnJvbSAncmVhY3QnXG5cbnR5cGUgU3RhdGUgPSBKU1guRWxlbWVudFtdIHwgdW5kZWZpbmVkXG5cbmV4cG9ydCB0eXBlIFNpZGVFZmZlY3RQcm9wcyA9IHtcbiAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6IDxUIGV4dGVuZHMge30+KFxuICAgIGNvbXBvbmVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICBwcm9wczogVFxuICApID0+IFN0YXRlXG4gIGhhbmRsZVN0YXRlQ2hhbmdlPzogKHN0YXRlOiBTdGF0ZSkgPT4gdm9pZFxuICBoZWFkTWFuYWdlcjogYW55XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxufVxuXG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5jb25zdCB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKSA9PiB7fSA6IHVzZUxheW91dEVmZmVjdFxuY29uc3QgdXNlQ2xpZW50T25seUVmZmVjdCA9IGlzU2VydmVyID8gKCkgPT4ge30gOiB1c2VFZmZlY3RcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lkZUVmZmVjdChwcm9wczogU2lkZUVmZmVjdFByb3BzKSB7XG4gIGNvbnN0IHsgaGVhZE1hbmFnZXIsIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIH0gPSBwcm9wc1xuXG4gIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoKSB7XG4gICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpIHtcbiAgICAgIGNvbnN0IGhlYWRFbGVtZW50cyA9IENoaWxkcmVuLnRvQXJyYXkoXG4gICAgICAgIEFycmF5LmZyb20oaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcyBhcyBTZXQ8UmVhY3QuUmVhY3ROb2RlPikuZmlsdGVyKFxuICAgICAgICAgIEJvb2xlYW5cbiAgICAgICAgKVxuICAgICAgKSBhcyBSZWFjdC5SZWFjdEVsZW1lbnRbXVxuICAgICAgaGVhZE1hbmFnZXIudXBkYXRlSGVhZChyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShoZWFkRWxlbWVudHMsIHByb3BzKSlcbiAgICB9XG4gIH1cblxuICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICBoZWFkTWFuYWdlcj8ubW91bnRlZEluc3RhbmNlcz8uYWRkKHByb3BzLmNoaWxkcmVuKVxuICAgIGVtaXRDaGFuZ2UoKVxuICB9XG5cbiAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmFkZChwcm9wcy5jaGlsZHJlbilcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaGVhZE1hbmFnZXI/Lm1vdW50ZWRJbnN0YW5jZXM/LmRlbGV0ZShwcm9wcy5jaGlsZHJlbilcbiAgICB9XG4gIH0pXG5cbiAgLy8gV2UgbmVlZCB0byBjYWxsIGB1cGRhdGVIZWFkYCBtZXRob2Qgd2hlbmV2ZXIgdGhlIGBTaWRlRWZmZWN0YCBpcyB0cmlnZ2VyIGluIGFsbFxuICAvLyBsaWZlLWN5Y2xlczogbW91bnQsIHVwZGF0ZSwgdW5tb3VudC4gSG93ZXZlciwgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGBTaWRlRWZmZWN0YHNcbiAgLy8gYmVpbmcgcmVuZGVyZWQsIHdlIG9ubHkgdHJpZ2dlciB0aGUgbWV0aG9kIGZyb20gdGhlIGxhc3Qgb25lLlxuICAvLyBUaGlzIGlzIGVuc3VyZWQgYnkga2VlcGluZyB0aGUgbGFzdCB1bmZsdXNoZWQgYHVwZGF0ZUhlYWRgIGluIHRoZSBgX3BlbmRpbmdVcGRhdGVgXG4gIC8vIHNpbmdsZXRvbiBpbiB0aGUgbGF5b3V0IGVmZmVjdCBwYXNzLCBhbmQgYWN0dWFsbHkgdHJpZ2dlciBpdCBpbiB0aGUgZWZmZWN0IHBhc3MuXG4gIHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHVzZUNsaWVudE9ubHlFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSkge1xuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBudWxsXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKVxuICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG51bGxcbn1cbiJdLCJuYW1lcyI6WyJTaWRlRWZmZWN0IiwiaXNTZXJ2ZXIiLCJ3aW5kb3ciLCJ1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ2xpZW50T25seUVmZmVjdCIsInVzZUVmZmVjdCIsInByb3BzIiwiaGVhZE1hbmFnZXIiLCJyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSIsImVtaXRDaGFuZ2UiLCJtb3VudGVkSW5zdGFuY2VzIiwiaGVhZEVsZW1lbnRzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwiQm9vbGVhbiIsInVwZGF0ZUhlYWQiLCJhZGQiLCJjaGlsZHJlbiIsImRlbGV0ZSIsIl9wZW5kaW5nVXBkYXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Mono\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatMono\"}":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{"path":"modules/layout/fonts.ts","import":"Red_Hat_Mono","arguments":[{"subsets":["latin"]}],"variableName":"redHatMono"} ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Red Hat Mono', 'Red Hat Mono Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_dbfe30\"};\n    if(true) {\n      // 1772336747378\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwibW9kdWxlcy9sYXlvdXQvZm9udHMudHNcIixcImltcG9ydFwiOlwiUmVkX0hhdF9Nb25vXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcInJlZEhhdE1vbm9cIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyw0RUFBNEU7QUFDdkcsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsOFZBQStMLGNBQWMsc0RBQXNEO0FBQ2pTLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcInBhdGhcIjpcIm1vZHVsZXMvbGF5b3V0L2ZvbnRzLnRzXCIsXCJpbXBvcnRcIjpcIlJlZF9IYXRfTW9ub1wiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJyZWRIYXRNb25vXCJ9Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidSZWQgSGF0IE1vbm8nLCAnUmVkIEhhdCBNb25vIEZhbGxiYWNrJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lX2RiZmUzMFwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzcyMzM2NzQ3Mzc4XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Mono\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatMono\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Text\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatText\"}":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{"path":"modules/layout/fonts.ts","import":"Red_Hat_Text","arguments":[{"subsets":["latin"]}],"variableName":"redHatText"} ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Red Hat Text', 'Red Hat Text Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_618921\"};\n    if(true) {\n      // 1772336747470\n      var cssReload = __webpack_require__(/*! ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwibW9kdWxlcy9sYXlvdXQvZm9udHMudHNcIixcImltcG9ydFwiOlwiUmVkX0hhdF9UZXh0XCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcInJlZEhhdFRleHRcIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyw0RUFBNEU7QUFDdkcsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsOFZBQStMLGNBQWMsc0RBQXNEO0FBQ2pTLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9mb250L2dvb2dsZS90YXJnZXQuY3NzP3tcInBhdGhcIjpcIm1vZHVsZXMvbGF5b3V0L2ZvbnRzLnRzXCIsXCJpbXBvcnRcIjpcIlJlZF9IYXRfVGV4dFwiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXX1dLFwidmFyaWFibGVOYW1lXCI6XCJyZWRIYXRUZXh0XCJ9Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJzdHlsZVwiOntcImZvbnRGYW1pbHlcIjpcIidSZWQgSGF0IFRleHQnLCAnUmVkIEhhdCBUZXh0IEZhbGxiYWNrJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lXzYxODkyMVwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzcyMzM2NzQ3NDcwXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/google/target.css?{\"path\":\"modules/layout/fonts.ts\",\"import\":\"Red_Hat_Text\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"redHatText\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*******************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*******************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpTEFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL3NhdGhpcmEvUHJvamVjdHMvZ3JvdHRvL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge30sXG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjEuNF9yZWFjdC1kb21AMTkuMC4wX3JlYWN0QDE5LjAuMF9fcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx5UUFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zYXRoaXJhL1Byb2plY3RzL2dyb3R0by9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4xLjRfcmVhY3QtZG9tQDE5LjAuMF9yZWFjdEAxOS4wLjBfX3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/animejs@4.1.4/node_modules/animejs/lib/anime.esm.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/animejs@4.1.4/node_modules/animejs/lib/anime.esm.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animatable: () => (/* binding */ Animatable),\n/* harmony export */   Draggable: () => (/* binding */ Draggable),\n/* harmony export */   JSAnimation: () => (/* binding */ JSAnimation),\n/* harmony export */   Scope: () => (/* binding */ Scope),\n/* harmony export */   ScrollObserver: () => (/* binding */ ScrollObserver),\n/* harmony export */   Spring: () => (/* binding */ Spring),\n/* harmony export */   TextSplitter: () => (/* binding */ TextSplitter),\n/* harmony export */   Timeline: () => (/* binding */ Timeline),\n/* harmony export */   Timer: () => (/* binding */ Timer),\n/* harmony export */   WAAPIAnimation: () => (/* binding */ WAAPIAnimation),\n/* harmony export */   animate: () => (/* binding */ animate),\n/* harmony export */   createAnimatable: () => (/* binding */ createAnimatable),\n/* harmony export */   createDraggable: () => (/* binding */ createDraggable),\n/* harmony export */   createScope: () => (/* binding */ createScope),\n/* harmony export */   createSpring: () => (/* binding */ createSpring),\n/* harmony export */   createTimeline: () => (/* binding */ createTimeline),\n/* harmony export */   createTimer: () => (/* binding */ createTimer),\n/* harmony export */   eases: () => (/* binding */ eases),\n/* harmony export */   engine: () => (/* binding */ engine),\n/* harmony export */   onScroll: () => (/* binding */ onScroll),\n/* harmony export */   scrollContainers: () => (/* binding */ scrollContainers),\n/* harmony export */   stagger: () => (/* binding */ stagger),\n/* harmony export */   svg: () => (/* binding */ svg),\n/* harmony export */   text: () => (/* binding */ text),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   waapi: () => (/* binding */ waapi)\n/* harmony export */ });\n/**\n * anime.js - ESM\n * @version v4.1.4\n * @author Julian Garnier\n * @license MIT\n * @copyright (c) 2025 Julian Garnier\n * @see https://animejs.com\n */\n\n// Global types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} DefaultsParams\n * @property {Number|String} [id]\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n * @property {Number} [playbackRate]\n * @property {Number} [frameRate]\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number|FunctionValue} [duration]\n * @property {Number|FunctionValue} [delay]\n * @property {Number} [loopDelay]\n * @property {EasingParam} [ease]\n * @property {'none'|'replace'|'blend'|compositionTypes} [composition]\n * @property {(v: any) => any} [modifier]\n * @property {(tickable: Tickable) => void} [onBegin]\n * @property {(tickable: Tickable) => void} [onBeforeUpdate]\n * @property {(tickable: Tickable) => void} [onUpdate]\n * @property {(tickable: Tickable) => void} [onLoop]\n * @property {(tickable: Tickable) => void} [onPause]\n * @property {(tickable: Tickable) => void} [onComplete]\n * @property {(renderable: Renderable) => void} [onRender]\n */\n\n/** @typedef {JSAnimation|Timeline} Renderable */\n/** @typedef {Timer|Renderable} Tickable */\n/** @typedef {Timer&JSAnimation&Timeline} CallbackArgument */\n/** @typedef {Animatable|Tickable|WAAPIAnimation|Draggable|ScrollObserver|TextSplitter|Scope} Revertible */\n\n// Stagger types ///////////////////////////////////////////////////////////////\n\n/**\n * @template T\n * @callback StaggerFunction\n * @param {Target} [target]\n * @param {Number} [index]\n * @param {Number} [length]\n * @param {Timeline} [tl]\n * @return {T}\n */\n\n/**\n * @typedef  {Object} StaggerParams\n * @property {Number|String} [start]\n * @property {Number|'first'|'center'|'last'|'random'} [from]\n * @property {Boolean} [reversed]\n * @property {Array.<Number>} [grid]\n * @property {('x'|'y')} [axis]\n * @property {String|((target: Target, i: Number, length: Number) => Number)} [use]\n * @property {Number} [total]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n */\n\n// Eases types /////////////////////////////////////////////////////////////////\n\n/**\n * @callback EasingFunction\n * @param {Number} time\n * @return {Number}\n */\n\n/**\n * @typedef {('linear'|'linear(x1, x2 25%, x3)'|'in'|'out'|'inOut'|'inQuad'|'outQuad'|'inOutQuad'|'inCubic'|'outCubic'|'inOutCubic'|'inQuart'|'outQuart'|'inOutQuart'|'inQuint'|'outQuint'|'inOutQuint'|'inSine'|'outSine'|'inOutSine'|'inCirc'|'outCirc'|'inOutCirc'|'inExpo'|'outExpo'|'inOutExpo'|'inBounce'|'outBounce'|'inOutBounce'|'inBack'|'outBack'|'inOutBack'|'inElastic'|'outElastic'|'inOutElastic'|'irregular'|'cubicBezier'|'steps'|'in(p = 1.675)'|'out(p = 1.675)'|'inOut(p = 1.675)'|'inBack(overshoot = 1.70158)'|'outBack(overshoot = 1.70158)'|'inOutBack(overshoot = 1.70158)'|'inElastic(amplitude = 1, period = .3)'|'outElastic(amplitude = 1, period = .3)'|'inOutElastic(amplitude = 1, period = .3)'|'irregular(length = 10, randomness = 1)'|'cubicBezier(x1, y1, x2, y2)'|'steps(steps = 10)')} EaseStringParamNames\n */\n\n// A hack to get both ease names suggestions AND allow any strings\n// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421\n/** @typedef {(String & {})|EaseStringParamNames|EasingFunction|Spring} EasingParam */\n\n/** @typedef {HTMLElement|SVGElement} DOMTarget */\n/** @typedef {Record<String, any>} JSTarget */\n/** @typedef {DOMTarget|JSTarget} Target */\n/** @typedef {Target|NodeList|String} TargetSelector */\n/** @typedef {DOMTarget|NodeList|String} DOMTargetSelector */\n/** @typedef {Array.<DOMTargetSelector>|DOMTargetSelector} DOMTargetsParam */\n/** @typedef {Array.<DOMTarget>} DOMTargetsArray */\n/** @typedef {Array.<JSTarget>|JSTarget} JSTargetsParam */\n/** @typedef {Array.<JSTarget>} JSTargetsArray */\n/** @typedef {Array.<TargetSelector>|TargetSelector} TargetsParam */\n/** @typedef {Array.<Target>} TargetsArray */\n\n// Spring types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} SpringParams\n * @property {Number} [mass=1] - Mass, default 1\n * @property {Number} [stiffness=100] - Stiffness, default 100\n * @property {Number} [damping=10] - Damping, default 10\n * @property {Number} [velocity=0] - Initial velocity, default 0\n */\n\n // Callback types //////////////////////////////////////////////////////////////\n\n/**\n * @template T\n * @callback Callback\n * @param {T} self - Returns itself\n * @param {PointerEvent} [e]\n * @return {*}\n */\n\n/**\n * @template {object} T\n * @typedef {Object} TickableCallbacks\n * @property {Callback<T>} [onBegin]\n * @property {Callback<T>} [onBeforeUpdate]\n * @property {Callback<T>} [onUpdate]\n * @property {Callback<T>} [onLoop]\n * @property {Callback<T>} [onPause]\n * @property {Callback<T>} [onComplete]\n */\n\n/**\n * @template {object} T\n * @typedef {Object} RenderableCallbacks\n * @property {Callback<T>} [onRender]\n */\n\n// Timer types /////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} TimerOptions\n * @property {Number|String} [id]\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {Number} [loopDelay]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|Number} [loop]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [frameRate]\n * @property {Number} [playbackRate]\n */\n\n/**\n\n/**\n * @typedef {TimerOptions & TickableCallbacks<Timer>} TimerParams\n */\n\n// Tween types /////////////////////////////////////////////////////////////////\n\n/**\n * @callback FunctionValue\n * @param {Target} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {Number|String|TweenObjectValue|Array.<Number|String|TweenObjectValue>}\n */\n\n/**\n * @callback TweenModifier\n * @param {Number} value - The animated value\n * @return {Number|String}\n */\n\n/** @typedef {[Number, Number, Number, Number]} ColorArray */\n\n/**\n * @typedef {Object} Tween\n * @property {Number} id\n * @property {JSAnimation} parent\n * @property {String} property\n * @property {Target} target\n * @property {String|Number} _value\n * @property {Function|null} _func\n * @property {EasingFunction} _ease\n * @property {Array.<Number>} _fromNumbers\n * @property {Array.<Number>} _toNumbers\n * @property {Array.<String>} _strings\n * @property {Number} _fromNumber\n * @property {Number} _toNumber\n * @property {Array.<Number>} _numbers\n * @property {Number} _number\n * @property {String} _unit\n * @property {TweenModifier} _modifier\n * @property {Number} _currentTime\n * @property {Number} _delay\n * @property {Number} _updateDuration\n * @property {Number} _startTime\n * @property {Number} _changeDuration\n * @property {Number} _absoluteStartTime\n * @property {tweenTypes} _tweenType\n * @property {valueTypes} _valueType\n * @property {Number} _composition\n * @property {Number} _isOverlapped\n * @property {Number} _isOverridden\n * @property {Number} _renderTransforms\n * @property {Tween} _prevRep\n * @property {Tween} _nextRep\n * @property {Tween} _prevAdd\n * @property {Tween} _nextAdd\n * @property {Tween} _prev\n * @property {Tween} _next\n */\n\n/**\n * @typedef TweenDecomposedValue\n * @property {Number} t - Type\n * @property {Number} n - Single number value\n * @property {String} u - Value unit\n * @property {String} o - Value operator\n * @property {Array.<Number>} d - Array of Numbers (in case of complex value type)\n * @property {Array.<String>} s - Strings (in case of complex value type)\n */\n\n/** @typedef {{_head: null|Tween, _tail: null|Tween}} TweenPropertySiblings */\n/** @typedef {Record<String, TweenPropertySiblings>} TweenLookups */\n/** @typedef {WeakMap.<Target, TweenLookups>} TweenReplaceLookups */\n/** @typedef {Map.<Target, TweenLookups>} TweenAdditiveLookups */\n\n// JSAnimation types ///////////////////////////////////////////////////////////\n\n/**\n * @typedef {Number|String|FunctionValue} TweenParamValue\n */\n\n/**\n * @typedef {TweenParamValue|[TweenParamValue, TweenParamValue]} TweenPropValue\n */\n\n/**\n * @typedef {(String & {})|'none'|'replace'|'blend'|compositionTypes} TweenComposition\n */\n\n/**\n * @typedef {Object} TweenParamsOptions\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */\n\n/**\n * @typedef {Object} TweenValues\n * @property {TweenParamValue} [from]\n * @property {TweenPropValue} [to]\n * @property {TweenPropValue} [fromTo]\n */\n\n/**\n * @typedef {TweenParamsOptions & TweenValues} TweenKeyValue\n */\n\n/**\n * @typedef {Array.<TweenKeyValue|TweenPropValue>} ArraySyntaxValue\n */\n\n/**\n * @typedef {TweenParamValue|ArraySyntaxValue|TweenKeyValue} TweenOptions\n */\n\n/**\n * @typedef {Partial<{to: TweenParamValue|Array.<TweenParamValue>; from: TweenParamValue|Array.<TweenParamValue>; fromTo: TweenParamValue|Array.<TweenParamValue>;}>} TweenObjectValue\n */\n\n/**\n * @typedef {Object} PercentageKeyframeOptions\n * @property {EasingParam} [ease]\n */\n\n/**\n * @typedef {Record<String, TweenParamValue>} PercentageKeyframeParams\n */\n\n/**\n * @typedef {Record<String, PercentageKeyframeParams & PercentageKeyframeOptions>} PercentageKeyframes\n */\n\n/**\n * @typedef {Array<Record<String, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>} DurationKeyframes\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n */\n\n// TODO: Currently setting TweenModifier to the intersected Record<> makes the FunctionValue type target param any if only one parameter is set\n/**\n * @typedef {Record<String, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | DurationKeyframes | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>} AnimationParams\n */\n\n// Timeline types //////////////////////////////////////////////////////////////\n\n/**\n * Accepts:<br>\n * - `Number` - Absolute position in milliseconds (e.g., `500` places element at exactly 500ms)<br>\n * - `'+=Number'` - Addition: Position element X ms after the last element (e.g., `'+=100'`)<br>\n * - `'-=Number'` - Subtraction: Position element X ms before the last element's end (e.g., `'-=100'`)<br>\n * - `'*=Number'` - Multiplier: Position element at a fraction of the total duration (e.g., `'*=.5'` for halfway)<br>\n * - `'<'` - Previous end: Position element at the end position of the previous element<br>\n * - `'<<'` - Previous start: Position element at the start position of the previous element<br>\n * - `'<<+=Number'` - Combined: Position element relative to previous element's start (e.g., `'<<+=250'`)<br>\n * - `'label'` - Label: Position element at a named label position (e.g., `'My Label'`)\n *\n * @typedef {Number|`+=${Number}`|`-=${Number}`|`*=${Number}`|'<'|'<<'|`<<+=${Number}`|`<<-=${Number}`|String} TimelinePosition\n */\n\n/**\n * Accepts:<br>\n * - `Number` - Absolute position in milliseconds (e.g., `500` places animation at exactly 500ms)<br>\n * - `'+=Number'` - Addition: Position animation X ms after the last animation (e.g., `'+=100'`)<br>\n * - `'-=Number'` - Subtraction: Position animation X ms before the last animation's end (e.g., `'-=100'`)<br>\n * - `'*=Number'` - Multiplier: Position animation at a fraction of the total duration (e.g., `'*=.5'` for halfway)<br>\n * - `'<'` - Previous end: Position animation at the end position of the previous animation<br>\n * - `'<<'` - Previous start: Position animation at the start position of the previous animation<br>\n * - `'<<+=Number'` - Combined: Position animation relative to previous animation's start (e.g., `'<<+=250'`)<br>\n * - `'label'` - Label: Position animation at a named label position (e.g., `'My Label'`)<br>\n * - `stagger(String|Nummber)` - Stagger multi-elements animation positions (e.g., 10, 20, 30...)\n *\n * @typedef {TimelinePosition | StaggerFunction<Number|String>} TimelineAnimationPosition\n */\n\n/**\n * @typedef {Object} TimelineOptions\n * @property {DefaultsParams} [defaults]\n * @property {EasingParam} [playbackEase]\n */\n\n/**\n * @typedef {TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} TimelineParams\n */\n\n// WAAPIAnimation types ////////////////////////////////////////////////////////\n\n/**\n * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue\n */\n\n/**\n * @callback WAAPIFunctionValue\n * @param {DOMTarget} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {WAAPITweenValue}\n */\n\n/**\n * @typedef {WAAPITweenValue|WAAPIFunctionValue|Array<String|Number|WAAPIFunctionValue>} WAAPIKeyframeValue\n */\n\n/**\n * @typedef {(animation: WAAPIAnimation) => void} WAAPICallback\n */\n\n/**\n * @typedef {Object} WAAPITweenOptions\n * @property {WAAPIKeyframeValue} [to]\n * @property {WAAPIKeyframeValue} [from]\n * @property {Number|WAAPIFunctionValue} [duration]\n * @property {Number|WAAPIFunctionValue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n */\n\n/**\n * @typedef {Object} WAAPIAnimationOptions\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [Reversed]\n * @property {Boolean} [Alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [playbackRate]\n * @property {Number|WAAPIFunctionValue} [duration]\n * @property {Number|WAAPIFunctionValue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n * @property {WAAPICallback} [onComplete]\n */\n\n/**\n * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | WAAPICallback | EasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams\n */\n\n// Animatable types ////////////////////////////////////////////////////////////\n\n/**\n * @callback AnimatablePropertySetter\n * @param  {Number|Array.<Number>} to\n * @param  {Number} [duration]\n * @param  {EasingParam} [ease]\n * @return {AnimatableObject}\n */\n\n/**\n * @callback AnimatablePropertyGetter\n * @return {Number|Array.<Number>}\n */\n\n/**\n * @typedef {AnimatablePropertySetter & AnimatablePropertyGetter} AnimatableProperty\n */\n\n/**\n * @typedef {Animatable & Record<String, AnimatableProperty>} AnimatableObject\n */\n\n/**\n * @typedef {Object} AnimatablePropertyParamsOptions\n * @property {String} [unit]\n * @property {TweenParamValue} [duration]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */\n\n/**\n * @typedef {Record<String, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions} AnimatableParams\n */\n\n// Scope types /////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} ReactRef\n * @property {HTMLElement|SVGElement|null} [current]\n */\n\n/**\n * @typedef {Object} AngularRef\n * @property {HTMLElement|SVGElement} [nativeElement]\n */\n\n/**\n * @typedef {Object} ScopeParams\n * @property {DOMTargetSelector|ReactRef|AngularRef} [root]\n * @property {DefaultsParams} [defaults]\n * @property {Record<String, String>} [mediaQueries]\n */\n\n/**\n * @template T\n * @callback ScopedCallback\n * @param {Scope} scope\n * @return {T}\n */\n\n/**\n * @callback ScopeCleanupCallback\n * @param {Scope} [scope]\n */\n\n/**\n * @callback ScopeConstructorCallback\n * @param {Scope} [scope]\n * @return {ScopeCleanupCallback|void}\n */\n\n/**\n * @callback ScopeMethod\n * @param {...*} args\n * @return {ScopeCleanupCallback|void}\n */\n\n// Scroll types ////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {String|Number} ScrollThresholdValue\n */\n\n/**\n * @typedef {Object} ScrollThresholdParam\n * @property {ScrollThresholdValue} [target]\n * @property {ScrollThresholdValue} [container]\n */\n\n/**\n * @callback ScrollObserverAxisCallback\n * @param {ScrollObserver} self\n * @return {'x'|'y'}\n */\n\n/**\n * @callback ScrollThresholdCallback\n * @param {ScrollObserver} self\n * @return {ScrollThresholdValue|ScrollThresholdParam}\n */\n\n/**\n * @typedef {Object} ScrollObserverParams\n * @property {Number|String} [id]\n * @property {Boolean|Number|String|EasingParam} [sync]\n * @property {TargetsParam} [container]\n * @property {TargetsParam} [target]\n * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]\n * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]\n * @property {Boolean} [debug]\n * @property {Callback<ScrollObserver>} [onEnter]\n * @property {Callback<ScrollObserver>} [onLeave]\n * @property {Callback<ScrollObserver>} [onEnterForward]\n * @property {Callback<ScrollObserver>} [onLeaveForward]\n * @property {Callback<ScrollObserver>} [onEnterBackward]\n * @property {Callback<ScrollObserver>} [onLeaveBackward]\n * @property {Callback<ScrollObserver>} [onUpdate]\n * @property {Callback<ScrollObserver>} [onSyncComplete]\n */\n\n// Draggable types /////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} DraggableAxisParam\n * @property {String} [mapTo]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n */\n\n/**\n * @typedef {Object} DraggableCursorParams\n * @property {String} [onHover]\n * @property {String} [onGrab]\n */\n\n/**\n * @typedef {Object} DraggableParams\n * @property {DOMTargetSelector} [trigger]\n * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]\n * @property {Boolean|DraggableAxisParam} [x]\n * @property {Boolean|DraggableAxisParam} [y]\n * @property {TweenModifier} [modifier]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]\n * @property {Number|((draggable: Draggable) => Number)} [containerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]\n * @property {Number|((draggable: Draggable) => Number)} [minVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]\n * @property {Number} [releaseMass]\n * @property {Number} [releaseStiffness]\n * @property {Number} [releaseDamping]\n * @property {Boolean} [releaseDamping]\n * @property {EasingParam} [releaseEase]\n * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]\n * @property {Callback<Draggable>} [onGrab]\n * @property {Callback<Draggable>} [onDrag]\n * @property {Callback<Draggable>} [onRelease]\n * @property {Callback<Draggable>} [onUpdate]\n * @property {Callback<Draggable>} [onSettle]\n * @property {Callback<Draggable>} [onSnap]\n * @property {Callback<Draggable>} [onResize]\n * @property {Callback<Draggable>} [onAfterResize]\n */\n\n// Text types //////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} splitTemplateParams\n * @property {false|String} [class]\n * @property {Boolean|'hidden'|'clip'|'visible'|'scroll'|'auto'} [wrap]\n * @property {Boolean|'top'|'right'|'bottom'|'left'|'center'} [clone]\n */\n\n/**\n * @typedef {Boolean|String} SplitValue\n */\n\n/**\n * @callback SplitFunctionValue\n * @param {Node|HTMLElement} [value]\n * @return String\n */\n\n/**\n * @typedef {Object} TextSplitterParams\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [lines]\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [words]\n * @property {SplitValue|splitTemplateParams|SplitFunctionValue} [chars]\n * @property {Boolean} [accessible]\n * @property {Boolean} [includeSpaces]\n * @property {Boolean} [debug]\n */\n\n// SVG types ///////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {SVGGeometryElement & {\n *   setAttribute(name: 'draw', value: `${number} ${number}`): void;\n *   draw: `${number} ${number}`;\n * }} DrawableSVGGeometry\n */\n\n\n// Environments\n\n// TODO: Do we need to check if we're running inside a worker ?\nconst isBrowser = typeof window !== 'undefined';\n\n/** @type {Window & {AnimeJS: Array}|null} */\nconst win = isBrowser ? /** @type {Window & {AnimeJS: Array}} */(/** @type {unknown} */(window)) : null;\n\n/** @type {Document|null} */\nconst doc = isBrowser ? document : null;\n\n// Enums\n\n/** @enum {Number} */\nconst tweenTypes = {\n  OBJECT: 0,\n  ATTRIBUTE: 1,\n  CSS: 2,\n  TRANSFORM: 3,\n  CSS_VAR: 4,\n};\n\n/** @enum {Number} */\nconst valueTypes = {\n  NUMBER: 0,\n  UNIT: 1,\n  COLOR: 2,\n  COMPLEX: 3,\n};\n\n/** @enum {Number} */\nconst tickModes = {\n  NONE: 0,\n  AUTO: 1,\n  FORCE: 2,\n};\n\n/** @enum {Number} */\nconst compositionTypes = {\n  replace: 0,\n  none: 1,\n  blend: 2,\n};\n\n// Cache symbols\n\nconst isRegisteredTargetSymbol = Symbol();\nconst isDomSymbol = Symbol();\nconst isSvgSymbol = Symbol();\nconst transformsSymbol = Symbol();\nconst morphPointsSymbol = Symbol();\nconst proxyTargetSymbol = Symbol();\n\n// Numbers\n\nconst minValue = 1e-11;\nconst maxValue = 1e12;\nconst K = 1e3;\nconst maxFps = 120;\n\n// Strings\n\nconst emptyString = '';\nconst shortTransforms = /*#__PURE__*/ (() => {\n  const map = new Map();\n  map.set('x', 'translateX');\n  map.set('y', 'translateY');\n  map.set('z', 'translateZ');\n  return map;\n})();\n\nconst validTransforms = [\n  'translateX',\n  'translateY',\n  'translateZ',\n  'rotate',\n  'rotateX',\n  'rotateY',\n  'rotateZ',\n  'scale',\n  'scaleX',\n  'scaleY',\n  'scaleZ',\n  'skew',\n  'skewX',\n  'skewY',\n  'perspective',\n  'matrix',\n  'matrix3d',\n];\n\nconst transformsFragmentStrings = /*#__PURE__*/ validTransforms.reduce((a, v) => ({...a, [v]: v + '('}), {});\n\n// Functions\n\n/** @return {void} */\nconst noop = () => {};\n\n// Regex\n\nconst hexTestRgx = /(^#([\\da-f]{3}){1,2}$)|(^#([\\da-f]{4}){1,2}$)/i;\nconst rgbExecRgx = /rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i;\nconst rgbaExecRgx = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\nconst hslExecRgx = /hsl\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*\\)/i;\nconst hslaExecRgx = /hsla\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\n// export const digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?/g;\nconst digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:e[-+]?\\d)?/gi;\n// export const unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)+([a-z]+|%)$/i;\nconst unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:e[-+]?\\d+)?)([a-z]+|%)$/i;\nconst lowerCaseRgx = /([a-z])([A-Z])/g;\nconst transformsExecRgx = /(\\w+)(\\([^)]+\\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()\nconst relativeValuesExecRgx = /(\\*=|\\+=|-=)/;\n\n\n\n\n/** @type {DefaultsParams} */\nconst defaults = {\n  id: null,\n  keyframes: null,\n  playbackEase: null,\n  playbackRate: 1,\n  frameRate: maxFps,\n  loop: 0,\n  reversed: false,\n  alternate: false,\n  autoplay: true,\n  duration: K,\n  delay: 0,\n  loopDelay: 0,\n  ease: 'out(2)',\n  composition: compositionTypes.replace,\n  modifier: v => v,\n  onBegin: noop,\n  onBeforeUpdate: noop,\n  onUpdate: noop,\n  onLoop: noop,\n  onPause: noop,\n  onComplete: noop,\n  onRender: noop,\n};\n\nconst scope = {\n  /** @type {Scope} */\n  current: null,\n  /** @type {Document|DOMTarget} */\n  root: doc,\n};\n\nconst globals = {\n  /** @type {DefaultsParams} */\n  defaults,\n  /** @type {Number} */\n  precision: 4,\n  /** @type {Number} equals 1 in ms mode, 0.001 in s mode */\n  timeScale: 1,\n  /** @type {Number} */\n  tickThreshold: 200,\n};\n\nconst globalVersions = { version: '4.1.4', engine: null };\n\nif (isBrowser) {\n  if (!win.AnimeJS) win.AnimeJS = [];\n  win.AnimeJS.push(globalVersions);\n}\n\n// Strings\n\n/**\n * @param  {String} str\n * @return {String}\n */\nconst toLowerCase = str => str.replace(lowerCaseRgx, '$1-$2').toLowerCase();\n\n/**\n * Prioritize this method instead of regex when possible\n * @param  {String} str\n * @param  {String} sub\n * @return {Boolean}\n */\nconst stringStartsWith = (str, sub) => str.indexOf(sub) === 0;\n\n// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.\nconst now = Date.now;\n\n// Types checkers\n\nconst isArr = Array.isArray;\n/**@param {any} a @return {a is Record<String, any>} */\nconst isObj = a => a && a.constructor === Object;\n/**@param {any} a @return {a is Number} */\nconst isNum = a => typeof a === 'number' && !isNaN(a);\n/**@param {any} a @return {a is String} */\nconst isStr = a => typeof a === 'string';\n/**@param {any} a @return {a is Function} */\nconst isFnc = a => typeof a === 'function';\n/**@param {any} a @return {a is undefined} */\nconst isUnd = a => typeof a === 'undefined';\n/**@param {any} a @return {a is null | undefined} */\nconst isNil = a => isUnd(a) || a === null;\n/**@param {any} a @return {a is SVGElement} */\nconst isSvg = a => isBrowser && a instanceof SVGElement;\n/**@param {any} a @return {Boolean} */\nconst isHex = a => hexTestRgx.test(a);\n/**@param {any} a @return {Boolean} */\nconst isRgb = a => stringStartsWith(a, 'rgb');\n/**@param {any} a @return {Boolean} */\nconst isHsl = a => stringStartsWith(a, 'hsl');\n/**@param {any} a @return {Boolean} */\nconst isCol = a => isHex(a) || isRgb(a) || isHsl(a);\n/**@param {any} a @return {Boolean} */\nconst isKey = a => !globals.defaults.hasOwnProperty(a);\n\n// Number\n\n/**\n * @param  {Number|String} str\n * @return {Number}\n */\nconst parseNumber = str => isStr(str) ?\n  parseFloat(/** @type {String} */(str)) :\n  /** @type {Number} */(str);\n\n// Math\n\nconst pow = Math.pow;\nconst sqrt = Math.sqrt;\nconst sin = Math.sin;\nconst cos = Math.cos;\nconst abs = Math.abs;\nconst exp = Math.exp;\nconst ceil = Math.ceil;\nconst floor = Math.floor;\nconst asin = Math.asin;\nconst max = Math.max;\nconst atan2 = Math.atan2;\nconst PI = Math.PI;\nconst _round = Math.round;\n\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */\nconst clamp = (v, min, max) => v < min ? min : v > max ? max : v;\n\nconst powCache = {};\n\n/**\n * @param  {Number} v\n * @param  {Number} decimalLength\n * @return {Number}\n */\nconst round = (v, decimalLength) => {\n  if (decimalLength < 0) return v;\n  if (!decimalLength) return _round(v);\n  let p = powCache[decimalLength];\n  if (!p) p = powCache[decimalLength] = 10 ** decimalLength;\n  return _round(v * p) / p;\n};\n\n/**\n * @param  {Number} v\n * @param  {Number|Array<Number>} increment\n * @return {Number}\n */\nconst snap = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => (abs(cv - v) < abs(closest - v) ? cv : closest)) : increment ? _round(v / increment) * increment : v;\n\n/**\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} progress\n * @return {Number}\n */\nconst interpolate = (start, end, progress) => start + (end - start) * progress;\n\n/**\n * @param  {Number} min\n * @param  {Number} max\n * @param  {Number} [decimalLength]\n * @return {Number}\n */\nconst random = (min, max, decimalLength) => { const m = 10 ** (decimalLength || 0); return floor((Math.random() * (max - min + (1 / m)) + min) * m) / m };\n\n/**\n * Adapted from https://bost.ocks.org/mike/shuffle/\n * @param  {Array} items\n * @return {Array}\n */\nconst shuffle = items => {\n  let m = items.length, t, i;\n  while (m) { i = random(0, --m); t = items[m]; items[m] = items[i]; items[i] = t; }\n  return items;\n};\n\n/**\n * @param  {Number} v\n * @return {Number}\n */\nconst clampInfinity = v => v === Infinity ? maxValue : v === -Infinity ? -maxValue : v;\n\n/**\n * @param  {Number} v\n * @return {Number}\n */\nconst normalizeTime = v => v <= minValue ? minValue : clampInfinity(round(v, 11));\n\n// Arrays\n\n/**\n * @template T\n * @param {T[]} a\n * @return {T[]}\n */\nconst cloneArray = a => isArr(a) ? [ ...a ] : a;\n\n// Objects\n\n/**\n * @template T\n * @template U\n * @param {T} o1\n * @param {U} o2\n * @return {T & U}\n */\nconst mergeObjects = (o1, o2) => {\n  const merged = /** @type {T & U} */({ ...o1 });\n  for (let p in o2) {\n    const o1p = /** @type {T & U} */(o1)[p];\n    merged[p] = isUnd(o1p) ? /** @type {T & U} */(o2)[p] : o1p;\n  }  return merged;\n};\n\n// Linked lists\n\n/**\n * @param {Object} parent\n * @param {Function} callback\n * @param {Boolean} [reverse]\n * @param {String} [prevProp]\n * @param {String} [nextProp]\n * @return {void}\n */\nconst forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {\n  let next = parent._head;\n  let adjustedNextProp = nextProp;\n  if (reverse) {\n    next = parent._tail;\n    adjustedNextProp = prevProp;\n  }\n  while (next) {\n    const currentNext = next[adjustedNextProp];\n    callback(next);\n    next = currentNext;\n  }\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {String} [prevProp]\n * @param  {String} [nextProp]\n * @return {void}\n */\nconst removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {\n  const prev = child[prevProp];\n  const next = child[nextProp];\n  prev ? prev[nextProp] = next : parent._head = next;\n  next ? next[prevProp] = prev : parent._tail = prev;\n  child[prevProp] = null;\n  child[nextProp] = null;\n};\n\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {Function} [sortMethod]\n * @param  {String} prevProp\n * @param  {String} nextProp\n * @return {void}\n */\nconst addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {\n  let prev = parent._tail;\n  while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];\n  const next = prev ? prev[nextProp] : parent._head;\n  prev ? prev[nextProp] = child : parent._head = child;\n  next ? next[prevProp] = child : parent._tail = child;\n  child[prevProp] = prev;\n  child[nextProp] = next;\n};\n\n/**\n * @param  {(...args: any[]) => Tickable | ((...args: any[]) => void)} constructor\n * @return {(...args: any[]) => Tickable | ((...args: any[]) => void)}\n */\nconst createRefreshable = constructor => {\n  /** @type {Tickable} */\n  let tracked;\n  return (...args) => {\n    let currentIteration, currentIterationProgress, reversed, alternate;\n    if (tracked) {\n      currentIteration = tracked.currentIteration;\n      currentIterationProgress = tracked.iterationProgress;\n      reversed = tracked.reversed;\n      alternate = tracked._alternate;\n      tracked.revert();\n    }\n    const cleanup = constructor(...args);\n    if (cleanup && !isFnc(cleanup) && cleanup.revert) tracked = cleanup;\n    if (!isUnd(currentIterationProgress)) {\n      /** @type {Tickable} */(tracked).currentIteration = currentIteration;\n      /** @type {Tickable} */(tracked).iterationProgress = (alternate ? !(currentIteration % 2) ? reversed : !reversed : reversed) ? 1 - currentIterationProgress : currentIterationProgress;\n    }\n    return cleanup || noop;\n  }\n};\n\n/*\n * Base class to control framerate and playback rate.\n * Inherited by Engine, Timer, Animation and Timeline.\n */\nclass Clock {\n\n  /** @param {Number} [initTime] */\n  constructor(initTime = 0) {\n    /** @type {Number} */\n    this.deltaTime = 0;\n    /** @type {Number} */\n    this._currentTime = initTime;\n    /** @type {Number} */\n    this._elapsedTime = initTime;\n    /** @type {Number} */\n    this._startTime = initTime;\n    /** @type {Number} */\n    this._lastTime = initTime;\n    /** @type {Number} */\n    this._scheduledTime = 0;\n    /** @type {Number} */\n    this._frameDuration = round(K / maxFps, 0);\n    /** @type {Number} */\n    this._fps = maxFps;\n    /** @type {Number} */\n    this._speed = 1;\n    /** @type {Boolean} */\n    this._hasChildren = false;\n    /** @type {Tickable|Tween} */\n    this._head = null;\n    /** @type {Tickable|Tween} */\n    this._tail = null;\n  }\n\n  get fps() {\n    return this._fps;\n  }\n\n  set fps(frameRate) {\n    const previousFrameDuration = this._frameDuration;\n    const fr = +frameRate;\n    const fps = fr < minValue ? minValue : fr;\n    const frameDuration = round(K / fps, 0);\n    this._fps = fps;\n    this._frameDuration = frameDuration;\n    this._scheduledTime += frameDuration - previousFrameDuration;\n  }\n\n  get speed() {\n    return this._speed;\n  }\n\n  set speed(playbackRate) {\n    const pbr = +playbackRate;\n    this._speed = pbr < minValue ? minValue : pbr;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {tickModes}\n   */\n  requestTick(time) {\n    const scheduledTime = this._scheduledTime;\n    const elapsedTime = this._elapsedTime;\n    this._elapsedTime += (time - elapsedTime);\n    // If the elapsed time is lower than the scheduled time\n    // this means not enough time has passed to hit one frameDuration\n    // so skip that frame\n    if (elapsedTime < scheduledTime) return tickModes.NONE;\n    const frameDuration = this._frameDuration;\n    const frameDelta = elapsedTime - scheduledTime;\n    // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.\n    // Skips ahead if the actual elapsed time is higher.\n    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;\n    return tickModes.AUTO;\n  }\n\n  /**\n   * @param  {Number} time\n   * @return {Number}\n   */\n  computeDeltaTime(time) {\n    const delta = time - this._lastTime;\n    this.deltaTime = delta;\n    this._lastTime = time;\n    return delta;\n  }\n\n}\n\n\n\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {tickModes} tickMode\n * @return {Number}\n */\nconst render = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n\n  const parent = tickable.parent;\n  const duration = tickable.duration;\n  const completed = tickable.completed;\n  const iterationDuration = tickable.iterationDuration;\n  const iterationCount = tickable.iterationCount;\n  const _currentIteration = tickable._currentIteration;\n  const _loopDelay = tickable._loopDelay;\n  const _reversed = tickable._reversed;\n  const _alternate = tickable._alternate;\n  const _hasChildren = tickable._hasChildren;\n  const tickableDelay = tickable._delay;\n  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime\n\n  const tickableEndTime = tickableDelay + iterationDuration;\n  const tickableAbsoluteTime = time - tickableDelay;\n  const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);\n  const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);\n  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;\n  const isCurrentTimeAboveZero = tickableCurrentTime > 0;\n  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;\n  const isSetter = duration <= minValue;\n  const forcedTick = tickMode === tickModes.FORCE;\n\n  let isOdd = 0;\n  let iterationElapsedTime = tickableAbsoluteTime;\n  // Render checks\n  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer\n  let hasRendered = 0;\n\n  // Execute the \"expensive\" iterations calculations only when necessary\n  if (iterationCount > 1) {\n    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers\n    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));\n    tickable._currentIteration = clamp(currentIteration, 0, iterationCount);\n    // Prevent the iteration count to go above the max iterations when reaching the end of the animation\n    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;\n    isOdd = tickable._currentIteration % 2;\n    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;\n  }\n\n  // Checks if exactly one of _reversed and (_alternate && isOdd) is true\n  const isReversed = _reversed ^ (_alternate && isOdd);\n  const _ease = /** @type {Renderable} */(tickable)._ease;\n  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;\n  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;\n  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;\n\n  tickable._currentTime = tickableAbsoluteTime;\n  tickable._iterationTime = iterationTime;\n  tickable.backwards = isRunningBackwards;\n\n  if (isCurrentTimeAboveZero && !tickable.began) {\n    tickable.began = true;\n    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n      tickable.onBegin(/** @type {CallbackArgument} */(tickable));\n    }\n  } else if (tickableAbsoluteTime <= 0) {\n    tickable.began = false;\n  }\n\n  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function\n  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values\n  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {\n    tickable.onLoop(/** @type {CallbackArgument} */(tickable));\n  }\n\n  if (\n    forcedTick ||\n    tickMode === tickModes.AUTO && (\n      time >= tickableDelay && time <= tickableEndTime || // Normal render\n      time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state\n      time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state\n    ) ||\n    iterationTime >= tickableEndTime && tickablePrevTime !== duration ||\n    iterationTime <= tickableDelay && tickablePrevTime > 0 ||\n    time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation\n    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped\n  ) {\n\n    if (isCurrentTimeAboveZero) {\n      // Trigger onUpdate callback before rendering\n      tickable.computeDeltaTime(tickablePrevTime);\n      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n    // Start tweens rendering\n    if (!_hasChildren) {\n\n      // Time has jumped more than globals.tickThreshold so consider this tick manual\n      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;\n      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;\n\n      // Only Animation can have tweens, Timer returns undefined\n      let tween = /** @type {Tween} */(/** @type {JSAnimation} */(tickable)._head);\n      let tweenTarget;\n      let tweenStyle;\n      let tweenTargetTransforms;\n      let tweenTargetTransformsProperties;\n      let tweenTransformsNeedUpdate = 0;\n\n      while (tween) {\n\n        const tweenComposition = tween._composition;\n        const tweenCurrentTime = tween._currentTime;\n        const tweenChangeDuration = tween._changeDuration;\n        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;\n        const tweenNextRep = tween._nextRep;\n        const tweenPrevRep = tween._prevRep;\n        const tweenHasComposition = tweenComposition !== compositionTypes.none;\n\n        if ((forcedRender || (\n            (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&\n            (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)\n          )) && (!tweenHasComposition || (\n            !tween._isOverridden &&\n            (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&\n            (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&\n            (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))\n          ))\n        ) {\n\n          const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);\n          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);\n          const tweenModifier = tween._modifier;\n          const tweenValueType = tween._valueType;\n          const tweenType = tween._tweenType;\n          const tweenIsObject = tweenType === tweenTypes.OBJECT;\n          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;\n          // Only round the in-between frames values if the final value is a string\n          const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;\n\n          // Recompose tween value\n          /** @type {String|Number} */\n          let value;\n          /** @type {Number} */\n          let number;\n\n          if (tweenIsNumber) {\n            value = number = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision )));\n          } else if (tweenValueType === valueTypes.UNIT) {\n            // Rounding the values speed up string composition\n            number = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision)));\n            value = `${number}${tween._unit}`;\n          } else if (tweenValueType === valueTypes.COLOR) {\n            const fn = tween._fromNumbers;\n            const tn = tween._toNumbers;\n            const r = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[0], tn[0], tweenProgress))), 0, 255), 0);\n            const g = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[1], tn[1], tweenProgress))), 0, 255), 0);\n            const b = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[2], tn[2], tweenProgress))), 0, 255), 0);\n            const a = clamp(/** @type {Number} */(tweenModifier(round(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);\n            value = `rgba(${r},${g},${b},${a})`;\n            if (tweenHasComposition) {\n              const ns = tween._numbers;\n              ns[0] = r;\n              ns[1] = g;\n              ns[2] = b;\n              ns[3] = a;\n            }\n          } else if (tweenValueType === valueTypes.COMPLEX) {\n            value = tween._strings[0];\n            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {\n              const n = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));\n              const s = tween._strings[j + 1];\n              value += `${s ? n + s : n}`;\n              if (tweenHasComposition) {\n                tween._numbers[j] = n;\n              }\n            }\n          }\n\n          // For additive tweens and Animatables\n          if (tweenHasComposition) {\n            tween._number = number;\n          }\n\n          if (!internalRender && tweenComposition !== compositionTypes.blend) {\n\n            const tweenProperty = tween.property;\n            tweenTarget = tween.target;\n\n            if (tweenIsObject) {\n              tweenTarget[tweenProperty] = value;\n            } else if (tweenType === tweenTypes.ATTRIBUTE) {\n              /** @type {DOMTarget} */(tweenTarget).setAttribute(tweenProperty, /** @type {String} */(value));\n            } else {\n              tweenStyle = /** @type {DOMTarget} */(tweenTarget).style;\n              if (tweenType === tweenTypes.TRANSFORM) {\n                if (tweenTarget !== tweenTargetTransforms) {\n                  tweenTargetTransforms = tweenTarget;\n                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.\n                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];\n                }\n                tweenTargetTransformsProperties[tweenProperty] = value;\n                tweenTransformsNeedUpdate = 1;\n              } else if (tweenType === tweenTypes.CSS) {\n                tweenStyle[tweenProperty] = value;\n              } else if (tweenType === tweenTypes.CSS_VAR) {\n                tweenStyle.setProperty(tweenProperty,/** @type {String} */(value));\n              }\n            }\n\n            if (isCurrentTimeAboveZero) hasRendered = 1;\n\n          } else {\n            // Used for composing timeline tweens without having to do a real render\n            tween._value = value;\n          }\n\n        }\n\n        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax\n        // to reduce memory usage on string composition\n        if (tweenTransformsNeedUpdate && tween._renderTransforms) {\n          let str = emptyString;\n          for (let key in tweenTargetTransformsProperties) {\n            str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;\n          }\n          tweenStyle.transform = str;\n          tweenTransformsNeedUpdate = 0;\n        }\n\n        tween = tween._next;\n      }\n\n      if (!muteCallbacks && hasRendered) {\n        /** @type {JSAnimation} */(tickable).onRender(/** @type {JSAnimation} */(tickable));\n      }\n    }\n\n    if (!muteCallbacks && isCurrentTimeAboveZero) {\n      tickable.onUpdate(/** @type {CallbackArgument} */(tickable));\n    }\n\n  }\n\n  // End tweens rendering\n\n  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards\n  if (parent && isSetter) {\n    if (!muteCallbacks && (\n      (parent.began && !isRunningBackwards && tickableAbsoluteTime >= duration && !completed) ||\n      (isRunningBackwards && tickableAbsoluteTime <= minValue && completed)\n    )) {\n      tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n      tickable.completed = !isRunningBackwards;\n    }\n  // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops\n  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {\n    if (iterationCount === Infinity) {\n      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer\n      tickable._startTime += tickable.duration;\n    } else if (tickable._currentIteration >= iterationCount - 1) {\n      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick\n      tickable.paused = true;\n      if (!completed && !_hasChildren) {\n        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function\n        tickable.completed = true;\n        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n          tickable.onComplete(/** @type {CallbackArgument} */(tickable));\n          tickable._resolve(/** @type {CallbackArgument} */(tickable));\n        }\n      }\n    }\n  // Otherwise set the completed flag to false\n  } else {\n    tickable.completed = false;\n  }\n\n  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?\n  return hasRendered;\n};\n\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {Number} tickMode\n * @return {void}\n */\nconst tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {\n  const _currentIteration = tickable._currentIteration;\n  render(tickable, time, muteCallbacks, internalRender, tickMode);\n  if (tickable._hasChildren) {\n    const tl = /** @type {Timeline} */(tickable);\n    const tlIsRunningBackwards = tl.backwards;\n    const tlChildrenTime = internalRender ? time : tl._iterationTime;\n    const tlCildrenTickTime = now();\n\n    let tlChildrenHasRendered = 0;\n    let tlChildrenHaveCompleted = true;\n\n    // If the timeline has looped forward, we need to manually triggers children skipped callbacks\n    if (!internalRender && tl._currentIteration !== _currentIteration) {\n      const tlIterationDuration = tl.iterationDuration;\n      forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n        if (!tlIsRunningBackwards) {\n          // Force an internal render to trigger the callbacks if the child has not completed on loop\n          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {\n            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);\n          }\n          // Reset their began and completed flags to allow retrigering callbacks on the next iteration\n          child.began = false;\n          child.completed = false;\n        } else {\n          const childDuration = child.duration;\n          const childStartTime = child._offset + child._delay;\n          const childEndTime = childStartTime + childDuration;\n          // Triggers the onComplete callback on reverse for children on the edges of the timeline\n          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {\n            child.onComplete(child);\n          }\n        }\n      });\n      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */(tl));\n    }\n\n    forEachChildren(tl, (/** @type {JSAnimation} */child) => {\n      const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds\n      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;\n      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);\n      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;\n    }, tlIsRunningBackwards);\n\n    // Renders on timeline are triggered by its children so it needs to be set after rendering the children\n    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */(tl));\n\n    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end\n    if ((tlChildrenHaveCompleted || tlIsRunningBackwards) && tl._currentTime >= tl.duration) {\n      // Make sure the paused flag is false in case it has been skipped in the render function\n      tl.paused = true;\n      if (!tl.completed) {\n        tl.completed = true;\n        if (!muteCallbacks) {\n          tl.onComplete(/** @type {CallbackArgument} */(tl));\n          tl._resolve(/** @type {CallbackArgument} */(tl));\n        }\n      }\n    }\n  }\n};\n\n\n\n\nconst additive = {\n  animation: null,\n  update: noop,\n};\n\n/**\n * @typedef AdditiveAnimation\n * @property {Number} duration\n * @property {Number} _offset\n * @property {Number} _delay\n * @property {Tween} _head\n * @property {Tween} _tail\n */\n\n/**\n * @param  {TweenAdditiveLookups} lookups\n * @return {AdditiveAnimation}\n */\nconst addAdditiveAnimation = lookups => {\n  let animation = additive.animation;\n  if (!animation) {\n    animation = {\n      duration: minValue,\n      computeDeltaTime: noop,\n      _offset: 0,\n      _delay: 0,\n      _head: null,\n      _tail: null,\n    };\n    additive.animation = animation;\n    additive.update = () => {\n      lookups.forEach(propertyAnimation => {\n        for (let propertyName in propertyAnimation) {\n          const tweens = propertyAnimation[propertyName];\n          const lookupTween = tweens._head;\n          if (lookupTween) {\n            const valueType = lookupTween._valueType;\n            const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;\n            let additiveValue = lookupTween._fromNumber;\n            let tween = tweens._tail;\n            while (tween && tween !== lookupTween) {\n              if (additiveValues) {\n                for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];\n              } else {\n                additiveValue += tween._number;\n              }\n              tween = tween._prevAdd;\n            }\n            lookupTween._toNumber = additiveValue;\n            lookupTween._toNumbers = additiveValues;\n          }\n        }\n      });\n      // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop\n      render(animation, 1, 1, 0, tickModes.FORCE);\n    };\n  }\n  return animation;\n};\n\nconst engineTickMethod = /*#__PURE__*/ (() => isBrowser ? requestAnimationFrame : setImmediate)();\nconst engineCancelMethod = /*#__PURE__*/ (() => isBrowser ? cancelAnimationFrame : clearImmediate)();\n\nclass Engine extends Clock {\n\n  /** @param {Number} [initTime] */\n  constructor(initTime) {\n    super(initTime);\n    this.useDefaultMainLoop = true;\n    this.pauseOnDocumentHidden = true;\n    /** @type {DefaultsParams} */\n    this.defaults = defaults;\n    // this.paused = isBrowser && doc.hidden ? true  : false;\n    this.paused = true;\n    /** @type {Number|NodeJS.Immediate} */\n    this.reqId = 0;\n  }\n\n  update() {\n    const time = this._currentTime = now();\n    if (this.requestTick(time)) {\n      this.computeDeltaTime(time);\n      const engineSpeed = this._speed;\n      const engineFps = this._fps;\n      let activeTickable = /** @type {Tickable} */(this._head);\n      while (activeTickable) {\n        const nextTickable = activeTickable._next;\n        if (!activeTickable.paused) {\n          tick(\n            activeTickable,\n            (time - activeTickable._startTime) * activeTickable._speed * engineSpeed,\n            0, // !muteCallbacks\n            0, // !internalRender\n            activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO\n          );\n        } else {\n          removeChild(this, activeTickable);\n          this._hasChildren = !!this._tail;\n          activeTickable._running = false;\n          if (activeTickable.completed && !activeTickable._cancelled) {\n            activeTickable.cancel();\n          }\n        }\n        activeTickable = nextTickable;\n      }\n      additive.update();\n    }\n  }\n\n  wake() {\n    if (this.useDefaultMainLoop && !this.reqId) {\n      // Imediatly request a tick to update engine._elapsedTime and get accurate offsetPosition calculation in timer.js\n      this.requestTick(now());\n      this.reqId = engineTickMethod(tickEngine);\n    }\n    return this;\n  }\n\n  pause() {\n    if (!this.reqId) return;\n    this.paused = true;\n    return killEngine();\n  }\n\n  resume() {\n    if (!this.paused) return;\n    this.paused = false;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.resetTime());\n    return this.wake();\n  }\n\n  // Getter and setter for speed\n  get speed() {\n    return this._speed * (globals.timeScale === 1 ? 1 : K);\n  }\n\n  set speed(playbackRate) {\n    this._speed = playbackRate * globals.timeScale;\n    forEachChildren(this, (/** @type {Tickable} */child) => child.speed = child._speed);\n  }\n\n  // Getter and setter for timeUnit\n  get timeUnit() {\n    return globals.timeScale === 1 ? 'ms' : 's';\n  };\n\n  set timeUnit(unit) {\n    const secondsScale = 0.001;\n    const isSecond = unit === 's';\n    const newScale = isSecond ? secondsScale : 1;\n    if (globals.timeScale !== newScale) {\n      globals.timeScale = newScale;\n      globals.tickThreshold = 200 * newScale;\n      const scaleFactor = isSecond ? secondsScale : K;\n      /** @type {Number} */\n      (this.defaults.duration) *= scaleFactor;\n      this._speed *= scaleFactor;\n    }\n  }\n\n  // Getter and setter for precision\n  get precision() {\n    return globals.precision;\n  }\n\n  set precision(precision) {\n    globals.precision = precision;\n  }\n\n}\nconst engine = /*#__PURE__*/(() => {\n  const engine = new Engine(now());\n  if (isBrowser) {\n    globalVersions.engine = engine;\n    doc.addEventListener('visibilitychange', () => {\n      if (!engine.pauseOnDocumentHidden) return;\n      doc.hidden ? engine.pause() : engine.resume();\n    });\n  }\n  return engine;\n})();\n\n\nconst tickEngine = () => {\n  if (engine._head) {\n    engine.reqId = engineTickMethod(tickEngine);\n    engine.update();\n  } else {\n    engine.reqId = 0;\n  }\n};\n\nconst killEngine = () => {\n  engineCancelMethod(/** @type {NodeJS.Immediate & Number} */(engine.reqId));\n  engine.reqId = 0;\n  return engine;\n};\n\n\n\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst parseInlineTransforms = (target, propName, animationInlineStyles) => {\n  const inlineTransforms = target.style.transform;\n  let inlinedStylesPropertyValue;\n  if (inlineTransforms) {\n    const cachedTransforms = target[transformsSymbol];\n    let t; while (t = transformsExecRgx.exec(inlineTransforms)) {\n      const inlinePropertyName = t[1];\n      // const inlinePropertyValue = t[2];\n      const inlinePropertyValue = t[2].slice(1, -1);\n      cachedTransforms[inlinePropertyName] = inlinePropertyValue;\n      if (inlinePropertyName === propName) {\n        inlinedStylesPropertyValue = inlinePropertyValue;\n        // Store the new parsed inline styles if animationInlineStyles is provided\n        if (animationInlineStyles) {\n          animationInlineStyles[propName] = inlinePropertyValue;\n        }\n      }\n    }\n  }\n  return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue :\n    stringStartsWith(propName, 'scale') ? '1' :\n    stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew') ? '0deg' : '0px';\n};\n\n\n\n\n/**\n * @param  {DOMTargetsParam|TargetsParam} v\n * @return {NodeList|HTMLCollection}\n */\nfunction getNodeList(v) {\n  const n = isStr(v) ? scope.root.querySelectorAll(v) : v;\n  if (n instanceof NodeList || n instanceof HTMLCollection) return n;\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction parseTargets(targets) {\n  if (isNil(targets)) return /** @type {TargetsArray} */([]);\n  if (!isBrowser) return /** @type {JSTargetsArray} */(isArr(targets) && targets.flat(Infinity) || [targets]);\n  if (isArr(targets)) {\n    const flattened = targets.flat(Infinity);\n    /** @type {TargetsArray} */\n    const parsed = [];\n    for (let i = 0, l = flattened.length; i < l; i++) {\n      const item = flattened[i];\n      if (!isNil(item)) {\n        const nodeList = getNodeList(item);\n        if (nodeList) {\n          for (let j = 0, jl = nodeList.length; j < jl; j++) {\n            const subItem = nodeList[j];\n            if (!isNil(subItem)) {\n              let isDuplicate = false;\n              for (let k = 0, kl = parsed.length; k < kl; k++) {\n                if (parsed[k] === subItem) {\n                  isDuplicate = true;\n                  break;\n                }\n              }\n              if (!isDuplicate) {\n                parsed.push(subItem);\n              }\n            }\n          }\n        } else {\n          let isDuplicate = false;\n          for (let j = 0, jl = parsed.length; j < jl; j++) {\n            if (parsed[j] === item) {\n              isDuplicate = true;\n              break;\n            }\n          }\n          if (!isDuplicate) {\n            parsed.push(item);\n          }\n        }\n      }\n    }\n    return parsed;\n  }\n  const nodeList = getNodeList(targets);\n  if (nodeList) return /** @type {DOMTargetsArray} */(Array.from(nodeList));\n  return /** @type {TargetsArray} */([targets]);\n}\n\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */\nfunction registerTargets(targets) {\n  const parsedTargetsArray = parseTargets(targets);\n  const parsedTargetsLength = parsedTargetsArray.length;\n  if (parsedTargetsLength) {\n    for (let i = 0; i < parsedTargetsLength; i++) {\n      const target = parsedTargetsArray[i];\n      if (!target[isRegisteredTargetSymbol]) {\n        target[isRegisteredTargetSymbol] = true;\n        const isSvgType = isSvg(target);\n        const isDom = /** @type {DOMTarget} */(target).nodeType || isSvgType;\n        if (isDom) {\n          target[isDomSymbol] = true;\n          target[isSvgSymbol] = isSvgType;\n          target[transformsSymbol] = {};\n        }\n      }\n    }\n  }\n  return parsedTargetsArray;\n}\n\n\n\n\n/**\n * @param  {TargetsParam} path\n * @return {SVGGeometryElement|undefined}\n */\nconst getPath = path => {\n  const parsedTargets = parseTargets(path);\n  const $parsedSvg = /** @type {SVGGeometryElement} */(parsedTargets[0]);\n  if (!$parsedSvg || !isSvg($parsedSvg)) return;\n  return $parsedSvg;\n};\n\n/**\n * @param  {TargetsParam} path2\n * @param  {Number} [precision]\n * @return {FunctionValue}\n */\nconst morphTo = (path2, precision = .33) => ($path1) => {\n  const $path2 = /** @type {SVGGeometryElement} */(getPath(path2));\n  if (!$path2) return;\n  const isPath = $path1.tagName === 'path';\n  const separator = isPath ? ' ' : ',';\n  const previousPoints = $path1[morphPointsSymbol];\n  if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);\n\n  let v1 = '', v2 = '';\n\n  if (!precision) {\n    v1 = $path1.getAttribute(isPath ? 'd' : 'points');\n    v2 = $path2.getAttribute(isPath ? 'd' : 'points');\n  } else {\n    const length1 = /** @type {SVGGeometryElement} */($path1).getTotalLength();\n    const length2 = $path2.getTotalLength();\n    const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));\n    for (let i = 0; i < maxPoints; i++) {\n      const t = i / (maxPoints - 1);\n      const pointOnPath1 = /** @type {SVGGeometryElement} */($path1).getPointAtLength(length1 * t);\n      const pointOnPath2 = $path2.getPointAtLength(length2 * t);\n      const prefix = isPath ? (i === 0 ? 'M' : 'L') : '';\n      v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';\n      v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';\n    }\n  }\n\n  $path1[morphPointsSymbol] = v2;\n\n  return [v1, v2];\n};\n\n/**\n * @param {SVGGeometryElement} [$el]\n * @return {Number}\n */\nconst getScaleFactor = $el => {\n  let scaleFactor = 1;\n  if ($el && $el.getCTM) {\n    const ctm = $el.getCTM();\n    if (ctm) {\n      const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);\n      const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);\n      scaleFactor = (scaleX + scaleY) / 2;\n    }\n  }\n  return scaleFactor;\n};\n\n/**\n * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.\n * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable\n * @param {number} start - Starting position (0-1)\n * @param {number} end - Ending position (0-1)\n * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality\n */\nconst createDrawableProxy = ($el, start, end) => {\n  const pathLength = K;\n  const computedStyles = getComputedStyle($el);\n  const strokeLineCap = computedStyles.strokeLinecap;\n  // @ts-ignore\n  const $scalled = computedStyles.vectorEffect === 'non-scaling-stroke' ? $el : null;\n  let currentCap = strokeLineCap;\n\n  const proxy = new Proxy($el, {\n    get(target, property) {\n      const value = target[property];\n      if (property === proxyTargetSymbol) return target;\n      if (property === 'setAttribute') {\n        return (...args) => {\n          if (args[0] === 'draw') {\n            const value = args[1];\n            const values = value.split(' ');\n            const v1 = +values[0];\n            const v2 = +values[1];\n            // TOTO: Benchmark if performing two slices is more performant than one split\n            // const spaceIndex = value.indexOf(' ');\n            // const v1 = round(+value.slice(0, spaceIndex), precision);\n            // const v2 = round(+value.slice(spaceIndex + 1), precision);\n            const scaleFactor = getScaleFactor($scalled);\n            const os = v1 * -pathLength * scaleFactor;\n            const d1 = (v2 * pathLength * scaleFactor) + os;\n            const d2 = (pathLength * scaleFactor +\n                      ((v1 === 0 && v2 === 1) || (v1 === 1 && v2 === 0) ? 0 : 10 * scaleFactor) - d1);\n            if (strokeLineCap !== 'butt') {\n              const newCap = v1 === v2 ? 'butt' : strokeLineCap;\n              if (currentCap !== newCap) {\n                target.style.strokeLinecap = `${newCap}`;\n                currentCap = newCap;\n              }\n            }\n            target.setAttribute('stroke-dashoffset', `${os}`);\n            target.setAttribute('stroke-dasharray', `${d1} ${d2}`);\n          }\n          return Reflect.apply(value, target, args);\n        };\n      }\n\n      if (isFnc(value)) {\n        return (...args) => Reflect.apply(value, target, args);\n      } else {\n        return value;\n      }\n    }\n  });\n\n  if ($el.getAttribute('pathLength') !== `${pathLength}`) {\n    $el.setAttribute('pathLength', `${pathLength}`);\n    proxy.setAttribute('draw', `${start} ${end}`);\n  }\n\n  return /** @type {DrawableSVGGeometry} */(proxy);\n};\n\n/**\n * Creates drawable proxies for multiple SVG elements.\n * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors\n * @param {number} [start=0] - Starting position (0-1)\n * @param {number} [end=0] - Ending position (0-1)\n * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality\n */\nconst createDrawable = (selector, start = 0, end = 0) => {\n  const els = parseTargets(selector);\n  return els.map($el => createDrawableProxy(\n    /** @type {SVGGeometryElement} */($el),\n    start,\n    end\n  ));\n};\n\n// Motion path animation\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {Number} progress\n * @param {Number}lookup\n * @return {DOMPoint}\n */\nconst getPathPoint = ($path, progress, lookup = 0) => {\n  return $path.getPointAtLength(progress + lookup >= 1 ? progress + lookup : 0);\n};\n\n/**\n * @param {SVGGeometryElement} $path\n * @param {String} pathProperty\n * @return {FunctionValue}\n */\nconst getPathProgess = ($path, pathProperty) => {\n  return $el => {\n    const totalLength = +($path.getTotalLength());\n    const inSvg = $el[isSvgSymbol];\n    const ctm = $path.getCTM();\n    /** @type {TweenObjectValue} */\n    return {\n      from: 0,\n      to: totalLength,\n      /** @type {TweenModifier} */\n      modifier: progress => {\n        if (pathProperty === 'a') {\n          const p0 = getPathPoint($path, progress, -1);\n          const p1 = getPathPoint($path, progress, 1);\n          return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;\n        } else {\n          const p = getPathPoint($path, progress, 0);\n          return pathProperty === 'x' ?\n            inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e :\n            inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {TargetsParam} path\n */\nconst createMotionPath = path => {\n  const $path = getPath(path);\n  if (!$path) return;\n  return {\n    translateX: getPathProgess($path, 'x'),\n    translateY: getPathProgess($path, 'y'),\n    rotate: getPathProgess($path, 'a'),\n  }\n};\n\n// Check for valid SVG attribute\n\nconst cssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];\n\n/**\n * @param  {Target} el\n * @param  {String} propertyName\n * @return {Boolean}\n */\nconst isValidSVGAttribute = (el, propertyName) => {\n  // Return early and use CSS opacity animation instead (already better default values (opacity: 1 instead of 0)) and rotate should be considered a transform\n  if (cssReservedProperties.includes(propertyName)) return false;\n  if (el.getAttribute(propertyName) || propertyName in el) {\n    if (propertyName === 'scale') { // Scale\n      const elParentNode = /** @type {SVGGeometryElement} */(/** @type {DOMTarget} */(el).parentNode);\n      // Only consider scale as a valid SVG attribute on filter element\n      return elParentNode && elParentNode.tagName === 'filter';\n    }\n    return true;\n  }\n};\n\nconst svg = {\n  morphTo,\n  createMotionPath,\n  createDrawable,\n};\n\n\n\n\n/**\n * RGB / RGBA Color value string -> RGBA values array\n * @param  {String} rgbValue\n * @return {ColorArray}\n */\nconst rgbToRgba = rgbValue => {\n  const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);\n  const a = !isUnd(rgba[4]) ? +rgba[4] : 1;\n  return [\n    +rgba[1],\n    +rgba[2],\n    +rgba[3],\n    a\n  ]\n};\n\n/**\n * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array\n * @param  {String} hexValue\n * @return {ColorArray}\n */\nconst hexToRgba = hexValue => {\n  const hexLength = hexValue.length;\n  const isShort = hexLength === 4 || hexLength === 5;\n  return [\n    +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),\n    +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),\n    +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),\n    ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)\n  ]\n};\n\n/**\n * @param  {Number} p\n * @param  {Number} q\n * @param  {Number} t\n * @return {Number}\n */\nconst hue2rgb = (p, q, t) => {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  return t < 1 / 6 ? p + (q - p) * 6 * t :\n         t < 1 / 2 ? q :\n         t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :\n         p;\n};\n\n/**\n * HSL / HSLA Color value string -> RGBA values array\n * @param  {String} hslValue\n * @return {ColorArray}\n */\nconst hslToRgba = hslValue => {\n  const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);\n  const h = +hsla[1] / 360;\n  const s = +hsla[2] / 100;\n  const l = +hsla[3] / 100;\n  const a = !isUnd(hsla[4]) ? +hsla[4] : 1;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = l;\n  } else {\n    const q = l < .5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);\n    g = round(hue2rgb(p, q, h) * 255, 0);\n    b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);\n  }\n  return [r, g, b, a];\n};\n\n/**\n * All in one color converter that converts a color string value into an array of RGBA values\n * @param  {String} colorString\n * @return {ColorArray}\n */\nconst convertColorStringValuesToRgbaArray = colorString => {\n  return isRgb(colorString) ? rgbToRgba(colorString) :\n         isHex(colorString) ? hexToRgba(colorString) :\n         isHsl(colorString) ? hslToRgba(colorString) :\n         [0, 0, 0, 1];\n};\n\n\n\n\n/**\n * @template T, D\n * @param {T|undefined} targetValue\n * @param {D} defaultValue\n * @return {T|D}\n */\nconst setValue = (targetValue, defaultValue) => {\n  return isUnd(targetValue) ? defaultValue : targetValue;\n};\n\n/**\n * @param  {TweenPropValue} value\n * @param  {Target} target\n * @param  {Number} index\n * @param  {Number} total\n * @param  {Object} [store]\n * @return {any}\n */\nconst getFunctionValue = (value, target, index, total, store) => {\n  if (isFnc(value)) {\n    const func = () => {\n      const computed = /** @type {Function} */(value)(target, index, total);\n      // Fallback to 0 if the function returns undefined / NaN / null / false / 0\n      return !isNaN(+computed) ? +computed : computed || 0;\n    };\n    if (store) {\n      store.func = func;\n    }\n    return func();\n  } else {\n    return value;\n  }\n};\n\n/**\n * @param  {Target} target\n * @param  {String} prop\n * @return {tweenTypes}\n */\nconst getTweenType = (target, prop) => {\n  return !target[isDomSymbol] ? tweenTypes.OBJECT :\n    // Handle SVG attributes\n    target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE :\n    // Handle CSS Transform properties differently than CSS to allow individual animations\n    validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM :\n    // CSS variables\n    stringStartsWith(prop, '--') ? tweenTypes.CSS_VAR :\n    // All other CSS properties\n    prop in /** @type {DOMTarget} */(target).style ? tweenTypes.CSS :\n    // Handle other DOM Attributes\n    prop in target ? tweenTypes.OBJECT :\n    tweenTypes.ATTRIBUTE;\n};\n\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */\nconst getCSSValue = (target, propName, animationInlineStyles) => {\n  const inlineStyles = target.style[propName];\n  if (inlineStyles && animationInlineStyles) {\n    animationInlineStyles[propName] = inlineStyles;\n  }\n  const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);\n  return value === 'auto' ? '0' : value;\n};\n\n/**\n * @param {Target} target\n * @param {String} propName\n * @param {tweenTypes} [tweenType]\n * @param {Object|void} [animationInlineStyles]\n * @return {String|Number}\n */\nconst getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {\n  const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);\n  return type === tweenTypes.OBJECT ? target[propName] || 0 :\n         type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */(target).getAttribute(propName) :\n         type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */(target), propName, animationInlineStyles) :\n         type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles).trimStart() :\n         getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles);\n};\n\n/**\n * @param  {Number} x\n * @param  {Number} y\n * @param  {String} operator\n * @return {Number}\n */\nconst getRelativeValue = (x, y, operator) => {\n  return operator === '-' ? x - y :\n         operator === '+' ? x + y :\n         x * y;\n};\n\n/** @return {TweenDecomposedValue} */\nconst createDecomposedValueTargetObject = () => {\n  return {\n    /** @type {valueTypes} */\n    t: valueTypes.NUMBER,\n    n: 0,\n    u: null,\n    o: null,\n    d: null,\n    s: null,\n  }\n};\n\n/**\n * @param  {String|Number} rawValue\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeRawValue = (rawValue, targetObject) => {\n  /** @type {valueTypes} */\n  targetObject.t = valueTypes.NUMBER;\n  targetObject.n = 0;\n  targetObject.u = null;\n  targetObject.o = null;\n  targetObject.d = null;\n  targetObject.s = null;\n  if (!rawValue) return targetObject;\n  const num = +rawValue;\n  if (!isNaN(num)) {\n    // It's a number\n    targetObject.n = num;\n    return targetObject;\n  } else {\n    // let str = /** @type {String} */(rawValue).trim();\n    let str = /** @type {String} */(rawValue);\n    // Parsing operators (+=, -=, *=) manually is much faster than using regex here\n    if (str[1] === '=') {\n      targetObject.o = str[0];\n      str = str.slice(2);\n    }\n    // Skip exec regex if the value type is complex or color to avoid long regex backtracking\n    const unitMatch = str.includes(' ') ? false : unitsExecRgx.exec(str);\n    if (unitMatch) {\n      // Has a number and a unit\n      targetObject.t = valueTypes.UNIT;\n      targetObject.n = +unitMatch[1];\n      targetObject.u = unitMatch[2];\n      return targetObject;\n    } else if (targetObject.o) {\n      // Has an operator (+=, -=, *=)\n      targetObject.n = +str;\n      return targetObject;\n    } else if (isCol(str)) {\n      // Is a color\n      targetObject.t = valueTypes.COLOR;\n      targetObject.d = convertColorStringValuesToRgbaArray(str);\n      return targetObject;\n    } else {\n      // Is a more complex string (generally svg coords, calc() or filters CSS values)\n      const matchedNumbers = str.match(digitWithExponentRgx);\n      targetObject.t = valueTypes.COMPLEX;\n      targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];\n      targetObject.s = str.split(digitWithExponentRgx) || [];\n      return targetObject;\n    }\n  }\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */\nconst decomposeTweenValue = (tween, targetObject) => {\n  targetObject.t = tween._valueType;\n  targetObject.n = tween._toNumber;\n  targetObject.u = tween._unit;\n  targetObject.o = null;\n  targetObject.d = cloneArray(tween._toNumbers);\n  targetObject.s = cloneArray(tween._strings);\n  return targetObject;\n};\n\nconst decomposedOriginalValue = createDecomposedValueTargetObject();\n\n\n\n\nconst lookups = {\n  /** @type {TweenReplaceLookups} */\n  _rep: new WeakMap(),\n  /** @type {TweenAdditiveLookups} */\n  _add: new Map(),\n};\n\n/**\n * @param  {Target} target\n * @param  {String} property\n * @param  {String} lookup\n * @return {TweenPropertySiblings}\n */\nconst getTweenSiblings = (target, property, lookup = '_rep') => {\n  const lookupMap = lookups[lookup];\n  let targetLookup = lookupMap.get(target);\n  if (!targetLookup) {\n    targetLookup = {};\n    lookupMap.set(target, targetLookup);\n  }\n  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {\n    _head: null,\n    _tail: null,\n  }\n};\n\n/**\n * @param  {Tween} p\n * @param  {Tween} c\n * @return {Number|Boolean}\n */\nconst addTweenSortMethod = (p, c) => {\n  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;\n};\n\n/**\n * @param {Tween} tween\n */\nconst overrideTween = tween => {\n  tween._isOverlapped = 1;\n  tween._isOverridden = 1;\n  tween._changeDuration = minValue;\n  tween._currentTime = minValue;\n};\n\n/**\n * @param  {Tween} tween\n * @param  {TweenPropertySiblings} siblings\n * @return {Tween}\n */\nconst composeTween = (tween, siblings) => {\n\n  const tweenCompositionType = tween._composition;\n\n  // Handle replaced tweens\n\n  if (tweenCompositionType === compositionTypes.replace) {\n\n    const tweenAbsStartTime = tween._absoluteStartTime;\n\n    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');\n\n    const prevSibling = tween._prevRep;\n\n    // Update the previous siblings for composition replace tweens\n\n    if (prevSibling) {\n\n      const prevParent = prevSibling.parent;\n      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;\n\n      // Handle looped animations tween\n\n      if (\n        // Check if the previous tween is from a different animation\n        tween.parent.id !== prevParent.id &&\n        // Check if the animation has loops\n        prevParent.iterationCount> 1 &&\n        // Check if _absoluteChangeEndTime of last loop overlaps the current tween\n        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime\n      ) {\n\n        // TODO: Find a way to only override the iterations overlapping with the tween\n        overrideTween(prevSibling);\n\n        let prevPrevSibling = prevSibling._prevRep;\n\n        // If the tween was part of a set of keyframes, override its siblings\n        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {\n          overrideTween(prevPrevSibling);\n          prevPrevSibling = prevPrevSibling._prevRep;\n        }\n\n      }\n\n      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;\n\n      if (prevAbsEndTime > absoluteUpdateStartTime) {\n\n        const prevChangeStartTime = prevSibling._startTime;\n        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);\n        // Rounding is necessary here to minimize floating point errors when working in seconds\n        const updatedPrevChangeDuration = round(absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime, 12);\n\n        prevSibling._changeDuration = updatedPrevChangeDuration;\n        prevSibling._currentTime = updatedPrevChangeDuration;\n        prevSibling._isOverlapped = 1;\n\n        // Override the previous tween if its new _changeDuration is lower than minValue\n        // TODO: See if it's even neceseeary to test against minValue, checking for 0 might be enough\n        if (updatedPrevChangeDuration < minValue) {\n          overrideTween(prevSibling);\n        }\n      }\n\n      // Pause (and cancel) the parent if it only contains overlapped tweens\n\n      let pausePrevParentAnimation = true;\n\n      forEachChildren(prevParent, (/** @type Tween */t) => {\n        if (!t._isOverlapped) pausePrevParentAnimation = false;\n      });\n\n      if (pausePrevParentAnimation) {\n        const prevParentTL = prevParent.parent;\n        if (prevParentTL) {\n          let pausePrevParentTL = true;\n          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {\n            if (a !== prevParent) {\n              forEachChildren(a, (/** @type Tween */t) => {\n                if (!t._isOverlapped) pausePrevParentTL = false;\n              });\n            }\n          });\n          if (pausePrevParentTL) {\n            prevParentTL.cancel();\n          }\n        } else {\n          prevParent.cancel();\n          // Previously, calling .cancel() on a timeline child would affect the render order of other children\n          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop\n          // This is no longer needed since timeline tween composition is now handled separately\n          // Keeping this here for reference\n          // prevParent.completed = true;\n          // prevParent.pause();\n        }\n      }\n\n    }\n\n    // let nextSibling = tween._nextRep;\n\n    // // All the next siblings are automatically overridden\n\n    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     console.log(tween.id, nextSibling.id);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n\n  // Handle additive tweens composition\n\n  } else if (tweenCompositionType === compositionTypes.blend) {\n\n    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');\n    const additiveAnimation = addAdditiveAnimation(lookups._add);\n\n    let lookupTween = additiveTweenSiblings._head;\n\n    if (!lookupTween) {\n      lookupTween = { ...tween };\n      lookupTween._composition = compositionTypes.replace;\n      lookupTween._updateDuration = minValue;\n      lookupTween._startTime = 0;\n      lookupTween._numbers = cloneArray(tween._fromNumbers);\n      lookupTween._number = 0;\n      lookupTween._next = null;\n      lookupTween._prev = null;\n      addChild(additiveTweenSiblings, lookupTween);\n      addChild(additiveAnimation, lookupTween);\n    }\n\n    // Convert the values of TO to FROM and set TO to 0\n\n    const toNumber = tween._toNumber;\n    tween._fromNumber = lookupTween._fromNumber - toNumber;\n    tween._toNumber = 0;\n    tween._numbers = cloneArray(tween._fromNumbers);\n    tween._number = 0;\n    lookupTween._fromNumber = toNumber;\n\n    if (tween._toNumbers) {\n      const toNumbers = cloneArray(tween._toNumbers);\n      if (toNumbers) {\n        toNumbers.forEach((value, i) => {\n          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;\n          tween._toNumbers[i] = 0;\n        });\n      }\n      lookupTween._fromNumbers = toNumbers;\n    }\n\n    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');\n\n  }\n\n  return tween;\n\n};\n\n/**\n * @param  {Tween} tween\n * @return {Tween}\n */\nconst removeTweenSliblings = tween => {\n  const tweenComposition = tween._composition;\n  if (tweenComposition !== compositionTypes.none) {\n    const tweenTarget = tween.target;\n    const tweenProperty = tween.property;\n    const replaceTweensLookup = lookups._rep;\n    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);\n    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];\n    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');\n    if (tweenComposition === compositionTypes.blend) {\n      const addTweensLookup = lookups._add;\n      const addTargetProps = addTweensLookup.get(tweenTarget);\n      if (!addTargetProps) return;\n      const additiveTweenSiblings = addTargetProps[tweenProperty];\n      const additiveAnimation = additive.animation;\n      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');\n      // If only one tween is left in the additive lookup, it's the tween lookup\n      const lookupTween = additiveTweenSiblings._head;\n      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {\n        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');\n        removeChild(additiveAnimation, lookupTween);\n        let shouldClean = true;\n        for (let prop in addTargetProps) {\n          if (addTargetProps[prop]._head) {\n            shouldClean = false;\n            break;\n          }\n        }\n        if (shouldClean) {\n          addTweensLookup.delete(tweenTarget);\n        }\n      }\n    }\n  }\n  return tween;\n};\n\n\n\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst resetTimerProperties = timer => {\n  timer.paused = true;\n  timer.began = false;\n  timer.completed = false;\n  return timer;\n};\n\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */\nconst reviveTimer = timer => {\n  if (!timer._cancelled) return timer;\n  if (timer._hasChildren) {\n    forEachChildren(timer, reviveTimer);\n  } else {\n    forEachChildren(timer, (/** @type {Tween} tween*/tween) => {\n      if (tween._composition !== compositionTypes.none) {\n        composeTween(tween, getTweenSiblings(tween.target, tween.property));\n      }\n    });\n  }\n  timer._cancelled = 0;\n  return timer;\n};\n\nlet timerId = 0;\n\n/**\n * Base class used to create Timers, Animations and Timelines\n */\nclass Timer extends Clock {\n  /**\n   * @param {TimerParams} [parameters]\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   */\n  constructor(parameters = {}, parent = null, parentPosition = 0) {\n\n    super(0);\n\n    const {\n      id,\n      delay,\n      duration,\n      reversed,\n      alternate,\n      loop,\n      loopDelay,\n      autoplay,\n      frameRate,\n      playbackRate,\n      onComplete,\n      onLoop,\n      onPause,\n      onBegin,\n      onBeforeUpdate,\n      onUpdate,\n    } = parameters;\n\n    if (scope.current) scope.current.register(this);\n\n    const timerInitTime = parent ? 0 : engine._elapsedTime;\n    const timerDefaults = parent ? parent.defaults : globals.defaults;\n    const timerDelay = /** @type {Number} */(isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay);\n    const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;\n    const timerLoop = setValue(loop, timerDefaults.loop);\n    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);\n    const timerIterationCount = timerLoop === true ||\n                                timerLoop === Infinity ||\n                                /** @type {Number} */(timerLoop) < 0 ? Infinity :\n                                /** @type {Number} */(timerLoop) + 1;\n\n\n    let offsetPosition = 0;\n\n    if (parent) {\n      offsetPosition = parentPosition;\n    } else {\n      // Make sure to tick the engine once if not currently running to get up to date engine._elapsedTime\n      // to avoid big gaps with the following offsetPosition calculation\n      if (!engine.reqId) engine.requestTick(now());\n      // Make sure to scale the offset position with globals.timeScale to properly handle seconds unit\n      offsetPosition = (engine._elapsedTime - engine._startTime) * globals.timeScale;\n    }\n\n    // Timer's parameters\n    this.id = !isUnd(id) ? id : ++timerId;\n    /** @type {Timeline} */\n    this.parent = parent;\n    // Total duration of the timer\n    this.duration = clampInfinity(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || minValue;\n    /** @type {Boolean} */\n    this.backwards = false;\n    /** @type {Boolean} */\n    this.paused = true;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Callback<this>} */\n    this.onBegin = onBegin || timerDefaults.onBegin;\n    /** @type {Callback<this>} */\n    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;\n    /** @type {Callback<this>} */\n    this.onUpdate = onUpdate || timerDefaults.onUpdate;\n    /** @type {Callback<this>} */\n    this.onLoop = onLoop || timerDefaults.onLoop;\n    /** @type {Callback<this>} */\n    this.onPause = onPause || timerDefaults.onPause;\n    /** @type {Callback<this>} */\n    this.onComplete = onComplete || timerDefaults.onComplete;\n    /** @type {Number} */\n    this.iterationDuration = timerDuration; // Duration of one loop\n    /** @type {Number} */\n    this.iterationCount = timerIterationCount; // Number of loops\n    /** @type {Boolean|ScrollObserver} */\n    this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);\n    /** @type {Number} */\n    this._offset = offsetPosition;\n    /** @type {Number} */\n    this._delay = timerDelay;\n    /** @type {Number} */\n    this._loopDelay = timerLoopDelay;\n    /** @type {Number} */\n    this._iterationTime = 0;\n    /** @type {Number} */\n    this._currentIteration = 0; // Current loop index\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Boolean} */\n    this._running = false;\n    /** @type {Number} */\n    this._reversed = +setValue(reversed, timerDefaults.reversed);\n    /** @type {Number} */\n    this._reverse = this._reversed;\n    /** @type {Number} */\n    this._cancelled = 0;\n    /** @type {Boolean} */\n    this._alternate = setValue(alternate, timerDefaults.alternate);\n    /** @type {Renderable} */\n    this._prev = null;\n    /** @type {Renderable} */\n    this._next = null;\n\n    // Clock's parameters\n    /** @type {Number} */\n    this._elapsedTime = timerInitTime;\n    /** @type {Number} */\n    this._startTime = timerInitTime;\n    /** @type {Number} */\n    this._lastTime = timerInitTime;\n    /** @type {Number} */\n    this._fps = setValue(frameRate, timerDefaults.frameRate);\n    /** @type {Number} */\n    this._speed = setValue(playbackRate, timerDefaults.playbackRate);\n  }\n\n  get cancelled() {\n    return !!this._cancelled;\n  }\n\n  /** @param {Boolean} cancelled  */\n  set cancelled(cancelled) {\n    cancelled ? this.cancel() : this.reset(1).play();\n  }\n\n  get currentTime() {\n    return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);\n  }\n\n  /** @param {Number} time  */\n  set currentTime(time) {\n    const paused = this.paused;\n    // Pausing the timer is necessary to avoid time jumps on a running instance\n    this.pause().seek(+time);\n    if (!paused) this.resume();\n  }\n\n  get iterationCurrentTime() {\n    return round(this._iterationTime, globals.precision);\n  }\n\n  /** @param {Number} time  */\n  set iterationCurrentTime(time) {\n    this.currentTime = (this.iterationDuration * this._currentIteration) + time;\n  }\n\n  get progress() {\n    return clamp(round(this._currentTime / this.duration, 10), 0, 1);\n  }\n\n  /** @param {Number} progress  */\n  set progress(progress) {\n    this.currentTime = this.duration * progress;\n  }\n\n  get iterationProgress() {\n    return clamp(round(this._iterationTime / this.iterationDuration, 10), 0, 1);\n  }\n\n  /** @param {Number} progress  */\n  set iterationProgress(progress) {\n    const iterationDuration = this.iterationDuration;\n    this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);\n  }\n\n  get currentIteration() {\n    return this._currentIteration;\n  }\n\n  /** @param {Number} iterationCount  */\n  set currentIteration(iterationCount) {\n    this.currentTime = (this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1));\n  }\n\n  get reversed() {\n    return !!this._reversed;\n  }\n\n  /** @param {Boolean} reverse  */\n  set reversed(reverse) {\n    reverse ? this.reverse() : this.play();\n  }\n\n  get speed() {\n    return super.speed;\n  }\n\n  /** @param {Number} playbackRate  */\n  set speed(playbackRate) {\n    super.speed = playbackRate;\n    this.resetTime();\n  }\n\n  /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */\n  reset(internalRender = 0) {\n    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings\n    reviveTimer(this);\n    if (this._reversed && !this._reverse) this.reversed = false;\n    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden\n    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order\n    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?\n    this._iterationTime = this.iterationDuration;\n    // Set tickMode to tickModes.FORCE to force rendering\n    tick(this, 0, 1, internalRender, tickModes.FORCE);\n    // Reset timer properties after revive / render to make sure the props are not updated again\n    resetTimerProperties(this);\n    // Also reset children properties\n    if (this._hasChildren) {\n      forEachChildren(this, resetTimerProperties);\n    }\n    return this;\n  }\n\n  /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */\n  init(internalRender = 0) {\n    this.fps = this._fps;\n    this.speed = this._speed;\n    // Manually calling .init() on timelines should render all children intial state\n    // Forces all children to render once then render to 0 when reseted\n    if (!internalRender && this._hasChildren) {\n      tick(this, this.duration, 1, internalRender, tickModes.FORCE);\n    }\n    this.reset(internalRender);\n    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link\n    const autoplay = this._autoplay;\n    if (autoplay === true) {\n      this.resume();\n    } else if (autoplay && !isUnd(/** @type {ScrollObserver} */(autoplay).linked)) {\n      /** @type {ScrollObserver} */(autoplay).link(this);\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  resetTime() {\n    const timeScale = 1 / (this._speed * engine._speed);\n    // TODO: See if we can safely use engine._elapsedTime here\n    // if (!engine.reqId) engine.requestTick(now())\n    // this._startTime = engine._elapsedTime - (this._currentTime + this._delay) * timeScale;\n    this._startTime = now() - (this._currentTime + this._delay) * timeScale;\n    return this;\n  }\n\n  /** @return {this} */\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    this.onPause(this);\n    return this;\n  }\n\n  /** @return {this} */\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // We can safely imediatly render a timer that has no duration and no children\n    if (this.duration <= minValue && !this._hasChildren) {\n      tick(this, minValue, 0, 0, tickModes.FORCE);\n    } else {\n      if (!this._running) {\n        addChild(engine, this);\n        engine._hasChildren = true;\n        this._running = true;\n      }\n      this.resetTime();\n      // Forces the timer to advance by at least one frame when the next tick occurs\n      this._startTime -= 12;\n      engine.wake();\n    }\n    return this;\n  }\n\n  /** @return {this} */\n  restart() {\n    return this.reset(0).resume();\n  }\n\n  /**\n   * @param  {Number} time\n   * @param  {Boolean|Number} [muteCallbacks]\n   * @param  {Boolean|Number} [internalRender]\n   * @return {this}\n   */\n  seek(time, muteCallbacks = 0, internalRender = 0) {\n    // Recompose the tween siblings in case the timer has been cancelled\n    reviveTimer(this);\n    // If you seek a completed animation, otherwise the next play will starts at 0\n    this.completed = false;\n    const isPaused = this.paused;\n    this.paused = true;\n    // timer, time, muteCallbacks, internalRender, tickMode\n    tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);\n    return isPaused ? this : this.resume();\n  }\n\n  /** @return {this} */\n  alternate() {\n    const reversed = this._reversed;\n    const count = this.iterationCount;\n    const duration = this.iterationDuration;\n    // Calculate the maximum iterations possible given the iteration duration\n    const iterations = count === Infinity ? floor(maxValue / duration) : count;\n    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);\n    if (count === Infinity) {\n      // Handle infinite loops to loop on themself\n      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;\n    } else {\n      this.seek((duration * iterations) - this._currentTime);\n    }\n    this.resetTime();\n    return this;\n  }\n\n  /** @return {this} */\n  play() {\n    if (this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  /** @return {this} */\n  reverse() {\n    if (!this._reversed) this.alternate();\n    return this.resume();\n  }\n\n  // TODO: Move all the animation / tweens / children related code to Animation / Timeline\n\n  /** @return {this} */\n  cancel() {\n    if (this._hasChildren) {\n      forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);\n    } else {\n      forEachChildren(this, removeTweenSliblings);\n    }\n    this._cancelled = 1;\n    // Pausing the timer removes it from the engine\n    return this.pause();\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    const normlizedDuration = normalizeTime(newDuration);\n    if (currentDuration === normlizedDuration) return this;\n    const timeScale = newDuration / currentDuration;\n    const isSetter = newDuration <= minValue;\n    this.duration = isSetter ? minValue : normlizedDuration;\n    this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);\n    this._offset *= timeScale;\n    this._delay *= timeScale;\n    this._loopDelay *= timeScale;\n    return this;\n  }\n\n /**\n   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary\n   * @return {this}\n   */\n  revert() {\n    tick(this, 0, 1, 0, tickModes.AUTO);\n    const ap = /** @type {ScrollObserver} */(this._autoplay);\n    if (ap && ap.linked && ap.linked === this) ap.revert();\n    return this.cancel();\n  }\n\n /**\n   * Imediatly completes the timer, cancels it and triggers the onComplete callback\n   * @return {this}\n   */\n  complete() {\n    return this.seek(this.duration).cancel();\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      // this.then = null prevents infinite recursion if returned by an async function\n      // https://github.com/juliangarnierorg/anime-beta/issues/26\n      this.then = null;\n      callback(this);\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      // Make sure to resolve imediatly if the timer has already completed\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n\n}\n\n/**\n * @param {TimerParams} [parameters]\n * @return {Timer}\n */\nconst createTimer = parameters => new Timer(parameters, null, 0).init();\n\n\n\n\n/** @type {EasingFunction} */\nconst none = t => t;\n\n// Cubic Bezier solver adapted from https://github.com/gre/bezier-ease  Gatan Renaudeau\n\n/**\n * @param  {Number} aT\n * @param  {Number} aA1\n * @param  {Number} aA2\n * @return {Number}\n */\nconst calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + (3 * aA1)) * aT;\n\n/**\n * @param  {Number} aX\n * @param  {Number} mX1\n * @param  {Number} mX2\n * @return {Number}\n */\nconst binarySubdivide = (aX, mX1, mX2) => {\n  let aA = 0, aB = 1, currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (abs(currentX) > .0000001 && ++i < 100);\n  return currentT;\n};\n\n/**\n * @param  {Number} [mX1] The x coordinate of the first point\n * @param  {Number} [mY1] The y coordinate of the first point\n * @param  {Number} [mX2] The x coordinate of the second point\n * @param  {Number} [mY2] The y coordinate of the second point\n * @return {EasingFunction}\n */\n\nconst cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0) => (mX1 === mY1 && mX2 === mY2) ? none :\n  t => t === 0 || t === 1 ? t :\n  calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);\n\n/**\n * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\n * Only covers 'end' and 'start' jumpterms\n * @param  {Number} steps\n * @param  {Boolean} [fromStart]\n * @return {EasingFunction}\n */\nconst steps = (steps = 10, fromStart) => {\n  const roundMethod = fromStart ? ceil : floor;\n  return t => roundMethod(clamp(t, 0, 1) * steps) * (1 / steps);\n};\n\n/**\n * Without parameters, the linear function creates a non-eased transition.\n * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.\n * @param  {...(String|Number)} args - Points\n * @return {EasingFunction}\n */\nconst linear = (...args) => {\n  const argsLength = args.length;\n  if (!argsLength) return none;\n  const totalPoints = argsLength - 1;\n  const firstArg = args[0];\n  const lastArg = args[totalPoints];\n  const xPoints = [0];\n  const yPoints = [parseNumber(firstArg)];\n  for (let i = 1; i < totalPoints; i++) {\n    const arg = args[i];\n    const splitValue = isStr(arg) ?\n    /** @type {String} */(arg).trim().split(' ') :\n    [arg];\n    const value = splitValue[0];\n    const percent = splitValue[1];\n    xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);\n    yPoints.push(parseNumber(value));\n  }\n  yPoints.push(parseNumber(lastArg));\n  xPoints.push(1);\n  return function easeLinear(t) {\n    for (let i = 1, l = xPoints.length; i < l; i++) {\n      const currentX = xPoints[i];\n      if (t <= currentX) {\n        const prevX = xPoints[i - 1];\n        const prevY = yPoints[i - 1];\n        return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);\n      }\n    }\n    return yPoints[yPoints.length - 1];\n  }\n};\n\n/**\n * Generate random steps\n * @param  {Number} [length] - The number of steps\n * @param  {Number} [randomness] - How strong the randomness is\n * @return {EasingFunction}\n */\nconst irregular = (length = 10, randomness = 1) => {\n  const values = [0];\n  const total = length - 1;\n  for (let i = 1; i < total; i++) {\n    const previousValue = values[i - 1];\n    const spacing = i / total;\n    const segmentEnd = (i + 1) / total;\n    const randomVariation = spacing + (segmentEnd - spacing) * Math.random();\n    // Mix the even spacing and random variation based on the randomness parameter\n    const randomValue = spacing * (1 - randomness) + randomVariation * randomness;\n    values.push(clamp(randomValue, previousValue, 1));\n  }\n  values.push(1);\n  return linear(...values);\n};\n\n// Easing functions adapted from http://www.robertpenner.com/ease  Robert Penner\n\n/**\n * @callback PowerEasing\n * @param {Number|String} [power=1.675]\n * @return {EasingFunction}\n */\n\n/**\n * @callback BackEasing\n * @param {Number|String} [overshoot=1.70158]\n * @return {EasingFunction}\n */\n\n/**\n * @callback ElasticEasing\n * @param {Number|String} [amplitude=1]\n * @param {Number|String} [period=.3]\n * @return {EasingFunction}\n */\n\n/**\n * @callback EaseFactory\n * @param {Number|String} [paramA]\n * @param {Number|String} [paramB]\n * @return {EasingFunction|Number}\n */\n\n/** @typedef {PowerEasing|BackEasing|ElasticEasing} EasesFactory */\n\nconst halfPI = PI / 2;\nconst doublePI = PI * 2;\n/** @type {PowerEasing} */\nconst easeInPower = (p = 1.68) => t => pow(t, +p);\n\n/** @type {Record<String, EasesFactory|EasingFunction>} */\nconst easeInFunctions = {\n  [emptyString]: easeInPower,\n  Quad: easeInPower(2),\n  Cubic: easeInPower(3),\n  Quart: easeInPower(4),\n  Quint: easeInPower(5),\n  /** @type {EasingFunction} */\n  Sine: t => 1 - cos(t * halfPI),\n  /** @type {EasingFunction} */\n  Circ: t => 1 - sqrt(1 - t * t),\n  /** @type {EasingFunction} */\n  Expo: t => t ? pow(2, 10 * t - 10) : 0,\n  /** @type {EasingFunction} */\n  Bounce: t => {\n    let pow2, b = 4;\n    while (t < ((pow2 = pow(2, --b)) - 1) / 11);\n    return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);\n  },\n  /** @type {BackEasing} */\n  Back: (overshoot = 1.70158) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,\n  /** @type {ElasticEasing} */\n  Elastic: (amplitude = 1, period = .3) => {\n    const a = clamp(+amplitude, 1, 10);\n    const p = clamp(+period, minValue, 2);\n    const s = (p / doublePI) * asin(1 / a);\n    const e = doublePI / p;\n    return t => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin(((1 - t) - s) * e);\n  }\n};\n\n/**\n * @callback EaseType\n * @param {EasingFunction} Ease\n * @return {EasingFunction}\n */\n\n/** @type {Record<String, EaseType>} */\nconst easeTypes = {\n  in: easeIn => t => easeIn(t),\n  out: easeIn => t => 1 - easeIn(1 - t),\n  inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,\n  outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2,\n};\n\n/**\n * @param  {String} string\n * @param  {Record<String, EasesFactory|EasingFunction>} easesFunctions\n * @param  {Object} easesLookups\n * @return {EasingFunction}\n */\nconst parseEaseString = (string, easesFunctions, easesLookups) => {\n  if (easesLookups[string]) return easesLookups[string];\n  if (string.indexOf('(') <= -1) {\n    const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');\n    const parsedFn = /** @type {EasingFunction} */(hasParams ? /** @type {EasesFactory} */(easesFunctions[string])() : easesFunctions[string]);\n    return parsedFn ? easesLookups[string] = parsedFn : none;\n  } else {\n    const split = string.slice(0, -1).split('(');\n    const parsedFn = /** @type {EasesFactory} */(easesFunctions[split[0]]);\n    return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : none;\n  }\n};\n\n/**\n * @typedef  {Object} EasesFunctions\n * @property {typeof linear} linear\n * @property {typeof irregular} irregular\n * @property {typeof steps} steps\n * @property {typeof cubicBezier} cubicBezier\n * @property {PowerEasing} in\n * @property {PowerEasing} out\n * @property {PowerEasing} inOut\n * @property {PowerEasing} outIn\n * @property {EasingFunction} inQuad\n * @property {EasingFunction} outQuad\n * @property {EasingFunction} inOutQuad\n * @property {EasingFunction} outInQuad\n * @property {EasingFunction} inCubic\n * @property {EasingFunction} outCubic\n * @property {EasingFunction} inOutCubic\n * @property {EasingFunction} outInCubic\n * @property {EasingFunction} inQuart\n * @property {EasingFunction} outQuart\n * @property {EasingFunction} inOutQuart\n * @property {EasingFunction} outInQuart\n * @property {EasingFunction} inQuint\n * @property {EasingFunction} outQuint\n * @property {EasingFunction} inOutQuint\n * @property {EasingFunction} outInQuint\n * @property {EasingFunction} inSine\n * @property {EasingFunction} outSine\n * @property {EasingFunction} inOutSine\n * @property {EasingFunction} outInSine\n * @property {EasingFunction} inCirc\n * @property {EasingFunction} outCirc\n * @property {EasingFunction} inOutCirc\n * @property {EasingFunction} outInCirc\n * @property {EasingFunction} inExpo\n * @property {EasingFunction} outExpo\n * @property {EasingFunction} inOutExpo\n * @property {EasingFunction} outInExpo\n * @property {EasingFunction} inBounce\n * @property {EasingFunction} outBounce\n * @property {EasingFunction} inOutBounce\n * @property {EasingFunction} outInBounce\n * @property {BackEasing} inBack\n * @property {BackEasing} outBack\n * @property {BackEasing} inOutBack\n * @property {BackEasing} outInBack\n * @property {ElasticEasing} inElastic\n * @property {ElasticEasing} outElastic\n * @property {ElasticEasing} inOutElastic\n * @property {ElasticEasing} outInElastic\n */\n\nconst eases = (/*#__PURE__*/ (() => {\n  const list = { linear, irregular, steps, cubicBezier };\n  for (let type in easeTypes) {\n    for (let name in easeInFunctions) {\n      const easeIn = easeInFunctions[name];\n      const easeType = easeTypes[type];\n      list[type + name] = /** @type {EasesFactory|EasingFunction} */(\n        name === emptyString || name === 'Back' || name === 'Elastic' ?\n        (a, b) => easeType(/** @type {EasesFactory} */(easeIn)(a, b)) :\n        easeType(/** @type {EasingFunction} */(easeIn))\n      );\n    }\n  }\n  return /** @type {EasesFunctions} */(list);\n})());\n\n/** @type {Record<String, EasingFunction>} */\nconst JSEasesLookups = { linear: none };\n\n/**\n * @param  {EasingParam} ease\n * @return {EasingFunction}\n */\nconst parseEasings = ease => isFnc(ease) ? ease :\n  isStr(ease) ? parseEaseString(/** @type {String} */(ease), eases, JSEasesLookups) :\n  none;\n\n\n\n\nconst propertyNamesCache = {};\n\n/**\n * @param  {String} propertyName\n * @param  {Target} target\n * @param  {tweenTypes} tweenType\n * @return {String}\n */\nconst sanitizePropertyName = (propertyName, target, tweenType) => {\n  if (tweenType === tweenTypes.TRANSFORM) {\n    const t = shortTransforms.get(propertyName);\n    return t ? t : propertyName;\n  } else if (\n    tweenType === tweenTypes.CSS ||\n    // Handle special cases where properties like \"strokeDashoffset\" needs to be set as \"stroke-dashoffset\"\n    // but properties like \"baseFrequency\" should stay in lowerCamelCase\n    (tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */(target).style))\n  ) {\n    const cachedPropertyName = propertyNamesCache[propertyName];\n    if (cachedPropertyName) {\n      return cachedPropertyName;\n    } else {\n      const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;\n      propertyNamesCache[propertyName] = lowerCaseName;\n      return lowerCaseName;\n    }\n  } else {\n    return propertyName;\n  }\n};\n\n\n\n\nconst angleUnitsMap = { 'deg': 1, 'rad': 180 / PI, 'turn': 360 };\nconst convertedValuesCache = {};\n\n/**\n * @param  {DOMTarget} el\n * @param  {TweenDecomposedValue} decomposedValue\n * @param  {String} unit\n * @param  {Boolean} [force]\n * @return {TweenDecomposedValue}\n */\nconst convertValueUnit = (el, decomposedValue, unit, force = false) => {\n  const currentUnit = decomposedValue.u;\n  const currentNumber = decomposedValue.n;\n  if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) { // TODO: Check if checking against the same unit string is necessary\n    return decomposedValue;\n  }\n  const cachedKey = currentNumber + currentUnit + unit;\n  const cached = convertedValuesCache[cachedKey];\n  if (!isUnd(cached) && !force) {\n    decomposedValue.n = cached;\n  } else {\n    let convertedValue;\n    if (currentUnit in angleUnitsMap) {\n      convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];\n    } else {\n      const baseline = 100;\n      const tempEl = /** @type {DOMTarget} */(el.cloneNode());\n      const parentNode = el.parentNode;\n      const parentEl = (parentNode && (parentNode !== doc)) ? parentNode : doc.body;\n      parentEl.appendChild(tempEl);\n      const elStyle = tempEl.style;\n      elStyle.width = baseline + currentUnit;\n      const currentUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;\n      elStyle.width = baseline + unit;\n      const newUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;\n      const factor = currentUnitWidth / newUnitWidth;\n      parentEl.removeChild(tempEl);\n      convertedValue = factor * currentNumber;\n    }\n    decomposedValue.n = convertedValue;\n    convertedValuesCache[cachedKey] = convertedValue;\n  }\n  decomposedValue.t === valueTypes.UNIT;\n  decomposedValue.u = unit;\n  return decomposedValue;\n};\n\n\n\n\n/**\n * @template {Renderable} T\n * @param {T} renderable\n * @return {T}\n */\nconst cleanInlineStyles = renderable => {\n  // Allow cleanInlineStyles() to be called on timelines\n  if (renderable._hasChildren) {\n    forEachChildren(renderable, cleanInlineStyles, true);\n  } else {\n    const animation = /** @type {JSAnimation} */(renderable);\n    animation.pause();\n    forEachChildren(animation, (/** @type {Tween} */tween) => {\n      const tweenProperty = tween.property;\n      const tweenTarget = tween.target;\n      if (tweenTarget[isDomSymbol]) {\n        const targetStyle = /** @type {DOMTarget} */(tweenTarget).style;\n        const originalInlinedValue = animation._inlineStyles[tweenProperty];\n        if (tween._tweenType === tweenTypes.TRANSFORM) {\n          const cachedTransforms = tweenTarget[transformsSymbol];\n          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n            delete cachedTransforms[tweenProperty];\n          } else {\n            cachedTransforms[tweenProperty] = originalInlinedValue;\n          }\n          if (tween._renderTransforms) {\n            if (!Object.keys(cachedTransforms).length) {\n              targetStyle.removeProperty('transform');\n            } else {\n              let str = emptyString;\n              for (let key in cachedTransforms) {\n                str += transformsFragmentStrings[key] + cachedTransforms[key] + ') ';\n              }\n              targetStyle.transform = str;\n            }\n          }\n        } else {\n          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n            targetStyle.removeProperty(tweenProperty);\n          } else {\n            targetStyle[tweenProperty] = originalInlinedValue;\n          }\n        }\n        if (animation._tail === tween) {\n          animation.targets.forEach(t => {\n            if (t.getAttribute && t.getAttribute('style') === emptyString) {\n              t.removeAttribute('style');\n            }          });\n        }\n      }\n    });\n  }\n  return renderable;\n};\n\n// Defines decomposed values target objects only once and mutate their properties later to avoid GC\n// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object\nconst fromTargetObject = createDecomposedValueTargetObject();\nconst toTargetObject = createDecomposedValueTargetObject();\nconst toFunctionStore = { func: null };\nconst keyframesTargetArray = [null];\nconst fastSetValuesArray = [null, null];\n/** @type {TweenKeyValue} */\nconst keyObjectTarget = { to: null };\n\nlet tweenId = 0;\nlet keyframes;\n/** @type {TweenParamsOptions & TweenValues} */\nlet key;\n\n/**\n * @param {DurationKeyframes | PercentageKeyframes} keyframes\n * @param {AnimationParams} parameters\n * @return {AnimationParams}\n */\nconst generateKeyframes = (keyframes, parameters) => {\n  /** @type {AnimationParams} */\n  const properties = {};\n  if (isArr(keyframes)) {\n    const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);\n    for (let i = 0, l = propertyNames.length; i < l; i++) {\n      const propName = propertyNames[i];\n      const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {\n        /** @type {TweenKeyValue} */\n        const newKey = {};\n        for (let p in key) {\n          const keyValue = /** @type {TweenPropValue} */(key[p]);\n          if (isKey(p)) {\n            if (p === propName) {\n              newKey.to = keyValue;\n            }\n          } else {\n            newKey[p] = keyValue;\n          }\n        }\n        return newKey;\n      });\n      properties[propName] = /** @type {ArraySyntaxValue} */(propArray);\n    }\n\n  } else {\n    const totalDuration = /** @type {Number} */(setValue(parameters.duration, globals.defaults.duration));\n    const keys = Object.keys(keyframes)\n    .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })\n    .sort((a, b) => a.o - b.o);\n    keys.forEach(key => {\n      const offset = key.o;\n      const prop = key.p;\n      for (let name in prop) {\n        if (isKey(name)) {\n          let propArray = /** @type {Array} */(properties[name]);\n          if (!propArray) propArray = properties[name] = [];\n          const duration = offset * totalDuration;\n          let length = propArray.length;\n          let prevKey = propArray[length - 1];\n          const keyObj = { to: prop[name] };\n          let durProgress = 0;\n          for (let i = 0; i < length; i++) {\n            durProgress += propArray[i].duration;\n          }\n          if (length === 1) {\n            keyObj.from = prevKey.to;\n          }\n          if (prop.ease) {\n            keyObj.ease = prop.ease;\n          }\n          keyObj.duration = duration - (length ? durProgress : 0);\n          propArray.push(keyObj);\n        }\n      }\n      return key;\n    });\n\n    for (let name in properties) {\n      const propArray = /** @type {Array} */(properties[name]);\n      let prevEase;\n      // let durProgress = 0\n      for (let i = 0, l = propArray.length; i < l; i++) {\n        const prop = propArray[i];\n        // Emulate WAPPI easing parameter position\n        const currentEase = prop.ease;\n        prop.ease = prevEase ? prevEase : undefined;\n        prevEase = currentEase;\n        // durProgress += prop.duration;\n        // if (i === l - 1 && durProgress !== totalDuration) {\n        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })\n        // }\n      }\n      if (!propArray[0].duration) {\n        propArray.shift();\n      }\n    }\n\n  }\n\n  return properties;\n};\n\nclass JSAnimation extends Timer {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimationParams} parameters\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   * @param {Boolean} [fastSet=false]\n   * @param {Number} [index=0]\n   * @param {Number} [length=0]\n   */\n  constructor(\n    targets,\n    parameters,\n    parent,\n    parentPosition,\n    fastSet = false,\n    index = 0,\n    length = 0\n  ) {\n\n    super(/** @type {TimerParams&AnimationParams} */(parameters), parent, parentPosition);\n\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    // If the parameters object contains a \"keyframes\" property, convert all the keyframes values to regular properties\n\n    const kfParams = /** @type {AnimationParams} */(parameters).keyframes;\n    const params = /** @type {AnimationParams} */(kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);\n\n    const {\n      delay,\n      duration,\n      ease,\n      playbackEase,\n      modifier,\n      composition,\n      onRender,\n    } = params;\n\n    const animDefaults = parent ? parent.defaults : globals.defaults;\n    const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);\n    const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);\n    const tEasing = hasSpring ? /** @type {Spring} */(ease).ease : setValue(ease, animEase ? 'linear' : animDefaults.ease);\n    const tDuration = hasSpring ? /** @type {Spring} */(ease).duration : setValue(duration, animDefaults.duration);\n    const tDelay = setValue(delay, animDefaults.delay);\n    const tModifier = modifier || animDefaults.modifier;\n    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation\n    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;\n    // TODO: Do not create an empty object until we know the animation will generate inline styles\n    const animInlineStyles = {};\n    // const absoluteOffsetTime = this._offset;\n    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);\n\n    let iterationDuration = NaN;\n    let iterationDelay = NaN;\n    let animationAnimationLength = 0;\n    let shouldTriggerRender = 0;\n\n    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {\n\n      const target = parsedTargets[targetIndex];\n      const ti = index || targetIndex;\n      const tl = length || targetsLength;\n\n      let lastTransformGroupIndex = NaN;\n      let lastTransformGroupLength = NaN;\n\n      for (let p in params) {\n\n        if (isKey(p)) {\n\n          const tweenType = getTweenType(target, p);\n\n          const propName = sanitizePropertyName(p, target, tweenType);\n\n          let propValue = params[p];\n\n          const isPropValueArray = isArr(propValue);\n\n          if (fastSet && !isPropValueArray) {\n            fastSetValuesArray[0] = propValue;\n            fastSetValuesArray[1] = propValue;\n            propValue = fastSetValuesArray;\n          }\n\n          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })\n          // Normalize property values to valid keyframe syntax:\n          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]\n          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];\n          if (isPropValueArray) {\n            const arrayLength = /** @type {Array} */(propValue).length;\n            const isNotObjectValue = !isObj(propValue[0]);\n            // Convert [x, y] to [{to: [x, y]}]\n            if (arrayLength === 2 && isNotObjectValue) {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));\n              keyframesTargetArray[0] = keyObjectTarget;\n              keyframes = keyframesTargetArray;\n            // Convert [x, y, z] to [[x, y], z]\n            } else if (arrayLength > 2 && isNotObjectValue) {\n              keyframes = [];\n              /** @type {Array.<Number>} */(propValue).forEach((v, i) => {\n                if (!i) {\n                  fastSetValuesArray[0] = v;\n                } else if (i === 1) {\n                  fastSetValuesArray[1] = v;\n                  keyframes.push(fastSetValuesArray);\n                } else {\n                  keyframes.push(v);\n                }\n              });\n            } else {\n              keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);\n            }\n          } else {\n            keyframesTargetArray[0] = propValue;\n            keyframes = keyframesTargetArray;\n          }\n\n          let siblings = null;\n          let prevTween = null;\n          let firstTweenChangeStartTime = NaN;\n          let lastTweenChangeEndTime = 0;\n          let tweenIndex = 0;\n\n          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {\n\n            const keyframe = keyframes[tweenIndex];\n\n            if (isObj(keyframe)) {\n              key = keyframe;\n            } else {\n              keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);\n              key = keyObjectTarget;\n            }\n\n            toFunctionStore.func = null;\n\n            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);\n\n            let tweenToValue;\n            // Allows function based values to return an object syntax value ({to: v})\n            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {\n              key = computedToValue;\n              tweenToValue = computedToValue.to;\n            } else {\n              tweenToValue = computedToValue;\n            }\n            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);\n            const keyEasing = key.ease;\n            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);\n            // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time\n            const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing || tEasing;\n            // Calculate default individual keyframe duration by dividing the tl of keyframes\n            const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).duration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);\n            // Default delay value should only be applied to the first tween\n            const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);\n            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);\n            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];\n            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper\n            const tweenModifier = key.modifier || tModifier;\n            const hasFromvalue = !isUnd(tweenFromValue);\n            const hasToValue = !isUnd(tweenToValue);\n            const isFromToArray = isArr(tweenToValue);\n            const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);\n            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const absoluteStartTime = round(absoluteOffsetTime + tweenStartTime, 12);\n\n            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false\n            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;\n\n            let prevSibling = prevTween;\n\n            if (tweenComposition !== compositionTypes.none) {\n              if (!siblings) siblings = getTweenSiblings(target, propName);\n              let nextSibling = siblings._head;\n              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time\n              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {\n                prevSibling = nextSibling;\n                nextSibling = nextSibling._nextRep;\n                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time\n                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {\n                  while (nextSibling) {\n                    overrideTween(nextSibling);\n                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden\n                    nextSibling = nextSibling._nextRep;\n                  }\n                }\n              }\n            }\n\n            // Decompose values\n            if (isFromToValue) {\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);\n              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);\n              if (fromTargetObject.t === valueTypes.NUMBER) {\n                if (prevSibling) {\n                  if (prevSibling._valueType === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = prevSibling._unit;\n                  }\n                } else {\n                  decomposeRawValue(\n                    getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),\n                    decomposedOriginalValue\n                  );\n                  if (decomposedOriginalValue.t === valueTypes.UNIT) {\n                    fromTargetObject.t = valueTypes.UNIT;\n                    fromTargetObject.u = decomposedOriginalValue.u;\n                  }\n                }\n              }\n            } else {\n              if (hasToValue) {\n                decomposeRawValue(tweenToValue, toTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, toTargetObject);\n                } else {\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);\n                }\n              }\n              if (hasFromvalue) {\n                decomposeRawValue(tweenFromValue, fromTargetObject);\n              } else {\n                if (prevTween) {\n                  decomposeTweenValue(prevTween, fromTargetObject);\n                } else {\n                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :\n                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), fromTargetObject);\n                }\n              }\n            }\n\n            // Apply operators\n            if (fromTargetObject.o) {\n              fromTargetObject.n = getRelativeValue(\n                !prevSibling ? decomposeRawValue(\n                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),\n                  decomposedOriginalValue\n                ).n : prevSibling._toNumber,\n                fromTargetObject.n,\n                fromTargetObject.o\n              );\n            }\n\n            if (toTargetObject.o) {\n              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);\n            }\n\n            // Values omogenisation in cases of type difference between \"from\" and \"to\"\n            if (fromTargetObject.t !== toTargetObject.t) {\n              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {\n                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;\n                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;\n                notComplexValue.t = valueTypes.COMPLEX;\n                notComplexValue.s = cloneArray(complexValue.s);\n                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);\n              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {\n                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;\n                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;\n                notUnitValue.t = valueTypes.UNIT;\n                notUnitValue.u = unitValue.u;\n              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {\n                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;\n                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;\n                notColorValue.t = valueTypes.COLOR;\n                notColorValue.s = colorValue.s;\n                notColorValue.d = [0, 0, 0, 1];\n              }\n            }\n\n            // Unit conversion\n            if (fromTargetObject.u !== toTargetObject.u) {\n              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;\n              valueToConvert = convertValueUnit(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);\n              // TODO:\n              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);\n            }\n\n            // Fill in non existing complex values\n            if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {\n              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;\n              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;\n              // TODO: Check if n should be used instead of 0 for default complex values\n              shortestValue.d = longestValue.d.map((_, i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);\n              shortestValue.s = cloneArray(longestValue.s);\n            }\n\n            // Tween factory\n\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            const tweenUpdateDuration = round(+tweenDuration || minValue, 12);\n\n            /** @type {Tween} */\n            const tween = {\n              parent: this,\n              id: tweenId++,\n              property: propName,\n              target: target,\n              _value: null,\n              _func: toFunctionStore.func,\n              _ease: parseEasings(tweenEasing),\n              _fromNumbers: cloneArray(fromTargetObject.d),\n              _toNumbers: cloneArray(toTargetObject.d),\n              _strings: cloneArray(toTargetObject.s),\n              _fromNumber: fromTargetObject.n,\n              _toNumber: toTargetObject.n,\n              _numbers: cloneArray(fromTargetObject.d), // For additive tween and animatables\n              _number: fromTargetObject.n, // For additive tween and animatables\n              _unit: toTargetObject.u,\n              _modifier: tweenModifier,\n              _currentTime: 0,\n              _startTime: tweenStartTime,\n              _delay: +tweenDelay,\n              _updateDuration: tweenUpdateDuration,\n              _changeDuration: tweenUpdateDuration,\n              _absoluteStartTime: absoluteStartTime,\n              // NOTE: Investigate bit packing to stores ENUM / BOOL\n              _tweenType: tweenType,\n              _valueType: toTargetObject.t,\n              _composition: tweenComposition,\n              _isOverlapped: 0,\n              _isOverridden: 0,\n              _renderTransforms: 0,\n              _prevRep: null, // For replaced tween\n              _nextRep: null, // For replaced tween\n              _prevAdd: null, // For additive tween\n              _nextAdd: null, // For additive tween\n              _prev: null,\n              _next: null,\n            };\n\n            if (tweenComposition !== compositionTypes.none) {\n              composeTween(tween, siblings);\n            }\n\n            if (isNaN(firstTweenChangeStartTime)) {\n              firstTweenChangeStartTime = tween._startTime;\n            }\n            // Rounding is necessary here to minimize floating point errors when working in seconds\n            lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);\n            prevTween = tween;\n            animationAnimationLength++;\n\n            addChild(this, tween);\n\n          }\n\n          // Update animation timings with the added tweens properties\n\n          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {\n            iterationDelay = firstTweenChangeStartTime;\n          }\n\n          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {\n            iterationDuration = lastTweenChangeEndTime;\n          }\n\n          // TODO: Find a way to inline tween._renderTransforms = 1 here\n          if (tweenType === tweenTypes.TRANSFORM) {\n            lastTransformGroupIndex = animationAnimationLength - tweenIndex;\n            lastTransformGroupLength = animationAnimationLength;\n          }\n\n        }\n\n      }\n\n      // Set _renderTransforms to last transform property to correctly render the transforms list\n      if (!isNaN(lastTransformGroupIndex)) {\n        let i = 0;\n        forEachChildren(this, (/** @type {Tween} */tween) => {\n          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {\n            tween._renderTransforms = 1;\n            if (tween._composition === compositionTypes.blend) {\n              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {\n                if (additiveTween.id === tween.id) {\n                  additiveTween._renderTransforms = 1;\n                }\n              });\n            }\n          }\n          i++;\n        });\n      }\n\n    }\n\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n\n    if (iterationDelay) {\n      forEachChildren(this, (/** @type {Tween} */tween) => {\n        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too\n        if (!(tween._startTime - tween._delay)) {\n          tween._delay -= iterationDelay;\n        }\n        tween._startTime -= iterationDelay;\n      });\n      iterationDuration -= iterationDelay;\n    } else {\n      iterationDelay = 0;\n    }\n\n    // Prevents iterationDuration to be NaN if no valid animatable props have been provided\n    // Prevents _iterationCount to be NaN if no valid animatable props have been provided\n    if (!iterationDuration) {\n      iterationDuration = minValue;\n      this.iterationCount = 0;\n    }\n    /** @type {TargetsArray} */\n    this.targets = parsedTargets;\n    /** @type {Number} */\n    this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;\n    /** @type {Callback<this>} */\n    this.onRender = onRender || animDefaults.onRender;\n    /** @type {EasingFunction} */\n    this._ease = animEase;\n    /** @type {Number} */\n    this._delay = iterationDelay;\n    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.\n    // this._delay = parent ? 0 : iterationDelay;\n    // this._offset += parent ? iterationDelay : 0;\n    /** @type {Number} */\n    this.iterationDuration = iterationDuration;\n    /** @type {{}} */\n    this._inlineStyles = animInlineStyles;\n\n    if (!this._autoplay && shouldTriggerRender) this.onRender(this);\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      // Rounding is necessary here to minimize floating point errors\n      tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);\n      tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);\n      tween._currentTime *= timeScale;\n      tween._startTime *= timeScale;\n      tween._absoluteStartTime *= timeScale;\n    });\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {Tween} */tween) => {\n      const tweenFunc = tween._func;\n      if (tweenFunc) {\n        const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);\n        decomposeRawValue(ogValue, decomposedOriginalValue);\n        decomposeRawValue(tweenFunc(), toTargetObject);\n        tween._fromNumbers = cloneArray(decomposedOriginalValue.d);\n        tween._fromNumber = decomposedOriginalValue.n;\n        tween._toNumbers = cloneArray(toTargetObject.d);\n        tween._strings = cloneArray(toTargetObject.s);\n        // Make sure to apply relative operators https://github.com/juliangarnier/anime/issues/1025\n        tween._toNumber = toTargetObject.o ? getRelativeValue(decomposedOriginalValue.n, toTargetObject.n, toTargetObject.o) : toTargetObject.n;\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Cancel the animation and revert all the values affected by this animation to their original state\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();\n\n\n\n\n/**\n * Converts an easing function into a valid CSS linear() timing function string\n * @param {EasingFunction} fn\n * @param {number} [samples=100]\n * @returns {string} CSS linear() timing function\n */\nconst easingToLinear = (fn, samples = 100) => {\n  const points = [];\n  for (let i = 0; i <= samples; i++) points.push(fn(i / samples));\n  return `linear(${points.join(', ')})`;\n};\n\nconst WAAPIEasesLookups = {\n  in: 'ease-in',\n  out: 'ease-out',\n  inOut: 'ease-in-out',\n};\n\nconst WAAPIeases = /*#__PURE__*/(() => {\n  const list = {};\n  for (let type in easeTypes) list[type] = (/** @type {String|Number} */p) => easeTypes[type](easeInPower(p));\n  return /** @type {Record<String, EasingFunction>} */(list);\n})();\n\n/**\n * @param  {EasingParam} ease\n * @return {String}\n */\nconst parseWAAPIEasing = (ease) => {\n  let parsedEase = WAAPIEasesLookups[ease];\n  if (parsedEase) return parsedEase;\n  parsedEase = 'linear';\n  if (isStr(ease)) {\n    if (\n      stringStartsWith(ease, 'linear') ||\n      stringStartsWith(ease, 'cubic-') ||\n      stringStartsWith(ease, 'steps') ||\n      stringStartsWith(ease, 'ease')\n    ) {\n      parsedEase = ease;\n    } else if (stringStartsWith(ease, 'cubicB')) {\n      parsedEase = toLowerCase(ease);\n    } else {\n      const parsed = parseEaseString(ease, WAAPIeases, WAAPIEasesLookups);\n      if (isFnc(parsed)) parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);\n    }\n    WAAPIEasesLookups[ease] = parsedEase;\n  } else if (isFnc(ease)) {\n    const easing = easingToLinear(ease);\n    if (easing) parsedEase = easing;\n  } else if (/** @type {Spring} */(ease).ease) {\n    parsedEase = easingToLinear(/** @type {Spring} */(ease).ease);\n  }\n  return parsedEase;\n};\n\nconst transformsShorthands = ['x', 'y', 'z'];\nconst commonDefaultPXProperties = [\n  'perspective',\n  'width',\n  'height',\n  'margin',\n  'padding',\n  'top',\n  'right',\n  'bottom',\n  'left',\n  'borderWidth',\n  'fontSize',\n  'borderRadius',\n  ...transformsShorthands\n];\n\nconst validIndividualTransforms = /*#__PURE__*/ (() => [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))])();\n\nlet transformsPropertiesRegistered = null;\n\nconst WAAPIAnimationsLookups = {\n  _head: null,\n  _tail: null,\n};\n\n/**\n * @param {DOMTarget} $el\n * @param {String} [property]\n * @param {WAAPIAnimation} [parent]\n */\nconst removeWAAPIAnimation = ($el, property, parent) => {\n  let nextLookup = WAAPIAnimationsLookups._head;\n  while (nextLookup) {\n    const next = nextLookup._next;\n    const matchTarget = nextLookup.$el === $el;\n    const matchProperty = !property || nextLookup.property === property;\n    const matchParent = !parent || nextLookup.parent === parent;\n    if (matchTarget && matchProperty && matchParent) {\n      const anim = nextLookup.animation;\n      try { anim.commitStyles(); } catch {}      anim.cancel();\n      removeChild(WAAPIAnimationsLookups, nextLookup);\n      const lookupParent = nextLookup.parent;\n      if (lookupParent) {\n        lookupParent._completed++;\n        if (lookupParent.animations.length === lookupParent._completed) {\n          lookupParent.completed = true;\n          if (!lookupParent.muteCallbacks) {\n            lookupParent.paused = true;\n            lookupParent.onComplete(lookupParent);\n            lookupParent._resolve(lookupParent);\n          }\n        }\n      }\n    }\n    nextLookup = next;\n  }\n};\n\n/**\n * @param {WAAPIAnimation} parent\n * @param {DOMTarget} $el\n * @param {String} property\n * @param {PropertyIndexedKeyframes} keyframes\n * @param {KeyframeAnimationOptions} params\n * @retun {Animation}\n */\nconst addWAAPIAnimation = (parent, $el, property, keyframes, params) => {\n  const animation = $el.animate(keyframes, params);\n  const animTotalDuration = params.delay + (+params.duration * params.iterations);\n  animation.playbackRate = parent._speed;\n  if (parent.paused) animation.pause();\n  if (parent.duration < animTotalDuration) {\n    parent.duration = animTotalDuration;\n    parent.controlAnimation = animation;\n  }\n  parent.animations.push(animation);\n  removeWAAPIAnimation($el, property);\n  addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });\n  const handleRemove = () => { removeWAAPIAnimation($el, property, parent); };\n  animation.onremove = handleRemove;\n  animation.onfinish = handleRemove;\n  return animation;\n};\n\n/**\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} value\n * @param  {DOMTarget} $el\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {String}\n */\nconst normalizeTweenValue = (propName, value, $el, i, targetsLength) => {\n  let v = getFunctionValue(/** @type {any} */(value), $el, i, targetsLength);\n  if (!isNum(v)) return v;\n  if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate')) return `${v}px`;\n  if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew')) return `${v}deg`;\n  return `${v}`;\n};\n\n/**\n * @param  {DOMTarget} $el\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} from\n * @param  {WAAPIKeyframeValue} to\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {WAAPITweenValue}\n */\nconst parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {\n  /** @type {WAAPITweenValue} */\n  let tweenValue = '0';\n  const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];\n  if (!isUnd(from)) {\n    const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);\n    tweenValue = [computedFrom, computedTo];\n  } else {\n    tweenValue = isArr(to) ? to.map((/** @type {any} */v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;\n  }\n  return tweenValue;\n};\n\nclass WAAPIAnimation {\n/**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n */\n  constructor(targets, params) {\n\n    if (scope.current) scope.current.register(this);\n\n    // Skip the registration and fallback to no animation in case CSS.registerProperty is not supported\n    if (isNil(transformsPropertiesRegistered)) {\n      if (isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'))) {\n        transformsPropertiesRegistered = false;\n      } else {\n        validTransforms.forEach(t => {\n          const isSkew = stringStartsWith(t, 'skew');\n          const isScale = stringStartsWith(t, 'scale');\n          const isRotate = stringStartsWith(t, 'rotate');\n          const isTranslate = stringStartsWith(t, 'translate');\n          const isAngle = isRotate || isSkew;\n          const syntax = isAngle ? '<angle>' : isScale ? \"<number>\" : isTranslate ? \"<length-percentage>\" : \"*\";\n          try {\n            CSS.registerProperty({\n              name: '--' + t,\n              syntax,\n              inherits: false,\n              initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0',\n            });\n          } catch {}        });\n        transformsPropertiesRegistered = true;\n      }\n    }\n\n    const parsedTargets = registerTargets(targets);\n    const targetsLength = parsedTargets.length;\n\n    if (!targetsLength) {\n      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n    }\n\n    const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));\n    const spring = /** @type {Spring} */(ease).ease && ease;\n    const autoplay = setValue(params.autoplay, globals.defaults.autoplay);\n    const scroll = autoplay && /** @type {ScrollObserver} */(autoplay).link ? autoplay : false;\n    const alternate = params.alternate && /** @type {Boolean} */(params.alternate) === true;\n    const reversed = params.reversed && /** @type {Boolean} */(params.reversed) === true;\n    const loop = setValue(params.loop, globals.defaults.loop);\n    const iterations = /** @type {Number} */((loop === true || loop === Infinity) ? Infinity : isNum(loop) ? loop + 1 : 1);\n    /** @type {PlaybackDirection} */\n    const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';\n    /** @type {FillMode} */\n    const fill = 'forwards';\n    /** @type {String} */\n    const easing = parseWAAPIEasing(ease);\n    const timeScale = (globals.timeScale === 1 ? 1 : K);\n\n    /** @type {DOMTargetsArray}] */\n    this.targets = parsedTargets;\n    /** @type {Array<globalThis.Animation>}] */\n    this.animations = [];\n    /** @type {globalThis.Animation}] */\n    this.controlAnimation = null;\n    /** @type {Callback<this>} */\n    this.onComplete = params.onComplete || noop;\n    /** @type {Number} */\n    this.duration = 0;\n    /** @type {Boolean} */\n    this.muteCallbacks = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.paused = !autoplay || scroll !== false;\n    /** @type {Boolean} */\n    this.reversed = reversed;\n    /** @type {Boolean|ScrollObserver} */\n    this.autoplay = autoplay;\n    /** @type {Number} */\n    this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);\n    /** @type {Function} */\n    this._resolve = noop; // Used by .then()\n    /** @type {Number} */\n    this._completed = 0;\n    /** @type {Array<Object>}] */\n    this._inlineStyles = parsedTargets.map($el => $el.getAttribute('style'));\n\n    parsedTargets.forEach(($el, i) => {\n\n      const cachedTransforms = $el[transformsSymbol];\n\n      const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));\n\n      /** @type {Number} */\n      const duration = (spring ? /** @type {Spring} */(spring).duration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;\n      /** @type {Number} */\n      const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;\n      /** @type {CompositeOperation} */\n      const composite = /** @type {CompositeOperation} */(setValue(params.composition, 'replace'));\n\n      for (let name in params) {\n        if (!isKey(name)) continue;\n        /** @type {PropertyIndexedKeyframes} */\n        const keyframes = {};\n        /** @type {KeyframeAnimationOptions} */\n        const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };\n        const propertyValue = params[name];\n        const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;\n        let parsedPropertyValue;\n        if (isObj(propertyValue)) {\n          const tweenOptions = /** @type {WAAPITweenOptions} */(propertyValue);\n          const tweenOptionsEase = setValue(tweenOptions.ease, ease);\n          const tweenOptionsSpring = /** @type {Spring} */(tweenOptionsEase).ease && tweenOptionsEase;\n          const to = /** @type {WAAPITweenOptions} */(tweenOptions).to;\n          const from = /** @type {WAAPITweenOptions} */(tweenOptions).from;\n          /** @type {Number} */\n          tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */(tweenOptionsSpring).duration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;\n          /** @type {Number} */\n          tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;\n          /** @type {CompositeOperation} */\n          tweenParams.composite = /** @type {CompositeOperation} */(setValue(tweenOptions.composition, composite));\n          /** @type {String} */\n          tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);\n          parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n          if (!isUnd(from)) {\n            if (!individualTransformProperty) {\n              $el.style[name] = keyframes[name][0];\n            } else {\n              const key = `--${individualTransformProperty}`;\n              $el.style.setProperty(key, keyframes[key][0]);\n            }\n          }\n        } else {\n          parsedPropertyValue = isArr(propertyValue) ?\n                                propertyValue.map((/** @type {any} */v) => normalizeTweenValue(name, v, $el, i, targetsLength)) :\n                                normalizeTweenValue(name, /** @type {any} */(propertyValue), $el, i, targetsLength);\n          if (individualTransformProperty) {\n            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n            cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n          } else {\n            keyframes[name] = parsedPropertyValue;\n          }\n          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n        }\n      }\n      if (hasIndividualTransforms) {\n        let transforms = emptyString;\n        for (let t in cachedTransforms) {\n          transforms += `${transformsFragmentStrings[t]}var(--${t})) `;\n        }\n        $el.style.transform = transforms;\n      }\n    });\n\n    if (scroll) {\n      /** @type {ScrollObserver} */(this.autoplay).link(this);\n    }\n  }\n\n  /**\n   * @callback forEachCallback\n   * @param {globalThis.Animation} animation\n   */\n\n  /**\n   * @param  {forEachCallback|String} callback\n   * @return {this}\n   */\n  forEach(callback) {\n    const cb = isStr(callback) ? (/** @type {globalThis.Animation} */a) => a[callback]() : callback;\n    this.animations.forEach(cb);\n    return this;\n  }\n\n  get speed() {\n    return this._speed;\n  }\n\n  /** @param {Number} speed */\n  set speed(speed) {\n    this._speed = +speed;\n    this.forEach(anim => anim.playbackRate = speed);\n  }\n\n  get currentTime() {\n    const controlAnimation = this.controlAnimation;\n    const timeScale = globals.timeScale;\n    return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;\n  }\n\n  /** @param {Number} time */\n  set currentTime(time) {\n    const t = time * (globals.timeScale === 1 ? 1 : K);\n    this.forEach(anim => {\n      // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.\n      // The \"paused\" play state supersedes the \"finished\" play state; if the animation is both paused and finished, the \"paused\" state is the one that will be reported.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event\n      if (t >= this.duration) anim.play();\n      anim.currentTime = t;\n    });\n  }\n\n  get progress() {\n    return this.currentTime / this.duration;\n  }\n\n  /** @param {Number} progress */\n  set progress(progress) {\n    this.forEach(anim => anim.currentTime = progress * this.duration || 0);\n  }\n\n  resume() {\n    if (!this.paused) return this;\n    this.paused = false;\n    // TODO: Store the current time, and seek back to the last position\n    return this.forEach('play');\n  }\n\n  pause() {\n    if (this.paused) return this;\n    this.paused = true;\n    return this.forEach('pause');\n  }\n\n  alternate() {\n    this.reversed = !this.reversed;\n    this.forEach('reverse');\n    if (this.paused) this.forEach('pause');\n    return this;\n  }\n\n  play() {\n    if (this.reversed) this.alternate();\n    return this.resume();\n  }\n\n  reverse() {\n    if (!this.reversed) this.alternate();\n    return this.resume();\n  }\n\n /**\n  * @param {Number} time\n  * @param {Boolean} muteCallbacks\n  */\n  seek(time, muteCallbacks = false) {\n    if (muteCallbacks) this.muteCallbacks = true;\n    if (time < this.duration) this.completed = false;\n    this.currentTime = time;\n    this.muteCallbacks = false;\n    if (this.paused) this.pause();\n    return this;\n  }\n\n  restart() {\n    this.completed = false;\n    return this.seek(0, true).resume();\n  }\n\n  commitStyles() {\n    return this.forEach('commitStyles');\n  }\n\n  complete() {\n    return this.seek(this.duration);\n  }\n\n  cancel() {\n    this.forEach('cancel');\n    return this.pause();\n  }\n\n  revert() {\n    this.cancel();\n    this.targets.forEach(($el, i) => $el.setAttribute('style', this._inlineStyles[i]) );\n    return this;\n  }\n\n  /**\n   * @param  {WAAPICallback} [callback]\n   * @return {Promise}\n   */\n  then(callback = noop) {\n    const then = this.then;\n    const onResolve = () => {\n      this.then = null;\n      callback(this);\n      this.then = then;\n      this._resolve = noop;\n    };\n    return new Promise(r => {\n      this._resolve = () => r(onResolve());\n      if (this.completed) this._resolve();\n      return this;\n    });\n  }\n}\n\nconst waapi = {\n/**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n * @return {WAAPIAnimation}\n */\n  animate: (targets, params) => new WAAPIAnimation(targets, params),\n  convertEase: easingToLinear\n};\n\n\n\n\n/**\n * @param  {Callback<Timer>} [callback]\n * @return {Timer}\n */\nconst sync = (callback = noop) => {\n  return new Timer({ duration: 1 * globals.timeScale, onComplete: callback }, null, 0).resume();\n};\n\n/**\n * @overload\n * @param  {DOMTargetSelector} targetSelector\n * @param  {String}            propName\n * @return {String}\n *\n * @overload\n * @param  {JSTargetsParam} targetSelector\n * @param  {String}         propName\n * @return {Number|String}\n *\n * @overload\n * @param  {DOMTargetsParam} targetSelector\n * @param  {String}          propName\n * @param  {String}          unit\n * @return {String}\n *\n * @overload\n * @param  {TargetsParam} targetSelector\n * @param  {String}       propName\n * @param  {Boolean}      unit\n * @return {Number}\n *\n * @param  {TargetsParam}   targetSelector\n * @param  {String}         propName\n * @param  {String|Boolean} [unit]\n */\nfunction getTargetValue(targetSelector, propName, unit) {\n  const targets = registerTargets(targetSelector);\n  if (!targets.length) return;\n  const [ target ] = targets;\n  const tweenType = getTweenType(target, propName);\n  const normalizePropName = sanitizePropertyName(propName, target, tweenType);\n  let originalValue = getOriginalAnimatableValue(target, normalizePropName);\n  if (isUnd(unit)) {\n    return originalValue;\n  } else {\n    decomposeRawValue(originalValue, decomposedOriginalValue);\n    if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {\n      if (unit === false) {\n        return decomposedOriginalValue.n;\n      } else {\n        const convertedValue = convertValueUnit(/** @type {DOMTarget} */(target), decomposedOriginalValue, /** @type {String} */(unit), false);\n        return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;\n      }\n    }\n  }\n}\n\n/**\n * @param  {TargetsParam}    targets\n * @param  {AnimationParams} parameters\n * @return {JSAnimation}\n */\nconst setTargetValues = (targets, parameters) => {\n  if (isUnd(parameters)) return;\n  parameters.duration = minValue;\n  // Do not overrides currently active tweens by default\n  parameters.composition = setValue(parameters.composition, compositionTypes.none);\n  // Skip init() and force rendering by playing the animation\n  return new JSAnimation(targets, parameters, null, 0, true).resume();\n};\n\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {JSAnimation}    animation\n * @param  {String}       [propertyName]\n * @return {Boolean}\n */\nconst removeTargetsFromAnimation = (targetsArray, animation, propertyName) => {\n  let tweensMatchesTargets = false;\n  forEachChildren(animation, (/**@type {Tween} */tween) => {\n    const tweenTarget = tween.target;\n    if (targetsArray.includes(tweenTarget)) {\n      const tweenName = tween.property;\n      const tweenType = tween._tweenType;\n      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);\n      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {\n        // Make sure to flag the previous CSS transform tween to renderTransform\n        if (tween.parent._tail === tween &&\n            tween._tweenType === tweenTypes.TRANSFORM &&\n            tween._prev &&\n            tween._prev._tweenType === tweenTypes.TRANSFORM\n        ) {\n          tween._prev._renderTransforms = 1;\n        }\n        // Removes the tween from the selected animation\n        removeChild(animation, tween);\n        // Detach the tween from its siblings to make sure blended tweens are correctlly removed\n        removeTweenSliblings(tween);\n        tweensMatchesTargets = true;\n      }\n    }\n  }, true);\n  return tweensMatchesTargets;\n};\n\n/**\n * @param  {TargetsParam} targets\n * @param  {Renderable|WAAPIAnimation} [renderable]\n * @param  {String}                    [propertyName]\n * @return {TargetsArray}\n */\nconst remove = (targets, renderable, propertyName) => {\n  const targetsArray = parseTargets(targets);\n  const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : engine);\n  const waapiAnimation = renderable && /** @type {WAAPIAnimation} */(renderable).controlAnimation && /** @type {WAAPIAnimation} */(renderable);\n  for (let i = 0, l = targetsArray.length; i < l; i++) {\n    const $el = /** @type {DOMTarget}  */(targetsArray[i]);\n    removeWAAPIAnimation($el, propertyName, waapiAnimation);\n  }\n  let removeMatches;\n  if (parent._hasChildren) {\n    let iterationDuration = 0;\n    forEachChildren(parent, (/** @type {Renderable} */child) => {\n      if (!child._hasChildren) {\n        removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);\n        // Remove the child from its parent if no tweens and no children left after the removal\n        if (removeMatches && !child._head) {\n          child.cancel();\n          removeChild(parent, child);\n        } else {\n          // Calculate the new iterationDuration value to handle onComplete with last child in render()\n          const childTLOffset = child._offset + child._delay;\n          const childDur = childTLOffset + child.duration;\n          if (childDur > iterationDuration) {\n            iterationDuration = childDur;\n          }\n        }\n      }\n      // Make sure to also remove engine's children targets\n      // NOTE: Avoid recursion?\n      if (child._head) {\n        remove(targets, child, propertyName);\n      } else {\n        child._hasChildren = false;\n      }\n    }, true);\n    // Update iterationDuration value to handle onComplete with last child in render()\n    if (!isUnd(/** @type {Renderable} */(parent).iterationDuration)) {\n      /** @type {Renderable} */(parent).iterationDuration = iterationDuration;\n    }\n  } else {\n    removeMatches = removeTargetsFromAnimation(\n      targetsArray,\n      /** @type {JSAnimation} */(parent),\n      propertyName\n    );\n  }\n\n  if (removeMatches && !parent._head) {\n    parent._hasChildren = false;\n    // Cancel the parent if there are no tweens and no children left after the removal\n    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself\n    if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();\n  }\n\n  return targetsArray;\n};\n\n/**\n * @param  {(...args: any[]) => Tickable} constructor\n * @return {(...args: any[]) => Tickable}\n */\nconst keepTime = createRefreshable;\n\n/**\n * @param  {String|Array} items\n * @return {any}\n */\nconst randomPick = items => items[random(0, items.length - 1)];\n\n/**\n * @param  {Number|String} v\n * @param  {Number} decimalLength\n * @return {String}\n */\nconst roundPad = (v, decimalLength) => (+v).toFixed(decimalLength);\n\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */\nconst padStart = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);\n\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */\nconst padEnd = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);\n\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */\nconst wrap = (v, min, max) => (((v - min) % (max - min) + (max - min)) % (max - min)) + min;\n\n/**\n * @param  {Number} value\n * @param  {Number} inLow\n * @param  {Number} inHigh\n * @param  {Number} outLow\n * @param  {Number} outHigh\n * @return {Number}\n */\nconst mapRange = (value, inLow, inHigh, outLow, outHigh) => outLow + ((value - inLow) / (inHigh - inLow)) * (outHigh - outLow);\n\n/**\n * @param  {Number} degrees\n * @return {Number}\n */\nconst degToRad = degrees => degrees * PI / 180;\n\n/**\n * @param  {Number} radians\n * @return {Number}\n */\nconst radToDeg = radians => radians * 180 / PI;\n\n/**\n * https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} amount\n * @param  {Renderable|Boolean} [renderable]\n * @return {Number}\n */\nconst lerp = (start, end, amount, renderable) => {\n  let dt = K / globals.defaults.frameRate;\n  if (renderable !== false) {\n    const ticker = /** @type Renderable */\n                   (renderable) ||\n                   (engine._hasChildren && engine);\n    if (ticker && ticker.deltaTime) {\n      dt = ticker.deltaTime;\n    }\n  }\n  const t = 1 - Math.exp(-amount * dt * .1);\n  return !amount ? start : amount === 1 ? end : (1 - t) * start + t * end;\n};\n\n// Chain-able utilities\n\n/**\n * @callback UtilityFunction\n * @param {...*} args\n * @return {Number|String}\n *\n * @param {UtilityFunction} fn\n * @param {Number} [last=0]\n * @return {function(...(Number|String)): function(Number|String): (Number|String)}\n */\nconst curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);\n\n/**\n * @param {Function} fn\n * @return {function(...(Number|String))}\n */\nconst chain = fn => {\n   return (...args) => {\n    const result = fn(...args);\n    return new Proxy(noop, {\n      apply: (_, __, [v]) => result(v),\n      get: (_, prop) => chain(/**@param {...Number|String} nextArgs */(...nextArgs) => {\n        const nextResult = utils[prop](...nextArgs);\n        return (/**@type {Number|String} */v) => nextResult(result(v));\n      })\n    });\n  }\n};\n\n/**\n * @param {UtilityFunction} fn\n * @param {Number} [right]\n * @return {function(...(Number|String)): UtilityFunction}\n */\nconst makeChainable = (fn, right = 0) => (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);\n\n/**\n * @callback ChainedUtilsResult\n * @param {Number} value\n * @return {Number}\n *\n * @typedef {Object} ChainableUtils\n * @property {ChainedClamp} clamp\n * @property {ChainedRound} round\n * @property {ChainedSnap} snap\n * @property {ChainedWrap} wrap\n * @property {ChainedInterpolate} interpolate\n * @property {ChainedMapRange} mapRange\n * @property {ChainedRoundPad} roundPad\n * @property {ChainedPadStart} padStart\n * @property {ChainedPadEnd} padEnd\n * @property {ChainedDegToRad} degToRad\n * @property {ChainedRadToDeg} radToDeg\n *\n * @typedef {ChainableUtils & ChainedUtilsResult} ChainableUtil\n *\n * @callback ChainedClamp\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedRound\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedSnap\n * @param {Number} increment\n * @return {ChainableUtil}\n *\n * @callback ChainedWrap\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedInterpolate\n * @param {Number} start\n * @param {Number} end\n * @return {ChainableUtil}\n *\n * @callback ChainedMapRange\n * @param {Number} inLow\n * @param {Number} inHigh\n * @param {Number} outLow\n * @param {Number} outHigh\n * @return {ChainableUtil}\n *\n * @callback ChainedRoundPad\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedPadStart\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedPadEnd\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedDegToRad\n * @return {ChainableUtil}\n *\n * @callback ChainedRadToDeg\n * @return {ChainableUtil}\n */\n\nconst utils = {\n  $: registerTargets,\n  get: getTargetValue,\n  set: setTargetValues,\n  remove,\n  cleanInlineStyles,\n  random,\n  randomPick,\n  shuffle,\n  lerp,\n  sync,\n  keepTime,\n  clamp: /** @type {typeof clamp & ChainedClamp} */(makeChainable(clamp)),\n  round: /** @type {typeof round & ChainedRound} */(makeChainable(round)),\n  snap: /** @type {typeof snap & ChainedSnap} */(makeChainable(snap)),\n  wrap: /** @type {typeof wrap & ChainedWrap} */(makeChainable(wrap)),\n  interpolate: /** @type {typeof interpolate & ChainedInterpolate} */(makeChainable(interpolate, 1)),\n  mapRange: /** @type {typeof mapRange & ChainedMapRange} */(makeChainable(mapRange)),\n  roundPad: /** @type {typeof roundPad & ChainedRoundPad} */(makeChainable(roundPad)),\n  padStart: /** @type {typeof padStart & ChainedPadStart} */(makeChainable(padStart)),\n  padEnd: /** @type {typeof padEnd & ChainedPadEnd} */(makeChainable(padEnd)),\n  degToRad: /** @type {typeof degToRad & ChainedDegToRad} */(makeChainable(degToRad)),\n  radToDeg: /** @type {typeof radToDeg & ChainedRadToDeg} */(makeChainable(radToDeg)),\n};\n\n\n\n\n/**\n * Timeline's children offsets positions parser\n * @param  {Timeline} timeline\n * @param  {String} timePosition\n * @return {Number}\n */\nconst getPrevChildOffset = (timeline, timePosition) => {\n  if (stringStartsWith(timePosition, '<')) {\n    const goToPrevAnimationOffset = timePosition[1] === '<';\n    const prevAnimation = /** @type {Tickable} */(timeline._tail);\n    const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;\n    return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;\n  }\n};\n\n/**\n * @param  {Timeline} timeline\n * @param  {TimelinePosition} [timePosition]\n * @return {Number}\n */\nconst parseTimelinePosition = (timeline, timePosition) => {\n  let tlDuration = timeline.iterationDuration;\n  if (tlDuration === minValue) tlDuration = 0;\n  if (isUnd(timePosition)) return tlDuration;\n  if (isNum(+timePosition)) return +timePosition;\n  const timePosStr = /** @type {String} */(timePosition);\n  const tlLabels = timeline ? timeline.labels : null;\n  const hasLabels = !isNil(tlLabels);\n  const prevOffset = getPrevChildOffset(timeline, timePosStr);\n  const hasSibling = !isUnd(prevOffset);\n  const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);\n  if (matchedRelativeOperator) {\n    const fullOperator = matchedRelativeOperator[0];\n    const split = timePosStr.split(fullOperator);\n    const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;\n    const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;\n    const parsedNumericalOffset = +split[1];\n    return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);\n  } else {\n    return hasSibling ? prevOffset :\n           hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] :\n           tlDuration : tlDuration;\n  }\n};\n\n/**\n * @param {Timeline} tl\n * @return {Number}\n */\nfunction getTimelineTotalDuration(tl) {\n  return clampInfinity(((tl.iterationDuration + tl._loopDelay) * tl.iterationCount) - tl._loopDelay) || minValue;\n}\n\n/**\n * @overload\n * @param  {TimerParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @return {Timeline}\n *\n * @overload\n * @param  {AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} targets\n * @param  {Number} [index]\n * @param  {Number} [length]\n * @return {Timeline}\n *\n * @param  {TimerParams|AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} [targets]\n * @param  {Number} [index]\n * @param  {Number} [length]\n */\nfunction addTlChild(childParams, tl, timePosition, targets, index, length) {\n  const isSetter = isNum(childParams.duration) && /** @type {Number} */(childParams.duration) <= minValue;\n  // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position\n  const adjustedPosition = isSetter ? timePosition - minValue : timePosition;\n  tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);\n  const tlChild = targets ?\n    new JSAnimation(targets,/** @type {AnimationParams} */(childParams), tl, adjustedPosition, false, index, length) :\n    new Timer(/** @type {TimerParams} */(childParams), tl, adjustedPosition);\n  tlChild.init(1);\n  // TODO: Might be better to insert at a position relative to startTime?\n  addChild(tl, tlChild);\n  forEachChildren(tl, (/** @type {Renderable} */child) => {\n    const childTLOffset = child._offset + child._delay;\n    const childDur = childTLOffset + child.duration;\n    if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;\n  });\n  tl.duration = getTimelineTotalDuration(tl);\n  return tl;\n}\n\nclass Timeline extends Timer {\n\n  /**\n   * @param {TimelineParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    super(/** @type {TimerParams&TimelineParams} */(parameters), null, 0);\n    /** @type {Number} */\n    this.duration = 0; // TL duration starts at 0 and grows when adding children\n    /** @type {Record<String, Number>} */\n    this.labels = {};\n    const defaultsParams = parameters.defaults;\n    const globalDefaults = globals.defaults;\n    /** @type {DefaultsParams} */\n    this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;\n    /** @type {Callback<this>} */\n    this.onRender = parameters.onRender || globalDefaults.onRender;\n    const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);\n    this._ease = tlPlaybackEase ? parseEasings(tlPlaybackEase) : null;\n    /** @type {Number} */\n    this.iterationDuration = 0;\n  }\n\n  /**\n   * @overload\n   * @param {TargetsParam} a1\n   * @param {AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   * @return {this}\n   *\n   * @overload\n   * @param {TimerParams} a1\n   * @param {TimelinePosition} [a2]\n   * @return {this}\n   *\n   * @param {TargetsParam|TimerParams} a1\n   * @param {TimelinePosition|AnimationParams} a2\n   * @param {TimelinePosition|StaggerFunction<Number|String>} [a3]\n   */\n  add(a1, a2, a3) {\n    const isAnim = isObj(a2);\n    const isTimer = isObj(a1);\n    if (isAnim || isTimer) {\n      this._hasChildren = true;\n      if (isAnim) {\n        const childParams = /** @type {AnimationParams} */(a2);\n        // Check for function for children stagger positions\n        if (isFnc(a3)) {\n          const staggeredPosition = a3;\n          const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */(a1));\n          // Store initial duration before adding new children that will change the duration\n          const tlDuration = this.duration;\n          // Store initial _iterationDuration before adding new children that will change the duration\n          const tlIterationDuration = this.iterationDuration;\n          // Store the original id in order to add specific indexes to the new animations ids\n          const id = childParams.id;\n          let i = 0;\n          /** @type {Number} */\n          const parsedLength = (parsedTargetsArray.length);\n          parsedTargetsArray.forEach((/** @type {Target} */target) => {\n            // Create a new parameter object for each staggered children\n            const staggeredChildParams = { ...childParams };\n            // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation\n            this.duration = tlDuration;\n            this.iterationDuration = tlIterationDuration;\n            if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;\n            addTlChild(\n              staggeredChildParams,\n              this,\n              parseTimelinePosition(this, staggeredPosition(target, i, parsedLength, this)),\n              target,\n              i,\n              parsedLength\n            );\n            i++;\n          });\n        } else {\n          addTlChild(\n            childParams,\n            this,\n            parseTimelinePosition(this, a3),\n            /** @type {TargetsParam} */(a1),\n          );\n        }\n      } else {\n        // It's a Timer\n        addTlChild(\n          /** @type TimerParams */(a1),\n          this,\n          parseTimelinePosition(this,a2),\n        );\n      }\n      return this.init(1); // 1 = internalRender\n    }\n  }\n\n  /**\n   * @overload\n   * @param {Tickable} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {WAAPIAnimation} [synced]\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]\n   * @param {TimelinePosition} [position]\n   */\n  sync(synced, position) {\n    if (isUnd(synced) || synced && isUnd(synced.pause)) return this;\n    synced.pause();\n    const duration = +(/** @type {globalThis.Animation} */(synced).effect ? /** @type {globalThis.Animation} */(synced).effect.getTiming().duration : /** @type {Tickable} */(synced).duration);\n    return this.add(synced, { currentTime: [0, duration], duration, ease: 'linear' }, position);\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {AnimationParams} parameters\n   * @param  {TimelinePosition} [position]\n   * @return {this}\n   */\n  set(targets, parameters, position) {\n    if (isUnd(parameters)) return this;\n    parameters.duration = minValue;\n    parameters.composition = compositionTypes.replace;\n    return this.add(targets, parameters, position);\n  }\n\n  /**\n   * @param {Callback<Timer>} callback\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   */\n  call(callback, position) {\n    if (isUnd(callback) || callback && !isFnc(callback)) return this;\n    return this.add({ duration: 0, onComplete: () => callback(this) }, position);\n  }\n\n  /**\n   * @param {String} labelName\n   * @param {TimelinePosition} [position]\n   * @return {this}\n   *\n   */\n  label(labelName, position) {\n    if (isUnd(labelName) || labelName && !isStr(labelName)) return this;\n    this.labels[labelName] = parseTimelinePosition(this, position);\n    return this;\n  }\n\n  /**\n   * @param  {TargetsParam} targets\n   * @param  {String} [propertyName]\n   * @return {this}\n   */\n  remove(targets, propertyName) {\n    remove(targets, this, propertyName);\n    return this;\n  }\n\n  /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */\n  stretch(newDuration) {\n    const currentDuration = this.duration;\n    if (currentDuration === normalizeTime(newDuration)) return this;\n    const timeScale = newDuration / currentDuration;\n    const labels = this.labels;\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.stretch(child.duration * timeScale));\n    for (let labelName in labels) labels[labelName] *= timeScale;\n    return super.stretch(newDuration);\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    forEachChildren(this, (/** @type {JSAnimation} */child) => {\n      if (child.refresh) child.refresh();\n    });\n    return this;\n  }\n\n  /**\n   * @return {this}\n   */\n  revert() {\n    super.revert();\n    forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);\n    return cleanInlineStyles(this);\n  }\n\n  /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */\n  then(callback) {\n    return super.then(callback);\n  }\n}\n\n/**\n * @param {TimelineParams} [parameters]\n * @return {Timeline}\n */\nconst createTimeline = parameters => new Timeline(parameters).init();\n\n\n\n\nclass Animatable {\n  /**\n   * @param {TargetsParam} targets\n   * @param {AnimatableParams} parameters\n   */\n  constructor(targets, parameters) {\n    if (scope.current) scope.current.register(this);\n    const beginHandler = () => {\n      if (this.callbacks.completed) this.callbacks.reset();\n      this.callbacks.play();\n    };\n    const pauseHandler = () => {\n      if (this.callbacks.completed) return;\n      let paused = true;\n      for (let name in this.animations) {\n        const anim = this.animations[name];\n        if (!anim.paused && paused) {\n          paused = false;\n          break;\n        }\n      }\n      if (paused) {\n        this.callbacks.complete();\n      }\n    };\n    /** @type {AnimationParams} */\n    const globalParams = {\n      onBegin: beginHandler,\n      onComplete: pauseHandler,\n      onPause: pauseHandler,\n    };\n    /** @type {AnimationParams} */\n    const callbacksAnimationParams = { v: 1, autoplay: false };\n    const properties = {};\n    this.targets = [];\n    this.animations = {};\n    /** @type {JSAnimation|null} */\n    this.callbacks = null;\n    if (isUnd(targets) || isUnd(parameters)) return;\n    for (let propName in parameters) {\n      const paramValue = parameters[propName];\n      if (isKey(propName)) {\n        properties[propName] = paramValue;\n      } else if (stringStartsWith(propName, 'on')) {\n        callbacksAnimationParams[propName] = paramValue;\n      } else {\n        globalParams[propName] = paramValue;\n      }\n    }\n    this.callbacks = new JSAnimation({ v: 0 }, callbacksAnimationParams);\n    for (let propName in properties) {\n      const propValue = properties[propName];\n      const isObjValue = isObj(propValue);\n      /** @type {TweenParamsOptions} */\n      let propParams = {};\n      let to = '+=0';\n      if (isObjValue) {\n        const unit = propValue.unit;\n        if (isStr(unit)) to += unit;\n      } else {\n        propParams.duration = propValue;\n      }\n      propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;\n      const animParams = mergeObjects(globalParams, propParams);\n      animParams.composition = compositionTypes.replace;\n      animParams.autoplay = false;\n      const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();\n      if (!this.targets.length) this.targets.push(...animation.targets);\n      /** @type {AnimatableProperty} */\n      this[propName] = (to, duration, ease) => {\n        const tween = /** @type {Tween} */(animation._head);\n        if (isUnd(to) && tween) {\n          const numbers = tween._numbers;\n          if (numbers && numbers.length) {\n            return numbers;\n          } else {\n            return tween._modifier(tween._number);\n          }\n        } else {\n          forEachChildren(animation, (/** @type {Tween} */tween) => {\n            if (isArr(to)) {\n              for (let i = 0, l = /** @type {Array} */(to).length; i < l; i++) {\n                if (!isUnd(tween._numbers[i])) {\n                  tween._fromNumbers[i] = /** @type {Number} */(tween._modifier(tween._numbers[i]));\n                  tween._toNumbers[i] = to[i];\n                }\n              }\n            } else {\n              tween._fromNumber = /** @type {Number} */(tween._modifier(tween._number));\n              tween._toNumber = /** @type {Number} */(to);\n            }\n            if (!isUnd(ease)) tween._ease = parseEasings(ease);\n            tween._currentTime = 0;\n          });\n          if (!isUnd(duration)) animation.stretch(duration);\n          animation.reset(1).resume();\n          return this;\n        }\n      };\n    }\n  }\n\n  revert() {\n    for (let propName in this.animations) {\n      this[propName] = noop;\n      this.animations[propName].revert();\n    }\n    this.animations = {};\n    this.targets.length = 0;\n    if (this.callbacks) this.callbacks.revert();\n    return this;\n  }\n}\n\n/**\n * @param {TargetsParam} targets\n * @param {AnimatableParams} parameters\n * @return {AnimatableObject}\n */\nconst createAnimatable = (targets, parameters) => /** @type {AnimatableObject} */ (new Animatable(targets, parameters));\n\n\n\n\n/*\n * Spring ease solver adapted from https://webkit.org/demos/spring/spring.js\n * Webkit Copyright  2016 Apple Inc\n */\n\nconst maxSpringParamValue = K * 10;\n\n/**\n * @typedef {Object} SpringParams\n * @property {Number} [mass=1] - Mass, default 1\n * @property {Number} [stiffness=100] - Stiffness, default 100\n * @property {Number} [damping=10] - Damping, default 10\n * @property {Number} [velocity=0] - Initial velocity, default 0\n */\nclass Spring {\n  /**\n   * @param {SpringParams} [parameters]\n   */\n  constructor(parameters = {}) {\n    this.timeStep = .02; // Interval fed to the solver to calculate duration\n    this.restThreshold = .0005; // Values below this threshold are considered resting position\n    this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold\n    this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)\n    this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation\n    this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration\n    this.m = clamp(setValue(parameters.mass, 1), 0, maxSpringParamValue);\n    this.s = clamp(setValue(parameters.stiffness, 100), 1, maxSpringParamValue);\n    this.d = clamp(setValue(parameters.damping, 10), .1, maxSpringParamValue);\n    this.v = clamp(setValue(parameters.velocity, 0), -maxSpringParamValue, maxSpringParamValue);\n    this.w0 = 0;\n    this.zeta = 0;\n    this.wd = 0;\n    this.b = 0;\n    this.solverDuration = 0;\n    this.duration = 0;\n    this.compute();\n    /** @type {EasingFunction} */\n    this.ease = t => t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);\n  }\n\n  /** @type {EasingFunction} */\n  solve(time) {\n    const { zeta, w0, wd, b } = this;\n    let t = time;\n    if (zeta < 1) {\n      t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));\n    } else {\n      t = (1 + b * t) * exp(-t * w0);\n    }\n    return 1 - t;\n  }\n\n  compute() {\n    const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;\n    const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);\n    const zeta = this.zeta = d / (2 * sqrt(s * m));\n    const wd = this.wd = zeta < 1 ? w0 * sqrt(1 - zeta * zeta) : 0;\n    this.b = zeta < 1 ? (zeta * w0 + -v) / wd : -v + w0;\n    let solverTime = 0;\n    let restSteps = 0;\n    let iterations = 0;\n    while (restSteps < maxRestSteps && iterations < maxIterations) {\n      if (abs(1 - this.solve(solverTime)) < restThreshold) {\n        restSteps++;\n      } else {\n        restSteps = 0;\n      }\n      this.solverDuration = solverTime;\n      solverTime += timeStep;\n      iterations++;\n    }\n    this.duration = round(this.solverDuration * K, 0) * globals.timeScale;\n  }\n\n  get mass() {\n    return this.m;\n  }\n\n  set mass(v) {\n    this.m = clamp(setValue(v, 1), 0, maxSpringParamValue);\n    this.compute();\n  }\n\n  get stiffness() {\n    return this.s;\n  }\n\n  set stiffness(v) {\n    this.s = clamp(setValue(v, 100), 1, maxSpringParamValue);\n    this.compute();\n  }\n\n  get damping() {\n    return this.d;\n  }\n\n  set damping(v) {\n    this.d = clamp(setValue(v, 10), .1, maxSpringParamValue);\n    this.compute();\n  }\n\n  get velocity() {\n    return this.v;\n  }\n\n  set velocity(v) {\n    this.v = clamp(setValue(v, 0), -maxSpringParamValue, maxSpringParamValue);\n    this.compute();\n  }\n}\n\n/**\n * @param {SpringParams} [parameters]\n * @returns {Spring}\n */\nconst createSpring = (parameters) => new Spring(parameters);\n\n\n\n\n/**\n * @param {Event} e\n */\nconst preventDefault = e => {\n  if (e.cancelable) e.preventDefault();\n};\n\nclass DOMProxy {\n  /** @param {Object} el */\n  constructor(el) {\n    this.el = el;\n    this.zIndex = 0;\n    this.parentElement = null;\n    this.classList = {\n      add: noop,\n      remove: noop,\n    };\n  }\n\n  get x() { return this.el.x || 0 };\n  set x(v) { this.el.x = v; };\n\n  get y() { return this.el.y || 0 };\n  set y(v) { this.el.y = v; };\n\n  get width() { return this.el.width || 0 };\n  set width(v) { this.el.width = v; };\n\n  get height() { return this.el.height || 0 };\n  set height(v) { this.el.height = v; };\n\n  getBoundingClientRect() {\n    return {\n      top: this.y,\n      right: this.x,\n      bottom: this.y + this.height,\n      left: this.x + this.width,\n    }\n  }\n}\n\nclass Transforms {\n  /**\n   * @param {DOMTarget|DOMProxy} $el\n   */\n  constructor($el) {\n    this.$el = $el;\n    this.inlineTransforms = [];\n    this.point = new DOMPoint();\n    this.inversedMatrix = this.getMatrix().inverse();\n  }\n\n  /**\n   * @param {Number} x\n   * @param {Number} y\n   * @return {DOMPoint}\n   */\n  normalizePoint(x, y) {\n    this.point.x = x;\n    this.point.y = y;\n    return this.point.matrixTransform(this.inversedMatrix);\n  }\n\n  /**\n   * @callback TraverseParentsCallback\n   * @param {DOMTarget} $el\n   * @param {Number} i\n   */\n\n  /**\n   * @param {TraverseParentsCallback} cb\n   */\n  traverseUp(cb) {\n    let $el = /** @type {DOMTarget|Document} */(this.$el.parentElement), i = 0;\n    while ($el && $el !== doc) {\n      cb(/** @type {DOMTarget} */($el), i);\n      $el = /** @type {DOMTarget} */($el.parentElement);\n      i++;\n    }\n  }\n\n  getMatrix() {\n    const matrix = new DOMMatrix();\n    this.traverseUp($el => {\n      const transformValue = getComputedStyle($el).transform;\n      if (transformValue) {\n        const elMatrix = new DOMMatrix(transformValue);\n        matrix.preMultiplySelf(elMatrix);\n      }\n    });\n    return matrix;\n  }\n\n  remove() {\n    this.traverseUp(($el, i) => {\n      this.inlineTransforms[i] = $el.style.transform;\n      $el.style.transform = 'none';\n    });\n  }\n\n  revert() {\n    this.traverseUp(($el, i) => {\n      const ct = this.inlineTransforms[i];\n      if (ct === '') {\n        $el.style.removeProperty('transform');\n      } else {\n        $el.style.transform = ct;\n      }\n    });\n  }\n}\n\n/**\n * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams} T\n * @param {T | ((draggable: Draggable) => T)} value\n * @param {Draggable} draggable\n * @return {T}\n */\nconst parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */(value)(draggable) : value;\n\nlet zIndex = 0;\n\nclass Draggable {\n  /**\n   * @param {TargetsParam} target\n   * @param {DraggableParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    if (!target) return;\n    if (scope.current) scope.current.register(this);\n    const paramX = parameters.x;\n    const paramY = parameters.y;\n    const trigger = parameters.trigger;\n    const modifier = parameters.modifier;\n    const ease = parameters.releaseEase;\n    const customEase = ease && parseEasings(ease);\n    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);\n    const xProp = /** @type {String} */(isObj(paramX) && !isUnd(/** @type {Object} */(paramX).mapTo) ? /** @type {Object} */(paramX).mapTo : 'translateX');\n    const yProp = /** @type {String} */(isObj(paramY) && !isUnd(/** @type {Object} */(paramY).mapTo) ? /** @type {Object} */(paramY).mapTo : 'translateY');\n    const container = parseDraggableFunctionParameter(parameters.container, this);\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.$target = /** @type {HTMLElement} */(isObj(target) ? new DOMProxy(target) : parseTargets(target)[0]);\n    this.$trigger = /** @type {HTMLElement} */(parseTargets(trigger ? trigger : target)[0]);\n    this.fixed = getTargetValue(this.$target, 'position') === 'fixed';\n    // Refreshable parameters\n    this.isFinePointer = true;\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerPadding = [0, 0, 0, 0];\n    /** @type {Number} */\n    this.containerFriction = 0;\n    /** @type {Number} */\n    this.releaseContainerFriction = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapX = 0;\n    /** @type {Number|Array<Number>} */\n    this.snapY = 0;\n    /** @type {Number} */\n    this.scrollSpeed = 0;\n    /** @type {Number} */\n    this.scrollThreshold = 0;\n    /** @type {Number} */\n    this.dragSpeed = 0;\n    /** @type {Number} */\n    this.maxVelocity = 0;\n    /** @type {Number} */\n    this.minVelocity = 0;\n    /** @type {Number} */\n    this.velocityMultiplier = 0;\n    /** @type {Boolean|DraggableCursorParams} */\n    this.cursor = false;\n    /** @type {Spring} */\n    this.releaseXSpring = hasSpring ? /** @type {Spring} */(ease) : createSpring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20),\n    });\n    /** @type {Spring} */\n    this.releaseYSpring = hasSpring ? /** @type {Spring} */(ease) : createSpring({\n      mass: setValue(parameters.releaseMass, 1),\n      stiffness: setValue(parameters.releaseStiffness, 80),\n      damping: setValue(parameters.releaseDamping, 20),\n    });\n    /** @type {EasingFunction} */\n    this.releaseEase = customEase || eases.outQuint;\n    /** @type {Boolean} */\n    this.hasReleaseSpring = hasSpring;\n    /** @type {Callback<this>} */\n    this.onGrab = parameters.onGrab || noop;\n    /** @type {Callback<this>} */\n    this.onDrag = parameters.onDrag || noop;\n    /** @type {Callback<this>} */\n    this.onRelease = parameters.onRelease || noop;\n    /** @type {Callback<this>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<this>} */\n    this.onSettle = parameters.onSettle || noop;\n    /** @type {Callback<this>} */\n    this.onSnap = parameters.onSnap || noop;\n    /** @type {Callback<this>} */\n    this.onResize = parameters.onResize || noop;\n    /** @type {Callback<this>} */\n    this.onAfterResize = parameters.onAfterResize || noop;\n    /** @type {[Number, Number]} */\n    this.disabled = [0, 0];\n    /** @type {AnimatableParams} */\n    const animatableParams = {};\n    if (modifier) animatableParams.modifier = modifier;\n    if (isUnd(paramX) || paramX === true) {\n      animatableParams[xProp] = 0;\n    } else if (isObj(paramX)) {\n      const paramXObject = /** @type {DraggableAxisParam} */(paramX);\n      const animatableXParams = {};\n      if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;\n      if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;\n      animatableParams[xProp] = animatableXParams;\n    } else if (paramX === false) {\n      animatableParams[xProp] = 0;\n      this.disabled[0] = 1;\n    }\n    if (isUnd(paramY) || paramY === true) {\n      animatableParams[yProp] = 0;\n    } else if (isObj(paramY)) {\n      const paramYObject = /** @type {DraggableAxisParam} */(paramY);\n      const animatableYParams = {};\n      if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;\n      if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;\n      animatableParams[yProp] = animatableYParams;\n    } else if (paramY === false) {\n      animatableParams[yProp] = 0;\n      this.disabled[1] = 1;\n    }\n    /** @type {AnimatableObject} */\n    this.animate = /** @type {AnimatableObject} */(new Animatable(this.$target, animatableParams));\n    // Internal props\n    this.xProp = xProp;\n    this.yProp = yProp;\n    this.destX = 0;\n    this.destY = 0;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.scroll = {x: 0, y: 0};\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y\n    /** @type {[Number, Number]} */\n    this.snapped = [0, 0]; // x, y\n    /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */\n    this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2\n    /** @type {[Number, Number]} */\n    this.scrollView = [0, 0]; // w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.dragArea = [0, 0, 0, 0]; // x, y, w, h\n    /** @type {[Number, Number, Number, Number]} */\n    this.containerBounds = [-maxValue, maxValue, maxValue, -maxValue]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number, Number, Number]} */\n    this.targetBounds = [0, 0, 0, 0]; // t, r, b, l\n    /** @type {[Number, Number]} */\n    this.window = [0, 0]; // w, h\n    /** @type {[Number, Number, Number]} */\n    this.velocityStack = [0, 0, 0];\n    /** @type {Number} */\n    this.velocityStackIndex = 0;\n    /** @type {Number} */\n    this.velocityTime = now();\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Number} */\n    this.angle = 0;\n    /** @type {JSAnimation} */\n    this.cursorStyles = null;\n    /** @type {JSAnimation} */\n    this.triggerStyles = null;\n    /** @type {JSAnimation} */\n    this.bodyStyles = null;\n    /** @type {JSAnimation} */\n    this.targetStyles = null;\n    /** @type {JSAnimation} */\n    this.touchActionStyles = null;\n    this.transforms = new Transforms(this.$target);\n    this.overshootCoords = { x: 0, y: 0 };\n    this.overshootTicker = new Timer({\n      autoplay: false,\n      onUpdate: () => {\n        this.updated = true;\n        this.manual = true;\n        // Use a duration of 1 to prevent the animatable from completing immediately to prevent issues with onSettle()\n        // https://github.com/juliangarnier/anime/issues/1045\n        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 1);\n        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 1);\n      },\n      onComplete: () => {\n        this.manual = false;\n        if (!this.disabled[0]) this.animate[this.xProp](this.overshootCoords.x, 0);\n        if (!this.disabled[1]) this.animate[this.yProp](this.overshootCoords.y, 0);\n      },\n    }, null, 0).init();\n    this.updateTicker = new Timer({ autoplay: false, onUpdate: () => this.update() }, null,0,).init();\n    this.contained = !isUnd(container);\n    this.manual = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.enabled = false;\n    this.initialized = false;\n    this.activeProp = this.disabled[1] ? xProp : yProp;\n    this.animate.callbacks.onRender = () => {\n      const hasUpdated = this.updated;\n      const hasMoved = this.grabbed && hasUpdated;\n      const hasReleased = !hasMoved && this.released;\n      const x = this.x;\n      const y = this.y;\n      const dx = x - this.coords[2];\n      const dy = y - this.coords[3];\n      this.deltaX = dx;\n      this.deltaY = dy;\n      this.coords[2] = x;\n      this.coords[3] = y;\n      // Check if dx or dy are not 0 to check if the draggable has actually moved\n      // https://github.com/juliangarnier/anime/issues/1032\n      if (hasUpdated && (dx || dy)) {\n        this.onUpdate(this);\n      }\n      if (!hasReleased) {\n        this.updated = false;\n      } else {\n        this.computeVelocity(dx, dy);\n        this.angle = atan2(dy, dx);\n      }\n    };\n    this.animate.callbacks.onComplete = () => {\n      if ((!this.grabbed && this.released)) {\n        // Set released to false before calling onSettle to avoid recursion\n        this.released = false;\n      }\n      if (!this.manual) {\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.velocity = 0;\n        this.velocityStack[0] = 0;\n        this.velocityStack[1] = 0;\n        this.velocityStack[2] = 0;\n        this.velocityStackIndex = 0;\n        this.onSettle(this);\n      }\n    };\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 150 * globals.timeScale,\n      onComplete: () => {\n        this.onResize(this);\n        this.refresh();\n        this.onAfterResize(this);\n      },\n    }).init();\n    this.parameters = parameters;\n    this.resizeObserver = new ResizeObserver(() => {\n      if (this.initialized) {\n        this.resizeTicker.restart();\n      } else {\n        this.initialized = true;\n      }\n    });\n    this.enable();\n    this.refresh();\n    this.resizeObserver.observe(this.$container);\n    if (!isObj(target)) this.resizeObserver.observe(this.$target);\n  }\n\n  /**\n   * @param  {Number} dx\n   * @param  {Number} dy\n   * @return {Number}\n   */\n  computeVelocity(dx, dy) {\n    const prevTime = this.velocityTime;\n    const curTime = now();\n    const elapsed = curTime - prevTime;\n    if (elapsed < 17) return this.velocity;\n    this.velocityTime = curTime;\n    const velocityStack = this.velocityStack;\n    const vMul = this.velocityMultiplier;\n    const minV = this.minVelocity;\n    const maxV = this.maxVelocity;\n    const vi = this.velocityStackIndex;\n    velocityStack[vi] = round(clamp((sqrt(dx * dx + dy * dy) / elapsed) * vMul, minV, maxV), 5);\n    const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);\n    this.velocity = velocity;\n    this.velocityStackIndex = (vi + 1) % 3;\n    return velocity;\n  }\n\n  /**\n   * @param {Number}  x\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setX(x, muteUpdateCallback = false) {\n    if (this.disabled[0]) return;\n    const v = round(x, 5);\n    this.overshootTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destX = v;\n    this.snapped[0] = snap(v, this.snapX);\n    this.animate[this.xProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n\n  /**\n   * @param {Number}  y\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */\n  setY(y, muteUpdateCallback = false) {\n    if (this.disabled[1]) return;\n    const v = round(y, 5);\n    this.overshootTicker.pause();\n    this.manual = true;\n    this.updated = !muteUpdateCallback;\n    this.destY = v;\n    this.snapped[1] = snap(v, this.snapY);\n    this.animate[this.yProp](v, 0);\n    this.manual = false;\n    return this;\n  }\n\n  get x() {\n    return round(/** @type {Number} */(this.animate[this.xProp]()), globals.precision);\n  }\n\n  set x(x) {\n    this.setX(x, false);\n  }\n\n  get y() {\n    return round(/** @type {Number} */(this.animate[this.yProp]()), globals.precision);\n  }\n\n  set y(y) {\n    this.setY(y, false);\n  }\n\n  get progressX() {\n    return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);\n  }\n\n  set progressX(x) {\n    this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);\n  }\n\n  get progressY() {\n    return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);\n  }\n\n  set progressY(y) {\n    this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);\n  }\n\n  updateScrollCoords() {\n    const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);\n    const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    const threshold = this.scrollThreshold;\n    this.scroll.x = sx;\n    this.scroll.y = sy;\n    this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;\n    this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;\n    this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;\n    this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;\n  }\n\n  updateBoundingValues() {\n    const $container = this.$container;\n    // Return early if no $container defined to prevents error when reading scrollWidth / scrollHeight\n    // https://github.com/juliangarnier/anime/issues/1064\n    if (!$container) return;\n    const cx = this.x;\n    const cy = this.y;\n    const cx2 = this.coords[2];\n    const cy2 =  this.coords[3];\n    // Prevents interfering with the scroll area in cases the target is outside of the container\n    // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates\n    this.coords[2] = 0;\n    this.coords[3] = 0;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.transforms.remove();\n    const iw = this.window[0] = win.innerWidth;\n    const ih = this.window[1] = win.innerHeight;\n    const uw = this.useWin;\n    const sw = $container.scrollWidth;\n    const sh = $container.scrollHeight;\n    const fx = this.fixed;\n    const transformContainerRect = $container.getBoundingClientRect();\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    this.dragArea[0] = uw ? 0 : transformContainerRect.left;\n    this.dragArea[1] = uw ? 0 : transformContainerRect.top;\n    this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;\n    this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;\n    this.updateScrollCoords();\n    const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();\n    this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);\n    this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);\n    const containerOverflow = getTargetValue($container, 'overflow');\n    const visibleOverflow = containerOverflow === 'visible';\n    const hiddenOverflow = containerOverflow === 'hidden';\n    this.canScroll = fx ? false :\n      this.contained &&\n      (($container === doc.body && visibleOverflow) || (!hiddenOverflow && !visibleOverflow)) &&\n      (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) &&\n      (!this.containerArray || (this.containerArray && !isArr(this.containerArray)));\n    if (this.contained) {\n      const sx = this.scroll.x;\n      const sy = this.scroll.y;\n      const canScroll = this.canScroll;\n      const targetRect = this.$target.getBoundingClientRect();\n      const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;\n      const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;\n      const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;\n      const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;\n      this.targetBounds[0] = round((targetRect.top + sy) - (uw ? 0 : top), 0);\n      this.targetBounds[1] = round((targetRect.right + sx) - (uw ? iw : right), 0);\n      this.targetBounds[2] = round((targetRect.bottom + sy) - (uw ? ih : bottom), 0);\n      this.targetBounds[3] = round((targetRect.left + sx) - (uw ? 0 : left), 0);\n      if (this.containerArray) {\n        this.containerBounds[0] = this.containerArray[0] + cpt;\n        this.containerBounds[1] = this.containerArray[1] - cpr;\n        this.containerBounds[2] = this.containerArray[2] - cpb;\n        this.containerBounds[3] = this.containerArray[3] + cpl;\n      } else {\n        this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);\n        this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);\n        this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);\n        this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);\n      }\n    }\n    this.transforms.revert();\n    // Restore coordinates\n    this.coords[2] = cx2;\n    this.coords[3] = cy2;\n    this.setX(cx, true);\n    this.setY(cy, true);\n  }\n\n  /**\n   * @param  {Array} bounds\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {Number}\n   */\n  isOutOfBounds(bounds, x, y) {\n    // Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB\n    if (!this.contained) return 0;\n    const [ bt, br, bb, bl ] = bounds;\n    const [ dx, dy ] = this.disabled;\n    const obx = !dx && x < bl || !dx && x > br;\n    const oby = !dy && y < bt || !dy && y > bb;\n    return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;\n  }\n\n  refresh() {\n    const params = this.parameters;\n    const paramX = params.x;\n    const paramY = params.y;\n    const container = parseDraggableFunctionParameter(params.container, this);\n    const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;\n    const containerPadding = /** @type {[Number, Number, Number, Number]} */(isArr(cp) ? cp : [cp, cp, cp, cp]);\n    const cx = this.x;\n    const cy = this.y;\n    const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);\n    const cursorStyles = { onHover: 'grab', onGrab: 'grabbing' };\n    if (parsedCursorStyles) {\n      const { onHover, onGrab } = /** @type {DraggableCursorParams} */(parsedCursorStyles);\n      if (onHover) cursorStyles.onHover = onHover;\n      if (onGrab) cursorStyles.onGrab = onGrab;\n    }\n    this.containerArray = isArr(container) ? container : null;\n    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);\n    this.useWin = this.$container === doc.body;\n    /** @type {Window | HTMLElement} */\n    this.$scrollContainer = this.useWin ? win : this.$container;\n    this.isFinePointer = matchMedia('(pointer:fine)').matches;\n    this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);\n    this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);\n    this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);\n    this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);\n    this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);\n    this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);\n    this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);\n    this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);\n    this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);\n    this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);\n    this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);\n    this.cursor = parsedCursorStyles === false ? false : cursorStyles;\n    this.updateBoundingValues();\n\n    // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);\n    // if (ob === 1 || ob === 3) this.progressX = px;\n    // if (ob === 2 || ob === 3) this.progressY = py;\n\n    // if (this.initialized && this.contained) {\n    //   if (this.progressX !== px) this.progressX = px;\n    //   if (this.progressY !== py) this.progressY = py;\n    // }\n\n    const [ bt, br, bb, bl ] = this.containerBounds;\n    this.setX(clamp(cx, bl, br), true);\n    this.setY(clamp(cy, bt, bb), true);\n  }\n\n  update() {\n    this.updateScrollCoords();\n    if (this.canScroll) {\n      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n      const [ sw, sh ] = this.scrollView;\n      const daw = this.dragArea[2];\n      const dah = this.dragArea[3];\n      const csx = this.scroll.x;\n      const csy = this.scroll.y;\n      const nsw = this.$container.scrollWidth;\n      const nsh = this.$container.scrollHeight;\n      const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;\n      const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;\n      const swd = sw - csw;\n      const shd = sh - csh;\n      // Handle cases where the scrollarea dimensions changes during drag\n      if (this.dragged && swd > 0) {\n        this.coords[0] -= swd;\n        this.scrollView[0] = csw;\n      }\n      if (this.dragged && shd > 0) {\n        this.coords[1] -= shd;\n        this.scrollView[1] = csh;\n      }\n      // Handle autoscroll when target is at the edges of the scroll bounds\n      const s = this.scrollSpeed * 10;\n      const threshold = this.scrollThreshold;\n      const [ x, y ] = this.coords;\n      const [ st, sr, sb, sl ] = this.scrollBounds;\n      const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);\n      const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);\n      const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);\n      const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);\n      if (t || b || l || r) {\n        const [nx, ny] = this.disabled;\n        let scrollX = csx;\n        let scrollY = csy;\n        if (!nx) {\n          scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);\n          this.coords[0] -= csx - scrollX;\n        }\n        if (!ny) {\n          scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);\n          this.coords[1] -= csy - scrollY;\n        }\n        // Note: Safari mobile requires to use different scroll methods depending if using the window or not\n        if (this.useWin) {\n          this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));\n        } else {\n          this.$scrollContainer.scrollTo(scrollX, scrollY);\n        }\n      }\n    }\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;\n    this.coords[0] += (px1 - px3) * this.dragSpeed;\n    this.coords[1] += (py1 - py3) * this.dragSpeed;\n    this.pointer[4] = px1;\n    this.pointer[5] = py1;\n    const [ cx, cy ] = this.coords;\n    const [ sx, sy ] = this.snapped;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);\n    this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);\n    this.computeVelocity(px1 - px3, py1 - py3);\n    this.angle = atan2(py1 - py2, px1 - px2);\n    const [ nsx, nsy ] = this.snapped;\n    if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {\n      this.onSnap(this);\n    }\n  }\n\n  stop() {\n    this.updateTicker.pause();\n    this.overshootTicker.pause();\n    // Pauses the in bounds onRelease animations\n    for (let prop in this.animate.animations) this.animate.animations[prop].pause();\n    remove(this, null, 'x');\n    remove(this, null, 'y');\n    remove(this, null, 'progressX');\n    remove(this, null, 'progressY');\n    remove(this.scroll); // Removes any active animations on the container scroll\n    remove(this.overshootCoords); // Removes active overshoot animations\n    return this;\n  }\n\n  /**\n   * @param {Number} [duration]\n   * @param {Number} [gap]\n   * @param {EasingParam} [ease]\n   * @return {this}\n   */\n  scrollInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.updateScrollCoords();\n    const x = this.destX;\n    const y = this.destY;\n    const scroll = this.scroll;\n    const scrollBounds = this.scrollBounds;\n    const canScroll = this.canScroll;\n    if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {\n      const [ st, sr, sb, sl ] = scrollBounds;\n      const t = round(clamp(y - st, -maxValue, 0), 0);\n      const r = round(clamp(x - sr, 0, maxValue), 0);\n      const b = round(clamp(y - sb, 0, maxValue), 0);\n      const l = round(clamp(x - sl, -maxValue, 0), 0);\n      new JSAnimation(scroll, {\n        x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),\n        y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),\n        duration: isUnd(duration) ? 350 * globals.timeScale : duration,\n        ease,\n        onUpdate: () => {\n          this.canScroll = false;\n          this.$scrollContainer.scrollTo(scroll.x, scroll.y);\n        }\n      }).init().then(() => {\n        this.canScroll = canScroll;\n      });\n    }\n    return this;\n  }\n\n  handleHover() {\n    if (this.isFinePointer && this.cursor && !this.cursorStyles) {\n      this.cursorStyles = setTargetValues(this.$trigger, {\n        cursor: /** @type {DraggableCursorParams} */(this.cursor).onHover\n      });\n    }\n  }\n\n  /**\n   * @param  {Number} [duration]\n   * @param  {Number} [gap]\n   * @param  {EasingParam} [ease]\n   * @return {this}\n   */\n  animateInView(duration, gap = 0, ease = eases.inOutQuad) {\n    this.stop();\n    this.updateBoundingValues();\n    const x = this.x;\n    const y = this.y;\n    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;\n    const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;\n    const br = this.scroll.x - this.targetBounds[1] - cpr - gap;\n    const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;\n    const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;\n    const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);\n    if (ob) {\n      const [ disabledX, disabledY ] = this.disabled;\n      const destX = clamp(snap(x, this.snapX), bl, br);\n      const destY = clamp(snap(y, this.snapY), bt, bb);\n      const dur = isUnd(duration) ? 350 * globals.timeScale : duration;\n      if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);\n      if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);\n    }\n    return this;\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleDown(e) {\n    const $eTarget = /** @type {HTMLElement} */(e.target);\n    if (this.grabbed || /** @type {HTMLInputElement} */($eTarget).type === 'range') return;\n\n    e.stopPropagation();\n\n    this.grabbed = true;\n    this.released = false;\n    this.stop();\n    this.updateBoundingValues();\n    const touches = /** @type {TouchEvent} */(e).changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;\n    const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const cf = (1 - this.containerFriction) * this.dragSpeed;\n    const cx = this.x;\n    const cy = this.y;\n    this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;\n    this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;\n    this.pointer[0] = x;\n    this.pointer[1] = y;\n    this.pointer[2] = x;\n    this.pointer[3] = y;\n    this.pointer[4] = x;\n    this.pointer[5] = y;\n    this.pointer[6] = x;\n    this.pointer[7] = y;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    const z = /** @type {Number} */(getTargetValue(this.$target, 'zIndex', false));\n    zIndex = (z > zIndex ? z : zIndex) + 1;\n    this.targetStyles = setTargetValues(this.$target, { zIndex });\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.isFinePointer && this.cursor) {\n      this.bodyStyles = setTargetValues(doc.body, {\n        cursor: /** @type {DraggableCursorParams} */(this.cursor).onGrab\n      });\n    }\n    this.scrollInView(100, 0, eases.out(3));\n    this.onGrab(this);\n\n    doc.addEventListener('touchmove', this);\n    doc.addEventListener('touchend', this);\n    doc.addEventListener('touchcancel', this);\n    doc.addEventListener('mousemove', this);\n    doc.addEventListener('mouseup', this);\n    doc.addEventListener('selectstart', this);\n  }\n\n  /**\n   * @param {MouseEvent|TouchEvent} e\n   */\n  handleMove(e) {\n    if (!this.grabbed) return;\n    const touches = /** @type {TouchEvent} */(e).changedTouches;\n    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;\n    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;\n    const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n    const movedX = x - this.pointer[6];\n    const movedY = y - this.pointer[7];\n\n    let $parent = /** @type {HTMLElement} */(e.target);\n    let isAtTop = false;\n    let isAtBottom = false;\n    let canTouchScroll = false;\n\n    while (touches && $parent && $parent !== this.$trigger) {\n      const overflowY = getTargetValue($parent, 'overflow-y');\n      if (overflowY !== 'hidden' && overflowY !== 'visible') {\n        const { scrollTop, scrollHeight, clientHeight } = $parent;\n        if (scrollHeight > clientHeight) {\n          canTouchScroll = true;\n          isAtTop = scrollTop <= 3;\n          isAtBottom = scrollTop >= (scrollHeight - clientHeight) - 3;\n          break;\n        }\n      }\n      $parent = /** @type {HTMLElement} */($parent.parentNode);\n    }\n\n    if (canTouchScroll && ((!isAtTop && !isAtBottom) || (isAtTop && movedY < 0) || (isAtBottom && movedY > 0))) {\n\n      this.pointer[0] = x;\n      this.pointer[1] = y;\n      this.pointer[2] = x;\n      this.pointer[3] = y;\n      this.pointer[4] = x;\n      this.pointer[5] = y;\n      this.pointer[6] = x;\n      this.pointer[7] = y;\n\n    } else {\n\n      preventDefault(e);\n\n      // Needed to prevents click on handleUp\n      if (!this.triggerStyles) this.triggerStyles = setTargetValues(this.$trigger, { pointerEvents: 'none' });\n      // Needed to prevent page scroll while dragging on touch devvice\n      this.$trigger.addEventListener('touchstart', preventDefault, { passive: false });\n      this.$trigger.addEventListener('touchmove', preventDefault, { passive: false });\n      this.$trigger.addEventListener('touchend', preventDefault);\n\n\n      if ((!this.disabled[0] && abs(movedX) > 3) || (!this.disabled[1] && abs(movedY) > 3)) {\n\n        this.updateTicker.resume();\n        this.pointer[2] = this.pointer[0];\n        this.pointer[3] = this.pointer[1];\n        this.pointer[0] = x;\n        this.pointer[1] = y;\n        this.dragged = true;\n        this.released = false;\n        this.onDrag(this);\n      }\n    }\n  }\n\n  handleUp() {\n\n    if (!this.grabbed) return;\n\n    this.updateTicker.pause();\n\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n\n    const [ disabledX, disabledY ] = this.disabled;\n    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;\n    const [ ct, cr, cb, cl ] = this.containerBounds;\n    const [ sx, sy ] = this.snapped;\n    const springX = this.releaseXSpring;\n    const springY = this.releaseYSpring;\n    const releaseEase = this.releaseEase;\n    const hasReleaseSpring = this.hasReleaseSpring;\n    const overshootCoords = this.overshootCoords;\n    const cx = this.x;\n    const cy = this.y;\n    const pv = this.computeVelocity(px1 - px3, py1 - py3);\n    const pa = this.angle = atan2(py1 - py2, px1 - px2);\n    const ds = pv * 150;\n    const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;\n    const nx = cx + (cos(pa) * ds);\n    const ny = cy + (sin(pa) * ds);\n    const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;\n    const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;\n    const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);\n    const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);\n    const ob = this.isOutOfBounds(this.containerBounds, nx, ny);\n\n    let durationX = 0;\n    let durationY = 0;\n    let easeX = releaseEase;\n    let easeY = releaseEase;\n    let longestReleaseDuration = 0;\n\n    overshootCoords.x = cx;\n    overshootCoords.y = cy;\n\n    if (!disabledX) {\n      const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;\n      const distanceX = round(cx - dx, 0);\n      springX.velocity = disabledY && hasReleaseSpring ? distanceX ? (ds * directionX) / abs(distanceX) : 0 : pv;\n      const { ease, duration, restDuration } = springX;\n      durationX = cx === dx ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);\n      if (hasReleaseSpring) easeX = ease;\n      if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;\n    }\n\n    if (!disabledY) {\n      const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;\n      const distanceY = round(cy - dy, 0);\n      springY.velocity = disabledX && hasReleaseSpring ? distanceY ? (ds * directionY) / abs(distanceY) : 0 : pv;\n      const { ease, duration, restDuration } = springY;\n      durationY = cy === dy ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);\n      if (hasReleaseSpring) easeY = ease;\n      if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;\n    }\n\n    if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {\n\n        const composition = compositionTypes.blend;\n\n        new JSAnimation(overshootCoords, {\n          x: { to: bx, duration: durationX * .65 },\n          y: { to: by, duration: durationY * .65 },\n          ease: releaseEase,\n          composition,\n        }).init();\n\n        new JSAnimation(overshootCoords, {\n          x: { to: dx, duration: durationX },\n          y: { to: dy, duration: durationY },\n          ease: releaseEase,\n          composition,\n        }).init();\n\n        this.overshootTicker.stretch(max(durationX, durationY)).restart();\n\n    } else {\n\n      if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);\n      if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);\n\n    }\n\n    this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);\n\n    let hasSnapped = false;\n\n    if (dx !== sx) {\n      this.snapped[0] = dx;\n      if (this.snapX) hasSnapped = true;\n    }\n\n    if (dy !== sy && this.snapY) {\n      this.snapped[1] = dy;\n      if (this.snapY) hasSnapped = true;\n    }\n\n    if (hasSnapped) this.onSnap(this);\n\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = true;\n    this.released = true;\n\n    // It's important to trigger the callback after the release animations to be able to cancel them\n    this.onRelease(this);\n\n    this.$trigger.removeEventListener('touchstart', preventDefault);\n    this.$trigger.removeEventListener('touchmove', preventDefault);\n    this.$trigger.removeEventListener('touchend', preventDefault);\n\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n  }\n\n  reset() {\n    this.stop();\n    this.resizeTicker.pause();\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.setX(0, true);\n    this.setY(0, true);\n    this.coords[0] = 0;\n    this.coords[1] = 0;\n    this.pointer[0] = 0;\n    this.pointer[1] = 0;\n    this.pointer[2] = 0;\n    this.pointer[3] = 0;\n    this.pointer[4] = 0;\n    this.pointer[5] = 0;\n    this.pointer[6] = 0;\n    this.pointer[7] = 0;\n    this.velocity = 0;\n    this.velocityStack[0] = 0;\n    this.velocityStack[1] = 0;\n    this.velocityStack[2] = 0;\n    this.velocityStackIndex = 0;\n    this.angle = 0;\n    return this;\n  }\n\n  enable() {\n    if (!this.enabled) {\n      this.enabled = true;\n      this.$target.classList.remove('is-disabled');\n      this.touchActionStyles = setTargetValues(this.$trigger, {\n        touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'\n      });\n      this.$trigger.addEventListener('touchstart', this, { passive: true });\n      this.$trigger.addEventListener('mousedown', this, { passive: true });\n      this.$trigger.addEventListener('mouseenter', this);\n    }\n    return this;\n  }\n\n  disable() {\n    this.enabled = false;\n    this.grabbed = false;\n    this.dragged = false;\n    this.updated = false;\n    this.released = false;\n    this.canScroll = false;\n    this.touchActionStyles.revert();\n    if (this.cursorStyles) {\n      this.cursorStyles.revert();\n      this.cursorStyles = null;\n    }\n    if (this.triggerStyles) {\n      this.triggerStyles.revert();\n      this.triggerStyles = null;\n    }\n    if (this.bodyStyles) {\n      this.bodyStyles.revert();\n      this.bodyStyles = null;\n    }\n    if (this.targetStyles) {\n      this.targetStyles.revert();\n      this.targetStyles = null;\n    }\n    this.$target.classList.add('is-disabled');\n    this.$trigger.removeEventListener('touchstart', this);\n    this.$trigger.removeEventListener('mousedown', this);\n    this.$trigger.removeEventListener('mouseenter', this);\n    doc.removeEventListener('touchmove', this);\n    doc.removeEventListener('touchend', this);\n    doc.removeEventListener('touchcancel', this);\n    doc.removeEventListener('mousemove', this);\n    doc.removeEventListener('mouseup', this);\n    doc.removeEventListener('selectstart', this);\n    return this;\n  }\n\n  revert() {\n    this.reset();\n    this.disable();\n    this.$target.classList.remove('is-disabled');\n    this.updateTicker.revert();\n    this.overshootTicker.revert();\n    this.resizeTicker.revert();\n    this.animate.revert();\n    this.resizeObserver.disconnect();\n    return this;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'mousedown':\n        this.handleDown(/** @type {MouseEvent} */(e));\n        break;\n      case 'touchstart':\n        this.handleDown(/** @type {TouchEvent} */(e));\n        break;\n      case 'mousemove':\n        this.handleMove(/** @type {MouseEvent} */(e));\n        break;\n      case 'touchmove':\n        this.handleMove(/** @type {TouchEvent} */(e));\n        break;\n      case 'mouseup':\n        this.handleUp();\n        break;\n      case 'touchend':\n        this.handleUp();\n        break;\n      case 'touchcancel':\n        this.handleUp();\n        break;\n      case 'mouseenter':\n        this.handleHover();\n        break;\n      case 'selectstart':\n        preventDefault(e);\n        break;\n    }\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @param {DraggableParams} [parameters]\n * @return {Draggable}\n */\nconst createDraggable = (target, parameters) => new Draggable(target, parameters);\n\n\n\n\nclass Scope {\n  /** @param {ScopeParams} [parameters] */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const rootParam = parameters.root;\n    /** @type {Document|DOMTarget} */\n    let root = doc;\n    if (rootParam) {\n      root = /** @type {ReactRef} */(rootParam).current ||\n             /** @type {AngularRef} */(rootParam).nativeElement ||\n             parseTargets(/** @type {DOMTargetSelector} */(rootParam))[0] ||\n             doc;\n    }\n    const scopeDefaults = parameters.defaults;\n    const globalDefault = globals.defaults;\n    const mediaQueries = parameters.mediaQueries;\n    /** @type {DefaultsParams} */\n    this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;\n    /** @type {Document|DOMTarget} */\n    this.root = root;\n    /** @type {Array<ScopeConstructorCallback>} */\n    this.constructors = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructors = [];\n    /** @type {Array<Revertible>} */\n    this.revertibles = [];\n    /** @type {Array<ScopeConstructorCallback | ((scope: this) => Tickable)>} */\n    this.constructorsOnce = [];\n    /** @type {Array<ScopeCleanupCallback>} */\n    this.revertConstructorsOnce = [];\n    /** @type {Array<Revertible>} */\n    this.revertiblesOnce = [];\n    /** @type {Boolean} */\n    this.once = false;\n    /** @type {Number} */\n    this.onceIndex = 0;\n    /** @type {Record<String, ScopeMethod>} */\n    this.methods = {};\n    /** @type {Record<String, Boolean>} */\n    this.matches = {};\n    /** @type {Record<String, MediaQueryList>} */\n    this.mediaQueryLists = {};\n    /** @type {Record<String, any>} */\n    this.data = {};\n    if (mediaQueries) {\n      for (let mq in mediaQueries) {\n        const _mq = win.matchMedia(mediaQueries[mq]);\n        this.mediaQueryLists[mq] = _mq;\n        _mq.addEventListener('change', this);\n      }\n    }\n  }\n\n  /**\n   * @param {Revertible} revertible\n   */\n  register(revertible) {\n    const store = this.once ? this.revertiblesOnce : this.revertibles;\n    store.push(revertible);\n  }\n\n  /**\n   * @template T\n   * @param {ScopedCallback<T>} cb\n   * @return {T}\n   */\n  execute(cb) {\n    let activeScope = scope.current;\n    let activeRoot = scope.root;\n    let activeDefaults = globals.defaults;\n    scope.current = this;\n    scope.root = this.root;\n    globals.defaults = this.defaults;\n    const mqs = this.mediaQueryLists;\n    for (let mq in mqs) this.matches[mq] = mqs[mq].matches;\n    const returned = cb(this);\n    scope.current = activeScope;\n    scope.root = activeRoot;\n    globals.defaults = activeDefaults;\n    return returned;\n  }\n\n  /**\n   * @return {this}\n   */\n  refresh() {\n    this.onceIndex = 0;\n    this.execute(() => {\n      let i = this.revertibles.length;\n      let y = this.revertConstructors.length;\n      while (i--) this.revertibles[i].revert();\n      while (y--) this.revertConstructors[y](this);\n      this.revertibles.length = 0;\n      this.revertConstructors.length = 0;\n      this.constructors.forEach((/** @type {ScopeConstructorCallback} */constructor) => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    });\n    return this;\n  }\n\n  /**\n   * @overload\n   * @param {String} a1\n   * @param {ScopeMethod} a2\n   * @return {this}\n   *\n   * @overload\n   * @param {ScopeConstructorCallback} a1\n   * @return {this}\n   *\n   * @param {String|ScopeConstructorCallback} a1\n   * @param {ScopeMethod} [a2]\n   */\n  add(a1, a2) {\n    this.once = false;\n    if (isFnc(a1)) {\n      const constructor = /** @type {ScopeConstructorCallback} */(a1);\n      this.constructors.push(constructor);\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructors.push(revertConstructor);\n        }\n      });\n    } else {\n      this.methods[/** @type {String} */(a1)] = (/** @type {any} */...args) => this.execute(() => a2(...args));\n    }\n    return this;\n  }\n\n  /**\n   * @param {ScopeConstructorCallback} scopeConstructorCallback\n   * @return {this}\n   */\n  addOnce(scopeConstructorCallback) {\n    this.once = true;\n    if (isFnc(scopeConstructorCallback)) {\n      const currentIndex = this.onceIndex++;\n      const tracked = this.constructorsOnce[currentIndex];\n      if (tracked) return this;\n      const constructor = /** @type {ScopeConstructorCallback} */(scopeConstructorCallback);\n      this.constructorsOnce[currentIndex] = constructor;\n      this.execute(() => {\n        const revertConstructor = constructor(this);\n        if (isFnc(revertConstructor)) {\n          this.revertConstructorsOnce.push(revertConstructor);\n        }\n      });\n    }\n    return this;\n  }\n\n  /**\n   * @param  {(scope: this) => Tickable} cb\n   * @return {Tickable}\n   */\n  keepTime(cb) {\n    this.once = true;\n    const currentIndex = this.onceIndex++;\n    const tracked = /** @type {(scope: this) => Tickable} */(this.constructorsOnce[currentIndex]);\n    if (isFnc(tracked)) return tracked(this);\n    const constructor = /** @type {(scope: this) => Tickable} */(createRefreshable(cb));\n    this.constructorsOnce[currentIndex] = constructor;\n    let trackedTickable;\n    this.execute(() => {\n      trackedTickable = constructor(this);\n    });\n    return trackedTickable;\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'change':\n        this.refresh();\n        break;\n    }\n  }\n\n  revert() {\n    const revertibles = this.revertibles;\n    const revertConstructors = this.revertConstructors;\n    const revertiblesOnce = this.revertiblesOnce;\n    const revertConstructorsOnce = this.revertConstructorsOnce;\n    const mqs = this.mediaQueryLists;\n    let i = revertibles.length;\n    let j = revertConstructors.length;\n    let k = revertiblesOnce.length;\n    let l = revertConstructorsOnce.length;\n    while (i--) revertibles[i].revert();\n    while (j--) revertConstructors[j](this);\n    while (k--) revertiblesOnce[k].revert();\n    while (l--) revertConstructorsOnce[l](this);\n    for (let mq in mqs) mqs[mq].removeEventListener('change', this);\n    revertibles.length = 0;\n    revertConstructors.length = 0;\n    this.constructors.length = 0;\n    revertiblesOnce.length = 0;\n    revertConstructorsOnce.length = 0;\n    this.constructorsOnce.length = 0;\n    this.onceIndex = 0;\n    this.matches = {};\n    this.methods = {};\n    this.mediaQueryLists = {};\n    this.data = {};\n  }\n}\n\n/**\n * @param {ScopeParams} [params]\n * @return {Scope}\n */\nconst createScope = params => new Scope(params);\n\n/**\n * @return {Number}\n */\nconst getMaxViewHeight = () => {\n  const $el = doc.createElement('div');\n  doc.body.appendChild($el);\n  $el.style.height = '100lvh';\n  const height = $el.offsetHeight;\n  doc.body.removeChild($el);\n  return height;\n};\n\n/**\n * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T\n * @param {T | ((observer: ScrollObserver) => T)} value\n * @param {ScrollObserver} scroller\n * @return {T}\n */\nconst parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */(value)(scroller) : value;\n\nconst scrollContainers = new Map();\n\nclass ScrollContainer {\n  /**\n   * @param {HTMLElement} $el\n   */\n  constructor($el) {\n    /** @type {HTMLElement} */\n    this.element = $el;\n    /** @type {Boolean} */\n    this.useWin = this.element === doc.body;\n    /** @type {Number} */\n    this.winWidth = 0;\n    /** @type {Number} */\n    this.winHeight = 0;\n    /** @type {Number} */\n    this.width = 0;\n    /** @type {Number} */\n    this.height = 0;\n    /** @type {Number} */\n    this.left = 0;\n    /** @type {Number} */\n    this.top = 0;\n    /** @type {Number} */\n    this.zIndex = 0;\n    /** @type {Number} */\n    this.scrollX = 0;\n    /** @type {Number} */\n    this.scrollY = 0;\n    /** @type {Number} */\n    this.prevScrollX = 0;\n    /** @type {Number} */\n    this.prevScrollY = 0;\n    /** @type {Number} */\n    this.scrollWidth = 0;\n    /** @type {Number} */\n    this.scrollHeight = 0;\n    /** @type {Number} */\n    this.velocity = 0;\n    /** @type {Boolean} */\n    this.backwardX = false;\n    /** @type {Boolean} */\n    this.backwardY = false;\n    /** @type {Timer} */\n    this.scrollTicker = new Timer({\n      autoplay: false,\n      onBegin: () => this.dataTimer.resume(),\n      onUpdate: () => {\n        const backwards = this.backwardX || this.backwardY;\n        forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);\n      },\n      onComplete: () => this.dataTimer.pause()\n    }).init();\n    /** @type {Timer} */\n    this.dataTimer = new Timer({\n      autoplay: false,\n      frameRate: 30,\n      onUpdate: self => {\n        const dt = self.deltaTime;\n        const px = this.prevScrollX;\n        const py = this.prevScrollY;\n        const nx = this.scrollX;\n        const ny = this.scrollY;\n        const dx = px - nx;\n        const dy = py - ny;\n        this.prevScrollX = nx;\n        this.prevScrollY = ny;\n        if (dx) this.backwardX = px > nx;\n        if (dy) this.backwardY = py > ny;\n        this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);\n      }\n    }).init();\n    /** @type {Timer} */\n    this.resizeTicker = new Timer({\n      autoplay: false,\n      duration: 250 * globals.timeScale,\n      onComplete: () => {\n        this.updateWindowBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n      }\n    }).init();\n    /** @type {Timer} */\n    this.wakeTicker = new Timer({\n      autoplay: false,\n      duration: 500 * globals.timeScale,\n      onBegin: () => {\n        this.scrollTicker.resume();\n      },\n      onComplete: () => {\n        this.scrollTicker.pause();\n      }\n    }).init();\n    /** @type {ScrollObserver} */\n    this._head = null;\n    /** @type {ScrollObserver} */\n    this._tail = null;\n    this.updateScrollCoords();\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n    this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());\n    this.resizeObserver.observe(this.element);\n    (this.useWin ? win : this.element).addEventListener('scroll', this, false);\n  }\n\n  updateScrollCoords() {\n    const useWin = this.useWin;\n    const $el = this.element;\n    this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);\n    this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);\n  }\n\n  updateWindowBounds() {\n    this.winWidth = win.innerWidth;\n    this.winHeight = getMaxViewHeight();\n  }\n\n  updateBounds() {\n    const style = getComputedStyle(this.element);\n    const $el = this.element;\n    this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    this.updateWindowBounds();\n    let width, height;\n    if (this.useWin) {\n      width = this.winWidth;\n      height = this.winHeight;\n    } else {\n      const elRect = $el.getBoundingClientRect();\n      width = $el.clientWidth;\n      height = $el.clientHeight;\n      this.top = elRect.top;\n      this.left = elRect.left;\n    }\n    this.width = width;\n    this.height = height;\n  }\n\n  refreshScrollObservers() {\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      if (child._debug) {\n        child.removeDebug();\n      }\n    });\n    this.updateBounds();\n    forEachChildren(this, (/** @type {ScrollObserver} */child) => {\n      child.refresh();\n      if (child._debug) {\n        child.debug();\n      }\n    });\n  }\n\n  refresh() {\n    this.updateWindowBounds();\n    this.updateBounds();\n    this.refreshScrollObservers();\n    this.handleScroll();\n  }\n\n  handleScroll() {\n    this.updateScrollCoords();\n    this.wakeTicker.restart();\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleEvent(e) {\n    switch (e.type) {\n      case 'scroll':\n        this.handleScroll();\n        break;\n    }\n  }\n\n  revert() {\n    this.scrollTicker.cancel();\n    this.dataTimer.cancel();\n    this.resizeTicker.cancel();\n    this.wakeTicker.cancel();\n    this.resizeObserver.disconnect();\n    (this.useWin ? win : this.element).removeEventListener('scroll', this);\n    scrollContainers.delete(this.element);\n  }\n}\n\n/**\n * @param {TargetsParam} target\n * @return {ScrollContainer}\n */\nconst registerAndGetScrollContainer = target => {\n  const $el = /** @type {HTMLElement} */(target ? parseTargets(target)[0] || doc.body : doc.body);\n  let scrollContainer = scrollContainers.get($el);\n  if (!scrollContainer) {\n    scrollContainer = new ScrollContainer($el);\n    scrollContainers.set($el, scrollContainer);\n  }\n  return scrollContainer;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number|string} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst convertValueToPx = ($el, v, size, under, over) => {\n  const clampMin = v === 'min';\n  const clampMax = v === 'max';\n  const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 :\n                v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' :\n                v === 'center' ? '50%' :\n                v;\n  const { n, u } = decomposeRawValue(value, decomposedOriginalValue);\n  let px = n;\n  if (u === '%') {\n    px = (n / 100) * size;\n  } else if (u) {\n    px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;\n  }\n  if (clampMax && under < 0) px += under;\n  if (clampMin && over > 0) px += over;\n  return px;\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {ScrollThresholdValue} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */\nconst parseBoundValue = ($el, v, size, under, over) => {\n  /** @type {Number} */\n  let value;\n  if (isStr(v)) {\n    const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */(v));\n    if (matchedOperator) {\n      const splitter = matchedOperator[0];\n      const operator = splitter[0];\n      const splitted = /** @type {String} */(v).split(splitter);\n      const clampMin = splitted[0] === 'min';\n      const clampMax = splitted[0] === 'max';\n      const valueAPx = convertValueToPx($el, splitted[0], size, under, over);\n      const valueBPx = convertValueToPx($el, splitted[1], size, under, over);\n      if (clampMin) {\n        const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);\n        value = min < valueAPx ? valueAPx : min;\n      } else if (clampMax) {\n        const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);\n        value = max > valueAPx ? valueAPx : max;\n      } else {\n        value = getRelativeValue(valueAPx, valueBPx, operator);\n      }\n    } else {\n      value = convertValueToPx($el, v, size, under, over);\n    }\n  } else {\n    value = /** @type {Number} */(v);\n  }\n  return round(value, 0);\n};\n\n/**\n * @param {JSAnimation} linked\n * @return {HTMLElement}\n */\nconst getAnimationDomTarget = linked => {\n  let $linkedTarget;\n  const linkedTargets = linked.targets;\n  for (let i = 0, l = linkedTargets.length; i < l; i++) {\n    const target = linkedTargets[i];\n    if (target[isDomSymbol]) {\n      $linkedTarget = /** @type {HTMLElement} */(target);\n      break;\n    }\n  }\n  return $linkedTarget;\n};\n\nlet scrollerIndex = 0;\n\nconst debugColors$1 = ['#FF4B4B','#FF971B','#FFC730','#F9F640','#7AFF5A','#18FF74','#17E09B','#3CFFEC','#05DBE9','#33B3F1','#638CF9','#C563FE','#FF4FCF','#F93F8A'];\n\nclass ScrollObserver {\n  /**\n   * @param {ScrollObserverParams} parameters\n   */\n  constructor(parameters = {}) {\n    if (scope.current) scope.current.register(this);\n    const syncMode = setValue(parameters.sync, 'play pause');\n    const ease = syncMode ? parseEasings(/** @type {EasingParam} */(syncMode)) : null;\n    const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);\n    const isEase = syncMode && !(ease === none && !isLinear);\n    const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);\n    const isMethods = syncMode && (isStr(syncMode) && !isEase && !isSmooth);\n    const syncMethods = isMethods ? /** @type {String} */(syncMode).split(' ').map(\n      (/** @type {String} */m) => () => {\n        const linked = this.linked;\n        return linked && linked[m] ? linked[m]() : null;\n      }\n    ) : null;\n    const biDirSync = isMethods && syncMethods.length > 2;\n    /** @type {Number} */\n    this.index = scrollerIndex++;\n    /** @type {String|Number} */\n    this.id = !isUnd(parameters.id) ? parameters.id : this.index;\n    /** @type {ScrollContainer} */\n    this.container = registerAndGetScrollContainer(parameters.container);\n    /** @type {HTMLElement} */\n    this.target = null;\n    /** @type {Tickable|WAAPIAnimation} */\n    this.linked = null;\n    /** @type {Boolean} */\n    this.repeat = null;\n    /** @type {Boolean} */\n    this.horizontal = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.enter = null;\n    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */\n    this.leave = null;\n    /** @type {Boolean} */\n    this.sync = isEase || isSmooth || !!syncMethods;\n    /** @type {EasingFunction} */\n    this.syncEase = isEase ? ease : null;\n    /** @type {Number} */\n    this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */(syncMode) : null;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnter = parameters.onEnter || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeave = parameters.onLeave || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterForward = parameters.onEnterForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveForward = parameters.onLeaveForward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onEnterBackward = parameters.onEnterBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onLeaveBackward = parameters.onLeaveBackward || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onUpdate = parameters.onUpdate || noop;\n    /** @type {Callback<ScrollObserver>} */\n    this.onSyncComplete = parameters.onSyncComplete || noop;\n    /** @type {Boolean} */\n    this.reverted = false;\n    /** @type {Boolean} */\n    this.completed = false;\n    /** @type {Boolean} */\n    this.began = false;\n    /** @type {Boolean} */\n    this.isInView = false;\n    /** @type {Boolean} */\n    this.forceEnter = false;\n    /** @type {Boolean} */\n    this.hasEntered = false;\n    /** @type {Boolean} */\n    this.isReady = false;\n    // /** @type {Array.<Number>} */\n    // this.offsets = [];\n    /** @type {Number} */\n    this.offset = 0;\n    /** @type {Number} */\n    this.offsetStart = 0;\n    /** @type {Number} */\n    this.offsetEnd = 0;\n    /** @type {Number} */\n    this.distance = 0;\n    /** @type {Number} */\n    this.prevProgress = 0;\n    /** @type {Array} */\n    this.thresholds = ['start', 'end', 'end', 'start'];\n    /** @type {[Number, Number, Number, Number]} */\n    this.coords = [0, 0, 0, 0];\n    /** @type {JSAnimation} */\n    this.debugStyles = null;\n    /** @type {HTMLElement} */\n    this.$debug = null;\n    /** @type {ScrollObserverParams} */\n    this._params = parameters;\n    /** @type {Boolean} */\n    this._debug = setValue(parameters.debug, false);\n    /** @type {ScrollObserver} */\n    this._next = null;\n    /** @type {ScrollObserver} */\n    this._prev = null;\n    addChild(this.container, this);\n    // Wait for the next frame to add to the container in order to handle calls to link()\n    sync(() => {\n      if (this.reverted) return;\n      if (!this.target) {\n        const target = /** @type {HTMLElement} */(parseTargets(parameters.target)[0]);\n        this.target = target || doc.body;\n        this.refresh();\n      }\n      if (this._debug) this.debug();\n    });\n  }\n\n  /**\n   * @param {Tickable|WAAPIAnimation} linked\n   */\n  link(linked) {\n    if (linked) {\n      // Make sure to pause the linked object in case it's added later\n      linked.pause();\n      this.linked = linked;\n      // Try to use a target of the linked object if no target parameters specified\n      if (!this._params.target) {\n        /** @type {HTMLElement} */\n        let $linkedTarget;\n        if (!isUnd(/** @type {JSAnimation} */(linked).targets)) {\n          $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(linked));\n        } else {\n          forEachChildren(/** @type {Timeline} */(linked), (/** @type {JSAnimation} */child) => {\n            if (child.targets && !$linkedTarget) {\n              $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(child));\n            }\n          });\n        }\n        // Fallback to body if no target found\n        this.target = $linkedTarget || doc.body;\n        this.refresh();\n      }\n    }\n    return this;\n  }\n\n  get velocity() {\n    return this.container.velocity;\n  }\n\n  get backward() {\n    return this.horizontal ? this.container.backwardX : this.container.backwardY;\n  }\n\n  get scroll() {\n    return this.horizontal ? this.container.scrollX : this.container.scrollY;\n  }\n\n  get progress() {\n    const p = (this.scroll - this.offsetStart) / this.distance;\n    return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);\n  }\n\n  refresh() {\n    // This flag is used to prevent running handleScroll() outside of this.refresh() with values not calculated\n    this.isReady = true;\n    this.reverted = false;\n    const params = this._params;\n    this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);\n    this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';\n    this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');\n    this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');\n    this.updateBounds();\n    this.handleScroll();\n    return this;\n  }\n\n  removeDebug() {\n    if (this.$debug) {\n      this.$debug.parentNode.removeChild(this.$debug);\n      this.$debug = null;\n    }\n    if (this.debugStyles) {\n      this.debugStyles.revert();\n      this.$debug = null;\n    }\n    return this;\n  }\n\n  debug() {\n    this.removeDebug();\n    const container = this.container;\n    const isHori = this.horizontal;\n    const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');\n    const $debug = doc.createElement('div');\n    const $thresholds = doc.createElement('div');\n    const $triggers = doc.createElement('div');\n    const color = debugColors$1[this.index % debugColors$1.length];\n    const useWin = container.useWin;\n    const containerWidth = useWin ? container.winWidth : container.width;\n    const containerHeight = useWin ? container.winHeight : container.height;\n    const scrollWidth = container.scrollWidth;\n    const scrollHeight = container.scrollHeight;\n    const size = this.container.width > 360 ? 320 : 260;\n    const offLeft = isHori ? 0 : 10;\n    const offTop = isHori ? 10 : 0;\n    const half = isHori ? 24 : size / 2;\n    const labelHeight = isHori ? half : 15;\n    const labelWidth = isHori ? 60 : half;\n    const labelSize = isHori ? labelWidth : labelHeight;\n    const repeat = isHori ? 'repeat-x' : 'repeat-y';\n    /**\n     * @param {Number} v\n     * @return {String}\n     */\n    const gradientOffset = v => isHori ? '0px '+(v)+'px' : (v)+'px'+' 2px';\n    /**\n     * @param {String} c\n     * @return {String}\n     */\n    const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;\n    /**\n     * @param {String} p\n     * @param {Number} l\n     * @param {Number} t\n     * @param {Number} w\n     * @param {Number} h\n     * @return {String}\n     */\n    const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;\n    $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${isHori ? 'column' : 'row'};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `;\n    $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;\n    if (!$existingDebug) {\n      $thresholds.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(half-10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(half-10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};\n      `;\n    }\n    $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;\n    if (!$existingDebug) {\n      $triggers.style.cssText += `background:\n        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},\n        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};\n      `;\n    }\n    const labels = [' enter: ', ' leave: '];\n    this.coords.forEach((v, i) => {\n      const isView = i > 1;\n      const value = (isView ? 0 : this.offset) + v;\n      const isTail = i % 2;\n      const isFirst = value < labelSize;\n      const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;\n      const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;\n      const $label = doc.createElement('div');\n      const $text = doc.createElement('div');\n      const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';\n      const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;\n      // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;\n      $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;\n      $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}\n        display: flex;\n        flex-direction: ${isHori ? 'column' : 'row'};\n        justify-content: flex-${isView ? 'start' : 'end'};\n        align-items: flex-${isFlip ? 'end' : 'start'};\n        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};\n      `;\n      $text.style.cssText = `\n        overflow: hidden;\n        max-width: ${(size / 2) - 10}px;\n        height: ${labelHeight};\n        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${isTail ? color : 'rgba(0,0,0,.75)'};\n        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};\n        border: 2px solid ${isTail ? color : 'transparent'};\n        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;\n        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;\n      `;\n      $label.appendChild($text);\n      let position = value - flipOffset + (isHori ? 1 : 0);\n      $label.style[isHori ? 'left' : 'top'] = `${position}px`;\n      // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';\n      (isView ? $thresholds : $triggers).appendChild($label);\n    });\n\n    $debug.appendChild($thresholds);\n    $debug.appendChild($triggers);\n    container.element.appendChild($debug);\n\n    if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');\n    this.$debug = $debug;\n    const containerPosition = getTargetValue(container.element, 'position');\n    if (containerPosition === 'static') {\n      this.debugStyles = setTargetValues(container.element, { position: 'relative '});\n    }\n\n  }\n\n  updateBounds() {\n    if (this._debug) {\n      this.removeDebug();\n    }\n    let stickys;\n    const $target = this.target;\n    const container = this.container;\n    const isHori = this.horizontal;\n    const linked = this.linked;\n    let linkedTime;\n    let $el = $target;\n    // let offsetX = 0;\n    // let offsetY = 0;\n    // let $offsetParent = $el;\n    /** @type {Element} */\n    if (linked) {\n      linkedTime = linked.currentTime;\n      linked.seek(0, true);\n    }\n    /* Old implementation to get offset and targetSize before fixing https://github.com/juliangarnier/anime/issues/1021\n    // const isContainerStatic = getTargetValue(container.element, 'position') === 'static' ? setTargetValues(container.element, { position: 'relative '}) : false;\n    // while ($el && $el !== container.element && $el !== doc.body) {\n    //   const isSticky = getTargetValue($el, 'position') === 'sticky' ?\n    //                    setTargetValues($el, { position: 'static' }) :\n    //                    false;\n    //   if ($el === $offsetParent) {\n    //     offsetX += $el.offsetLeft || 0;\n    //     offsetY += $el.offsetTop || 0;\n    //     $offsetParent = $el.offsetParent;\n    //   }\n    //   $el = /** @type {HTMLElement} */($el.parentElement);\n    //   if (isSticky) {\n    //     if (!stickys) stickys = [];\n    //     stickys.push(isSticky);\n    //   }\n    // }\n    // if (isContainerStatic) isContainerStatic.revert();\n    // const offset = isHori ? offsetX : offsetY;\n    // const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;\n\n    while ($el && $el !== container.element && $el !== doc.body) {\n      const isSticky = getTargetValue($el, 'position') === 'sticky' ? setTargetValues($el, { position: 'static' }) : false;\n      $el = $el.parentElement;\n      if (isSticky) {\n        if (!stickys) stickys = [];\n        stickys.push(isSticky);\n      }\n    }\n    const rect = $target.getBoundingClientRect();\n    const offset = isHori ? rect.left + container.scrollX - container.left : rect.top + container.scrollY - container.top;\n    const targetSize = isHori ? rect.width : rect.height;\n    const containerSize = isHori ? container.width : container.height;\n    const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;\n    const maxScroll = scrollSize - containerSize;\n    const enter = this.enter;\n    const leave = this.leave;\n\n    /** @type {ScrollThresholdValue} */\n    let enterTarget = 'start';\n    /** @type {ScrollThresholdValue} */\n    let leaveTarget = 'end';\n    /** @type {ScrollThresholdValue} */\n    let enterContainer = 'end';\n    /** @type {ScrollThresholdValue} */\n    let leaveContainer = 'start';\n\n    if (isStr(enter)) {\n      const splitted = /** @type {String} */(enter).split(' ');\n      enterContainer = splitted[0];\n      enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;\n    } else if (isObj(enter)) {\n      const e = /** @type {ScrollThresholdParam} */(enter);\n      if (!isUnd(e.container)) enterContainer = e.container;\n      if (!isUnd(e.target)) enterTarget = e.target;\n    } else if (isNum(enter)) {\n      enterContainer = /** @type {Number} */(enter);\n    }\n\n    if (isStr(leave)) {\n      const splitted = /** @type {String} */(leave).split(' ');\n      leaveContainer = splitted[0];\n      leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;\n    } else if (isObj(leave)) {\n      const t = /** @type {ScrollThresholdParam} */(leave);\n      if (!isUnd(t.container)) leaveContainer = t.container;\n      if (!isUnd(t.target)) leaveTarget = t.target;\n    } else if (isNum(leave)) {\n      leaveContainer = /** @type {Number} */(leave);\n    }\n\n    const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);\n    const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);\n    const under = (parsedEnterTarget + offset) - containerSize;\n    const over = (parsedLeaveTarget + offset) - maxScroll;\n    const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);\n    const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);\n    const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;\n    const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;\n    const scrollDelta = offsetEnd - offsetStart;\n    // this.offsets[0] = offsetX;\n    // this.offsets[1] = offsetY;\n    this.offset = offset;\n    this.offsetStart = offsetStart;\n    this.offsetEnd = offsetEnd;\n    this.distance = scrollDelta <= 0 ? 0 : scrollDelta;\n    this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];\n    this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];\n    if (stickys) {\n      stickys.forEach(sticky => sticky.revert());\n    }\n    if (linked) {\n      linked.seek(linkedTime, true);\n    }\n    if (this._debug) {\n      this.debug();\n    }\n  }\n\n  handleScroll() {\n    if (!this.isReady) return;\n    const linked = this.linked;\n    const sync = this.sync;\n    const syncEase = this.syncEase;\n    const syncSmooth = this.syncSmooth;\n    const shouldSeek = linked && (syncEase || syncSmooth);\n    const isHori = this.horizontal;\n    const container = this.container;\n    const scroll = this.scroll;\n    const isBefore = scroll <= this.offsetStart;\n    const isAfter = scroll >= this.offsetEnd;\n    const isInView = !isBefore && !isAfter;\n    const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;\n    const forceEnter = !this.hasEntered && isOnTheEdge;\n    const $debug = this._debug && this.$debug;\n    let hasUpdated = false;\n    let syncCompleted = false;\n    let p = this.progress;\n\n    if (isBefore && this.began) {\n      this.began = false;\n    }\n\n    if (p > 0 && !this.began) {\n      this.began = true;\n    }\n\n    if (shouldSeek) {\n      const lp = linked.progress;\n      if (syncSmooth && isNum(syncSmooth)) {\n        if (/** @type {Number} */(syncSmooth) < 1) {\n          const step = 0.0001;\n          const snap = lp < p && p === 1 ? step : lp > p && !p ? -step : 0;\n          p = round(lerp(lp, p, interpolate(.01, .2, /** @type {Number} */(syncSmooth)), false) + snap, 6);\n        }\n      } else if (syncEase) {\n        p = syncEase(p);\n      }\n      hasUpdated = p !== this.prevProgress;\n      syncCompleted = lp === 1;\n      if (hasUpdated && !syncCompleted && (syncSmooth && lp)) {\n        container.wakeTicker.restart();\n      }\n    }\n\n    if ($debug) {\n      const sticky = isHori ? container.scrollY : container.scrollX;\n      $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';\n    }\n\n    // Trigger enter callbacks if already in view or when entering the view\n    if ((isInView && !this.isInView) || (forceEnter && !this.forceEnter && !this.hasEntered)) {\n      if (isInView) this.isInView = true;\n      if (!this.forceEnter || !this.hasEntered) {\n        if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;\n        this.onSyncEnter(this);\n        this.onEnter(this);\n        if (this.backward) {\n          this.onSyncEnterBackward(this);\n          this.onEnterBackward(this);\n        } else {\n          this.onSyncEnterForward(this);\n          this.onEnterForward(this);\n        }\n        this.hasEntered = true;\n        if (forceEnter) this.forceEnter = true;\n      } else if (isInView) {\n        this.forceEnter = false;\n      }\n    }\n\n    if (isInView || !isInView && this.isInView) {\n      hasUpdated = true;\n    }\n\n    if (hasUpdated) {\n      if (shouldSeek) linked.seek(linked.duration * p);\n      this.onUpdate(this);\n    }\n\n    if (!isInView && this.isInView) {\n      this.isInView = false;\n      this.onSyncLeave(this);\n      this.onLeave(this);\n      if (this.backward) {\n        this.onSyncLeaveBackward(this);\n        this.onLeaveBackward(this);\n      } else {\n        this.onSyncLeaveForward(this);\n        this.onLeaveForward(this);\n      }\n      if (sync && !syncSmooth) {\n        syncCompleted = true;\n      }\n    }\n\n    if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {\n      if (sync) {\n        this.onSyncComplete(this);\n      }\n      this.completed = true;\n      if ((!this.repeat && !linked) || (!this.repeat && linked && linked.completed)) {\n        this.revert();\n      }\n    }\n\n    if (p < 1 && this.completed) {\n      this.completed = false;\n    }\n\n    this.prevProgress = p;\n  }\n\n  revert() {\n    if (this.reverted) return;\n    const container = this.container;\n    removeChild(container, this);\n    if (!container._head) {\n      container.revert();\n    }\n    if (this._debug) {\n      this.removeDebug();\n    }\n    this.reverted = true;\n    this.isReady = false;\n    return this;\n  }\n\n}\n\n/**\n * @param {ScrollObserverParams} [parameters={}]\n * @return {ScrollObserver}\n */\nconst onScroll = (parameters = {}) => new ScrollObserver(parameters);\n\n\n\n\nconst segmenter = (typeof Intl !== 'undefined') && Intl.Segmenter;\nconst valueRgx = /\\{value\\}/g;\nconst indexRgx = /\\{i\\}/g;\nconst whiteSpaceGroupRgx = /(\\s+)/;\nconst whiteSpaceRgx = /^\\s+$/;\nconst lineType = 'line';\nconst wordType = 'word';\nconst charType = 'char';\nconst dataLine = `data-line`;\n\n/**\n * @typedef {Object} Segment\n * @property {String} segment\n * @property {Boolean} [isWordLike]\n */\n\n/**\n * @typedef {Object} Segmenter\n * @property {function(String): Iterable<Segment>} segment\n */\n\n/** @type {Segmenter} */\nlet wordSegmenter = null;\n/** @type {Segmenter} */\nlet graphemeSegmenter = null;\nlet $splitTemplate = null;\n\n/**\n * @param  {Segment} seg\n * @return {Boolean}\n */\nconst isSegmentWordLike = seg => {\n  return seg.isWordLike ||\n         seg.segment === ' ' || // Consider spaces as words first, then handle them diffrently later\n         isNum(+seg.segment); // Safari doesn't considers numbers as words\n};\n\n/**\n * @param {HTMLElement} $el\n */\nconst setAriaHidden = $el => $el.setAttribute('aria-hidden', 'true');\n\n/**\n * @param {DOMTarget} $el\n * @param {String} type\n * @return {Array<HTMLElement>}\n */\nconst getAllTopLevelElements = ($el, type) => [.../** @type {*} */($el.querySelectorAll(`[data-${type}]:not([data-${type}] [data-${type}])`))];\n\nconst debugColors = { line: '#00D672', word: '#FF4B4B', char: '#5A87FF' };\n\n/**\n * @param {HTMLElement} $el\n */\nconst filterEmptyElements = $el => {\n  if (!$el.childElementCount && !$el.textContent.trim()) {\n    const $parent = $el.parentElement;\n    $el.remove();\n    if ($parent) filterEmptyElements($parent);\n  }\n};\n\n/**\n * @param {HTMLElement} $el\n * @param {Number} lineIndex\n * @param {Set<HTMLElement>} bin\n * @returns {Set<HTMLElement>}\n */\nconst filterLineElements = ($el, lineIndex, bin) => {\n  const dataLineAttr = $el.getAttribute(dataLine);\n  if (dataLineAttr !== null && +dataLineAttr !== lineIndex || $el.tagName === 'BR') bin.add($el);\n  let i = $el.childElementCount;\n  while (i--) filterLineElements(/** @type {HTMLElement} */($el.children[i]), lineIndex, bin);\n  return bin;\n};\n\n/**\n * @param  {'line'|'word'|'char'} type\n * @param  {splitTemplateParams} params\n * @return {String}\n */\nconst generateTemplate = (type, params = {}) => {\n  let template = ``;\n  const classString = isStr(params.class) ? ` class=\"${params.class}\"` : '';\n  const cloneType = setValue(params.clone, false);\n  const wrapType = setValue(params.wrap, false);\n  const overflow = wrapType ? wrapType === true ? 'clip' : wrapType : cloneType ? 'clip' : false;\n  if (wrapType) template += `<span${overflow ? ` style=\"overflow:${overflow};\"` : ''}>`;\n  template += `<span${classString}${cloneType ? ` style=\"position:relative;\"` : ''} data-${type}=\"{i}\">`;\n  if (cloneType) {\n    const left = cloneType === 'left' ? '-100%' : cloneType === 'right' ? '100%' : '0';\n    const top = cloneType === 'top' ? '-100%' : cloneType === 'bottom' ? '100%' : '0';\n    template += `<span>{value}</span>`;\n    template += `<span inert style=\"position:absolute;top:${top};left:${left};white-space:nowrap;\">{value}</span>`;\n  } else {\n    template += `{value}`;\n  }\n  template += `</span>`;\n  if (wrapType) template += `</span>`;\n  return template;\n};\n\n/**\n * @param  {String|SplitFunctionValue} htmlTemplate\n * @param  {Array<HTMLElement>} store\n * @param  {Node|HTMLElement} node\n * @param  {DocumentFragment} $parentFragment\n * @param  {'line'|'word'|'char'} type\n * @param  {Boolean} debug\n * @param  {Number} lineIndex\n * @param  {Number} [wordIndex]\n * @param  {Number} [charIndex]\n * @return {HTMLElement}\n */\nconst processHTMLTemplate = (htmlTemplate, store, node, $parentFragment, type, debug, lineIndex, wordIndex, charIndex) => {\n  const isLine = type === lineType;\n  const isChar = type === charType;\n  const className = `_${type}_`;\n  const template = isFnc(htmlTemplate) ? htmlTemplate(node) : htmlTemplate;\n  const displayStyle = isLine ? 'block' : 'inline-block';\n  $splitTemplate.innerHTML = template\n    .replace(valueRgx, `<i class=\"${className}\"></i>`)\n    .replace(indexRgx, `${isChar ? charIndex : isLine ? lineIndex : wordIndex}`);\n  const $content = $splitTemplate.content;\n  const $highestParent = /** @type {HTMLElement} */($content.firstElementChild);\n  const $split = /** @type {HTMLElement} */($content.querySelector(`[data-${type}]`)) || $highestParent;\n  const $replacables = /** @type {NodeListOf<HTMLElement>} */($content.querySelectorAll(`i.${className}`));\n  const replacablesLength = $replacables.length;\n  if (replacablesLength) {\n    $highestParent.style.display = displayStyle;\n    $split.style.display = displayStyle;\n    $split.setAttribute(dataLine, `${lineIndex}`);\n    if (!isLine) {\n      $split.setAttribute('data-word', `${wordIndex}`);\n      if (isChar) $split.setAttribute('data-char', `${charIndex}`);\n    }\n    let i = replacablesLength;\n    while (i--) {\n      const $replace = $replacables[i];\n      const $closestParent = $replace.parentElement;\n      $closestParent.style.display = displayStyle;\n      if (isLine) {\n        $closestParent.innerHTML = /** @type {HTMLElement} */(node).innerHTML;\n      } else {\n        $closestParent.replaceChild(node.cloneNode(true), $replace);\n      }\n    }\n    store.push($split);\n    $parentFragment.appendChild($content);\n  } else {\n    console.warn(`The expression \"{value}\" is missing from the provided template.`);\n  }\n  if (debug) $highestParent.style.outline = `1px dotted ${debugColors[type]}`;\n  return $highestParent;\n};\n\n/**\n * A class that splits text into words and wraps them in span elements while preserving the original HTML structure.\n * @class\n */\nclass TextSplitter {\n  /**\n   * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n   * @param  {TextSplitterParams} [parameters]\n   */\n  constructor(target, parameters = {}) {\n    // Only init segmenters when needed\n    if (!wordSegmenter) wordSegmenter = segmenter ? new segmenter([], { granularity: wordType }) : {\n      segment: (text) => {\n        const segments = [];\n        const words = text.split(whiteSpaceGroupRgx);\n        for (let i = 0, l = words.length; i < l; i++) {\n          const segment = words[i];\n          segments.push({\n            segment,\n            isWordLike: !whiteSpaceRgx.test(segment), // Consider non-whitespace as word-like\n          });\n        }\n        return segments;\n      }\n    };\n    if (!graphemeSegmenter) graphemeSegmenter = segmenter ? new segmenter([], { granularity: 'grapheme' }) : {\n      segment: text => [...text].map(char => ({ segment: char }))\n    };\n    if (!$splitTemplate && isBrowser) $splitTemplate = doc.createElement('template');\n    if (scope.current) scope.current.register(this);\n    const { words, chars, lines, accessible, includeSpaces, debug } = parameters;\n    const $target = /** @type {HTMLElement} */((target = isArr(target) ? target[0] : target) && /** @type {Node} */(target).nodeType ? target : (getNodeList(target) || [])[0]);\n    const lineParams = lines === true ? {} : lines;\n    const wordParams = words === true || isUnd(words) ? {} : words;\n    const charParams = chars === true ? {} : chars;\n    this.debug = setValue(debug, false);\n    this.includeSpaces = setValue(includeSpaces, false);\n    this.accessible = setValue(accessible, true);\n    this.linesOnly = lineParams && (!wordParams && !charParams);\n    /** @type {String|false|SplitFunctionValue} */\n    this.lineTemplate = isObj(lineParams) ? generateTemplate(lineType, /** @type {splitTemplateParams} */(lineParams)) : lineParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.wordTemplate = isObj(wordParams) || this.linesOnly ? generateTemplate(wordType, /** @type {splitTemplateParams} */(wordParams)) : wordParams;\n    /** @type {String|false|SplitFunctionValue} */\n    this.charTemplate = isObj(charParams) ? generateTemplate(charType, /** @type {splitTemplateParams} */(charParams)) : charParams;\n    this.$target = $target;\n    this.html = $target && $target.innerHTML;\n    this.lines = [];\n    this.words = [];\n    this.chars = [];\n    this.effects = [];\n    this.effectsCleanups = [];\n    this.cache = null;\n    this.ready = false;\n    this.width = 0;\n    this.resizeTimeout = null;\n    const handleSplit = () => this.html && (lineParams || wordParams || charParams) && this.split();\n    // Make sure this is declared before calling handleSplit() in case revert() is called inside an effect callback\n    this.resizeObserver = new ResizeObserver(() => {\n      // Use a setTimeout instead of a Timer for better tree shaking\n      clearTimeout(this.resizeTimeout);\n      this.resizeTimeout = setTimeout(() => {\n        const currentWidth = /** @type {HTMLElement} */($target).offsetWidth;\n        if (currentWidth === this.width) return;\n        this.width = currentWidth;\n        handleSplit();\n      }, 150);\n    });\n    // Only declare the font ready promise when splitting by lines and not alreay split\n    if (this.lineTemplate && !this.ready) {\n      doc.fonts.ready.then(handleSplit);\n    } else {\n      handleSplit();\n    }\n    $target ? this.resizeObserver.observe($target) : console.warn('No Text Splitter target found.');\n  }\n\n  /**\n   * @param  {(...args: any[]) => Tickable | (() => void)} effect\n   * @return this\n   */\n  addEffect(effect) {\n    if (!isFnc(effect)) return console.warn('Effect must return a function.');\n    const refreshableEffect = createRefreshable(effect);\n    this.effects.push(refreshableEffect);\n    if (this.ready) this.effectsCleanups[this.effects.length - 1] = refreshableEffect(this);\n    return this;\n  }\n\n  revert() {\n    clearTimeout(this.resizeTimeout);\n    this.lines.length = this.words.length = this.chars.length = 0;\n    this.resizeObserver.disconnect();\n    // Make sure to revert the effects after disconnecting the resizeObserver to avoid triggering it in the process\n    this.effectsCleanups.forEach(cleanup => isFnc(cleanup) ? cleanup(this) : cleanup.revert && cleanup.revert());\n    this.$target.innerHTML = this.html;\n    return this;\n  }\n\n  /**\n   * Recursively processes a node and its children\n   * @param {Node} node\n   */\n  splitNode(node) {\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const includeSpaces = this.includeSpaces;\n    const debug = this.debug;\n    const nodeType = node.nodeType;\n    if (nodeType === 3) {\n      const nodeText = node.nodeValue;\n      // If the nodeText is only whitespace, leave it as is\n      if (nodeText.trim()) {\n        const tempWords = [];\n        const words = this.words;\n        const chars = this.chars;\n        const wordSegments = wordSegmenter.segment(nodeText);\n        const $wordsFragment = doc.createDocumentFragment();\n        let prevSeg = null;\n        for (const wordSegment of wordSegments) {\n          const segment = wordSegment.segment;\n          const isWordLike = isSegmentWordLike(wordSegment);\n          // Determine if this segment should be a new word, first segment always becomes a new word\n          if (!prevSeg || (isWordLike && (prevSeg && (isSegmentWordLike(prevSeg))))) {\n            tempWords.push(segment);\n          } else {\n            // Only concatenate if both current and previous are non-word-like and don't contain spaces\n            const lastWordIndex = tempWords.length - 1;\n            const lastWord = tempWords[lastWordIndex];\n            if (!lastWord.includes(' ') && !segment.includes(' ')) {\n              tempWords[lastWordIndex] += segment;\n            } else {\n              tempWords.push(segment);\n            }\n          }\n          prevSeg = wordSegment;\n        }\n\n        for (let i = 0, l = tempWords.length; i < l; i++) {\n          const word = tempWords[i];\n          if (!word.trim()) {\n            // Preserve whitespace only if includeSpaces is false and if the current space is not the first node\n            if (i && includeSpaces) continue;\n            $wordsFragment.appendChild(doc.createTextNode(word));\n          } else {\n            const nextWord = tempWords[i + 1];\n            const hasWordFollowingSpace = includeSpaces && nextWord && !nextWord.trim();\n            const wordToProcess = word;\n            const charSegments = charTemplate ? graphemeSegmenter.segment(wordToProcess) : null;\n            const $charsFragment = charTemplate ? doc.createDocumentFragment() : doc.createTextNode(hasWordFollowingSpace ? word + '\\xa0' : word);\n            if (charTemplate) {\n              const charSegmentsArray = [...charSegments];\n              for (let j = 0, jl = charSegmentsArray.length; j < jl; j++) {\n                const charSegment = charSegmentsArray[j];\n                const isLastChar = j === jl - 1;\n                // If this is the last character and includeSpaces is true with a following space, append the space\n                const charText = isLastChar && hasWordFollowingSpace ? charSegment.segment + '\\xa0' : charSegment.segment;\n                const $charNode = doc.createTextNode(charText);\n                processHTMLTemplate(charTemplate, chars, $charNode, /** @type {DocumentFragment} */($charsFragment), charType, debug, -1, words.length, chars.length);\n              }\n            }\n            if (wordTemplate) {\n              processHTMLTemplate(wordTemplate, words, $charsFragment, $wordsFragment, wordType, debug, -1, words.length, chars.length);\n              // Chars elements must be re-parsed in the split() method if both words and chars are parsed\n            } else if (charTemplate) {\n              $wordsFragment.appendChild($charsFragment);\n            } else {\n              $wordsFragment.appendChild(doc.createTextNode(word));\n            }\n            // Skip the next iteration if we included a space\n            if (hasWordFollowingSpace) i++;\n          }\n        }\n        node.parentNode.replaceChild($wordsFragment, node);\n      }\n    } else if (nodeType === 1) {\n      // Converting to an array is necessary to work around childNodes pottential mutation\n      const childNodes = /** @type {Array<Node>} */([.../** @type {*} */(node.childNodes)]);\n      for (let i = 0, l = childNodes.length; i < l; i++) this.splitNode(childNodes[i]);\n    }\n  }\n\n  /**\n   * @param {Boolean} clearCache\n   * @return {this}\n   */\n  split(clearCache = false) {\n    const $el = this.$target;\n    const isCached = !!this.cache && !clearCache;\n    const lineTemplate = this.lineTemplate;\n    const wordTemplate = this.wordTemplate;\n    const charTemplate = this.charTemplate;\n    const fontsReady = doc.fonts.status !== 'loading';\n    const canSplitLines = lineTemplate && fontsReady;\n    this.ready = !lineTemplate || fontsReady;\n    if (canSplitLines || clearCache) {\n      // No need to revert effects animations here since it's already taken care by the refreshable\n      this.effectsCleanups.forEach(cleanup => isFnc(cleanup) && cleanup(this));\n    }\n    if (!isCached) {\n      if (clearCache) {\n        $el.innerHTML = this.html;\n        this.words.length = this.chars.length = 0;\n      }\n      this.splitNode($el);\n      this.cache = $el.innerHTML;\n    }\n    if (canSplitLines) {\n      if (isCached) $el.innerHTML = this.cache;\n      this.lines.length = 0;\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n    }\n    // Always reparse characters after a line reset or if both words and chars are activated\n    if (charTemplate && (canSplitLines || wordTemplate)) {\n      this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Words are used when lines only and prioritized over chars\n    const elementsArray = this.words.length ? this.words : this.chars;\n    let y, linesCount = 0;\n    for (let i = 0, l = elementsArray.length; i < l; i++) {\n      const $el = elementsArray[i];\n      const { top, height } = $el.getBoundingClientRect();\n      if (y && top - y > height * .5) linesCount++;\n      $el.setAttribute(dataLine, `${linesCount}`);\n      const nested = $el.querySelectorAll(`[${dataLine}]`);\n      let c = nested.length;\n      while (c--) nested[c].setAttribute(dataLine, `${linesCount}`);\n      y = top;\n    }\n    if (canSplitLines) {\n      const linesFragment = doc.createDocumentFragment();\n      const parents = new Set();\n      const clones = [];\n      for (let lineIndex = 0; lineIndex < linesCount + 1; lineIndex++) {\n        const $clone = /** @type {HTMLElement} */($el.cloneNode(true));\n        filterLineElements($clone, lineIndex, new Set()).forEach($el => {\n          const $parent = $el.parentElement;\n          if ($parent) parents.add($parent);\n          $el.remove();\n        });\n        clones.push($clone);\n      }\n      parents.forEach(filterEmptyElements);\n      for (let cloneIndex = 0, clonesLength = clones.length; cloneIndex < clonesLength; cloneIndex++) {\n        processHTMLTemplate(lineTemplate, this.lines, clones[cloneIndex], linesFragment, lineType, this.debug, cloneIndex);\n      }\n      $el.innerHTML = '';\n      $el.appendChild(linesFragment);\n      if (wordTemplate) this.words = getAllTopLevelElements($el, wordType);\n      if (charTemplate) this.chars = getAllTopLevelElements($el, charType);\n    }\n    // Remove the word wrappers and clear the words array if lines split only\n    if (this.linesOnly) {\n      const words = this.words;\n      let w = words.length;\n      while (w--) {\n        const $word = words[w];\n        $word.replaceWith($word.textContent);\n      }\n      words.length = 0;\n    }\n    if (this.accessible && (canSplitLines || !isCached)) {\n      const $accessible = doc.createElement('span');\n      // Make the accessible element visually-hidden (https://www.scottohara.me/blog/2017/04/14/inclusively-hidden.html)\n      $accessible.style.cssText = `position:absolute;overflow:hidden;clip:rect(0 0 0 0);clip-path:inset(50%);width:1px;height:1px;white-space:nowrap;`;\n      // $accessible.setAttribute('tabindex', '-1');\n      $accessible.innerHTML = this.html;\n      $el.insertBefore($accessible, $el.firstChild);\n      this.lines.forEach(setAriaHidden);\n      this.words.forEach(setAriaHidden);\n      this.chars.forEach(setAriaHidden);\n    }\n    this.width = /** @type {HTMLElement} */($el).offsetWidth;\n    if (canSplitLines || clearCache) {\n      this.effects.forEach((effect, i) => this.effectsCleanups[i] = effect(this));\n    }\n    return this;\n  }\n\n  refresh() {\n    this.split(true);\n  }\n}\n\n/**\n * @param  {HTMLElement|NodeList|String|Array<HTMLElement>} target\n * @param  {TextSplitterParams} [parameters]\n * @return {TextSplitter}\n */\nconst split = (target, parameters) => new TextSplitter(target, parameters);\n\nconst text = {\n  split,\n};\n\n\n\n\n/**\n * @overload\n * @param {Number} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<Number>}\n */\n/**\n * @overload\n * @param {String} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<String>}\n */\n/**\n * @overload\n * @param {[Number, Number]} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<Number>}\n */\n/**\n * @overload\n * @param {[String, String]} val\n * @param {StaggerParams} [params]\n * @return {StaggerFunction<String>}\n */\n/**\n * @param {Number|String|[Number, Number]|[String, String]} val The staggered value or range\n * @param {StaggerParams} [params] The stagger parameters\n * @return {StaggerFunction<Number|String>}\n */\nconst stagger = (val, params = {}) => {\n  let values = [];\n  let maxValue = 0;\n  const from = params.from;\n  const reversed = params.reversed;\n  const ease = params.ease;\n  const hasEasing = !isUnd(ease);\n  const hasSpring = hasEasing && !isUnd(/** @type {Spring} */(ease).ease);\n  const staggerEase = hasSpring ? /** @type {Spring} */(ease).ease : hasEasing ? parseEasings(ease) : null;\n  const grid = params.grid;\n  const axis = params.axis;\n  const customTotal = params.total;\n  const fromFirst = isUnd(from) || from === 0 || from === 'first';\n  const fromCenter = from === 'center';\n  const fromLast = from === 'last';\n  const fromRandom = from === 'random';\n  const isRange = isArr(val);\n  const useProp = params.use;\n  const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);\n  const val2 = isRange ? parseNumber(val[1]) : 0;\n  const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);\n  const start = params.start || 0 + (isRange ? val1 : 0);\n  let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;\n  return (target, i, t, tl) => {\n    const [ registeredTarget ] = registerTargets(target);\n    const total = isUnd(customTotal) ? t : customTotal;\n    const customIndex = !isUnd(useProp) ? isFnc(useProp) ? useProp(registeredTarget, i, total) : getOriginalAnimatableValue(registeredTarget, useProp) : false;\n    const staggerIndex = isNum(customIndex) || isStr(customIndex) && isNum(+customIndex) ? +customIndex : i;\n    if (fromCenter) fromIndex = (total - 1) / 2;\n    if (fromLast) fromIndex = total - 1;\n    if (!values.length) {\n      for (let index = 0; index < total; index++) {\n        if (!grid) {\n          values.push(abs(fromIndex - index));\n        } else {\n          const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n          const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n          const toX = index % grid[0];\n          const toY = floor(index / grid[0]);\n          const distanceX = fromX - toX;\n          const distanceY = fromY - toY;\n          let value = sqrt(distanceX * distanceX + distanceY * distanceY);\n          if (axis === 'x') value = -distanceX;\n          if (axis === 'y') value = -distanceY;\n          values.push(value);\n        }\n        maxValue = max(...values);\n      }\n      if (staggerEase) values = values.map(val => staggerEase(val / maxValue) * maxValue);\n      if (reversed) values = values.map(val => axis ? (val < 0) ? val * -1 : -val : abs(maxValue - val));\n      if (fromRandom) values = shuffle(values);\n    }\n    const spacing = isRange ? (val2 - val1) / maxValue : val1;\n    const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */(start);\n    /** @type {String|Number} */\n    let output = offset + ((spacing * round(values[staggerIndex], 2)) || 0);\n    if (params.modifier) output = params.modifier(output);\n    if (unitMatch) output = `${output}${unitMatch[2]}`;\n    return output;\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9hbmltZWpzQDQuMS40L25vZGVfbW9kdWxlcy9hbmltZWpzL2xpYi9hbmltZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QixjQUFjLHVDQUF1QztBQUNyRCxjQUFjLGFBQWE7QUFDM0IsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsUUFBUTtBQUN0QixjQUFjLGFBQWE7QUFDM0IsY0FBYywyQ0FBMkM7QUFDekQsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyxrQ0FBa0M7QUFDaEQ7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyw0QkFBNEI7QUFDMUMsY0FBYyxnRkFBZ0Y7O0FBRTlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxlQUFlO0FBQzdCLGNBQWMseUNBQXlDO0FBQ3ZELGNBQWMsU0FBUztBQUN2QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFdBQVc7QUFDekIsY0FBYyxnRUFBZ0U7QUFDOUUsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQixjQUFjLGVBQWU7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQSxhQUFhLGl4QkFBaXhCO0FBQzl4Qjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZLDhDQUE4Qzs7QUFFeEUsY0FBYyx3QkFBd0I7QUFDdEMsY0FBYyxxQkFBcUI7QUFDbkMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyx3QkFBd0I7QUFDdEMsY0FBYywyQkFBMkI7QUFDekMsY0FBYyw2Q0FBNkM7QUFDM0QsY0FBYyxtQkFBbUI7QUFDakMsY0FBYywyQkFBMkI7QUFDekMsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyx1Q0FBdUM7QUFDckQsY0FBYyxnQkFBZ0I7O0FBRTlCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLGNBQWM7QUFDekIsWUFBWTtBQUNaOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixjQUFjLGFBQWE7QUFDM0IsY0FBYyxhQUFhO0FBQzNCLGNBQWMsYUFBYTtBQUMzQixjQUFjLGFBQWE7QUFDM0IsY0FBYyxhQUFhO0FBQzNCLGNBQWMsYUFBYTtBQUMzQjs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckIsY0FBYyxhQUFhO0FBQzNCOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLHdCQUF3QjtBQUN0QyxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjs7QUFFQSxjQUFjLGtDQUFrQzs7QUFFaEQ7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGVBQWU7QUFDN0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsZUFBZTtBQUM3QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsY0FBYyxZQUFZO0FBQzFCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsZ0JBQWdCO0FBQzlCOztBQUVBLGVBQWUsdUNBQXVDO0FBQ3RELGNBQWMsdUNBQXVDO0FBQ3JELGNBQWMsZ0NBQWdDO0FBQzlDLGNBQWMsNEJBQTRCOztBQUUxQzs7QUFFQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDOztBQUVBO0FBQ0EsYUFBYSxvREFBb0Q7QUFDakU7O0FBRUE7QUFDQSxhQUFhLFlBQVksNkNBQTZDO0FBQ3RFOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsYUFBYTtBQUMzQixjQUFjLGVBQWU7QUFDN0IsY0FBYyxrQkFBa0I7QUFDaEM7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxnQkFBZ0I7QUFDOUI7O0FBRUE7QUFDQSxhQUFhLGtDQUFrQztBQUMvQzs7QUFFQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25EOztBQUVBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0Q7O0FBRUE7QUFDQSxhQUFhLFNBQVMsNkNBQTZDLCtDQUErQyxpREFBaUQsR0FBRztBQUN0Szs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGFBQWE7QUFDM0I7O0FBRUE7QUFDQSxhQUFhLGlDQUFpQztBQUM5Qzs7QUFFQTtBQUNBLGFBQWEsc0VBQXNFO0FBQ25GOztBQUVBO0FBQ0EsYUFBYSxvRkFBb0Y7QUFDakc7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyx1Q0FBdUM7QUFDckQsY0FBYyxhQUFhO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHNRQUFzUTtBQUNuUjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxrQkFBa0IsT0FBTyxTQUFTLE9BQU8sVUFBVTtBQUMvRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFtRDtBQUNoRTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGFBQWE7QUFDM0I7O0FBRUE7QUFDQSxhQUFhLDhGQUE4RjtBQUMzRzs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsMkNBQTJDO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7O0FBRUE7QUFDQSxhQUFhLDRFQUE0RTtBQUN6Rjs7QUFFQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsMkJBQTJCO0FBQ3pDLGNBQWMsMkJBQTJCO0FBQ3pDLGNBQWMsYUFBYTtBQUMzQixjQUFjLG9CQUFvQjtBQUNsQzs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsUUFBUTtBQUN0QixjQUFjLDJCQUEyQjtBQUN6QyxjQUFjLDJCQUEyQjtBQUN6QyxjQUFjLGFBQWE7QUFDM0IsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxlQUFlO0FBQzdCOztBQUVBO0FBQ0EsYUFBYSxpS0FBaUs7QUFDOUs7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DLFlBQVksUUFBUTtBQUNwQixZQUFZLGFBQWE7QUFDekIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQSxhQUFhLHFEQUFxRDtBQUNsRTs7QUFFQTtBQUNBLGFBQWEsaURBQWlEO0FBQzlEOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGFBQWE7QUFDM0IsY0FBYyxlQUFlO0FBQzdCLGNBQWMsa0JBQWtCO0FBQ2hDOztBQUVBO0FBQ0EsYUFBYSxzSkFBc0o7QUFDbks7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyw2QkFBNkI7QUFDM0M7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyx3QkFBd0I7QUFDdEM7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyx1Q0FBdUM7QUFDckQsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyx3QkFBd0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWTtBQUNaOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsc0JBQXNCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGVBQWU7QUFDN0IsY0FBYyxtQ0FBbUM7QUFDakQsY0FBYyxjQUFjO0FBQzVCLGNBQWMsY0FBYztBQUM1QixjQUFjLHVHQUF1RztBQUNySCxjQUFjLHFLQUFxSztBQUNuTCxjQUFjLHFLQUFxSztBQUNuTCxjQUFjLGlEQUFpRDtBQUMvRCxjQUFjLFNBQVM7QUFDdkIsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLHVFQUF1RTtBQUNyRjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsbUJBQW1CO0FBQ2pDLGNBQWMsNkZBQTZGO0FBQzNHLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsZUFBZTtBQUM3QixjQUFjLHVFQUF1RTtBQUNyRixjQUFjLHVFQUF1RTtBQUNyRixjQUFjLDJDQUEyQztBQUN6RCxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLDJDQUEyQztBQUN6RCxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxhQUFhO0FBQzNCLGNBQWMseUZBQXlGO0FBQ3ZHLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMscUJBQXFCO0FBQ25DLGNBQWMscUJBQXFCO0FBQ25DOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsY0FBYztBQUM1QixjQUFjLG1EQUFtRDtBQUNqRSxjQUFjLGdEQUFnRDtBQUM5RDs7QUFFQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsbURBQW1EO0FBQ2pFLGNBQWMsbURBQW1EO0FBQ2pFLGNBQWMsbURBQW1EO0FBQ2pFLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLDBDQUEwQyxRQUFRLEVBQUUsT0FBTztBQUMzRCxjQUFjLFFBQVEsRUFBRSxPQUFPO0FBQy9CLE1BQU07QUFDTjs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLFVBQVUsZUFBZSxPQUFPO0FBQzNDLG1DQUFtQyxVQUFVLGlCQUFpQixjQUFjLFNBQVM7O0FBRXJGLFdBQVcsZUFBZTtBQUMxQjs7QUFFQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1GQUFtRixtQkFBbUIsS0FBSzs7QUFFM0c7O0FBRUEsYUFBYSxNQUFNO0FBQ25COztBQUVBOztBQUVBLGdDQUFnQyxFQUFFLEVBQUUsSUFBSSxlQUFlLEVBQUUsRUFBRSxJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7Ozs7QUFLQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLEtBQUssV0FBVywwQkFBMEI7QUFDckQ7QUFDQSxXQUFXLEtBQUssV0FBVyxhQUFhO0FBQ3hDO0FBQ0EsV0FBVyxLQUFLLFdBQVcsYUFBYTtBQUN4QztBQUNBLFdBQVcsS0FBSyxXQUFXLGVBQWU7QUFDMUM7QUFDQSxXQUFXLEtBQUssV0FBVyxnQkFBZ0I7QUFDM0M7QUFDQSxXQUFXLEtBQUssV0FBVyx1QkFBdUI7QUFDbEQ7QUFDQSxXQUFXLEtBQUssV0FBVyxpQkFBaUI7QUFDNUM7QUFDQSxXQUFXLEtBQUssV0FBVyxTQUFTO0FBQ3BDO0FBQ0EsV0FBVyxLQUFLLFdBQVcsU0FBUztBQUNwQztBQUNBLFdBQVcsS0FBSyxXQUFXLFNBQVM7QUFDcEM7QUFDQSxXQUFXLEtBQUssV0FBVyxTQUFTO0FBQ3BDO0FBQ0EsV0FBVyxLQUFLLFdBQVcsU0FBUztBQUNwQzs7QUFFQTs7QUFFQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZO0FBQ1o7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLGFBQWEsUUFBUTs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxzQkFBc0I7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBLDhDQUE4QyxzQ0FBc0M7O0FBRXBGO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CLGNBQWMscUJBQXFCO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRCQUE0QixPQUFPLEtBQUssT0FBTztBQUMvQztBQUNBLDJCQUEyQixPQUFPO0FBQ2xDLHdDQUF3QyxPQUFPO0FBQy9DLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwyREFBMkQ7QUFDdkUsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksV0FBVztBQUN2QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjtBQUMvRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixPQUFPLGNBQWMsYUFBYTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7O0FBRUE7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRCxZQUFZO0FBQ1o7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4Qyx1QkFBdUIsT0FBTyxFQUFFLFlBQVk7QUFDNUMsWUFBWTtBQUNaO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRCw2Q0FBNkMsUUFBUTtBQUNyRCw2Q0FBNkMsUUFBUTtBQUNyRCx1Q0FBdUMsUUFBUTtBQUMvQyw0QkFBNEIsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QseUJBQXlCLFdBQVcsdURBQXVELFFBQVE7QUFDbkcsY0FBYztBQUNkLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEIsZ0VBQWdFLFFBQVE7QUFDeEU7QUFDQTs7QUFFQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCLEVBQUUscUNBQXFDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsYUFBYSxpQ0FBaUMsYUFBYTtBQUM5RTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQjtBQUMzRCx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwrQ0FBK0Msa0JBQWtCO0FBQ2pFOztBQUVBLG9DQUFvQyxhQUFhO0FBQ2pELG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esd0VBQXdFLGtCQUFrQjs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JELGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxPQUFPO0FBQ2xFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWTtBQUNaO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3RELG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRCxvQkFBb0IsY0FBYztBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZO0FBQ1o7QUFDQSxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsR0FBRztBQUMzRCx1REFBdUQsSUFBSSxFQUFFLEdBQUc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILDRDQUE0QyxXQUFXO0FBQ3ZELHNDQUFzQyxXQUFXO0FBQ2pELGtDQUFrQyxPQUFPLEVBQUUsSUFBSTtBQUMvQzs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0Msb0JBQW9CLGNBQWMsV0FBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLEdBQUc7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0QsMEVBQTBFLFdBQVc7QUFDckYsOERBQThELFdBQVc7QUFDekUsZ0NBQWdDLFdBQVc7QUFDM0M7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLHNCQUFzQjtBQUNsQyxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNEJBQTRCLFFBQVE7QUFDcEMseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLHNCQUFzQjtBQUNsQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLHVCQUF1QjtBQUNuQyxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsNkJBQTZCOztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25ELDJDQUEyQyxRQUFROzs7QUFHbkQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxlQUFlLFFBQVE7QUFDdkIsNENBQTRDO0FBQzVDLGVBQWUsUUFBUTtBQUN2QiwrQ0FBK0M7QUFDL0MsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0NBQWdDO0FBQ2hDLGVBQWUsVUFBVTtBQUN6QiwwQkFBMEI7QUFDMUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUNBQXVDLGdCQUFnQjtBQUM3RCxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7Ozs7O0FBS0EsV0FBVyxnQkFBZ0I7QUFDM0I7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7O0FBRUEsY0FBYyxzQ0FBc0M7O0FBRXBEO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7O0FBRUEsV0FBVyw2Q0FBNkM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYSxZQUFZO0FBQ3pCO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVk7QUFDWjs7QUFFQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSw2Q0FBNkM7QUFDekQsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQiwwQkFBMEIsY0FBYztBQUN4RjtBQUNBLElBQUk7QUFDSjtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLGVBQWU7QUFDN0IsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxjQUFjO0FBQzVCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsYUFBYTtBQUMzQixjQUFjLGFBQWE7QUFDM0IsY0FBYyxhQUFhO0FBQzNCLGNBQWMsYUFBYTtBQUMzQixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFlBQVk7QUFDMUIsY0FBYyxZQUFZO0FBQzFCLGNBQWMsWUFBWTtBQUMxQixjQUFjLFlBQVk7QUFDMUIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGVBQWU7QUFDN0IsY0FBYyxlQUFlO0FBQzdCOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZCQUE2QjtBQUNsRTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BELDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxDQUFDOztBQUVELFdBQVcsZ0NBQWdDO0FBQzNDLHlCQUF5Qjs7QUFFekI7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWTtBQUNaO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDs7Ozs7QUFLQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxZQUFZO0FBQ3hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixXQUFXO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7Ozs7QUFLQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxzQkFBc0I7QUFDbEMsWUFBWSxRQUFRO0FBQ3BCLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxjQUFjLFlBQVk7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUNBQWlDLGFBQWE7QUFDOUM7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDOztBQUVBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0Esa0RBQWtELG1CQUFtQjtBQUNyRSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0NBQXdDLGtCQUFrQjtBQUMxRDs7QUFFQSxJQUFJO0FBQ0oscUNBQXFDLFFBQVE7QUFDN0M7QUFDQSxrQkFBa0IsUUFBUSw4Q0FBOEM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUVBQXVFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsNkJBQTZCOztBQUVsRDtBQUNBOztBQUVBOztBQUVBLGdDQUFnQyxpQkFBaUI7QUFDakQsOEJBQThCLGlCQUFpQix3REFBd0QsbUJBQW1COztBQUUxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRSwyQ0FBMkMsUUFBUTtBQUNuRCw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qiw2QkFBNkI7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEVBQTRFLHdCQUF3QjtBQUNwRztBQUNBLHlCQUF5QixXQUFXLE1BQU0sT0FBTyxLQUFLLE1BQU0seUJBQXlCLElBQUksSUFBSTtBQUM3RixzR0FBc0csZUFBZTtBQUNySDtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQSw4Q0FBOEMsaUJBQWlCLGNBQWMsU0FBUztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxnQkFBZ0I7O0FBRXpEOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsK0VBQStFLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVE7QUFDN0U7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVztBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVk7QUFDWjtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEUsb0JBQW9CLGdDQUFnQztBQUNwRCxDQUFDOztBQUVEO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSSxvQkFBb0IsUUFBUTtBQUNoQywyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUIsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDREQUE0RDtBQUNqRywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxvQkFBb0I7QUFDaEMsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBLHlHQUF5RyxFQUFFO0FBQzNHLDRGQUE0RixFQUFFO0FBQzlGLFlBQVksRUFBRTtBQUNkOztBQUVBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQixZQUFZLG9CQUFvQjtBQUNoQyxZQUFZLG9CQUFvQjtBQUNoQyxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFELHFEQUFxRCxTQUFTO0FBQzlELG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUMsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLDBCQUEwQjtBQUMxQixlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLGNBQWM7QUFDN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekIsNENBQTRDLFFBQVE7QUFDcEQsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDLG1DQUFtQyxvQkFBb0I7O0FBRXZEO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3Qyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQsZ0NBQWdDLG1CQUFtQjtBQUNuRCxrQ0FBa0MsbUJBQW1CO0FBQ3JELHFCQUFxQixRQUFRO0FBQzdCLGtFQUFrRSxRQUFRO0FBQzFFLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6Qyw2Q0FBNkMsb0JBQW9CO0FBQ2pFLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsOERBQThELEtBQUs7QUFDbkUscUVBQXFFLEtBQUs7QUFDMUU7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCLFFBQVEsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQzs7QUFFQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkNBQTZDLHNCQUFzQjtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLHNCQUFzQjtBQUNqQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZO0FBQ1o7QUFDQTtBQUNBLHFCQUFxQix1REFBdUQ7QUFDNUU7O0FBRUE7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksbUJBQW1CO0FBQy9CLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGlCQUFpQjtBQUM3QixZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCLFlBQVk7QUFDWjtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDJEQUEyRCxXQUFXLGdEQUFnRCxRQUFRO0FBQzlILGtCQUFrQiwyQ0FBMkMsRUFBRSxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGlCQUFpQjtBQUM3QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksY0FBYztBQUMxQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSwyQkFBMkI7QUFDdkMsWUFBWSwyQkFBMkI7QUFDdkMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQsa0RBQWtELGdCQUFnQiw4Q0FBOEMsZ0JBQWdCO0FBQ2hJLDJDQUEyQyxPQUFPO0FBQ2xELDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZLDhCQUE4QixZQUFZO0FBQ3pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQyxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQSxtREFBbUQsRUFBRTs7QUFFckQ7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQSxpREFBaUQsRUFBRTs7QUFFbkQ7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksb0JBQW9CO0FBQ2hDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWTtBQUNaO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekMsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsY0FBYztBQUM1QixjQUFjLGNBQWM7QUFDNUIsY0FBYyxhQUFhO0FBQzNCLGNBQWMsYUFBYTtBQUMzQixjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGVBQWU7QUFDN0IsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQSxhQUFhLHFDQUFxQztBQUNsRDtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pELG9CQUFvQiw2QkFBNkI7QUFDakQsbUJBQW1CLDJCQUEyQjtBQUM5QyxtQkFBbUIsMkJBQTJCO0FBQzlDLDBCQUEwQix5Q0FBeUM7QUFDbkUsdUJBQXVCLG1DQUFtQztBQUMxRCx1QkFBdUIsbUNBQW1DO0FBQzFELHVCQUF1QixtQ0FBbUM7QUFDMUQscUJBQXFCLCtCQUErQjtBQUNwRCx1QkFBdUIsbUNBQW1DO0FBQzFELHVCQUF1QixtQ0FBbUM7QUFDMUQ7Ozs7O0FBS0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksVUFBVTtBQUN0QixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDLFlBQVksVUFBVTtBQUN0QixZQUFZLFFBQVE7QUFDcEIsWUFBWSxjQUFjO0FBQzFCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLDZEQUE2RCxRQUFRO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RCx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0IscUJBQXFCLDRCQUE0QjtBQUNqRCxlQUFlLFFBQVE7QUFDdkIsdUJBQXVCO0FBQ3ZCLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlEQUFpRDtBQUM5RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLGtCQUFrQjtBQUMvQixjQUFjO0FBQ2Q7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QyxhQUFhLGtDQUFrQztBQUMvQyxhQUFhLGlEQUFpRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsa0JBQWtCO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxrQkFBa0I7QUFDL0IsY0FBYztBQUNkO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLGtCQUFrQjtBQUMvQixjQUFjO0FBQ2Q7QUFDQSxhQUFhLDhDQUE4QztBQUMzRCxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0IsK0JBQStCLHNCQUFzQixvREFBb0QsVUFBVTtBQUMzSyw4QkFBOEIsc0RBQXNEO0FBQ3BGOztBQUVBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsa0JBQWtCO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQStDO0FBQ3JFOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsa0JBQWtCO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsY0FBYztBQUM1QixjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixZQUFZO0FBQ1o7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EseURBQXlELElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0EsNkNBQTZDLE9BQU8sZUFBZSxPQUFPO0FBQzFFO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDZDQUE2QyxRQUFRO0FBQ3JELDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNBLDZEQUE2RCxrQkFBa0I7Ozs7O0FBSy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLCtEQUErRDtBQUMvRCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7O0FBRUEsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1FQUFtRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBOzs7OztBQUtBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1osYUFBYTs7QUFFYixZQUFZO0FBQ1osYUFBYTs7QUFFYixnQkFBZ0I7QUFDaEIsaUJBQWlCOztBQUVqQixpQkFBaUI7QUFDakIsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQSxvQkFBb0IsV0FBVztBQUMvQix1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzRkFBc0Y7QUFDcEcsV0FBVyxtQ0FBbUM7QUFDOUMsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBLGlHQUFpRyxVQUFVOztBQUUzRzs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRSw2QkFBNkIsUUFBUSxzQ0FBc0MsUUFBUSwrQkFBK0IsUUFBUTtBQUMxSCw2QkFBNkIsUUFBUSxzQ0FBc0MsUUFBUSwrQkFBK0IsUUFBUTtBQUMxSDtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsK0RBQStELFdBQVc7QUFDeEg7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBLDhCQUE4QixhQUFhO0FBQzNDLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pEO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLFFBQVE7QUFDdkIsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixlQUFlLGtDQUFrQztBQUNqRCwwQ0FBMEM7QUFDMUMsZUFBZSxrQkFBa0I7QUFDakMsMkJBQTJCO0FBQzNCLGVBQWUsa0VBQWtFO0FBQ2pGLDZDQUE2QztBQUM3QyxlQUFlLGtCQUFrQjtBQUNqQyw4QkFBOEI7QUFDOUIsZUFBZSxrQ0FBa0M7QUFDakQsa0NBQWtDO0FBQ2xDLGVBQWUsa0NBQWtDO0FBQ2pELHVFQUF1RTtBQUN2RSxlQUFlLGtDQUFrQztBQUNqRCxzQ0FBc0M7QUFDdEMsZUFBZSxrQ0FBa0M7QUFDakQsc0NBQXNDO0FBQ3RDLGVBQWUsa0JBQWtCO0FBQ2pDLDBCQUEwQjtBQUMxQixlQUFlLDBCQUEwQjtBQUN6QztBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsb0NBQW9DLGdEQUFnRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUErQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJEQUEyRCxlQUFlO0FBQzFFLDBEQUEwRCxlQUFlO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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WTtBQUNaO0FBQ0E7QUFDQSxXQUFXLGlEQUFpRDtBQUM1RCxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNELDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUgsUUFBUTtBQUMzSCxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBLCtCQUErQixPQUFPLEVBQUUsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7O0FBRTZTIiwic291cmNlcyI6WyIvVXNlcnMvc2F0aGlyYS9Qcm9qZWN0cy9ncm90dG8vbm9kZV9tb2R1bGVzLy5wbnBtL2FuaW1lanNANC4xLjQvbm9kZV9tb2R1bGVzL2FuaW1lanMvbGliL2FuaW1lLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGFuaW1lLmpzIC0gRVNNXG4gKiBAdmVyc2lvbiB2NC4xLjRcbiAqIEBhdXRob3IgSnVsaWFuIEdhcm5pZXJcbiAqIEBsaWNlbnNlIE1JVFxuICogQGNvcHlyaWdodCAoYykgMjAyNSBKdWxpYW4gR2FybmllclxuICogQHNlZSBodHRwczovL2FuaW1lanMuY29tXG4gKi9cblxuLy8gR2xvYmFsIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0c1BhcmFtc1xuICogQHByb3BlcnR5IHtOdW1iZXJ8U3RyaW5nfSBbaWRdXG4gKiBAcHJvcGVydHkge1BlcmNlbnRhZ2VLZXlmcmFtZXN8RHVyYXRpb25LZXlmcmFtZXN9IFtrZXlmcmFtZXNdXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbcGxheWJhY2tFYXNlXVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwbGF5YmFja1JhdGVdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2ZyYW1lUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEJvb2xlYW59IFtsb29wXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbcmV2ZXJzZWRdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFthbHRlcm5hdGVdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58U2Nyb2xsT2JzZXJ2ZXJ9IFthdXRvcGxheV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9uVmFsdWV9IFtkdXJhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9uVmFsdWV9IFtkZWxheV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbG9vcERlbGF5XVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gKiBAcHJvcGVydHkgeydub25lJ3wncmVwbGFjZSd8J2JsZW5kJ3xjb21wb3NpdGlvblR5cGVzfSBbY29tcG9zaXRpb25dXG4gKiBAcHJvcGVydHkgeyh2OiBhbnkpID0+IGFueX0gW21vZGlmaWVyXVxuICogQHByb3BlcnR5IHsodGlja2FibGU6IFRpY2thYmxlKSA9PiB2b2lkfSBbb25CZWdpbl1cbiAqIEBwcm9wZXJ0eSB7KHRpY2thYmxlOiBUaWNrYWJsZSkgPT4gdm9pZH0gW29uQmVmb3JlVXBkYXRlXVxuICogQHByb3BlcnR5IHsodGlja2FibGU6IFRpY2thYmxlKSA9PiB2b2lkfSBbb25VcGRhdGVdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvbkxvb3BdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvblBhdXNlXVxuICogQHByb3BlcnR5IHsodGlja2FibGU6IFRpY2thYmxlKSA9PiB2b2lkfSBbb25Db21wbGV0ZV1cbiAqIEBwcm9wZXJ0eSB7KHJlbmRlcmFibGU6IFJlbmRlcmFibGUpID0+IHZvaWR9IFtvblJlbmRlcl1cbiAqL1xuXG4vKiogQHR5cGVkZWYge0pTQW5pbWF0aW9ufFRpbWVsaW5lfSBSZW5kZXJhYmxlICovXG4vKiogQHR5cGVkZWYge1RpbWVyfFJlbmRlcmFibGV9IFRpY2thYmxlICovXG4vKiogQHR5cGVkZWYge1RpbWVyJkpTQW5pbWF0aW9uJlRpbWVsaW5lfSBDYWxsYmFja0FyZ3VtZW50ICovXG4vKiogQHR5cGVkZWYge0FuaW1hdGFibGV8VGlja2FibGV8V0FBUElBbmltYXRpb258RHJhZ2dhYmxlfFNjcm9sbE9ic2VydmVyfFRleHRTcGxpdHRlcnxTY29wZX0gUmV2ZXJ0aWJsZSAqL1xuXG4vLyBTdGFnZ2VyIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAY2FsbGJhY2sgU3RhZ2dlckZ1bmN0aW9uXG4gKiBAcGFyYW0ge1RhcmdldH0gW3RhcmdldF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdXG4gKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aF1cbiAqIEBwYXJhbSB7VGltZWxpbmV9IFt0bF1cbiAqIEByZXR1cm4ge1R9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiAge09iamVjdH0gU3RhZ2dlclBhcmFtc1xuICogQHByb3BlcnR5IHtOdW1iZXJ8U3RyaW5nfSBbc3RhcnRdXG4gKiBAcHJvcGVydHkge051bWJlcnwnZmlyc3QnfCdjZW50ZXInfCdsYXN0J3wncmFuZG9tJ30gW2Zyb21dXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXZlcnNlZF1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj59IFtncmlkXVxuICogQHByb3BlcnR5IHsoJ3gnfCd5Jyl9IFtheGlzXVxuICogQHByb3BlcnR5IHtTdHJpbmd8KCh0YXJnZXQ6IFRhcmdldCwgaTogTnVtYmVyLCBsZW5ndGg6IE51bWJlcikgPT4gTnVtYmVyKX0gW3VzZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdG90YWxdXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gW21vZGlmaWVyXVxuICovXG5cbi8vIEVhc2VzIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQGNhbGxiYWNrIEVhc2luZ0Z1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeygnbGluZWFyJ3wnbGluZWFyKHgxLCB4MiAyNSUsIHgzKSd8J2luJ3wnb3V0J3wnaW5PdXQnfCdpblF1YWQnfCdvdXRRdWFkJ3wnaW5PdXRRdWFkJ3wnaW5DdWJpYyd8J291dEN1YmljJ3wnaW5PdXRDdWJpYyd8J2luUXVhcnQnfCdvdXRRdWFydCd8J2luT3V0UXVhcnQnfCdpblF1aW50J3wnb3V0UXVpbnQnfCdpbk91dFF1aW50J3wnaW5TaW5lJ3wnb3V0U2luZSd8J2luT3V0U2luZSd8J2luQ2lyYyd8J291dENpcmMnfCdpbk91dENpcmMnfCdpbkV4cG8nfCdvdXRFeHBvJ3wnaW5PdXRFeHBvJ3wnaW5Cb3VuY2UnfCdvdXRCb3VuY2UnfCdpbk91dEJvdW5jZSd8J2luQmFjayd8J291dEJhY2snfCdpbk91dEJhY2snfCdpbkVsYXN0aWMnfCdvdXRFbGFzdGljJ3wnaW5PdXRFbGFzdGljJ3wnaXJyZWd1bGFyJ3wnY3ViaWNCZXppZXInfCdzdGVwcyd8J2luKHAgPSAxLjY3NSknfCdvdXQocCA9IDEuNjc1KSd8J2luT3V0KHAgPSAxLjY3NSknfCdpbkJhY2sob3ZlcnNob290ID0gMS43MDE1OCknfCdvdXRCYWNrKG92ZXJzaG9vdCA9IDEuNzAxNTgpJ3wnaW5PdXRCYWNrKG92ZXJzaG9vdCA9IDEuNzAxNTgpJ3wnaW5FbGFzdGljKGFtcGxpdHVkZSA9IDEsIHBlcmlvZCA9IC4zKSd8J291dEVsYXN0aWMoYW1wbGl0dWRlID0gMSwgcGVyaW9kID0gLjMpJ3wnaW5PdXRFbGFzdGljKGFtcGxpdHVkZSA9IDEsIHBlcmlvZCA9IC4zKSd8J2lycmVndWxhcihsZW5ndGggPSAxMCwgcmFuZG9tbmVzcyA9IDEpJ3wnY3ViaWNCZXppZXIoeDEsIHkxLCB4MiwgeTIpJ3wnc3RlcHMoc3RlcHMgPSAxMCknKX0gRWFzZVN0cmluZ1BhcmFtTmFtZXNcbiAqL1xuXG4vLyBBIGhhY2sgdG8gZ2V0IGJvdGggZWFzZSBuYW1lcyBzdWdnZXN0aW9ucyBBTkQgYWxsb3cgYW55IHN0cmluZ3Ncbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjk3MjkjaXNzdWVjb21tZW50LTQ2MDM0NjQyMVxuLyoqIEB0eXBlZGVmIHsoU3RyaW5nICYge30pfEVhc2VTdHJpbmdQYXJhbU5hbWVzfEVhc2luZ0Z1bmN0aW9ufFNwcmluZ30gRWFzaW5nUGFyYW0gKi9cblxuLyoqIEB0eXBlZGVmIHtIVE1MRWxlbWVudHxTVkdFbGVtZW50fSBET01UYXJnZXQgKi9cbi8qKiBAdHlwZWRlZiB7UmVjb3JkPFN0cmluZywgYW55Pn0gSlNUYXJnZXQgKi9cbi8qKiBAdHlwZWRlZiB7RE9NVGFyZ2V0fEpTVGFyZ2V0fSBUYXJnZXQgKi9cbi8qKiBAdHlwZWRlZiB7VGFyZ2V0fE5vZGVMaXN0fFN0cmluZ30gVGFyZ2V0U2VsZWN0b3IgKi9cbi8qKiBAdHlwZWRlZiB7RE9NVGFyZ2V0fE5vZGVMaXN0fFN0cmluZ30gRE9NVGFyZ2V0U2VsZWN0b3IgKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPERPTVRhcmdldFNlbGVjdG9yPnxET01UYXJnZXRTZWxlY3Rvcn0gRE9NVGFyZ2V0c1BhcmFtICovXG4vKiogQHR5cGVkZWYge0FycmF5LjxET01UYXJnZXQ+fSBET01UYXJnZXRzQXJyYXkgKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPEpTVGFyZ2V0PnxKU1RhcmdldH0gSlNUYXJnZXRzUGFyYW0gKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPEpTVGFyZ2V0Pn0gSlNUYXJnZXRzQXJyYXkgKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPFRhcmdldFNlbGVjdG9yPnxUYXJnZXRTZWxlY3Rvcn0gVGFyZ2V0c1BhcmFtICovXG4vKiogQHR5cGVkZWYge0FycmF5LjxUYXJnZXQ+fSBUYXJnZXRzQXJyYXkgKi9cblxuLy8gU3ByaW5nIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcHJpbmdQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFzcz0xXSAtIE1hc3MsIGRlZmF1bHQgMVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdGlmZm5lc3M9MTAwXSAtIFN0aWZmbmVzcywgZGVmYXVsdCAxMDBcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGFtcGluZz0xMF0gLSBEYW1waW5nLCBkZWZhdWx0IDEwXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3ZlbG9jaXR5PTBdIC0gSW5pdGlhbCB2ZWxvY2l0eSwgZGVmYXVsdCAwXG4gKi9cblxuIC8vIENhbGxiYWNrIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBjYWxsYmFjayBDYWxsYmFja1xuICogQHBhcmFtIHtUfSBzZWxmIC0gUmV0dXJucyBpdHNlbGZcbiAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBbZV1cbiAqIEByZXR1cm4geyp9XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge29iamVjdH0gVFxuICogQHR5cGVkZWYge09iamVjdH0gVGlja2FibGVDYWxsYmFja3NcbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8VD59IFtvbkJlZ2luXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uQmVmb3JlVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uTG9vcF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8VD59IFtvblBhdXNlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uQ29tcGxldGVdXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge29iamVjdH0gVFxuICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyYWJsZUNhbGxiYWNrc1xuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uUmVuZGVyXVxuICovXG5cbi8vIFRpbWVyIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtpZF1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZHVyYXRpb25dXG4gKiBAcHJvcGVydHkge1R3ZWVuUGFyYW1WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsb29wRGVsYXldXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXZlcnNlZF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FsdGVybmF0ZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxOdW1iZXJ9IFtsb29wXVxuICogQHByb3BlcnR5IHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSBbYXV0b3BsYXldXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2ZyYW1lUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGxheWJhY2tSYXRlXVxuICovXG5cbi8qKlxuXG4vKipcbiAqIEB0eXBlZGVmIHtUaW1lck9wdGlvbnMgJiBUaWNrYWJsZUNhbGxiYWNrczxUaW1lcj59IFRpbWVyUGFyYW1zXG4gKi9cblxuLy8gVHdlZW4gdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRnVuY3Rpb25WYWx1ZVxuICogQHBhcmFtIHtUYXJnZXR9IHRhcmdldCAtIFRoZSBhbmltYXRlZCB0YXJnZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSB0YXJnZXQgaW5kZXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBUaGUgdG90YWwgbnVtYmVyIG9mIGFuaW1hdGVkIHRhcmdldHNcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd8VHdlZW5PYmplY3RWYWx1ZXxBcnJheS48TnVtYmVyfFN0cmluZ3xUd2Vlbk9iamVjdFZhbHVlPn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBUd2Vlbk1vZGlmaWVyXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBUaGUgYW5pbWF0ZWQgdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyXX0gQ29sb3JBcnJheSAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFR3ZWVuXG4gKiBAcHJvcGVydHkge051bWJlcn0gaWRcbiAqIEBwcm9wZXJ0eSB7SlNBbmltYXRpb259IHBhcmVudFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcHJvcGVydHkge1RhcmdldH0gdGFyZ2V0XG4gKiBAcHJvcGVydHkge1N0cmluZ3xOdW1iZXJ9IF92YWx1ZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxudWxsfSBfZnVuY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gX2Vhc2VcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPE51bWJlcj59IF9mcm9tTnVtYmVyc1xuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gX3RvTnVtYmVyc1xuICogQHByb3BlcnR5IHtBcnJheS48U3RyaW5nPn0gX3N0cmluZ3NcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfZnJvbU51bWJlclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF90b051bWJlclxuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gX251bWJlcnNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfbnVtYmVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gX3VuaXRcbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gX21vZGlmaWVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2N1cnJlbnRUaW1lXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2RlbGF5XG4gKiBAcHJvcGVydHkge051bWJlcn0gX3VwZGF0ZUR1cmF0aW9uXG4gKiBAcHJvcGVydHkge051bWJlcn0gX3N0YXJ0VGltZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9jaGFuZ2VEdXJhdGlvblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9hYnNvbHV0ZVN0YXJ0VGltZVxuICogQHByb3BlcnR5IHt0d2VlblR5cGVzfSBfdHdlZW5UeXBlXG4gKiBAcHJvcGVydHkge3ZhbHVlVHlwZXN9IF92YWx1ZVR5cGVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfY29tcG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfaXNPdmVybGFwcGVkXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2lzT3ZlcnJpZGRlblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9yZW5kZXJUcmFuc2Zvcm1zXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfcHJldlJlcFxuICogQHByb3BlcnR5IHtUd2Vlbn0gX25leHRSZXBcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9wcmV2QWRkXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfbmV4dEFkZFxuICogQHByb3BlcnR5IHtUd2Vlbn0gX3ByZXZcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9uZXh0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBUd2VlbkRlY29tcG9zZWRWYWx1ZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHQgLSBUeXBlXG4gKiBAcHJvcGVydHkge051bWJlcn0gbiAtIFNpbmdsZSBudW1iZXIgdmFsdWVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB1IC0gVmFsdWUgdW5pdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IG8gLSBWYWx1ZSBvcGVyYXRvclxuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gZCAtIEFycmF5IG9mIE51bWJlcnMgKGluIGNhc2Ugb2YgY29tcGxleCB2YWx1ZSB0eXBlKVxuICogQHByb3BlcnR5IHtBcnJheS48U3RyaW5nPn0gcyAtIFN0cmluZ3MgKGluIGNhc2Ugb2YgY29tcGxleCB2YWx1ZSB0eXBlKVxuICovXG5cbi8qKiBAdHlwZWRlZiB7e19oZWFkOiBudWxsfFR3ZWVuLCBfdGFpbDogbnVsbHxUd2Vlbn19IFR3ZWVuUHJvcGVydHlTaWJsaW5ncyAqL1xuLyoqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBUd2VlblByb3BlcnR5U2libGluZ3M+fSBUd2Vlbkxvb2t1cHMgKi9cbi8qKiBAdHlwZWRlZiB7V2Vha01hcC48VGFyZ2V0LCBUd2Vlbkxvb2t1cHM+fSBUd2VlblJlcGxhY2VMb29rdXBzICovXG4vKiogQHR5cGVkZWYge01hcC48VGFyZ2V0LCBUd2Vlbkxvb2t1cHM+fSBUd2VlbkFkZGl0aXZlTG9va3VwcyAqL1xuXG4vLyBKU0FuaW1hdGlvbiB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtOdW1iZXJ8U3RyaW5nfEZ1bmN0aW9uVmFsdWV9IFR3ZWVuUGFyYW1WYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1R3ZWVuUGFyYW1WYWx1ZXxbVHdlZW5QYXJhbVZhbHVlLCBUd2VlblBhcmFtVmFsdWVdfSBUd2VlblByb3BWYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhTdHJpbmcgJiB7fSl8J25vbmUnfCdyZXBsYWNlJ3wnYmxlbmQnfGNvbXBvc2l0aW9uVHlwZXN9IFR3ZWVuQ29tcG9zaXRpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFR3ZWVuUGFyYW1zT3B0aW9uc1xuICogQHByb3BlcnR5IHtUd2VlblBhcmFtVmFsdWV9IFtkdXJhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZGVsYXldXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gW21vZGlmaWVyXVxuICogQHByb3BlcnR5IHtUd2VlbkNvbXBvc2l0aW9ufSBbY29tcG9zaXRpb25dXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUd2VlblZhbHVlc1xuICogQHByb3BlcnR5IHtUd2VlblBhcmFtVmFsdWV9IFtmcm9tXVxuICogQHByb3BlcnR5IHtUd2VlblByb3BWYWx1ZX0gW3RvXVxuICogQHByb3BlcnR5IHtUd2VlblByb3BWYWx1ZX0gW2Zyb21Ub11cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtUd2VlblBhcmFtc09wdGlvbnMgJiBUd2VlblZhbHVlc30gVHdlZW5LZXlWYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0FycmF5LjxUd2VlbktleVZhbHVlfFR3ZWVuUHJvcFZhbHVlPn0gQXJyYXlTeW50YXhWYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1R3ZWVuUGFyYW1WYWx1ZXxBcnJheVN5bnRheFZhbHVlfFR3ZWVuS2V5VmFsdWV9IFR3ZWVuT3B0aW9uc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1BhcnRpYWw8e3RvOiBUd2VlblBhcmFtVmFsdWV8QXJyYXkuPFR3ZWVuUGFyYW1WYWx1ZT47IGZyb206IFR3ZWVuUGFyYW1WYWx1ZXxBcnJheS48VHdlZW5QYXJhbVZhbHVlPjsgZnJvbVRvOiBUd2VlblBhcmFtVmFsdWV8QXJyYXkuPFR3ZWVuUGFyYW1WYWx1ZT47fT59IFR3ZWVuT2JqZWN0VmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBlcmNlbnRhZ2VLZXlmcmFtZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFR3ZWVuUGFyYW1WYWx1ZT59IFBlcmNlbnRhZ2VLZXlmcmFtZVBhcmFtc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFBlcmNlbnRhZ2VLZXlmcmFtZVBhcmFtcyAmIFBlcmNlbnRhZ2VLZXlmcmFtZU9wdGlvbnM+fSBQZXJjZW50YWdlS2V5ZnJhbWVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXk8UmVjb3JkPFN0cmluZywgVHdlZW5PcHRpb25zIHwgVHdlZW5Nb2RpZmllciB8IGJvb2xlYW4+ICYgVHdlZW5QYXJhbXNPcHRpb25zPn0gRHVyYXRpb25LZXlmcmFtZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7UGVyY2VudGFnZUtleWZyYW1lc3xEdXJhdGlvbktleWZyYW1lc30gW2tleWZyYW1lc11cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtwbGF5YmFja0Vhc2VdXG4gKi9cblxuLy8gVE9ETzogQ3VycmVudGx5IHNldHRpbmcgVHdlZW5Nb2RpZmllciB0byB0aGUgaW50ZXJzZWN0ZWQgUmVjb3JkPD4gbWFrZXMgdGhlIEZ1bmN0aW9uVmFsdWUgdHlwZSB0YXJnZXQgcGFyYW0gYW55IGlmIG9ubHkgb25lIHBhcmFtZXRlciBpcyBzZXRcbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFR3ZWVuT3B0aW9ucyB8IENhbGxiYWNrPEpTQW5pbWF0aW9uPiB8IFR3ZWVuTW9kaWZpZXIgfCBib29sZWFuIHwgUGVyY2VudGFnZUtleWZyYW1lcyB8IER1cmF0aW9uS2V5ZnJhbWVzIHwgU2Nyb2xsT2JzZXJ2ZXI+ICYgVGltZXJPcHRpb25zICYgQW5pbWF0aW9uT3B0aW9ucyAmIFR3ZWVuUGFyYW1zT3B0aW9ucyAmIFRpY2thYmxlQ2FsbGJhY2tzPEpTQW5pbWF0aW9uPiAmIFJlbmRlcmFibGVDYWxsYmFja3M8SlNBbmltYXRpb24+fSBBbmltYXRpb25QYXJhbXNcbiAqL1xuXG4vLyBUaW1lbGluZSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEFjY2VwdHM6PGJyPlxuICogLSBgTnVtYmVyYCAtIEFic29sdXRlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAoZS5nLiwgYDUwMGAgcGxhY2VzIGVsZW1lbnQgYXQgZXhhY3RseSA1MDBtcyk8YnI+XG4gKiAtIGAnKz1OdW1iZXInYCAtIEFkZGl0aW9uOiBQb3NpdGlvbiBlbGVtZW50IFggbXMgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudCAoZS5nLiwgYCcrPTEwMCdgKTxicj5cbiAqIC0gYCctPU51bWJlcidgIC0gU3VidHJhY3Rpb246IFBvc2l0aW9uIGVsZW1lbnQgWCBtcyBiZWZvcmUgdGhlIGxhc3QgZWxlbWVudCdzIGVuZCAoZS5nLiwgYCctPTEwMCdgKTxicj5cbiAqIC0gYCcqPU51bWJlcidgIC0gTXVsdGlwbGllcjogUG9zaXRpb24gZWxlbWVudCBhdCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCBkdXJhdGlvbiAoZS5nLiwgYCcqPS41J2AgZm9yIGhhbGZ3YXkpPGJyPlxuICogLSBgJzwnYCAtIFByZXZpb3VzIGVuZDogUG9zaXRpb24gZWxlbWVudCBhdCB0aGUgZW5kIHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyBlbGVtZW50PGJyPlxuICogLSBgJzw8J2AgLSBQcmV2aW91cyBzdGFydDogUG9zaXRpb24gZWxlbWVudCBhdCB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIGVsZW1lbnQ8YnI+XG4gKiAtIGAnPDwrPU51bWJlcidgIC0gQ29tYmluZWQ6IFBvc2l0aW9uIGVsZW1lbnQgcmVsYXRpdmUgdG8gcHJldmlvdXMgZWxlbWVudCdzIHN0YXJ0IChlLmcuLCBgJzw8Kz0yNTAnYCk8YnI+XG4gKiAtIGAnbGFiZWwnYCAtIExhYmVsOiBQb3NpdGlvbiBlbGVtZW50IGF0IGEgbmFtZWQgbGFiZWwgcG9zaXRpb24gKGUuZy4sIGAnTXkgTGFiZWwnYClcbiAqXG4gKiBAdHlwZWRlZiB7TnVtYmVyfGArPSR7TnVtYmVyfWB8YC09JHtOdW1iZXJ9YHxgKj0ke051bWJlcn1gfCc8J3wnPDwnfGA8PCs9JHtOdW1iZXJ9YHxgPDwtPSR7TnVtYmVyfWB8U3RyaW5nfSBUaW1lbGluZVBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBBY2NlcHRzOjxicj5cbiAqIC0gYE51bWJlcmAgLSBBYnNvbHV0ZSBwb3NpdGlvbiBpbiBtaWxsaXNlY29uZHMgKGUuZy4sIGA1MDBgIHBsYWNlcyBhbmltYXRpb24gYXQgZXhhY3RseSA1MDBtcyk8YnI+XG4gKiAtIGAnKz1OdW1iZXInYCAtIEFkZGl0aW9uOiBQb3NpdGlvbiBhbmltYXRpb24gWCBtcyBhZnRlciB0aGUgbGFzdCBhbmltYXRpb24gKGUuZy4sIGAnKz0xMDAnYCk8YnI+XG4gKiAtIGAnLT1OdW1iZXInYCAtIFN1YnRyYWN0aW9uOiBQb3NpdGlvbiBhbmltYXRpb24gWCBtcyBiZWZvcmUgdGhlIGxhc3QgYW5pbWF0aW9uJ3MgZW5kIChlLmcuLCBgJy09MTAwJ2ApPGJyPlxuICogLSBgJyo9TnVtYmVyJ2AgLSBNdWx0aXBsaWVyOiBQb3NpdGlvbiBhbmltYXRpb24gYXQgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgZHVyYXRpb24gKGUuZy4sIGAnKj0uNSdgIGZvciBoYWxmd2F5KTxicj5cbiAqIC0gYCc8J2AgLSBQcmV2aW91cyBlbmQ6IFBvc2l0aW9uIGFuaW1hdGlvbiBhdCB0aGUgZW5kIHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyBhbmltYXRpb248YnI+XG4gKiAtIGAnPDwnYCAtIFByZXZpb3VzIHN0YXJ0OiBQb3NpdGlvbiBhbmltYXRpb24gYXQgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyBhbmltYXRpb248YnI+XG4gKiAtIGAnPDwrPU51bWJlcidgIC0gQ29tYmluZWQ6IFBvc2l0aW9uIGFuaW1hdGlvbiByZWxhdGl2ZSB0byBwcmV2aW91cyBhbmltYXRpb24ncyBzdGFydCAoZS5nLiwgYCc8PCs9MjUwJ2ApPGJyPlxuICogLSBgJ2xhYmVsJ2AgLSBMYWJlbDogUG9zaXRpb24gYW5pbWF0aW9uIGF0IGEgbmFtZWQgbGFiZWwgcG9zaXRpb24gKGUuZy4sIGAnTXkgTGFiZWwnYCk8YnI+XG4gKiAtIGBzdGFnZ2VyKFN0cmluZ3xOdW1tYmVyKWAgLSBTdGFnZ2VyIG11bHRpLWVsZW1lbnRzIGFuaW1hdGlvbiBwb3NpdGlvbnMgKGUuZy4sIDEwLCAyMCwgMzAuLi4pXG4gKlxuICogQHR5cGVkZWYge1RpbWVsaW5lUG9zaXRpb24gfCBTdGFnZ2VyRnVuY3Rpb248TnVtYmVyfFN0cmluZz59IFRpbWVsaW5lQW5pbWF0aW9uUG9zaXRpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbWVsaW5lT3B0aW9uc1xuICogQHByb3BlcnR5IHtEZWZhdWx0c1BhcmFtc30gW2RlZmF1bHRzXVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW3BsYXliYWNrRWFzZV1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtUaW1lck9wdGlvbnMgJiBUaW1lbGluZU9wdGlvbnMgJiBUaWNrYWJsZUNhbGxiYWNrczxUaW1lbGluZT4gJiBSZW5kZXJhYmxlQ2FsbGJhY2tzPFRpbWVsaW5lPn0gVGltZWxpbmVQYXJhbXNcbiAqL1xuXG4vLyBXQUFQSUFuaW1hdGlvbiB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtTdHJpbmd8TnVtYmVyfEFycmF5PFN0cmluZz58QXJyYXk8TnVtYmVyPn0gV0FBUElUd2VlblZhbHVlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV0FBUElGdW5jdGlvblZhbHVlXG4gKiBAcGFyYW0ge0RPTVRhcmdldH0gdGFyZ2V0IC0gVGhlIGFuaW1hdGVkIHRhcmdldFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIHRhcmdldCBpbmRleFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSB0b3RhbCBudW1iZXIgb2YgYW5pbWF0ZWQgdGFyZ2V0c1xuICogQHJldHVybiB7V0FBUElUd2VlblZhbHVlfVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1dBQVBJVHdlZW5WYWx1ZXxXQUFQSUZ1bmN0aW9uVmFsdWV8QXJyYXk8U3RyaW5nfE51bWJlcnxXQUFQSUZ1bmN0aW9uVmFsdWU+fSBXQUFQSUtleWZyYW1lVmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYW5pbWF0aW9uOiBXQUFQSUFuaW1hdGlvbikgPT4gdm9pZH0gV0FBUElDYWxsYmFja1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV0FBUElUd2Vlbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7V0FBUElLZXlmcmFtZVZhbHVlfSBbdG9dXG4gKiBAcHJvcGVydHkge1dBQVBJS2V5ZnJhbWVWYWx1ZX0gW2Zyb21dXG4gKiBAcHJvcGVydHkge051bWJlcnxXQUFQSUZ1bmN0aW9uVmFsdWV9IFtkdXJhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfFdBQVBJRnVuY3Rpb25WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gKiBAcHJvcGVydHkge0NvbXBvc2l0ZU9wZXJhdGlvbn0gW2NvbXBvc2l0aW9uXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV0FBUElBbmltYXRpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge051bWJlcnxCb29sZWFufSBbbG9vcF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW1JldmVyc2VkXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbQWx0ZXJuYXRlXVxuICogQHByb3BlcnR5IHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSBbYXV0b3BsYXldXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3BsYXliYWNrUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfFdBQVBJRnVuY3Rpb25WYWx1ZX0gW2R1cmF0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8V0FBUElGdW5jdGlvblZhbHVlfSBbZGVsYXldXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7Q29tcG9zaXRlT3BlcmF0aW9ufSBbY29tcG9zaXRpb25dXG4gKiBAcHJvcGVydHkge1dBQVBJQ2FsbGJhY2t9IFtvbkNvbXBsZXRlXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFdBQVBJS2V5ZnJhbWVWYWx1ZSB8IFdBQVBJQW5pbWF0aW9uT3B0aW9ucyB8IEJvb2xlYW4gfCBTY3JvbGxPYnNlcnZlciB8IFdBQVBJQ2FsbGJhY2sgfCBFYXNpbmdQYXJhbSB8IFdBQVBJVHdlZW5PcHRpb25zPiAmIFdBQVBJQW5pbWF0aW9uT3B0aW9uc30gV0FBUElBbmltYXRpb25QYXJhbXNcbiAqL1xuXG4vLyBBbmltYXRhYmxlIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBbmltYXRhYmxlUHJvcGVydHlTZXR0ZXJcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheS48TnVtYmVyPn0gdG9cbiAqIEBwYXJhbSAge051bWJlcn0gW2R1cmF0aW9uXVxuICogQHBhcmFtICB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICogQHJldHVybiB7QW5pbWF0YWJsZU9iamVjdH1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBBbmltYXRhYmxlUHJvcGVydHlHZXR0ZXJcbiAqIEByZXR1cm4ge051bWJlcnxBcnJheS48TnVtYmVyPn1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtBbmltYXRhYmxlUHJvcGVydHlTZXR0ZXIgJiBBbmltYXRhYmxlUHJvcGVydHlHZXR0ZXJ9IEFuaW1hdGFibGVQcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0FuaW1hdGFibGUgJiBSZWNvcmQ8U3RyaW5nLCBBbmltYXRhYmxlUHJvcGVydHk+fSBBbmltYXRhYmxlT2JqZWN0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmltYXRhYmxlUHJvcGVydHlQYXJhbXNPcHRpb25zXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW3VuaXRdXG4gKiBAcHJvcGVydHkge1R3ZWVuUGFyYW1WYWx1ZX0gW2R1cmF0aW9uXVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gKiBAcHJvcGVydHkge1R3ZWVuTW9kaWZpZXJ9IFttb2RpZmllcl1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Db21wb3NpdGlvbn0gW2NvbXBvc2l0aW9uXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFR3ZWVuUGFyYW1WYWx1ZSB8IEVhc2luZ1BhcmFtIHwgVHdlZW5Nb2RpZmllciB8IFR3ZWVuQ29tcG9zaXRpb24gfCBBbmltYXRhYmxlUHJvcGVydHlQYXJhbXNPcHRpb25zPiAmIEFuaW1hdGFibGVQcm9wZXJ0eVBhcmFtc09wdGlvbnN9IEFuaW1hdGFibGVQYXJhbXNcbiAqL1xuXG4vLyBTY29wZSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWN0UmVmXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR8bnVsbH0gW2N1cnJlbnRdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmd1bGFyUmVmXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IFtuYXRpdmVFbGVtZW50XVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2NvcGVQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7RE9NVGFyZ2V0U2VsZWN0b3J8UmVhY3RSZWZ8QW5ndWxhclJlZn0gW3Jvb3RdXG4gKiBAcHJvcGVydHkge0RlZmF1bHRzUGFyYW1zfSBbZGVmYXVsdHNdXG4gKiBAcHJvcGVydHkge1JlY29yZDxTdHJpbmcsIFN0cmluZz59IFttZWRpYVF1ZXJpZXNdXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQGNhbGxiYWNrIFNjb3BlZENhbGxiYWNrXG4gKiBAcGFyYW0ge1Njb3BlfSBzY29wZVxuICogQHJldHVybiB7VH1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZUNsZWFudXBDYWxsYmFja1xuICogQHBhcmFtIHtTY29wZX0gW3Njb3BlXVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNjb3BlQ29uc3RydWN0b3JDYWxsYmFja1xuICogQHBhcmFtIHtTY29wZX0gW3Njb3BlXVxuICogQHJldHVybiB7U2NvcGVDbGVhbnVwQ2FsbGJhY2t8dm9pZH1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZU1ldGhvZFxuICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gKiBAcmV0dXJuIHtTY29wZUNsZWFudXBDYWxsYmFja3x2b2lkfVxuICovXG5cbi8vIFNjcm9sbCB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ3xOdW1iZXJ9IFNjcm9sbFRocmVzaG9sZFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTY3JvbGxUaHJlc2hvbGRQYXJhbVxuICogQHByb3BlcnR5IHtTY3JvbGxUaHJlc2hvbGRWYWx1ZX0gW3RhcmdldF1cbiAqIEBwcm9wZXJ0eSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9IFtjb250YWluZXJdXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2Nyb2xsT2JzZXJ2ZXJBeGlzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7U2Nyb2xsT2JzZXJ2ZXJ9IHNlbGZcbiAqIEByZXR1cm4geyd4J3wneSd9XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2tcbiAqIEBwYXJhbSB7U2Nyb2xsT2JzZXJ2ZXJ9IHNlbGZcbiAqIEByZXR1cm4ge1Njcm9sbFRocmVzaG9sZFZhbHVlfFNjcm9sbFRocmVzaG9sZFBhcmFtfVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2Nyb2xsT2JzZXJ2ZXJQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfFN0cmluZ30gW2lkXVxuICogQHByb3BlcnR5IHtCb29sZWFufE51bWJlcnxTdHJpbmd8RWFzaW5nUGFyYW19IFtzeW5jXVxuICogQHByb3BlcnR5IHtUYXJnZXRzUGFyYW19IFtjb250YWluZXJdXG4gKiBAcHJvcGVydHkge1RhcmdldHNQYXJhbX0gW3RhcmdldF1cbiAqIEBwcm9wZXJ0eSB7J3gnfCd5J3xTY3JvbGxPYnNlcnZlckF4aXNDYWxsYmFja3woKG9ic2VydmVyOiBTY3JvbGxPYnNlcnZlcikgPT4gJ3gnfCd5J3xTY3JvbGxPYnNlcnZlckF4aXNDYWxsYmFjayl9IFtheGlzXVxuICogQHByb3BlcnR5IHtTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRQYXJhbXxTY3JvbGxUaHJlc2hvbGRDYWxsYmFja3woKG9ic2VydmVyOiBTY3JvbGxPYnNlcnZlcikgPT4gU2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2spfSBbZW50ZXJdXG4gKiBAcHJvcGVydHkge1Njcm9sbFRocmVzaG9sZFZhbHVlfFNjcm9sbFRocmVzaG9sZFBhcmFtfFNjcm9sbFRocmVzaG9sZENhbGxiYWNrfCgob2JzZXJ2ZXI6IFNjcm9sbE9ic2VydmVyKSA9PiBTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRQYXJhbXxTY3JvbGxUaHJlc2hvbGRDYWxsYmFjayl9IFtsZWF2ZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnwoKG9ic2VydmVyOiBTY3JvbGxPYnNlcnZlcikgPT4gQm9vbGVhbil9IFtyZXBlYXRdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkZWJ1Z11cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25FbnRlcl1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25MZWF2ZV1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25FbnRlckZvcndhcmRdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uTGVhdmVGb3J3YXJkXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59IFtvbkVudGVyQmFja3dhcmRdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uTGVhdmVCYWNrd2FyZF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25VcGRhdGVdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uU3luY0NvbXBsZXRlXVxuICovXG5cbi8vIERyYWdnYWJsZSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRHJhZ2dhYmxlQXhpc1BhcmFtXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW21hcFRvXVxuICogQHByb3BlcnR5IHtUd2Vlbk1vZGlmaWVyfSBbbW9kaWZpZXJdXG4gKiBAcHJvcGVydHkge1R3ZWVuQ29tcG9zaXRpb259IFtjb21wb3NpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEFycmF5PE51bWJlcj58KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyfEFycmF5PE51bWJlcj4pfSBbc25hcF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERyYWdnYWJsZUN1cnNvclBhcmFtc1xuICogQHByb3BlcnR5IHtTdHJpbmd9IFtvbkhvdmVyXVxuICogQHByb3BlcnR5IHtTdHJpbmd9IFtvbkdyYWJdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEcmFnZ2FibGVQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7RE9NVGFyZ2V0U2VsZWN0b3J9IFt0cmlnZ2VyXVxuICogQHByb3BlcnR5IHtET01UYXJnZXRTZWxlY3RvcnxBcnJheTxOdW1iZXI+fCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IERPTVRhcmdldFNlbGVjdG9yfEFycmF5PE51bWJlcj4pfSBbY29udGFpbmVyXVxuICogQHByb3BlcnR5IHtCb29sZWFufERyYWdnYWJsZUF4aXNQYXJhbX0gW3hdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58RHJhZ2dhYmxlQXhpc1BhcmFtfSBbeV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gW21vZGlmaWVyXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8QXJyYXk8TnVtYmVyPnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXJ8QXJyYXk8TnVtYmVyPil9IFtzbmFwXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8QXJyYXk8TnVtYmVyPnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXJ8QXJyYXk8TnVtYmVyPil9IFtjb250YWluZXJQYWRkaW5nXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW2NvbnRhaW5lckZyaWN0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW3JlbGVhc2VDb250YWluZXJGcmljdGlvbl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcil9IFtkcmFnU3BlZWRdXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbc2Nyb2xsU3BlZWRdXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbc2Nyb2xsVGhyZXNob2xkXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW21pblZlbG9jaXR5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW21heFZlbG9jaXR5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW3ZlbG9jaXR5TXVsdGlwbGllcl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmVsZWFzZU1hc3NdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3JlbGVhc2VTdGlmZm5lc3NdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3JlbGVhc2VEYW1waW5nXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVsZWFzZURhbXBpbmddXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbcmVsZWFzZUVhc2VdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58RHJhZ2dhYmxlQ3Vyc29yUGFyYW1zfCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IEJvb2xlYW58RHJhZ2dhYmxlQ3Vyc29yUGFyYW1zKX0gW2N1cnNvcl1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uR3JhYl1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uRHJhZ11cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uUmVsZWFzZV1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25TZXR0bGVdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPERyYWdnYWJsZT59IFtvblNuYXBdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPERyYWdnYWJsZT59IFtvblJlc2l6ZV1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uQWZ0ZXJSZXNpemVdXG4gKi9cblxuLy8gVGV4dCB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBzcGxpdFRlbXBsYXRlUGFyYW1zXG4gKiBAcHJvcGVydHkge2ZhbHNlfFN0cmluZ30gW2NsYXNzXVxuICogQHByb3BlcnR5IHtCb29sZWFufCdoaWRkZW4nfCdjbGlwJ3wndmlzaWJsZSd8J3Njcm9sbCd8J2F1dG8nfSBbd3JhcF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnwndG9wJ3wncmlnaHQnfCdib3R0b20nfCdsZWZ0J3wnY2VudGVyJ30gW2Nsb25lXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0Jvb2xlYW58U3RyaW5nfSBTcGxpdFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU3BsaXRGdW5jdGlvblZhbHVlXG4gKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IFt2YWx1ZV1cbiAqIEByZXR1cm4gU3RyaW5nXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0U3BsaXR0ZXJQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7U3BsaXRWYWx1ZXxzcGxpdFRlbXBsYXRlUGFyYW1zfFNwbGl0RnVuY3Rpb25WYWx1ZX0gW2xpbmVzXVxuICogQHByb3BlcnR5IHtTcGxpdFZhbHVlfHNwbGl0VGVtcGxhdGVQYXJhbXN8U3BsaXRGdW5jdGlvblZhbHVlfSBbd29yZHNdXG4gKiBAcHJvcGVydHkge1NwbGl0VmFsdWV8c3BsaXRUZW1wbGF0ZVBhcmFtc3xTcGxpdEZ1bmN0aW9uVmFsdWV9IFtjaGFyc11cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FjY2Vzc2libGVdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbmNsdWRlU3BhY2VzXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbZGVidWddXG4gKi9cblxuLy8gU1ZHIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAdHlwZWRlZiB7U1ZHR2VvbWV0cnlFbGVtZW50ICYge1xuICogICBzZXRBdHRyaWJ1dGUobmFtZTogJ2RyYXcnLCB2YWx1ZTogYCR7bnVtYmVyfSAke251bWJlcn1gKTogdm9pZDtcbiAqICAgZHJhdzogYCR7bnVtYmVyfSAke251bWJlcn1gO1xuICogfX0gRHJhd2FibGVTVkdHZW9tZXRyeVxuICovXG5cblxuLy8gRW52aXJvbm1lbnRzXG5cbi8vIFRPRE86IERvIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UncmUgcnVubmluZyBpbnNpZGUgYSB3b3JrZXIgP1xuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKiBAdHlwZSB7V2luZG93ICYge0FuaW1lSlM6IEFycmF5fXxudWxsfSAqL1xuY29uc3Qgd2luID0gaXNCcm93c2VyID8gLyoqIEB0eXBlIHtXaW5kb3cgJiB7QW5pbWVKUzogQXJyYXl9fSAqLygvKiogQHR5cGUge3Vua25vd259ICovKHdpbmRvdykpIDogbnVsbDtcblxuLyoqIEB0eXBlIHtEb2N1bWVudHxudWxsfSAqL1xuY29uc3QgZG9jID0gaXNCcm93c2VyID8gZG9jdW1lbnQgOiBudWxsO1xuXG4vLyBFbnVtc1xuXG4vKiogQGVudW0ge051bWJlcn0gKi9cbmNvbnN0IHR3ZWVuVHlwZXMgPSB7XG4gIE9CSkVDVDogMCxcbiAgQVRUUklCVVRFOiAxLFxuICBDU1M6IDIsXG4gIFRSQU5TRk9STTogMyxcbiAgQ1NTX1ZBUjogNCxcbn07XG5cbi8qKiBAZW51bSB7TnVtYmVyfSAqL1xuY29uc3QgdmFsdWVUeXBlcyA9IHtcbiAgTlVNQkVSOiAwLFxuICBVTklUOiAxLFxuICBDT0xPUjogMixcbiAgQ09NUExFWDogMyxcbn07XG5cbi8qKiBAZW51bSB7TnVtYmVyfSAqL1xuY29uc3QgdGlja01vZGVzID0ge1xuICBOT05FOiAwLFxuICBBVVRPOiAxLFxuICBGT1JDRTogMixcbn07XG5cbi8qKiBAZW51bSB7TnVtYmVyfSAqL1xuY29uc3QgY29tcG9zaXRpb25UeXBlcyA9IHtcbiAgcmVwbGFjZTogMCxcbiAgbm9uZTogMSxcbiAgYmxlbmQ6IDIsXG59O1xuXG4vLyBDYWNoZSBzeW1ib2xzXG5cbmNvbnN0IGlzUmVnaXN0ZXJlZFRhcmdldFN5bWJvbCA9IFN5bWJvbCgpO1xuY29uc3QgaXNEb21TeW1ib2wgPSBTeW1ib2woKTtcbmNvbnN0IGlzU3ZnU3ltYm9sID0gU3ltYm9sKCk7XG5jb25zdCB0cmFuc2Zvcm1zU3ltYm9sID0gU3ltYm9sKCk7XG5jb25zdCBtb3JwaFBvaW50c1N5bWJvbCA9IFN5bWJvbCgpO1xuY29uc3QgcHJveHlUYXJnZXRTeW1ib2wgPSBTeW1ib2woKTtcblxuLy8gTnVtYmVyc1xuXG5jb25zdCBtaW5WYWx1ZSA9IDFlLTExO1xuY29uc3QgbWF4VmFsdWUgPSAxZTEyO1xuY29uc3QgSyA9IDFlMztcbmNvbnN0IG1heEZwcyA9IDEyMDtcblxuLy8gU3RyaW5nc1xuXG5jb25zdCBlbXB0eVN0cmluZyA9ICcnO1xuY29uc3Qgc2hvcnRUcmFuc2Zvcm1zID0gLyojX19QVVJFX18qLyAoKCkgPT4ge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIG1hcC5zZXQoJ3gnLCAndHJhbnNsYXRlWCcpO1xuICBtYXAuc2V0KCd5JywgJ3RyYW5zbGF0ZVknKTtcbiAgbWFwLnNldCgneicsICd0cmFuc2xhdGVaJyk7XG4gIHJldHVybiBtYXA7XG59KSgpO1xuXG5jb25zdCB2YWxpZFRyYW5zZm9ybXMgPSBbXG4gICd0cmFuc2xhdGVYJyxcbiAgJ3RyYW5zbGF0ZVknLFxuICAndHJhbnNsYXRlWicsXG4gICdyb3RhdGUnLFxuICAncm90YXRlWCcsXG4gICdyb3RhdGVZJyxcbiAgJ3JvdGF0ZVonLFxuICAnc2NhbGUnLFxuICAnc2NhbGVYJyxcbiAgJ3NjYWxlWScsXG4gICdzY2FsZVonLFxuICAnc2tldycsXG4gICdza2V3WCcsXG4gICdza2V3WScsXG4gICdwZXJzcGVjdGl2ZScsXG4gICdtYXRyaXgnLFxuICAnbWF0cml4M2QnLFxuXTtcblxuY29uc3QgdHJhbnNmb3Jtc0ZyYWdtZW50U3RyaW5ncyA9IC8qI19fUFVSRV9fKi8gdmFsaWRUcmFuc2Zvcm1zLnJlZHVjZSgoYSwgdikgPT4gKHsuLi5hLCBbdl06IHYgKyAnKCd9KSwge30pO1xuXG4vLyBGdW5jdGlvbnNcblxuLyoqIEByZXR1cm4ge3ZvaWR9ICovXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbi8vIFJlZ2V4XG5cbmNvbnN0IGhleFRlc3RSZ3ggPSAvKF4jKFtcXGRhLWZdezN9KXsxLDJ9JCl8KF4jKFtcXGRhLWZdezR9KXsxLDJ9JCkvaTtcbmNvbnN0IHJnYkV4ZWNSZ3ggPSAvcmdiXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccypcXCkvaTtcbmNvbnN0IHJnYmFFeGVjUmd4ID0gL3JnYmFcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKC0/XFxkK3wtP1xcZCouXFxkKylcXHMqXFwpL2k7XG5jb25zdCBoc2xFeGVjUmd4ID0gL2hzbFxcKFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspJVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspJVxccypcXCkvaTtcbmNvbnN0IGhzbGFFeGVjUmd4ID0gL2hzbGFcXChcXHMqKC0/XFxkK3wtP1xcZCouXFxkKylcXHMqLFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKSVcXHMqLFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKSVcXHMqLFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKVxccypcXCkvaTtcbi8vIGV4cG9ydCBjb25zdCBkaWdpdFdpdGhFeHBvbmVudFJneCA9IC9bLStdP1xcZCpcXC4/XFxkKyg/OltlRV1bLStdP1xcZCspPy9nO1xuY29uc3QgZGlnaXRXaXRoRXhwb25lbnRSZ3ggPSAvWy0rXT9cXGQqXFwuP1xcZCsoPzplWy0rXT9cXGQpPy9naTtcbi8vIGV4cG9ydCBjb25zdCB1bml0c0V4ZWNSZ3ggPSAvXihbLStdP1xcZCpcXC4/XFxkKyg/OltlRV1bLStdP1xcZCspPykrKFthLXpdK3wlKSQvaTtcbmNvbnN0IHVuaXRzRXhlY1JneCA9IC9eKFstK10/XFxkKlxcLj9cXGQrKD86ZVstK10/XFxkKyk/KShbYS16XSt8JSkkL2k7XG5jb25zdCBsb3dlckNhc2VSZ3ggPSAvKFthLXpdKShbQS1aXSkvZztcbmNvbnN0IHRyYW5zZm9ybXNFeGVjUmd4ID0gLyhcXHcrKShcXChbXildK1xcKSspL2c7IC8vIE1hdGNoIGlubGluZSB0cmFuc2Zvcm1zIHdpdGggY2FjbCgpIHZhbHVlcywgcmV0dXJucyB0aGUgdmFsdWUgd3JhcHBlZCBpbiAoKVxuY29uc3QgcmVsYXRpdmVWYWx1ZXNFeGVjUmd4ID0gLyhcXCo9fFxcKz18LT0pLztcblxuXG5cblxuLyoqIEB0eXBlIHtEZWZhdWx0c1BhcmFtc30gKi9cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBpZDogbnVsbCxcbiAga2V5ZnJhbWVzOiBudWxsLFxuICBwbGF5YmFja0Vhc2U6IG51bGwsXG4gIHBsYXliYWNrUmF0ZTogMSxcbiAgZnJhbWVSYXRlOiBtYXhGcHMsXG4gIGxvb3A6IDAsXG4gIHJldmVyc2VkOiBmYWxzZSxcbiAgYWx0ZXJuYXRlOiBmYWxzZSxcbiAgYXV0b3BsYXk6IHRydWUsXG4gIGR1cmF0aW9uOiBLLFxuICBkZWxheTogMCxcbiAgbG9vcERlbGF5OiAwLFxuICBlYXNlOiAnb3V0KDIpJyxcbiAgY29tcG9zaXRpb246IGNvbXBvc2l0aW9uVHlwZXMucmVwbGFjZSxcbiAgbW9kaWZpZXI6IHYgPT4gdixcbiAgb25CZWdpbjogbm9vcCxcbiAgb25CZWZvcmVVcGRhdGU6IG5vb3AsXG4gIG9uVXBkYXRlOiBub29wLFxuICBvbkxvb3A6IG5vb3AsXG4gIG9uUGF1c2U6IG5vb3AsXG4gIG9uQ29tcGxldGU6IG5vb3AsXG4gIG9uUmVuZGVyOiBub29wLFxufTtcblxuY29uc3Qgc2NvcGUgPSB7XG4gIC8qKiBAdHlwZSB7U2NvcGV9ICovXG4gIGN1cnJlbnQ6IG51bGwsXG4gIC8qKiBAdHlwZSB7RG9jdW1lbnR8RE9NVGFyZ2V0fSAqL1xuICByb290OiBkb2MsXG59O1xuXG5jb25zdCBnbG9iYWxzID0ge1xuICAvKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuICBkZWZhdWx0cyxcbiAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gIHByZWNpc2lvbjogNCxcbiAgLyoqIEB0eXBlIHtOdW1iZXJ9IGVxdWFscyAxIGluIG1zIG1vZGUsIDAuMDAxIGluIHMgbW9kZSAqL1xuICB0aW1lU2NhbGU6IDEsXG4gIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICB0aWNrVGhyZXNob2xkOiAyMDAsXG59O1xuXG5jb25zdCBnbG9iYWxWZXJzaW9ucyA9IHsgdmVyc2lvbjogJzQuMS40JywgZW5naW5lOiBudWxsIH07XG5cbmlmIChpc0Jyb3dzZXIpIHtcbiAgaWYgKCF3aW4uQW5pbWVKUykgd2luLkFuaW1lSlMgPSBbXTtcbiAgd2luLkFuaW1lSlMucHVzaChnbG9iYWxWZXJzaW9ucyk7XG59XG5cbi8vIFN0cmluZ3NcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCB0b0xvd2VyQ2FzZSA9IHN0ciA9PiBzdHIucmVwbGFjZShsb3dlckNhc2VSZ3gsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbi8qKlxuICogUHJpb3JpdGl6ZSB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIHJlZ2V4IHdoZW4gcG9zc2libGVcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN1YlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuY29uc3Qgc3RyaW5nU3RhcnRzV2l0aCA9IChzdHIsIHN1YikgPT4gc3RyLmluZGV4T2Yoc3ViKSA9PT0gMDtcblxuLy8gTm90ZTogRGF0ZS5ub3cgaXMgdXNlZCBpbnN0ZWFkIG9mIHBlcmZvcm1hbmNlLm5vdyBzaW5jZSBpdCBpcyBwcmVjaXNlIGVub3VnaCBmb3IgdGltaW5ncyBjYWxjdWxhdGlvbnMsIHBlcmZvcm1zIHNsaWdodGx5IGZhc3RlciBhbmQgd29ya3MgaW4gTm9kZS5qcyBlbnZpcm9uZW1lbnQuXG5jb25zdCBub3cgPSBEYXRlLm5vdztcblxuLy8gVHlwZXMgY2hlY2tlcnNcblxuY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5O1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7YSBpcyBSZWNvcmQ8U3RyaW5nLCBhbnk+fSAqL1xuY29uc3QgaXNPYmogPSBhID0+IGEgJiYgYS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7YSBpcyBOdW1iZXJ9ICovXG5jb25zdCBpc051bSA9IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInICYmICFpc05hTihhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgU3RyaW5nfSAqL1xuY29uc3QgaXNTdHIgPSBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJztcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgRnVuY3Rpb259ICovXG5jb25zdCBpc0ZuYyA9IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHthIGlzIHVuZGVmaW5lZH0gKi9cbmNvbnN0IGlzVW5kID0gYSA9PiB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCc7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHthIGlzIG51bGwgfCB1bmRlZmluZWR9ICovXG5jb25zdCBpc05pbCA9IGEgPT4gaXNVbmQoYSkgfHwgYSA9PT0gbnVsbDtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgU1ZHRWxlbWVudH0gKi9cbmNvbnN0IGlzU3ZnID0gYSA9PiBpc0Jyb3dzZXIgJiYgYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHtCb29sZWFufSAqL1xuY29uc3QgaXNIZXggPSBhID0+IGhleFRlc3RSZ3gudGVzdChhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge0Jvb2xlYW59ICovXG5jb25zdCBpc1JnYiA9IGEgPT4gc3RyaW5nU3RhcnRzV2l0aChhLCAncmdiJyk7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHtCb29sZWFufSAqL1xuY29uc3QgaXNIc2wgPSBhID0+IHN0cmluZ1N0YXJ0c1dpdGgoYSwgJ2hzbCcpO1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7Qm9vbGVhbn0gKi9cbmNvbnN0IGlzQ29sID0gYSA9PiBpc0hleChhKSB8fCBpc1JnYihhKSB8fCBpc0hzbChhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge0Jvb2xlYW59ICovXG5jb25zdCBpc0tleSA9IGEgPT4gIWdsb2JhbHMuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoYSk7XG5cbi8vIE51bWJlclxuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBwYXJzZU51bWJlciA9IHN0ciA9PiBpc1N0cihzdHIpID9cbiAgcGFyc2VGbG9hdCgvKiogQHR5cGUge1N0cmluZ30gKi8oc3RyKSkgOlxuICAvKiogQHR5cGUge051bWJlcn0gKi8oc3RyKTtcblxuLy8gTWF0aFxuXG5jb25zdCBwb3cgPSBNYXRoLnBvdztcbmNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG5jb25zdCBzaW4gPSBNYXRoLnNpbjtcbmNvbnN0IGNvcyA9IE1hdGguY29zO1xuY29uc3QgYWJzID0gTWF0aC5hYnM7XG5jb25zdCBleHAgPSBNYXRoLmV4cDtcbmNvbnN0IGNlaWwgPSBNYXRoLmNlaWw7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBhc2luID0gTWF0aC5hc2luO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCBhdGFuMiA9IE1hdGguYXRhbjI7XG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBfcm91bmQgPSBNYXRoLnJvdW5kO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdlxuICogQHBhcmFtICB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGNsYW1wID0gKHYsIG1pbiwgbWF4KSA9PiB2IDwgbWluID8gbWluIDogdiA+IG1heCA/IG1heCA6IHY7XG5cbmNvbnN0IHBvd0NhY2hlID0ge307XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlY2ltYWxMZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgcm91bmQgPSAodiwgZGVjaW1hbExlbmd0aCkgPT4ge1xuICBpZiAoZGVjaW1hbExlbmd0aCA8IDApIHJldHVybiB2O1xuICBpZiAoIWRlY2ltYWxMZW5ndGgpIHJldHVybiBfcm91bmQodik7XG4gIGxldCBwID0gcG93Q2FjaGVbZGVjaW1hbExlbmd0aF07XG4gIGlmICghcCkgcCA9IHBvd0NhY2hlW2RlY2ltYWxMZW5ndGhdID0gMTAgKiogZGVjaW1hbExlbmd0aDtcbiAgcmV0dXJuIF9yb3VuZCh2ICogcCkgLyBwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheTxOdW1iZXI+fSBpbmNyZW1lbnRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgc25hcCA9ICh2LCBpbmNyZW1lbnQpID0+IGlzQXJyKGluY3JlbWVudCkgPyBpbmNyZW1lbnQucmVkdWNlKChjbG9zZXN0LCBjdikgPT4gKGFicyhjdiAtIHYpIDwgYWJzKGNsb3Nlc3QgLSB2KSA/IGN2IDogY2xvc2VzdCkpIDogaW5jcmVtZW50ID8gX3JvdW5kKHYgLyBpbmNyZW1lbnQpICogaW5jcmVtZW50IDogdjtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZFxuICogQHBhcmFtICB7TnVtYmVyfSBwcm9ncmVzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBpbnRlcnBvbGF0ZSA9IChzdGFydCwgZW5kLCBwcm9ncmVzcykgPT4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcHJvZ3Jlc3M7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtkZWNpbWFsTGVuZ3RoXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCByYW5kb20gPSAobWluLCBtYXgsIGRlY2ltYWxMZW5ndGgpID0+IHsgY29uc3QgbSA9IDEwICoqIChkZWNpbWFsTGVuZ3RoIHx8IDApOyByZXR1cm4gZmxvb3IoKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgKDEgLyBtKSkgKyBtaW4pICogbSkgLyBtIH07XG5cbi8qKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vYm9zdC5vY2tzLm9yZy9taWtlL3NodWZmbGUvXG4gKiBAcGFyYW0gIHtBcnJheX0gaXRlbXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5jb25zdCBzaHVmZmxlID0gaXRlbXMgPT4ge1xuICBsZXQgbSA9IGl0ZW1zLmxlbmd0aCwgdCwgaTtcbiAgd2hpbGUgKG0pIHsgaSA9IHJhbmRvbSgwLCAtLW0pOyB0ID0gaXRlbXNbbV07IGl0ZW1zW21dID0gaXRlbXNbaV07IGl0ZW1zW2ldID0gdDsgfVxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBjbGFtcEluZmluaXR5ID0gdiA9PiB2ID09PSBJbmZpbml0eSA/IG1heFZhbHVlIDogdiA9PT0gLUluZmluaXR5ID8gLW1heFZhbHVlIDogdjtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgbm9ybWFsaXplVGltZSA9IHYgPT4gdiA8PSBtaW5WYWx1ZSA/IG1pblZhbHVlIDogY2xhbXBJbmZpbml0eShyb3VuZCh2LCAxMSkpO1xuXG4vLyBBcnJheXNcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUW119IGFcbiAqIEByZXR1cm4ge1RbXX1cbiAqL1xuY29uc3QgY2xvbmVBcnJheSA9IGEgPT4gaXNBcnIoYSkgPyBbIC4uLmEgXSA6IGE7XG5cbi8vIE9iamVjdHNcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFVcbiAqIEBwYXJhbSB7VH0gbzFcbiAqIEBwYXJhbSB7VX0gbzJcbiAqIEByZXR1cm4ge1QgJiBVfVxuICovXG5jb25zdCBtZXJnZU9iamVjdHMgPSAobzEsIG8yKSA9PiB7XG4gIGNvbnN0IG1lcmdlZCA9IC8qKiBAdHlwZSB7VCAmIFV9ICovKHsgLi4ubzEgfSk7XG4gIGZvciAobGV0IHAgaW4gbzIpIHtcbiAgICBjb25zdCBvMXAgPSAvKiogQHR5cGUge1QgJiBVfSAqLyhvMSlbcF07XG4gICAgbWVyZ2VkW3BdID0gaXNVbmQobzFwKSA/IC8qKiBAdHlwZSB7VCAmIFV9ICovKG8yKVtwXSA6IG8xcDtcbiAgfSAgcmV0dXJuIG1lcmdlZDtcbn07XG5cbi8vIExpbmtlZCBsaXN0c1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXZlcnNlXVxuICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2UHJvcF1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmV4dFByb3BdXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5jb25zdCBmb3JFYWNoQ2hpbGRyZW4gPSAocGFyZW50LCBjYWxsYmFjaywgcmV2ZXJzZSwgcHJldlByb3AgPSAnX3ByZXYnLCBuZXh0UHJvcCA9ICdfbmV4dCcpID0+IHtcbiAgbGV0IG5leHQgPSBwYXJlbnQuX2hlYWQ7XG4gIGxldCBhZGp1c3RlZE5leHRQcm9wID0gbmV4dFByb3A7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgbmV4dCA9IHBhcmVudC5fdGFpbDtcbiAgICBhZGp1c3RlZE5leHRQcm9wID0gcHJldlByb3A7XG4gIH1cbiAgd2hpbGUgKG5leHQpIHtcbiAgICBjb25zdCBjdXJyZW50TmV4dCA9IG5leHRbYWRqdXN0ZWROZXh0UHJvcF07XG4gICAgY2FsbGJhY2sobmV4dCk7XG4gICAgbmV4dCA9IGN1cnJlbnROZXh0O1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0gIHtPYmplY3R9IGNoaWxkXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtwcmV2UHJvcF1cbiAqIEBwYXJhbSAge1N0cmluZ30gW25leHRQcm9wXVxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuY29uc3QgcmVtb3ZlQ2hpbGQgPSAocGFyZW50LCBjaGlsZCwgcHJldlByb3AgPSAnX3ByZXYnLCBuZXh0UHJvcCA9ICdfbmV4dCcpID0+IHtcbiAgY29uc3QgcHJldiA9IGNoaWxkW3ByZXZQcm9wXTtcbiAgY29uc3QgbmV4dCA9IGNoaWxkW25leHRQcm9wXTtcbiAgcHJldiA/IHByZXZbbmV4dFByb3BdID0gbmV4dCA6IHBhcmVudC5faGVhZCA9IG5leHQ7XG4gIG5leHQgPyBuZXh0W3ByZXZQcm9wXSA9IHByZXYgOiBwYXJlbnQuX3RhaWwgPSBwcmV2O1xuICBjaGlsZFtwcmV2UHJvcF0gPSBudWxsO1xuICBjaGlsZFtuZXh0UHJvcF0gPSBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtICB7T2JqZWN0fSBjaGlsZFxuICogQHBhcmFtICB7RnVuY3Rpb259IFtzb3J0TWV0aG9kXVxuICogQHBhcmFtICB7U3RyaW5nfSBwcmV2UHJvcFxuICogQHBhcmFtICB7U3RyaW5nfSBuZXh0UHJvcFxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuY29uc3QgYWRkQ2hpbGQgPSAocGFyZW50LCBjaGlsZCwgc29ydE1ldGhvZCwgcHJldlByb3AgPSAnX3ByZXYnLCBuZXh0UHJvcCA9ICdfbmV4dCcpID0+IHtcbiAgbGV0IHByZXYgPSBwYXJlbnQuX3RhaWw7XG4gIHdoaWxlIChwcmV2ICYmIHNvcnRNZXRob2QgJiYgc29ydE1ldGhvZChwcmV2LCBjaGlsZCkpIHByZXYgPSBwcmV2W3ByZXZQcm9wXTtcbiAgY29uc3QgbmV4dCA9IHByZXYgPyBwcmV2W25leHRQcm9wXSA6IHBhcmVudC5faGVhZDtcbiAgcHJldiA/IHByZXZbbmV4dFByb3BdID0gY2hpbGQgOiBwYXJlbnQuX2hlYWQgPSBjaGlsZDtcbiAgbmV4dCA/IG5leHRbcHJldlByb3BdID0gY2hpbGQgOiBwYXJlbnQuX3RhaWwgPSBjaGlsZDtcbiAgY2hpbGRbcHJldlByb3BdID0gcHJldjtcbiAgY2hpbGRbbmV4dFByb3BdID0gbmV4dDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7KC4uLmFyZ3M6IGFueVtdKSA9PiBUaWNrYWJsZSB8ICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpfSBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7KC4uLmFyZ3M6IGFueVtdKSA9PiBUaWNrYWJsZSB8ICgoLi4uYXJnczogYW55W10pID0+IHZvaWQpfVxuICovXG5jb25zdCBjcmVhdGVSZWZyZXNoYWJsZSA9IGNvbnN0cnVjdG9yID0+IHtcbiAgLyoqIEB0eXBlIHtUaWNrYWJsZX0gKi9cbiAgbGV0IHRyYWNrZWQ7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGxldCBjdXJyZW50SXRlcmF0aW9uLCBjdXJyZW50SXRlcmF0aW9uUHJvZ3Jlc3MsIHJldmVyc2VkLCBhbHRlcm5hdGU7XG4gICAgaWYgKHRyYWNrZWQpIHtcbiAgICAgIGN1cnJlbnRJdGVyYXRpb24gPSB0cmFja2VkLmN1cnJlbnRJdGVyYXRpb247XG4gICAgICBjdXJyZW50SXRlcmF0aW9uUHJvZ3Jlc3MgPSB0cmFja2VkLml0ZXJhdGlvblByb2dyZXNzO1xuICAgICAgcmV2ZXJzZWQgPSB0cmFja2VkLnJldmVyc2VkO1xuICAgICAgYWx0ZXJuYXRlID0gdHJhY2tlZC5fYWx0ZXJuYXRlO1xuICAgICAgdHJhY2tlZC5yZXZlcnQoKTtcbiAgICB9XG4gICAgY29uc3QgY2xlYW51cCA9IGNvbnN0cnVjdG9yKC4uLmFyZ3MpO1xuICAgIGlmIChjbGVhbnVwICYmICFpc0ZuYyhjbGVhbnVwKSAmJiBjbGVhbnVwLnJldmVydCkgdHJhY2tlZCA9IGNsZWFudXA7XG4gICAgaWYgKCFpc1VuZChjdXJyZW50SXRlcmF0aW9uUHJvZ3Jlc3MpKSB7XG4gICAgICAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0cmFja2VkKS5jdXJyZW50SXRlcmF0aW9uID0gY3VycmVudEl0ZXJhdGlvbjtcbiAgICAgIC8qKiBAdHlwZSB7VGlja2FibGV9ICovKHRyYWNrZWQpLml0ZXJhdGlvblByb2dyZXNzID0gKGFsdGVybmF0ZSA/ICEoY3VycmVudEl0ZXJhdGlvbiAlIDIpID8gcmV2ZXJzZWQgOiAhcmV2ZXJzZWQgOiByZXZlcnNlZCkgPyAxIC0gY3VycmVudEl0ZXJhdGlvblByb2dyZXNzIDogY3VycmVudEl0ZXJhdGlvblByb2dyZXNzO1xuICAgIH1cbiAgICByZXR1cm4gY2xlYW51cCB8fCBub29wO1xuICB9XG59O1xuXG4vKlxuICogQmFzZSBjbGFzcyB0byBjb250cm9sIGZyYW1lcmF0ZSBhbmQgcGxheWJhY2sgcmF0ZS5cbiAqIEluaGVyaXRlZCBieSBFbmdpbmUsIFRpbWVyLCBBbmltYXRpb24gYW5kIFRpbWVsaW5lLlxuICovXG5jbGFzcyBDbG9jayB7XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBbaW5pdFRpbWVdICovXG4gIGNvbnN0cnVjdG9yKGluaXRUaW1lID0gMCkge1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZGVsdGFUaW1lID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IGluaXRUaW1lO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gaW5pdFRpbWU7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gaW5pdFRpbWU7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fbGFzdFRpbWUgPSBpbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zY2hlZHVsZWRUaW1lID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9mcmFtZUR1cmF0aW9uID0gcm91bmQoSyAvIG1heEZwcywgMCk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZnBzID0gbWF4RnBzO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX3NwZWVkID0gMTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge1RpY2thYmxlfFR3ZWVufSAqL1xuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7VGlja2FibGV8VHdlZW59ICovXG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gIH1cblxuICBnZXQgZnBzKCkge1xuICAgIHJldHVybiB0aGlzLl9mcHM7XG4gIH1cblxuICBzZXQgZnBzKGZyYW1lUmF0ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzRnJhbWVEdXJhdGlvbiA9IHRoaXMuX2ZyYW1lRHVyYXRpb247XG4gICAgY29uc3QgZnIgPSArZnJhbWVSYXRlO1xuICAgIGNvbnN0IGZwcyA9IGZyIDwgbWluVmFsdWUgPyBtaW5WYWx1ZSA6IGZyO1xuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSByb3VuZChLIC8gZnBzLCAwKTtcbiAgICB0aGlzLl9mcHMgPSBmcHM7XG4gICAgdGhpcy5fZnJhbWVEdXJhdGlvbiA9IGZyYW1lRHVyYXRpb247XG4gICAgdGhpcy5fc2NoZWR1bGVkVGltZSArPSBmcmFtZUR1cmF0aW9uIC0gcHJldmlvdXNGcmFtZUR1cmF0aW9uO1xuICB9XG5cbiAgZ2V0IHNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zcGVlZDtcbiAgfVxuXG4gIHNldCBzcGVlZChwbGF5YmFja1JhdGUpIHtcbiAgICBjb25zdCBwYnIgPSArcGxheWJhY2tSYXRlO1xuICAgIHRoaXMuX3NwZWVkID0gcGJyIDwgbWluVmFsdWUgPyBtaW5WYWx1ZSA6IHBicjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVcbiAgICogQHJldHVybiB7dGlja01vZGVzfVxuICAgKi9cbiAgcmVxdWVzdFRpY2sodGltZSkge1xuICAgIGNvbnN0IHNjaGVkdWxlZFRpbWUgPSB0aGlzLl9zY2hlZHVsZWRUaW1lO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gdGhpcy5fZWxhcHNlZFRpbWU7XG4gICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gKHRpbWUgLSBlbGFwc2VkVGltZSk7XG4gICAgLy8gSWYgdGhlIGVsYXBzZWQgdGltZSBpcyBsb3dlciB0aGFuIHRoZSBzY2hlZHVsZWQgdGltZVxuICAgIC8vIHRoaXMgbWVhbnMgbm90IGVub3VnaCB0aW1lIGhhcyBwYXNzZWQgdG8gaGl0IG9uZSBmcmFtZUR1cmF0aW9uXG4gICAgLy8gc28gc2tpcCB0aGF0IGZyYW1lXG4gICAgaWYgKGVsYXBzZWRUaW1lIDwgc2NoZWR1bGVkVGltZSkgcmV0dXJuIHRpY2tNb2Rlcy5OT05FO1xuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSB0aGlzLl9mcmFtZUR1cmF0aW9uO1xuICAgIGNvbnN0IGZyYW1lRGVsdGEgPSBlbGFwc2VkVGltZSAtIHNjaGVkdWxlZFRpbWU7XG4gICAgLy8gRW5zdXJlcyB0aGF0IF9zY2hlZHVsZWRUaW1lIHByb2dyZXNzZXMgaW4gc3RlcHMgb2YgYXQgbGVhc3QgMSBmcmFtZUR1cmF0aW9uLlxuICAgIC8vIFNraXBzIGFoZWFkIGlmIHRoZSBhY3R1YWwgZWxhcHNlZCB0aW1lIGlzIGhpZ2hlci5cbiAgICB0aGlzLl9zY2hlZHVsZWRUaW1lICs9IGZyYW1lRGVsdGEgPCBmcmFtZUR1cmF0aW9uID8gZnJhbWVEdXJhdGlvbiA6IGZyYW1lRGVsdGE7XG4gICAgcmV0dXJuIHRpY2tNb2Rlcy5BVVRPO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdGltZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb21wdXRlRGVsdGFUaW1lKHRpbWUpIHtcbiAgICBjb25zdCBkZWx0YSA9IHRpbWUgLSB0aGlzLl9sYXN0VGltZTtcbiAgICB0aGlzLmRlbHRhVGltZSA9IGRlbHRhO1xuICAgIHRoaXMuX2xhc3RUaW1lID0gdGltZTtcbiAgICByZXR1cm4gZGVsdGE7XG4gIH1cblxufVxuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge1RpY2thYmxlfSB0aWNrYWJsZVxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG11dGVDYWxsYmFja3NcbiAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAqIEBwYXJhbSAge3RpY2tNb2Rlc30gdGlja01vZGVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcmVuZGVyID0gKHRpY2thYmxlLCB0aW1lLCBtdXRlQ2FsbGJhY2tzLCBpbnRlcm5hbFJlbmRlciwgdGlja01vZGUpID0+IHtcblxuICBjb25zdCBwYXJlbnQgPSB0aWNrYWJsZS5wYXJlbnQ7XG4gIGNvbnN0IGR1cmF0aW9uID0gdGlja2FibGUuZHVyYXRpb247XG4gIGNvbnN0IGNvbXBsZXRlZCA9IHRpY2thYmxlLmNvbXBsZXRlZDtcbiAgY29uc3QgaXRlcmF0aW9uRHVyYXRpb24gPSB0aWNrYWJsZS5pdGVyYXRpb25EdXJhdGlvbjtcbiAgY29uc3QgaXRlcmF0aW9uQ291bnQgPSB0aWNrYWJsZS5pdGVyYXRpb25Db3VudDtcbiAgY29uc3QgX2N1cnJlbnRJdGVyYXRpb24gPSB0aWNrYWJsZS5fY3VycmVudEl0ZXJhdGlvbjtcbiAgY29uc3QgX2xvb3BEZWxheSA9IHRpY2thYmxlLl9sb29wRGVsYXk7XG4gIGNvbnN0IF9yZXZlcnNlZCA9IHRpY2thYmxlLl9yZXZlcnNlZDtcbiAgY29uc3QgX2FsdGVybmF0ZSA9IHRpY2thYmxlLl9hbHRlcm5hdGU7XG4gIGNvbnN0IF9oYXNDaGlsZHJlbiA9IHRpY2thYmxlLl9oYXNDaGlsZHJlbjtcbiAgY29uc3QgdGlja2FibGVEZWxheSA9IHRpY2thYmxlLl9kZWxheTtcbiAgY29uc3QgdGlja2FibGVQcmV2QWJzb2x1dGVUaW1lID0gdGlja2FibGUuX2N1cnJlbnRUaW1lOyAvLyBUT0RPOiByZW5hbWUgLl9jdXJyZW50VGltZSB0byAuX2Fic29sdXRlQ3VycmVudFRpbWVcblxuICBjb25zdCB0aWNrYWJsZUVuZFRpbWUgPSB0aWNrYWJsZURlbGF5ICsgaXRlcmF0aW9uRHVyYXRpb247XG4gIGNvbnN0IHRpY2thYmxlQWJzb2x1dGVUaW1lID0gdGltZSAtIHRpY2thYmxlRGVsYXk7XG4gIGNvbnN0IHRpY2thYmxlUHJldlRpbWUgPSBjbGFtcCh0aWNrYWJsZVByZXZBYnNvbHV0ZVRpbWUsIC10aWNrYWJsZURlbGF5LCBkdXJhdGlvbik7XG4gIGNvbnN0IHRpY2thYmxlQ3VycmVudFRpbWUgPSBjbGFtcCh0aWNrYWJsZUFic29sdXRlVGltZSwgLXRpY2thYmxlRGVsYXksIGR1cmF0aW9uKTtcbiAgY29uc3QgZGVsdGFUaW1lID0gdGlja2FibGVBYnNvbHV0ZVRpbWUgLSB0aWNrYWJsZVByZXZBYnNvbHV0ZVRpbWU7XG4gIGNvbnN0IGlzQ3VycmVudFRpbWVBYm92ZVplcm8gPSB0aWNrYWJsZUN1cnJlbnRUaW1lID4gMDtcbiAgY29uc3QgaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID0gdGlja2FibGVDdXJyZW50VGltZSA+PSBkdXJhdGlvbjtcbiAgY29uc3QgaXNTZXR0ZXIgPSBkdXJhdGlvbiA8PSBtaW5WYWx1ZTtcbiAgY29uc3QgZm9yY2VkVGljayA9IHRpY2tNb2RlID09PSB0aWNrTW9kZXMuRk9SQ0U7XG5cbiAgbGV0IGlzT2RkID0gMDtcbiAgbGV0IGl0ZXJhdGlvbkVsYXBzZWRUaW1lID0gdGlja2FibGVBYnNvbHV0ZVRpbWU7XG4gIC8vIFJlbmRlciBjaGVja3NcbiAgLy8gVXNlZCB0byBhbHNvIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIHJlbmRlcmVkIGluIG9yZGVyIHRvIHRyaWdnZXIgdGhlIG9uUmVuZGVyIGNhbGxiYWNrIG9uIHRoZSBwYXJlbnQgdGltZXJcbiAgbGV0IGhhc1JlbmRlcmVkID0gMDtcblxuICAvLyBFeGVjdXRlIHRoZSBcImV4cGVuc2l2ZVwiIGl0ZXJhdGlvbnMgY2FsY3VsYXRpb25zIG9ubHkgd2hlbiBuZWNlc3NhcnlcbiAgaWYgKGl0ZXJhdGlvbkNvdW50ID4gMSkge1xuICAgIC8vIGJpdHdpc2UgTk9UIG9wZXJhdG9yIHNlZW1zIHRvIGJlIGdlbmVyYWxseSBmYXN0ZXIgdGhhbiBNYXRoLmZsb29yKCkgYWNyb3NzIGJyb3dzZXJzXG4gICAgY29uc3QgY3VycmVudEl0ZXJhdGlvbiA9IH5+KHRpY2thYmxlQ3VycmVudFRpbWUgLyAoaXRlcmF0aW9uRHVyYXRpb24gKyAoaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID8gMCA6IF9sb29wRGVsYXkpKSk7XG4gICAgdGlja2FibGUuX2N1cnJlbnRJdGVyYXRpb24gPSBjbGFtcChjdXJyZW50SXRlcmF0aW9uLCAwLCBpdGVyYXRpb25Db3VudCk7XG4gICAgLy8gUHJldmVudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIGdvIGFib3ZlIHRoZSBtYXggaXRlcmF0aW9ucyB3aGVuIHJlYWNoaW5nIHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvblxuICAgIGlmIChpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24pIHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uLS07XG4gICAgaXNPZGQgPSB0aWNrYWJsZS5fY3VycmVudEl0ZXJhdGlvbiAlIDI7XG4gICAgaXRlcmF0aW9uRWxhcHNlZFRpbWUgPSB0aWNrYWJsZUN1cnJlbnRUaW1lICUgKGl0ZXJhdGlvbkR1cmF0aW9uICsgX2xvb3BEZWxheSkgfHwgMDtcbiAgfVxuXG4gIC8vIENoZWNrcyBpZiBleGFjdGx5IG9uZSBvZiBfcmV2ZXJzZWQgYW5kIChfYWx0ZXJuYXRlICYmIGlzT2RkKSBpcyB0cnVlXG4gIGNvbnN0IGlzUmV2ZXJzZWQgPSBfcmV2ZXJzZWQgXiAoX2FsdGVybmF0ZSAmJiBpc09kZCk7XG4gIGNvbnN0IF9lYXNlID0gLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqLyh0aWNrYWJsZSkuX2Vhc2U7XG4gIGxldCBpdGVyYXRpb25UaW1lID0gaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID8gaXNSZXZlcnNlZCA/IDAgOiBkdXJhdGlvbiA6IGlzUmV2ZXJzZWQgPyBpdGVyYXRpb25EdXJhdGlvbiAtIGl0ZXJhdGlvbkVsYXBzZWRUaW1lIDogaXRlcmF0aW9uRWxhcHNlZFRpbWU7XG4gIGlmIChfZWFzZSkgaXRlcmF0aW9uVGltZSA9IGl0ZXJhdGlvbkR1cmF0aW9uICogX2Vhc2UoaXRlcmF0aW9uVGltZSAvIGl0ZXJhdGlvbkR1cmF0aW9uKSB8fCAwO1xuICBjb25zdCBpc1J1bm5pbmdCYWNrd2FyZHMgPSAocGFyZW50ID8gcGFyZW50LmJhY2t3YXJkcyA6IHRpY2thYmxlQWJzb2x1dGVUaW1lIDwgdGlja2FibGVQcmV2QWJzb2x1dGVUaW1lKSA/ICFpc1JldmVyc2VkIDogISFpc1JldmVyc2VkO1xuXG4gIHRpY2thYmxlLl9jdXJyZW50VGltZSA9IHRpY2thYmxlQWJzb2x1dGVUaW1lO1xuICB0aWNrYWJsZS5faXRlcmF0aW9uVGltZSA9IGl0ZXJhdGlvblRpbWU7XG4gIHRpY2thYmxlLmJhY2t3YXJkcyA9IGlzUnVubmluZ0JhY2t3YXJkcztcblxuICBpZiAoaXNDdXJyZW50VGltZUFib3ZlWmVybyAmJiAhdGlja2FibGUuYmVnYW4pIHtcbiAgICB0aWNrYWJsZS5iZWdhbiA9IHRydWU7XG4gICAgaWYgKCFtdXRlQ2FsbGJhY2tzICYmICEocGFyZW50ICYmIChpc1J1bm5pbmdCYWNrd2FyZHMgfHwgIXBhcmVudC5iZWdhbikpKSB7XG4gICAgICB0aWNrYWJsZS5vbkJlZ2luKC8qKiBAdHlwZSB7Q2FsbGJhY2tBcmd1bWVudH0gKi8odGlja2FibGUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGlja2FibGVBYnNvbHV0ZVRpbWUgPD0gMCkge1xuICAgIHRpY2thYmxlLmJlZ2FuID0gZmFsc2U7XG4gIH1cblxuICAvLyBPbmx5IHRyaWdnZXJzIG9uTG9vcCBmb3IgdGlja2FibGUgd2l0aG91dCBjaGlsZHJlbiwgb3RoZXJ3aXNlIGNhbGwgdGhlIHRoZSBvbkxvb3AgY2FsbGJhY2sgaW4gdGhlIHRpY2sgZnVuY3Rpb25cbiAgLy8gTWFrZSBzdXJlIHRvIHRyaWdnZXIgdGhlIG9uTG9vcCBiZWZvcmUgcmVuZGVyaW5nIHRvIGFsbG93IC5yZWZyZXNoKCkgdG8gcGlja3VwIHRoZSBjdXJyZW50IHZhbHVlc1xuICBpZiAoIW11dGVDYWxsYmFja3MgJiYgIV9oYXNDaGlsZHJlbiAmJiBpc0N1cnJlbnRUaW1lQWJvdmVaZXJvICYmIHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uICE9PSBfY3VycmVudEl0ZXJhdGlvbikge1xuICAgIHRpY2thYmxlLm9uTG9vcCgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRpY2thYmxlKSk7XG4gIH1cblxuICBpZiAoXG4gICAgZm9yY2VkVGljayB8fFxuICAgIHRpY2tNb2RlID09PSB0aWNrTW9kZXMuQVVUTyAmJiAoXG4gICAgICB0aW1lID49IHRpY2thYmxlRGVsYXkgJiYgdGltZSA8PSB0aWNrYWJsZUVuZFRpbWUgfHwgLy8gTm9ybWFsIHJlbmRlclxuICAgICAgdGltZSA8PSB0aWNrYWJsZURlbGF5ICYmIHRpY2thYmxlUHJldlRpbWUgPiB0aWNrYWJsZURlbGF5IHx8IC8vIFBsYXloZWFkIGlzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0IHRpbWUgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgYXQgaXRzIGluaXRpYWwgc3RhdGVcbiAgICAgIHRpbWUgPj0gdGlja2FibGVFbmRUaW1lICYmIHRpY2thYmxlUHJldlRpbWUgIT09IGR1cmF0aW9uIC8vIFBsYXloZWFkIGlzIGFmdGVyIHRoZSBhbmltYXRpb24gZW5kIHRpbWUgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgYXQgaXRzIGVuZCBzdGF0ZVxuICAgICkgfHxcbiAgICBpdGVyYXRpb25UaW1lID49IHRpY2thYmxlRW5kVGltZSAmJiB0aWNrYWJsZVByZXZUaW1lICE9PSBkdXJhdGlvbiB8fFxuICAgIGl0ZXJhdGlvblRpbWUgPD0gdGlja2FibGVEZWxheSAmJiB0aWNrYWJsZVByZXZUaW1lID4gMCB8fFxuICAgIHRpbWUgPD0gdGlja2FibGVQcmV2VGltZSAmJiB0aWNrYWJsZVByZXZUaW1lID09PSBkdXJhdGlvbiAmJiBjb21wbGV0ZWQgfHwgLy8gRm9yY2UgYSByZW5kZXIgaWYgYSBzZWVrIG9jY3VycyBvbiBhbiBjb21wbGV0ZWQgYW5pbWF0aW9uXG4gICAgaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uICYmICFjb21wbGV0ZWQgJiYgaXNTZXR0ZXIgLy8gVGhpcyBwcmV2ZW50cyAwIGR1cmF0aW9uIHRpY2thYmxlcyB0byBiZSBza2lwcGVkXG4gICkge1xuXG4gICAgaWYgKGlzQ3VycmVudFRpbWVBYm92ZVplcm8pIHtcbiAgICAgIC8vIFRyaWdnZXIgb25VcGRhdGUgY2FsbGJhY2sgYmVmb3JlIHJlbmRlcmluZ1xuICAgICAgdGlja2FibGUuY29tcHV0ZURlbHRhVGltZSh0aWNrYWJsZVByZXZUaW1lKTtcbiAgICAgIGlmICghbXV0ZUNhbGxiYWNrcykgdGlja2FibGUub25CZWZvcmVVcGRhdGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHR3ZWVucyByZW5kZXJpbmdcbiAgICBpZiAoIV9oYXNDaGlsZHJlbikge1xuXG4gICAgICAvLyBUaW1lIGhhcyBqdW1wZWQgbW9yZSB0aGFuIGdsb2JhbHMudGlja1RocmVzaG9sZCBzbyBjb25zaWRlciB0aGlzIHRpY2sgbWFudWFsXG4gICAgICBjb25zdCBmb3JjZWRSZW5kZXIgPSBmb3JjZWRUaWNrIHx8IChpc1J1bm5pbmdCYWNrd2FyZHMgPyBkZWx0YVRpbWUgKiAtMSA6IGRlbHRhVGltZSkgPj0gZ2xvYmFscy50aWNrVGhyZXNob2xkO1xuICAgICAgY29uc3QgYWJzb2x1dGVUaW1lID0gdGlja2FibGUuX29mZnNldCArIChwYXJlbnQgPyBwYXJlbnQuX29mZnNldCA6IDApICsgdGlja2FibGVEZWxheSArIGl0ZXJhdGlvblRpbWU7XG5cbiAgICAgIC8vIE9ubHkgQW5pbWF0aW9uIGNhbiBoYXZlIHR3ZWVucywgVGltZXIgcmV0dXJucyB1bmRlZmluZWRcbiAgICAgIGxldCB0d2VlbiA9IC8qKiBAdHlwZSB7VHdlZW59ICovKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKHRpY2thYmxlKS5faGVhZCk7XG4gICAgICBsZXQgdHdlZW5UYXJnZXQ7XG4gICAgICBsZXQgdHdlZW5TdHlsZTtcbiAgICAgIGxldCB0d2VlblRhcmdldFRyYW5zZm9ybXM7XG4gICAgICBsZXQgdHdlZW5UYXJnZXRUcmFuc2Zvcm1zUHJvcGVydGllcztcbiAgICAgIGxldCB0d2VlblRyYW5zZm9ybXNOZWVkVXBkYXRlID0gMDtcblxuICAgICAgd2hpbGUgKHR3ZWVuKSB7XG5cbiAgICAgICAgY29uc3QgdHdlZW5Db21wb3NpdGlvbiA9IHR3ZWVuLl9jb21wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdHdlZW5DdXJyZW50VGltZSA9IHR3ZWVuLl9jdXJyZW50VGltZTtcbiAgICAgICAgY29uc3QgdHdlZW5DaGFuZ2VEdXJhdGlvbiA9IHR3ZWVuLl9jaGFuZ2VEdXJhdGlvbjtcbiAgICAgICAgY29uc3QgdHdlZW5BYnNFbmRUaW1lID0gdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lICsgdHdlZW4uX2NoYW5nZUR1cmF0aW9uO1xuICAgICAgICBjb25zdCB0d2Vlbk5leHRSZXAgPSB0d2Vlbi5fbmV4dFJlcDtcbiAgICAgICAgY29uc3QgdHdlZW5QcmV2UmVwID0gdHdlZW4uX3ByZXZSZXA7XG4gICAgICAgIGNvbnN0IHR3ZWVuSGFzQ29tcG9zaXRpb24gPSB0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLm5vbmU7XG5cbiAgICAgICAgaWYgKChmb3JjZWRSZW5kZXIgfHwgKFxuICAgICAgICAgICAgKHR3ZWVuQ3VycmVudFRpbWUgIT09IHR3ZWVuQ2hhbmdlRHVyYXRpb24gfHwgYWJzb2x1dGVUaW1lIDw9IHR3ZWVuQWJzRW5kVGltZSArICh0d2Vlbk5leHRSZXAgPyB0d2Vlbk5leHRSZXAuX2RlbGF5IDogMCkpICYmXG4gICAgICAgICAgICAodHdlZW5DdXJyZW50VGltZSAhPT0gMCB8fCBhYnNvbHV0ZVRpbWUgPj0gdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lKVxuICAgICAgICAgICkpICYmICghdHdlZW5IYXNDb21wb3NpdGlvbiB8fCAoXG4gICAgICAgICAgICAhdHdlZW4uX2lzT3ZlcnJpZGRlbiAmJlxuICAgICAgICAgICAgKCF0d2Vlbi5faXNPdmVybGFwcGVkIHx8IGFic29sdXRlVGltZSA8PSB0d2VlbkFic0VuZFRpbWUpICYmXG4gICAgICAgICAgICAoIXR3ZWVuTmV4dFJlcCB8fCAodHdlZW5OZXh0UmVwLl9pc092ZXJyaWRkZW4gfHwgYWJzb2x1dGVUaW1lIDw9IHR3ZWVuTmV4dFJlcC5fYWJzb2x1dGVTdGFydFRpbWUpKSAmJlxuICAgICAgICAgICAgKCF0d2VlblByZXZSZXAgfHwgKHR3ZWVuUHJldlJlcC5faXNPdmVycmlkZGVuIHx8IChhYnNvbHV0ZVRpbWUgPj0gKHR3ZWVuUHJldlJlcC5fYWJzb2x1dGVTdGFydFRpbWUgKyB0d2VlblByZXZSZXAuX2NoYW5nZUR1cmF0aW9uKSArIHR3ZWVuLl9kZWxheSkpKVxuICAgICAgICAgICkpXG4gICAgICAgICkge1xuXG4gICAgICAgICAgY29uc3QgdHdlZW5OZXdUaW1lID0gdHdlZW4uX2N1cnJlbnRUaW1lID0gY2xhbXAoaXRlcmF0aW9uVGltZSAtIHR3ZWVuLl9zdGFydFRpbWUsIDAsIHR3ZWVuQ2hhbmdlRHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuUHJvZ3Jlc3MgPSB0d2Vlbi5fZWFzZSh0d2Vlbk5ld1RpbWUgLyB0d2Vlbi5fdXBkYXRlRHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuTW9kaWZpZXIgPSB0d2Vlbi5fbW9kaWZpZXI7XG4gICAgICAgICAgY29uc3QgdHdlZW5WYWx1ZVR5cGUgPSB0d2Vlbi5fdmFsdWVUeXBlO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuVHlwZSA9IHR3ZWVuLl90d2VlblR5cGU7XG4gICAgICAgICAgY29uc3QgdHdlZW5Jc09iamVjdCA9IHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5PQkpFQ1Q7XG4gICAgICAgICAgY29uc3QgdHdlZW5Jc051bWJlciA9IHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLk5VTUJFUjtcbiAgICAgICAgICAvLyBPbmx5IHJvdW5kIHRoZSBpbi1iZXR3ZWVuIGZyYW1lcyB2YWx1ZXMgaWYgdGhlIGZpbmFsIHZhbHVlIGlzIGEgc3RyaW5nXG4gICAgICAgICAgY29uc3QgdHdlZW5QcmVjaXNpb24gPSAodHdlZW5Jc051bWJlciAmJiB0d2VlbklzT2JqZWN0KSB8fCB0d2VlblByb2dyZXNzID09PSAwIHx8IHR3ZWVuUHJvZ3Jlc3MgPT09IDEgPyAtMSA6IGdsb2JhbHMucHJlY2lzaW9uO1xuXG4gICAgICAgICAgLy8gUmVjb21wb3NlIHR3ZWVuIHZhbHVlXG4gICAgICAgICAgLyoqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfSAqL1xuICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICAgICBsZXQgbnVtYmVyO1xuXG4gICAgICAgICAgaWYgKHR3ZWVuSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIocm91bmQoaW50ZXJwb2xhdGUodHdlZW4uX2Zyb21OdW1iZXIsIHR3ZWVuLl90b051bWJlciwgIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbiApKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0d2VlblZhbHVlVHlwZSA9PT0gdmFsdWVUeXBlcy5VTklUKSB7XG4gICAgICAgICAgICAvLyBSb3VuZGluZyB0aGUgdmFsdWVzIHNwZWVkIHVwIHN0cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgICAgbnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIocm91bmQoaW50ZXJwb2xhdGUodHdlZW4uX2Zyb21OdW1iZXIsIHR3ZWVuLl90b051bWJlciwgIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKTtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7bnVtYmVyfSR7dHdlZW4uX3VuaXR9YDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTE9SKSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHR3ZWVuLl9mcm9tTnVtYmVycztcbiAgICAgICAgICAgIGNvbnN0IHRuID0gdHdlZW4uX3RvTnVtYmVycztcbiAgICAgICAgICAgIGNvbnN0IHIgPSByb3VuZChjbGFtcCgvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihpbnRlcnBvbGF0ZShmblswXSwgdG5bMF0sIHR3ZWVuUHJvZ3Jlc3MpKSksIDAsIDI1NSksIDApO1xuICAgICAgICAgICAgY29uc3QgZyA9IHJvdW5kKGNsYW1wKC8qKiBAdHlwZSB7TnVtYmVyfSAqLyh0d2Vlbk1vZGlmaWVyKGludGVycG9sYXRlKGZuWzFdLCB0blsxXSwgdHdlZW5Qcm9ncmVzcykpKSwgMCwgMjU1KSwgMCk7XG4gICAgICAgICAgICBjb25zdCBiID0gcm91bmQoY2xhbXAoLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIoaW50ZXJwb2xhdGUoZm5bMl0sIHRuWzJdLCB0d2VlblByb2dyZXNzKSkpLCAwLCAyNTUpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBjbGFtcCgvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihyb3VuZChpbnRlcnBvbGF0ZShmblszXSwgdG5bM10sIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKSwgMCwgMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGByZ2JhKCR7cn0sJHtnfSwke2J9LCR7YX0pYDtcbiAgICAgICAgICAgIGlmICh0d2Vlbkhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5zID0gdHdlZW4uX251bWJlcnM7XG4gICAgICAgICAgICAgIG5zWzBdID0gcjtcbiAgICAgICAgICAgICAgbnNbMV0gPSBnO1xuICAgICAgICAgICAgICBuc1syXSA9IGI7XG4gICAgICAgICAgICAgIG5zWzNdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTVBMRVgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHdlZW4uX3N0cmluZ3NbMF07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbCA9IHR3ZWVuLl90b051bWJlcnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSAvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihyb3VuZChpbnRlcnBvbGF0ZSh0d2Vlbi5fZnJvbU51bWJlcnNbal0sIHR3ZWVuLl90b051bWJlcnNbal0sIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKTtcbiAgICAgICAgICAgICAgY29uc3QgcyA9IHR3ZWVuLl9zdHJpbmdzW2ogKyAxXTtcbiAgICAgICAgICAgICAgdmFsdWUgKz0gYCR7cyA/IG4gKyBzIDogbn1gO1xuICAgICAgICAgICAgICBpZiAodHdlZW5IYXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHR3ZWVuLl9udW1iZXJzW2pdID0gbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZvciBhZGRpdGl2ZSB0d2VlbnMgYW5kIEFuaW1hdGFibGVzXG4gICAgICAgICAgaWYgKHR3ZWVuSGFzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHR3ZWVuLl9udW1iZXIgPSBudW1iZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbnRlcm5hbFJlbmRlciAmJiB0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLmJsZW5kKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuUHJvcGVydHkgPSB0d2Vlbi5wcm9wZXJ0eTtcbiAgICAgICAgICAgIHR3ZWVuVGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAodHdlZW5Jc09iamVjdCkge1xuICAgICAgICAgICAgICB0d2VlblRhcmdldFt0d2VlblByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgIC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc2V0QXR0cmlidXRlKHR3ZWVuUHJvcGVydHksIC8qKiBAdHlwZSB7U3RyaW5nfSAqLyh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW5TdHlsZSA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc3R5bGU7XG4gICAgICAgICAgICAgIGlmICh0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR3ZWVuVGFyZ2V0ICE9PSB0d2VlblRhcmdldFRyYW5zZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgIHR3ZWVuVGFyZ2V0VHJhbnNmb3JtcyA9IHR3ZWVuVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgLy8gTk9URTogUmVmZXJlbmNpbmcgdGhlIGNhY2hlZFRyYW5zZm9ybXMgaW4gdGhlIHR3ZWVuIHByb3BlcnR5IGRpcmVjdGx5IGNhbiBiZSBhIGxpdHRsZSBiaXQgZmFzdGVyIGJ1dCBhcHBlYXJzIHRvIGluY3JlYXNlIG1lbW9yeSB1c2FnZS5cbiAgICAgICAgICAgICAgICAgIHR3ZWVuVGFyZ2V0VHJhbnNmb3Jtc1Byb3BlcnRpZXMgPSB0d2VlblRhcmdldFt0cmFuc2Zvcm1zU3ltYm9sXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHdlZW5UYXJnZXRUcmFuc2Zvcm1zUHJvcGVydGllc1t0d2VlblByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHR3ZWVuVHJhbnNmb3Jtc05lZWRVcGRhdGUgPSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5DU1MpIHtcbiAgICAgICAgICAgICAgICB0d2VlblN0eWxlW3R3ZWVuUHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLkNTU19WQVIpIHtcbiAgICAgICAgICAgICAgICB0d2VlblN0eWxlLnNldFByb3BlcnR5KHR3ZWVuUHJvcGVydHksLyoqIEB0eXBlIHtTdHJpbmd9ICovKHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQ3VycmVudFRpbWVBYm92ZVplcm8pIGhhc1JlbmRlcmVkID0gMTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2VkIGZvciBjb21wb3NpbmcgdGltZWxpbmUgdHdlZW5zIHdpdGhvdXQgaGF2aW5nIHRvIGRvIGEgcmVhbCByZW5kZXJcbiAgICAgICAgICAgIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTk9URTogUG9zc2libGUgaW1wcm92ZW1lbnQ6IFVzZSB0cmFuc2xhdGUoeCx5KSAvIHRyYW5zbGF0ZTNkKHgseSx6KSBzeW50YXhcbiAgICAgICAgLy8gdG8gcmVkdWNlIG1lbW9yeSB1c2FnZSBvbiBzdHJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgaWYgKHR3ZWVuVHJhbnNmb3Jtc05lZWRVcGRhdGUgJiYgdHdlZW4uX3JlbmRlclRyYW5zZm9ybXMpIHtcbiAgICAgICAgICBsZXQgc3RyID0gZW1wdHlTdHJpbmc7XG4gICAgICAgICAgZm9yIChsZXQga2V5IGluIHR3ZWVuVGFyZ2V0VHJhbnNmb3Jtc1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHN0ciArPSBgJHt0cmFuc2Zvcm1zRnJhZ21lbnRTdHJpbmdzW2tleV19JHt0d2VlblRhcmdldFRyYW5zZm9ybXNQcm9wZXJ0aWVzW2tleV19KSBgO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0d2VlblN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICAgICAgICB0d2VlblRyYW5zZm9ybXNOZWVkVXBkYXRlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHR3ZWVuID0gdHdlZW4uX25leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghbXV0ZUNhbGxiYWNrcyAmJiBoYXNSZW5kZXJlZCkge1xuICAgICAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqLyh0aWNrYWJsZSkub25SZW5kZXIoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8odGlja2FibGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgaXNDdXJyZW50VGltZUFib3ZlWmVybykge1xuICAgICAgdGlja2FibGUub25VcGRhdGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgIH1cblxuICB9XG5cbiAgLy8gRW5kIHR3ZWVucyByZW5kZXJpbmdcblxuICAvLyBIYW5kbGUgc2V0dGVycyBvbiB0aW1lbGluZSBkaWZmZXJlbnRseSBhbmQgYWxsb3cgcmUtdHJpZ2VyaW5nIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIHdoZW4gc2Vla2luZyBiYWNrd2FyZHNcbiAgaWYgKHBhcmVudCAmJiBpc1NldHRlcikge1xuICAgIGlmICghbXV0ZUNhbGxiYWNrcyAmJiAoXG4gICAgICAocGFyZW50LmJlZ2FuICYmICFpc1J1bm5pbmdCYWNrd2FyZHMgJiYgdGlja2FibGVBYnNvbHV0ZVRpbWUgPj0gZHVyYXRpb24gJiYgIWNvbXBsZXRlZCkgfHxcbiAgICAgIChpc1J1bm5pbmdCYWNrd2FyZHMgJiYgdGlja2FibGVBYnNvbHV0ZVRpbWUgPD0gbWluVmFsdWUgJiYgY29tcGxldGVkKVxuICAgICkpIHtcbiAgICAgIHRpY2thYmxlLm9uQ29tcGxldGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgICAgdGlja2FibGUuY29tcGxldGVkID0gIWlzUnVubmluZ0JhY2t3YXJkcztcbiAgICB9XG4gIC8vIElmIGN1cnJlbnRUaW1lIGlzIGJvdGggYWJvdmUgMCBhbmQgYXQgbGVhc3QgZXF1YWxzIHRvIGR1cmF0aW9uLCBoYW5kbGVzIG5vcm1hbCBvbkNvbXBsZXRlIG9yIGluZmluaXRlIGxvb3BzXG4gIH0gZWxzZSBpZiAoaXNDdXJyZW50VGltZUFib3ZlWmVybyAmJiBpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24pIHtcbiAgICBpZiAoaXRlcmF0aW9uQ291bnQgPT09IEluZmluaXR5KSB7XG4gICAgICAvLyBPZmZzZXQgdGhlIHRpY2thYmxlIF9zdGFydFRpbWUgd2l0aCBpdHMgZHVyYXRpb24gdG8gcmVzZXQgX2N1cnJlbnRUaW1lIHRvIDAgYW5kIGNvbnRpbnVlIHRoZSBpbmZpbml0ZSB0aW1lclxuICAgICAgdGlja2FibGUuX3N0YXJ0VGltZSArPSB0aWNrYWJsZS5kdXJhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uID49IGl0ZXJhdGlvbkNvdW50IC0gMSkge1xuICAgICAgLy8gQnkgc2V0dGluZyBwYXVzZWQgdG8gdHJ1ZSwgd2UgdGVsbCB0aGUgZW5naW5lIGxvb3AgdG8gbm90IHJlbmRlciB0aGlzIHRpY2thYmxlIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGxpc3Qgb24gdGhlIG5leHQgdGlja1xuICAgICAgdGlja2FibGUucGF1c2VkID0gdHJ1ZTtcbiAgICAgIGlmICghY29tcGxldGVkICYmICFfaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgLy8gSWYgdGhlIHRpY2thYmxlIGhhcyBjaGlsZHJlbiwgdHJpZ2dlcnMgb25Db21wbGV0ZSgpIG9ubHkgd2hlbiBhbGwgY2hpbGRyZW4gaGF2ZSBjb21wbGV0ZWQgaW4gdGhlIHRpY2sgZnVuY3Rpb25cbiAgICAgICAgdGlja2FibGUuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFtdXRlQ2FsbGJhY2tzICYmICEocGFyZW50ICYmIChpc1J1bm5pbmdCYWNrd2FyZHMgfHwgIXBhcmVudC5iZWdhbikpKSB7XG4gICAgICAgICAgdGlja2FibGUub25Db21wbGV0ZSgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRpY2thYmxlKSk7XG4gICAgICAgICAgdGlja2FibGUuX3Jlc29sdmUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBjb21wbGV0ZWQgZmxhZyB0byBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHRpY2thYmxlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gTk9URTogaGFzUmVuZGVyZWQgKiBkaXJlY3Rpb24gKG5lZ2F0aXZlIGZvciBiYWNrd2FyZHMpIHRoaXMgd2F5IHdlIGNhbiByZW1vdmUgdGhlIHRpY2thYmxlLmJhY2t3YXJkcyBwcm9wZXJ0eSBjb21wbGV0bHkgP1xuICByZXR1cm4gaGFzUmVuZGVyZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RpY2thYmxlfSB0aWNrYWJsZVxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG11dGVDYWxsYmFja3NcbiAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAqIEBwYXJhbSAge051bWJlcn0gdGlja01vZGVcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmNvbnN0IHRpY2sgPSAodGlja2FibGUsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZSkgPT4ge1xuICBjb25zdCBfY3VycmVudEl0ZXJhdGlvbiA9IHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uO1xuICByZW5kZXIodGlja2FibGUsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZSk7XG4gIGlmICh0aWNrYWJsZS5faGFzQ2hpbGRyZW4pIHtcbiAgICBjb25zdCB0bCA9IC8qKiBAdHlwZSB7VGltZWxpbmV9ICovKHRpY2thYmxlKTtcbiAgICBjb25zdCB0bElzUnVubmluZ0JhY2t3YXJkcyA9IHRsLmJhY2t3YXJkcztcbiAgICBjb25zdCB0bENoaWxkcmVuVGltZSA9IGludGVybmFsUmVuZGVyID8gdGltZSA6IHRsLl9pdGVyYXRpb25UaW1lO1xuICAgIGNvbnN0IHRsQ2lsZHJlblRpY2tUaW1lID0gbm93KCk7XG5cbiAgICBsZXQgdGxDaGlsZHJlbkhhc1JlbmRlcmVkID0gMDtcbiAgICBsZXQgdGxDaGlsZHJlbkhhdmVDb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgLy8gSWYgdGhlIHRpbWVsaW5lIGhhcyBsb29wZWQgZm9yd2FyZCwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VycyBjaGlsZHJlbiBza2lwcGVkIGNhbGxiYWNrc1xuICAgIGlmICghaW50ZXJuYWxSZW5kZXIgJiYgdGwuX2N1cnJlbnRJdGVyYXRpb24gIT09IF9jdXJyZW50SXRlcmF0aW9uKSB7XG4gICAgICBjb25zdCB0bEl0ZXJhdGlvbkR1cmF0aW9uID0gdGwuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGwsICgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL2NoaWxkKSA9PiB7XG4gICAgICAgIGlmICghdGxJc1J1bm5pbmdCYWNrd2FyZHMpIHtcbiAgICAgICAgICAvLyBGb3JjZSBhbiBpbnRlcm5hbCByZW5kZXIgdG8gdHJpZ2dlciB0aGUgY2FsbGJhY2tzIGlmIHRoZSBjaGlsZCBoYXMgbm90IGNvbXBsZXRlZCBvbiBsb29wXG4gICAgICAgICAgaWYgKCFjaGlsZC5jb21wbGV0ZWQgJiYgIWNoaWxkLmJhY2t3YXJkcyAmJiBjaGlsZC5fY3VycmVudFRpbWUgPCBjaGlsZC5pdGVyYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgcmVuZGVyKGNoaWxkLCB0bEl0ZXJhdGlvbkR1cmF0aW9uLCBtdXRlQ2FsbGJhY2tzLCAxLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGVpciBiZWdhbiBhbmQgY29tcGxldGVkIGZsYWdzIHRvIGFsbG93IHJldHJpZ2VyaW5nIGNhbGxiYWNrcyBvbiB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICBjaGlsZC5iZWdhbiA9IGZhbHNlO1xuICAgICAgICAgIGNoaWxkLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNoaWxkRHVyYXRpb24gPSBjaGlsZC5kdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBjaGlsZFN0YXJ0VGltZSA9IGNoaWxkLl9vZmZzZXQgKyBjaGlsZC5fZGVsYXk7XG4gICAgICAgICAgY29uc3QgY2hpbGRFbmRUaW1lID0gY2hpbGRTdGFydFRpbWUgKyBjaGlsZER1cmF0aW9uO1xuICAgICAgICAgIC8vIFRyaWdnZXJzIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIG9uIHJldmVyc2UgZm9yIGNoaWxkcmVuIG9uIHRoZSBlZGdlcyBvZiB0aGUgdGltZWxpbmVcbiAgICAgICAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgY2hpbGREdXJhdGlvbiA8PSBtaW5WYWx1ZSAmJiAoIWNoaWxkU3RhcnRUaW1lIHx8IGNoaWxkRW5kVGltZSA9PT0gdGxJdGVyYXRpb25EdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGNoaWxkLm9uQ29tcGxldGUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIW11dGVDYWxsYmFja3MpIHRsLm9uTG9vcCgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG4gICAgfVxuXG4gICAgZm9yRWFjaENoaWxkcmVuKHRsLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRUaW1lID0gcm91bmQoKHRsQ2hpbGRyZW5UaW1lIC0gY2hpbGQuX29mZnNldCkgKiBjaGlsZC5fc3BlZWQsIDEyKTsgLy8gUm91bmRpbmcgaXMgbmVlZGVkIHdoZW4gdXNpbmcgc2Vjb25kc1xuICAgICAgY29uc3QgY2hpbGRUaWNrTW9kZSA9IGNoaWxkLl9mcHMgPCB0bC5fZnBzID8gY2hpbGQucmVxdWVzdFRpY2sodGxDaWxkcmVuVGlja1RpbWUpIDogdGlja01vZGU7XG4gICAgICB0bENoaWxkcmVuSGFzUmVuZGVyZWQgKz0gcmVuZGVyKGNoaWxkLCBjaGlsZFRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCBjaGlsZFRpY2tNb2RlKTtcbiAgICAgIGlmICghY2hpbGQuY29tcGxldGVkICYmIHRsQ2hpbGRyZW5IYXZlQ29tcGxldGVkKSB0bENoaWxkcmVuSGF2ZUNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH0sIHRsSXNSdW5uaW5nQmFja3dhcmRzKTtcblxuICAgIC8vIFJlbmRlcnMgb24gdGltZWxpbmUgYXJlIHRyaWdnZXJlZCBieSBpdHMgY2hpbGRyZW4gc28gaXQgbmVlZHMgdG8gYmUgc2V0IGFmdGVyIHJlbmRlcmluZyB0aGUgY2hpbGRyZW5cbiAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgdGxDaGlsZHJlbkhhc1JlbmRlcmVkKSB0bC5vblJlbmRlcigvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG5cbiAgICAvLyBUcmlnZ2VycyB0aGUgdGltZWxpbmUgb25Db21wbGV0ZSgpIG9uY2UgYWxsIGNoaW5kcmVuIGFsbCBjb21wbGV0ZWQgYW5kIHRoZSBjdXJyZW50IHRpbWUgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgIGlmICgodGxDaGlsZHJlbkhhdmVDb21wbGV0ZWQgfHwgdGxJc1J1bm5pbmdCYWNrd2FyZHMpICYmIHRsLl9jdXJyZW50VGltZSA+PSB0bC5kdXJhdGlvbikge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXVzZWQgZmxhZyBpcyBmYWxzZSBpbiBjYXNlIGl0IGhhcyBiZWVuIHNraXBwZWQgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgICAgdGwucGF1c2VkID0gdHJ1ZTtcbiAgICAgIGlmICghdGwuY29tcGxldGVkKSB7XG4gICAgICAgIHRsLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICghbXV0ZUNhbGxiYWNrcykge1xuICAgICAgICAgIHRsLm9uQ29tcGxldGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0bCkpO1xuICAgICAgICAgIHRsLl9yZXNvbHZlKC8qKiBAdHlwZSB7Q2FsbGJhY2tBcmd1bWVudH0gKi8odGwpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG5cblxuY29uc3QgYWRkaXRpdmUgPSB7XG4gIGFuaW1hdGlvbjogbnVsbCxcbiAgdXBkYXRlOiBub29wLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBBZGRpdGl2ZUFuaW1hdGlvblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGR1cmF0aW9uXG4gKiBAcHJvcGVydHkge051bWJlcn0gX29mZnNldFxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9kZWxheVxuICogQHByb3BlcnR5IHtUd2Vlbn0gX2hlYWRcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF90YWlsXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gIHtUd2VlbkFkZGl0aXZlTG9va3Vwc30gbG9va3Vwc1xuICogQHJldHVybiB7QWRkaXRpdmVBbmltYXRpb259XG4gKi9cbmNvbnN0IGFkZEFkZGl0aXZlQW5pbWF0aW9uID0gbG9va3VwcyA9PiB7XG4gIGxldCBhbmltYXRpb24gPSBhZGRpdGl2ZS5hbmltYXRpb247XG4gIGlmICghYW5pbWF0aW9uKSB7XG4gICAgYW5pbWF0aW9uID0ge1xuICAgICAgZHVyYXRpb246IG1pblZhbHVlLFxuICAgICAgY29tcHV0ZURlbHRhVGltZTogbm9vcCxcbiAgICAgIF9vZmZzZXQ6IDAsXG4gICAgICBfZGVsYXk6IDAsXG4gICAgICBfaGVhZDogbnVsbCxcbiAgICAgIF90YWlsOiBudWxsLFxuICAgIH07XG4gICAgYWRkaXRpdmUuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgIGFkZGl0aXZlLnVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGxvb2t1cHMuZm9yRWFjaChwcm9wZXJ0eUFuaW1hdGlvbiA9PiB7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0eUFuaW1hdGlvbikge1xuICAgICAgICAgIGNvbnN0IHR3ZWVucyA9IHByb3BlcnR5QW5pbWF0aW9uW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgY29uc3QgbG9va3VwVHdlZW4gPSB0d2VlbnMuX2hlYWQ7XG4gICAgICAgICAgaWYgKGxvb2t1cFR3ZWVuKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBsb29rdXBUd2Vlbi5fdmFsdWVUeXBlO1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpdmVWYWx1ZXMgPSB2YWx1ZVR5cGUgPT09IHZhbHVlVHlwZXMuQ09NUExFWCB8fCB2YWx1ZVR5cGUgPT09IHZhbHVlVHlwZXMuQ09MT1IgPyBjbG9uZUFycmF5KGxvb2t1cFR3ZWVuLl9mcm9tTnVtYmVycykgOiBudWxsO1xuICAgICAgICAgICAgbGV0IGFkZGl0aXZlVmFsdWUgPSBsb29rdXBUd2Vlbi5fZnJvbU51bWJlcjtcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHR3ZWVucy5fdGFpbDtcbiAgICAgICAgICAgIHdoaWxlICh0d2VlbiAmJiB0d2VlbiAhPT0gbG9va3VwVHdlZW4pIHtcbiAgICAgICAgICAgICAgaWYgKGFkZGl0aXZlVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0d2Vlbi5fbnVtYmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIGFkZGl0aXZlVmFsdWVzW2ldICs9IHR3ZWVuLl9udW1iZXJzW2ldO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZGl0aXZlVmFsdWUgKz0gdHdlZW4uX251bWJlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0d2VlbiA9IHR3ZWVuLl9wcmV2QWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9va3VwVHdlZW4uX3RvTnVtYmVyID0gYWRkaXRpdmVWYWx1ZTtcbiAgICAgICAgICAgIGxvb2t1cFR3ZWVuLl90b051bWJlcnMgPSBhZGRpdGl2ZVZhbHVlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gVE9ETzogQXZvaWQgcG9seW1vcnBoaXNtIGhlcmUsIGlkZWFseSB0aGUgYWRkaXRpdmUgYW5pbWF0aW9uIHNob3VsZCBiZSBhIHJlZ3VsYXIgYW5pbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJpb3JpdHkgaW4gdGhlIHJlbmRlciBsb29wXG4gICAgICByZW5kZXIoYW5pbWF0aW9uLCAxLCAxLCAwLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn07XG5cbmNvbnN0IGVuZ2luZVRpY2tNZXRob2QgPSAvKiNfX1BVUkVfXyovICgoKSA9PiBpc0Jyb3dzZXIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRJbW1lZGlhdGUpKCk7XG5jb25zdCBlbmdpbmVDYW5jZWxNZXRob2QgPSAvKiNfX1BVUkVfXyovICgoKSA9PiBpc0Jyb3dzZXIgPyBjYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFySW1tZWRpYXRlKSgpO1xuXG5jbGFzcyBFbmdpbmUgZXh0ZW5kcyBDbG9jayB7XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBbaW5pdFRpbWVdICovXG4gIGNvbnN0cnVjdG9yKGluaXRUaW1lKSB7XG4gICAgc3VwZXIoaW5pdFRpbWUpO1xuICAgIHRoaXMudXNlRGVmYXVsdE1haW5Mb29wID0gdHJ1ZTtcbiAgICB0aGlzLnBhdXNlT25Eb2N1bWVudEhpZGRlbiA9IHRydWU7XG4gICAgLyoqIEB0eXBlIHtEZWZhdWx0c1BhcmFtc30gKi9cbiAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgLy8gdGhpcy5wYXVzZWQgPSBpc0Jyb3dzZXIgJiYgZG9jLmhpZGRlbiA/IHRydWUgIDogZmFsc2U7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfE5vZGVKUy5JbW1lZGlhdGV9ICovXG4gICAgdGhpcy5yZXFJZCA9IDA7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMuX2N1cnJlbnRUaW1lID0gbm93KCk7XG4gICAgaWYgKHRoaXMucmVxdWVzdFRpY2sodGltZSkpIHtcbiAgICAgIHRoaXMuY29tcHV0ZURlbHRhVGltZSh0aW1lKTtcbiAgICAgIGNvbnN0IGVuZ2luZVNwZWVkID0gdGhpcy5fc3BlZWQ7XG4gICAgICBjb25zdCBlbmdpbmVGcHMgPSB0aGlzLl9mcHM7XG4gICAgICBsZXQgYWN0aXZlVGlja2FibGUgPSAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0aGlzLl9oZWFkKTtcbiAgICAgIHdoaWxlIChhY3RpdmVUaWNrYWJsZSkge1xuICAgICAgICBjb25zdCBuZXh0VGlja2FibGUgPSBhY3RpdmVUaWNrYWJsZS5fbmV4dDtcbiAgICAgICAgaWYgKCFhY3RpdmVUaWNrYWJsZS5wYXVzZWQpIHtcbiAgICAgICAgICB0aWNrKFxuICAgICAgICAgICAgYWN0aXZlVGlja2FibGUsXG4gICAgICAgICAgICAodGltZSAtIGFjdGl2ZVRpY2thYmxlLl9zdGFydFRpbWUpICogYWN0aXZlVGlja2FibGUuX3NwZWVkICogZW5naW5lU3BlZWQsXG4gICAgICAgICAgICAwLCAvLyAhbXV0ZUNhbGxiYWNrc1xuICAgICAgICAgICAgMCwgLy8gIWludGVybmFsUmVuZGVyXG4gICAgICAgICAgICBhY3RpdmVUaWNrYWJsZS5fZnBzIDwgZW5naW5lRnBzID8gYWN0aXZlVGlja2FibGUucmVxdWVzdFRpY2sodGltZSkgOiB0aWNrTW9kZXMuQVVUT1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQodGhpcywgYWN0aXZlVGlja2FibGUpO1xuICAgICAgICAgIHRoaXMuX2hhc0NoaWxkcmVuID0gISF0aGlzLl90YWlsO1xuICAgICAgICAgIGFjdGl2ZVRpY2thYmxlLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGFjdGl2ZVRpY2thYmxlLmNvbXBsZXRlZCAmJiAhYWN0aXZlVGlja2FibGUuX2NhbmNlbGxlZCkge1xuICAgICAgICAgICAgYWN0aXZlVGlja2FibGUuY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVRpY2thYmxlID0gbmV4dFRpY2thYmxlO1xuICAgICAgfVxuICAgICAgYWRkaXRpdmUudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgd2FrZSgpIHtcbiAgICBpZiAodGhpcy51c2VEZWZhdWx0TWFpbkxvb3AgJiYgIXRoaXMucmVxSWQpIHtcbiAgICAgIC8vIEltZWRpYXRseSByZXF1ZXN0IGEgdGljayB0byB1cGRhdGUgZW5naW5lLl9lbGFwc2VkVGltZSBhbmQgZ2V0IGFjY3VyYXRlIG9mZnNldFBvc2l0aW9uIGNhbGN1bGF0aW9uIGluIHRpbWVyLmpzXG4gICAgICB0aGlzLnJlcXVlc3RUaWNrKG5vdygpKTtcbiAgICAgIHRoaXMucmVxSWQgPSBlbmdpbmVUaWNrTWV0aG9kKHRpY2tFbmdpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIGlmICghdGhpcy5yZXFJZCkgcmV0dXJuO1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICByZXR1cm4ga2lsbEVuZ2luZSgpO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHJldHVybjtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtUaWNrYWJsZX0gKi9jaGlsZCkgPT4gY2hpbGQucmVzZXRUaW1lKCkpO1xuICAgIHJldHVybiB0aGlzLndha2UoKTtcbiAgfVxuXG4gIC8vIEdldHRlciBhbmQgc2V0dGVyIGZvciBzcGVlZFxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwZWVkICogKGdsb2JhbHMudGltZVNjYWxlID09PSAxID8gMSA6IEspO1xuICB9XG5cbiAgc2V0IHNwZWVkKHBsYXliYWNrUmF0ZSkge1xuICAgIHRoaXMuX3NwZWVkID0gcGxheWJhY2tSYXRlICogZ2xvYmFscy50aW1lU2NhbGU7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1RpY2thYmxlfSAqL2NoaWxkKSA9PiBjaGlsZC5zcGVlZCA9IGNoaWxkLl9zcGVlZCk7XG4gIH1cblxuICAvLyBHZXR0ZXIgYW5kIHNldHRlciBmb3IgdGltZVVuaXRcbiAgZ2V0IHRpbWVVbml0KCkge1xuICAgIHJldHVybiBnbG9iYWxzLnRpbWVTY2FsZSA9PT0gMSA/ICdtcycgOiAncyc7XG4gIH07XG5cbiAgc2V0IHRpbWVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBzZWNvbmRzU2NhbGUgPSAwLjAwMTtcbiAgICBjb25zdCBpc1NlY29uZCA9IHVuaXQgPT09ICdzJztcbiAgICBjb25zdCBuZXdTY2FsZSA9IGlzU2Vjb25kID8gc2Vjb25kc1NjYWxlIDogMTtcbiAgICBpZiAoZ2xvYmFscy50aW1lU2NhbGUgIT09IG5ld1NjYWxlKSB7XG4gICAgICBnbG9iYWxzLnRpbWVTY2FsZSA9IG5ld1NjYWxlO1xuICAgICAgZ2xvYmFscy50aWNrVGhyZXNob2xkID0gMjAwICogbmV3U2NhbGU7XG4gICAgICBjb25zdCBzY2FsZUZhY3RvciA9IGlzU2Vjb25kID8gc2Vjb25kc1NjYWxlIDogSztcbiAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgICAgKHRoaXMuZGVmYXVsdHMuZHVyYXRpb24pICo9IHNjYWxlRmFjdG9yO1xuICAgICAgdGhpcy5fc3BlZWQgKj0gc2NhbGVGYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHByZWNpc2lvblxuICBnZXQgcHJlY2lzaW9uKCkge1xuICAgIHJldHVybiBnbG9iYWxzLnByZWNpc2lvbjtcbiAgfVxuXG4gIHNldCBwcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgZ2xvYmFscy5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gIH1cblxufVxuY29uc3QgZW5naW5lID0gLyojX19QVVJFX18qLygoKSA9PiB7XG4gIGNvbnN0IGVuZ2luZSA9IG5ldyBFbmdpbmUobm93KCkpO1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgZ2xvYmFsVmVyc2lvbnMuZW5naW5lID0gZW5naW5lO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgaWYgKCFlbmdpbmUucGF1c2VPbkRvY3VtZW50SGlkZGVuKSByZXR1cm47XG4gICAgICBkb2MuaGlkZGVuID8gZW5naW5lLnBhdXNlKCkgOiBlbmdpbmUucmVzdW1lKCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuZ2luZTtcbn0pKCk7XG5cblxuY29uc3QgdGlja0VuZ2luZSA9ICgpID0+IHtcbiAgaWYgKGVuZ2luZS5faGVhZCkge1xuICAgIGVuZ2luZS5yZXFJZCA9IGVuZ2luZVRpY2tNZXRob2QodGlja0VuZ2luZSk7XG4gICAgZW5naW5lLnVwZGF0ZSgpO1xuICB9IGVsc2Uge1xuICAgIGVuZ2luZS5yZXFJZCA9IDA7XG4gIH1cbn07XG5cbmNvbnN0IGtpbGxFbmdpbmUgPSAoKSA9PiB7XG4gIGVuZ2luZUNhbmNlbE1ldGhvZCgvKiogQHR5cGUge05vZGVKUy5JbW1lZGlhdGUgJiBOdW1iZXJ9ICovKGVuZ2luZS5yZXFJZCkpO1xuICBlbmdpbmUucmVxSWQgPSAwO1xuICByZXR1cm4gZW5naW5lO1xufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtET01UYXJnZXR9IHRhcmdldFxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBhbmltYXRpb25JbmxpbmVTdHlsZXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3QgcGFyc2VJbmxpbmVUcmFuc2Zvcm1zID0gKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgPT4ge1xuICBjb25zdCBpbmxpbmVUcmFuc2Zvcm1zID0gdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybTtcbiAgbGV0IGlubGluZWRTdHlsZXNQcm9wZXJ0eVZhbHVlO1xuICBpZiAoaW5saW5lVHJhbnNmb3Jtcykge1xuICAgIGNvbnN0IGNhY2hlZFRyYW5zZm9ybXMgPSB0YXJnZXRbdHJhbnNmb3Jtc1N5bWJvbF07XG4gICAgbGV0IHQ7IHdoaWxlICh0ID0gdHJhbnNmb3Jtc0V4ZWNSZ3guZXhlYyhpbmxpbmVUcmFuc2Zvcm1zKSkge1xuICAgICAgY29uc3QgaW5saW5lUHJvcGVydHlOYW1lID0gdFsxXTtcbiAgICAgIC8vIGNvbnN0IGlubGluZVByb3BlcnR5VmFsdWUgPSB0WzJdO1xuICAgICAgY29uc3QgaW5saW5lUHJvcGVydHlWYWx1ZSA9IHRbMl0uc2xpY2UoMSwgLTEpO1xuICAgICAgY2FjaGVkVHJhbnNmb3Jtc1tpbmxpbmVQcm9wZXJ0eU5hbWVdID0gaW5saW5lUHJvcGVydHlWYWx1ZTtcbiAgICAgIGlmIChpbmxpbmVQcm9wZXJ0eU5hbWUgPT09IHByb3BOYW1lKSB7XG4gICAgICAgIGlubGluZWRTdHlsZXNQcm9wZXJ0eVZhbHVlID0gaW5saW5lUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIG5ldyBwYXJzZWQgaW5saW5lIHN0eWxlcyBpZiBhbmltYXRpb25JbmxpbmVTdHlsZXMgaXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFuaW1hdGlvbklubGluZVN0eWxlcykge1xuICAgICAgICAgIGFuaW1hdGlvbklubGluZVN0eWxlc1twcm9wTmFtZV0gPSBpbmxpbmVQcm9wZXJ0eVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmxpbmVUcmFuc2Zvcm1zICYmICFpc1VuZChpbmxpbmVkU3R5bGVzUHJvcGVydHlWYWx1ZSkgPyBpbmxpbmVkU3R5bGVzUHJvcGVydHlWYWx1ZSA6XG4gICAgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3NjYWxlJykgPyAnMScgOlxuICAgIHN0cmluZ1N0YXJ0c1dpdGgocHJvcE5hbWUsICdyb3RhdGUnKSB8fCBzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAnc2tldycpID8gJzBkZWcnIDogJzBweCc7XG59O1xuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge0RPTVRhcmdldHNQYXJhbXxUYXJnZXRzUGFyYW19IHZcbiAqIEByZXR1cm4ge05vZGVMaXN0fEhUTUxDb2xsZWN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXROb2RlTGlzdCh2KSB7XG4gIGNvbnN0IG4gPSBpc1N0cih2KSA/IHNjb3BlLnJvb3QucXVlcnlTZWxlY3RvckFsbCh2KSA6IHY7XG4gIGlmIChuIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgbiBpbnN0YW5jZW9mIEhUTUxDb2xsZWN0aW9uKSByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0RPTVRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHJldHVybiB7RE9NVGFyZ2V0c0FycmF5fVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7SlNUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEByZXR1cm4ge0pTVGFyZ2V0c0FycmF5fVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcmV0dXJuIHtUYXJnZXRzQXJyYXl9XG4gKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfEpTVGFyZ2V0c1BhcmFtfFRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICovXG5mdW5jdGlvbiBwYXJzZVRhcmdldHModGFyZ2V0cykge1xuICBpZiAoaXNOaWwodGFyZ2V0cykpIHJldHVybiAvKiogQHR5cGUge1RhcmdldHNBcnJheX0gKi8oW10pO1xuICBpZiAoIWlzQnJvd3NlcikgcmV0dXJuIC8qKiBAdHlwZSB7SlNUYXJnZXRzQXJyYXl9ICovKGlzQXJyKHRhcmdldHMpICYmIHRhcmdldHMuZmxhdChJbmZpbml0eSkgfHwgW3RhcmdldHNdKTtcbiAgaWYgKGlzQXJyKHRhcmdldHMpKSB7XG4gICAgY29uc3QgZmxhdHRlbmVkID0gdGFyZ2V0cy5mbGF0KEluZmluaXR5KTtcbiAgICAvKiogQHR5cGUge1RhcmdldHNBcnJheX0gKi9cbiAgICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGZsYXR0ZW5lZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBmbGF0dGVuZWRbaV07XG4gICAgICBpZiAoIWlzTmlsKGl0ZW0pKSB7XG4gICAgICAgIGNvbnN0IG5vZGVMaXN0ID0gZ2V0Tm9kZUxpc3QoaXRlbSk7XG4gICAgICAgIGlmIChub2RlTGlzdCkge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG5vZGVMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Ykl0ZW0gPSBub2RlTGlzdFtqXTtcbiAgICAgICAgICAgIGlmICghaXNOaWwoc3ViSXRlbSkpIHtcbiAgICAgICAgICAgICAgbGV0IGlzRHVwbGljYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwLCBrbCA9IHBhcnNlZC5sZW5ndGg7IGsgPCBrbDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFtrXSA9PT0gc3ViSXRlbSkge1xuICAgICAgICAgICAgICAgICAgaXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucHVzaChzdWJJdGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaXNEdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBwYXJzZWQubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnNlZFtqXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICBpc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICAgICAgICBwYXJzZWQucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBjb25zdCBub2RlTGlzdCA9IGdldE5vZGVMaXN0KHRhcmdldHMpO1xuICBpZiAobm9kZUxpc3QpIHJldHVybiAvKiogQHR5cGUge0RPTVRhcmdldHNBcnJheX0gKi8oQXJyYXkuZnJvbShub2RlTGlzdCkpO1xuICByZXR1cm4gLyoqIEB0eXBlIHtUYXJnZXRzQXJyYXl9ICovKFt0YXJnZXRzXSk7XG59XG5cbi8qKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtET01UYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEByZXR1cm4ge0RPTVRhcmdldHNBcnJheX1cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0pTVGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcmV0dXJuIHtKU1RhcmdldHNBcnJheX1cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHJldHVybiB7VGFyZ2V0c0FycmF5fVxuICpcbiAqIEBwYXJhbSAge0RPTVRhcmdldHNQYXJhbXxKU1RhcmdldHNQYXJhbXxUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJUYXJnZXRzKHRhcmdldHMpIHtcbiAgY29uc3QgcGFyc2VkVGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICBjb25zdCBwYXJzZWRUYXJnZXRzTGVuZ3RoID0gcGFyc2VkVGFyZ2V0c0FycmF5Lmxlbmd0aDtcbiAgaWYgKHBhcnNlZFRhcmdldHNMZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZFRhcmdldHNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VkVGFyZ2V0c0FycmF5W2ldO1xuICAgICAgaWYgKCF0YXJnZXRbaXNSZWdpc3RlcmVkVGFyZ2V0U3ltYm9sXSkge1xuICAgICAgICB0YXJnZXRbaXNSZWdpc3RlcmVkVGFyZ2V0U3ltYm9sXSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGlzU3ZnVHlwZSA9IGlzU3ZnKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzRG9tID0gLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCkubm9kZVR5cGUgfHwgaXNTdmdUeXBlO1xuICAgICAgICBpZiAoaXNEb20pIHtcbiAgICAgICAgICB0YXJnZXRbaXNEb21TeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgICB0YXJnZXRbaXNTdmdTeW1ib2xdID0gaXNTdmdUeXBlO1xuICAgICAgICAgIHRhcmdldFt0cmFuc2Zvcm1zU3ltYm9sXSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJzZWRUYXJnZXRzQXJyYXk7XG59XG5cblxuXG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSBwYXRoXG4gKiBAcmV0dXJuIHtTVkdHZW9tZXRyeUVsZW1lbnR8dW5kZWZpbmVkfVxuICovXG5jb25zdCBnZXRQYXRoID0gcGF0aCA9PiB7XG4gIGNvbnN0IHBhcnNlZFRhcmdldHMgPSBwYXJzZVRhcmdldHMocGF0aCk7XG4gIGNvbnN0ICRwYXJzZWRTdmcgPSAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8ocGFyc2VkVGFyZ2V0c1swXSk7XG4gIGlmICghJHBhcnNlZFN2ZyB8fCAhaXNTdmcoJHBhcnNlZFN2ZykpIHJldHVybjtcbiAgcmV0dXJuICRwYXJzZWRTdmc7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gcGF0aDJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9uVmFsdWV9XG4gKi9cbmNvbnN0IG1vcnBoVG8gPSAocGF0aDIsIHByZWNpc2lvbiA9IC4zMykgPT4gKCRwYXRoMSkgPT4ge1xuICBjb25zdCAkcGF0aDIgPSAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oZ2V0UGF0aChwYXRoMikpO1xuICBpZiAoISRwYXRoMikgcmV0dXJuO1xuICBjb25zdCBpc1BhdGggPSAkcGF0aDEudGFnTmFtZSA9PT0gJ3BhdGgnO1xuICBjb25zdCBzZXBhcmF0b3IgPSBpc1BhdGggPyAnICcgOiAnLCc7XG4gIGNvbnN0IHByZXZpb3VzUG9pbnRzID0gJHBhdGgxW21vcnBoUG9pbnRzU3ltYm9sXTtcbiAgaWYgKHByZXZpb3VzUG9pbnRzKSAkcGF0aDEuc2V0QXR0cmlidXRlKGlzUGF0aCA/ICdkJyA6ICdwb2ludHMnLCBwcmV2aW91c1BvaW50cyk7XG5cbiAgbGV0IHYxID0gJycsIHYyID0gJyc7XG5cbiAgaWYgKCFwcmVjaXNpb24pIHtcbiAgICB2MSA9ICRwYXRoMS5nZXRBdHRyaWJ1dGUoaXNQYXRoID8gJ2QnIDogJ3BvaW50cycpO1xuICAgIHYyID0gJHBhdGgyLmdldEF0dHJpYnV0ZShpc1BhdGggPyAnZCcgOiAncG9pbnRzJyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVuZ3RoMSA9IC8qKiBAdHlwZSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAqLygkcGF0aDEpLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgY29uc3QgbGVuZ3RoMiA9ICRwYXRoMi5nZXRUb3RhbExlbmd0aCgpO1xuICAgIGNvbnN0IG1heFBvaW50cyA9IE1hdGgubWF4KE1hdGguY2VpbChsZW5ndGgxICogcHJlY2lzaW9uKSwgTWF0aC5jZWlsKGxlbmd0aDIgKiBwcmVjaXNpb24pKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFBvaW50czsgaSsrKSB7XG4gICAgICBjb25zdCB0ID0gaSAvIChtYXhQb2ludHMgLSAxKTtcbiAgICAgIGNvbnN0IHBvaW50T25QYXRoMSA9IC8qKiBAdHlwZSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAqLygkcGF0aDEpLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoMSAqIHQpO1xuICAgICAgY29uc3QgcG9pbnRPblBhdGgyID0gJHBhdGgyLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoMiAqIHQpO1xuICAgICAgY29uc3QgcHJlZml4ID0gaXNQYXRoID8gKGkgPT09IDAgPyAnTScgOiAnTCcpIDogJyc7XG4gICAgICB2MSArPSBwcmVmaXggKyByb3VuZChwb2ludE9uUGF0aDEueCwgMykgKyBzZXBhcmF0b3IgKyBwb2ludE9uUGF0aDEueSArICcgJztcbiAgICAgIHYyICs9IHByZWZpeCArIHJvdW5kKHBvaW50T25QYXRoMi54LCAzKSArIHNlcGFyYXRvciArIHBvaW50T25QYXRoMi55ICsgJyAnO1xuICAgIH1cbiAgfVxuXG4gICRwYXRoMVttb3JwaFBvaW50c1N5bWJvbF0gPSB2MjtcblxuICByZXR1cm4gW3YxLCB2Ml07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U1ZHR2VvbWV0cnlFbGVtZW50fSBbJGVsXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBnZXRTY2FsZUZhY3RvciA9ICRlbCA9PiB7XG4gIGxldCBzY2FsZUZhY3RvciA9IDE7XG4gIGlmICgkZWwgJiYgJGVsLmdldENUTSkge1xuICAgIGNvbnN0IGN0bSA9ICRlbC5nZXRDVE0oKTtcbiAgICBpZiAoY3RtKSB7XG4gICAgICBjb25zdCBzY2FsZVggPSBzcXJ0KGN0bS5hICogY3RtLmEgKyBjdG0uYiAqIGN0bS5iKTtcbiAgICAgIGNvbnN0IHNjYWxlWSA9IHNxcnQoY3RtLmMgKiBjdG0uYyArIGN0bS5kICogY3RtLmQpO1xuICAgICAgc2NhbGVGYWN0b3IgPSAoc2NhbGVYICsgc2NhbGVZKSAvIDI7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY2FsZUZhY3Rvcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb3h5IHRoYXQgd3JhcHMgYW4gU1ZHR2VvbWV0cnlFbGVtZW50IGFuZCBhZGRzIGRyYXdpbmcgZnVuY3Rpb25hbGl0eS5cbiAqIEBwYXJhbSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAkZWwgLSBUaGUgU1ZHIGVsZW1lbnQgdG8gdHJhbnNmb3JtIGludG8gYSBkcmF3YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gU3RhcnRpbmcgcG9zaXRpb24gKDAtMSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBFbmRpbmcgcG9zaXRpb24gKDAtMSlcbiAqIEByZXR1cm4ge0RyYXdhYmxlU1ZHR2VvbWV0cnl9IC0gUmV0dXJucyBhIHByb3h5IHRoYXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBlbGVtZW50J3MgdHlwZSB3aXRoIGFkZGl0aW9uYWwgJ2RyYXcnIGF0dHJpYnV0ZSBmdW5jdGlvbmFsaXR5XG4gKi9cbmNvbnN0IGNyZWF0ZURyYXdhYmxlUHJveHkgPSAoJGVsLCBzdGFydCwgZW5kKSA9PiB7XG4gIGNvbnN0IHBhdGhMZW5ndGggPSBLO1xuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoJGVsKTtcbiAgY29uc3Qgc3Ryb2tlTGluZUNhcCA9IGNvbXB1dGVkU3R5bGVzLnN0cm9rZUxpbmVjYXA7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgJHNjYWxsZWQgPSBjb21wdXRlZFN0eWxlcy52ZWN0b3JFZmZlY3QgPT09ICdub24tc2NhbGluZy1zdHJva2UnID8gJGVsIDogbnVsbDtcbiAgbGV0IGN1cnJlbnRDYXAgPSBzdHJva2VMaW5lQ2FwO1xuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KCRlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtwcm9wZXJ0eV07XG4gICAgICBpZiAocHJvcGVydHkgPT09IHByb3h5VGFyZ2V0U3ltYm9sKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgaWYgKHByb3BlcnR5ID09PSAnc2V0QXR0cmlidXRlJykge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICBpZiAoYXJnc1swXSA9PT0gJ2RyYXcnKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgY29uc3QgdjEgPSArdmFsdWVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdjIgPSArdmFsdWVzWzFdO1xuICAgICAgICAgICAgLy8gVE9UTzogQmVuY2htYXJrIGlmIHBlcmZvcm1pbmcgdHdvIHNsaWNlcyBpcyBtb3JlIHBlcmZvcm1hbnQgdGhhbiBvbmUgc3BsaXRcbiAgICAgICAgICAgIC8vIGNvbnN0IHNwYWNlSW5kZXggPSB2YWx1ZS5pbmRleE9mKCcgJyk7XG4gICAgICAgICAgICAvLyBjb25zdCB2MSA9IHJvdW5kKCt2YWx1ZS5zbGljZSgwLCBzcGFjZUluZGV4KSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IHYyID0gcm91bmQoK3ZhbHVlLnNsaWNlKHNwYWNlSW5kZXggKyAxKSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gZ2V0U2NhbGVGYWN0b3IoJHNjYWxsZWQpO1xuICAgICAgICAgICAgY29uc3Qgb3MgPSB2MSAqIC1wYXRoTGVuZ3RoICogc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICBjb25zdCBkMSA9ICh2MiAqIHBhdGhMZW5ndGggKiBzY2FsZUZhY3RvcikgKyBvcztcbiAgICAgICAgICAgIGNvbnN0IGQyID0gKHBhdGhMZW5ndGggKiBzY2FsZUZhY3RvciArXG4gICAgICAgICAgICAgICAgICAgICAgKCh2MSA9PT0gMCAmJiB2MiA9PT0gMSkgfHwgKHYxID09PSAxICYmIHYyID09PSAwKSA/IDAgOiAxMCAqIHNjYWxlRmFjdG9yKSAtIGQxKTtcbiAgICAgICAgICAgIGlmIChzdHJva2VMaW5lQ2FwICE9PSAnYnV0dCcpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3Q2FwID0gdjEgPT09IHYyID8gJ2J1dHQnIDogc3Ryb2tlTGluZUNhcDtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDYXAgIT09IG5ld0NhcCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5zdHJva2VMaW5lY2FwID0gYCR7bmV3Q2FwfWA7XG4gICAgICAgICAgICAgICAgY3VycmVudENhcCA9IG5ld0NhcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBgJHtvc31gKTtcbiAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBgJHtkMX0gJHtkMn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodmFsdWUsIHRhcmdldCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZuYyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBSZWZsZWN0LmFwcGx5KHZhbHVlLCB0YXJnZXQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCRlbC5nZXRBdHRyaWJ1dGUoJ3BhdGhMZW5ndGgnKSAhPT0gYCR7cGF0aExlbmd0aH1gKSB7XG4gICAgJGVsLnNldEF0dHJpYnV0ZSgncGF0aExlbmd0aCcsIGAke3BhdGhMZW5ndGh9YCk7XG4gICAgcHJveHkuc2V0QXR0cmlidXRlKCdkcmF3JywgYCR7c3RhcnR9ICR7ZW5kfWApO1xuICB9XG5cbiAgcmV0dXJuIC8qKiBAdHlwZSB7RHJhd2FibGVTVkdHZW9tZXRyeX0gKi8ocHJveHkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGRyYXdhYmxlIHByb3hpZXMgZm9yIG11bHRpcGxlIFNWRyBlbGVtZW50cy5cbiAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSBzZWxlY3RvciAtIENTUyBzZWxlY3RvciwgU1ZHIGVsZW1lbnQsIG9yIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBzZWxlY3RvcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gLSBTdGFydGluZyBwb3NpdGlvbiAoMC0xKVxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9MF0gLSBFbmRpbmcgcG9zaXRpb24gKDAtMSlcbiAqIEByZXR1cm4ge0FycmF5PERyYXdhYmxlU1ZHR2VvbWV0cnk+fSAtIEFycmF5IG9mIHByb3hpZWQgZWxlbWVudHMgd2l0aCBkcmF3aW5nIGZ1bmN0aW9uYWxpdHlcbiAqL1xuY29uc3QgY3JlYXRlRHJhd2FibGUgPSAoc2VsZWN0b3IsIHN0YXJ0ID0gMCwgZW5kID0gMCkgPT4ge1xuICBjb25zdCBlbHMgPSBwYXJzZVRhcmdldHMoc2VsZWN0b3IpO1xuICByZXR1cm4gZWxzLm1hcCgkZWwgPT4gY3JlYXRlRHJhd2FibGVQcm94eShcbiAgICAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oJGVsKSxcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgKSk7XG59O1xuXG4vLyBNb3Rpb24gcGF0aCBhbmltYXRpb25cblxuLyoqXG4gKiBAcGFyYW0ge1NWR0dlb21ldHJ5RWxlbWVudH0gJHBhdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzc1xuICogQHBhcmFtIHtOdW1iZXJ9bG9va3VwXG4gKiBAcmV0dXJuIHtET01Qb2ludH1cbiAqL1xuY29uc3QgZ2V0UGF0aFBvaW50ID0gKCRwYXRoLCBwcm9ncmVzcywgbG9va3VwID0gMCkgPT4ge1xuICByZXR1cm4gJHBhdGguZ2V0UG9pbnRBdExlbmd0aChwcm9ncmVzcyArIGxvb2t1cCA+PSAxID8gcHJvZ3Jlc3MgKyBsb29rdXAgOiAwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTVkdHZW9tZXRyeUVsZW1lbnR9ICRwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFByb3BlcnR5XG4gKiBAcmV0dXJuIHtGdW5jdGlvblZhbHVlfVxuICovXG5jb25zdCBnZXRQYXRoUHJvZ2VzcyA9ICgkcGF0aCwgcGF0aFByb3BlcnR5KSA9PiB7XG4gIHJldHVybiAkZWwgPT4ge1xuICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gKygkcGF0aC5nZXRUb3RhbExlbmd0aCgpKTtcbiAgICBjb25zdCBpblN2ZyA9ICRlbFtpc1N2Z1N5bWJvbF07XG4gICAgY29uc3QgY3RtID0gJHBhdGguZ2V0Q1RNKCk7XG4gICAgLyoqIEB0eXBlIHtUd2Vlbk9iamVjdFZhbHVlfSAqL1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IHRvdGFsTGVuZ3RoLFxuICAgICAgLyoqIEB0eXBlIHtUd2Vlbk1vZGlmaWVyfSAqL1xuICAgICAgbW9kaWZpZXI6IHByb2dyZXNzID0+IHtcbiAgICAgICAgaWYgKHBhdGhQcm9wZXJ0eSA9PT0gJ2EnKSB7XG4gICAgICAgICAgY29uc3QgcDAgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAtMSk7XG4gICAgICAgICAgY29uc3QgcDEgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAxKTtcbiAgICAgICAgICByZXR1cm4gYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KSAqIDE4MCAvIFBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHAgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAwKTtcbiAgICAgICAgICByZXR1cm4gcGF0aFByb3BlcnR5ID09PSAneCcgP1xuICAgICAgICAgICAgaW5TdmcgfHwgIWN0bSA/IHAueCA6IHAueCAqIGN0bS5hICsgcC55ICogY3RtLmMgKyBjdG0uZSA6XG4gICAgICAgICAgICBpblN2ZyB8fCAhY3RtID8gcC55IDogcC54ICogY3RtLmIgKyBwLnkgKiBjdG0uZCArIGN0bS5mXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHBhdGhcbiAqL1xuY29uc3QgY3JlYXRlTW90aW9uUGF0aCA9IHBhdGggPT4ge1xuICBjb25zdCAkcGF0aCA9IGdldFBhdGgocGF0aCk7XG4gIGlmICghJHBhdGgpIHJldHVybjtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBnZXRQYXRoUHJvZ2VzcygkcGF0aCwgJ3gnKSxcbiAgICB0cmFuc2xhdGVZOiBnZXRQYXRoUHJvZ2VzcygkcGF0aCwgJ3knKSxcbiAgICByb3RhdGU6IGdldFBhdGhQcm9nZXNzKCRwYXRoLCAnYScpLFxuICB9XG59O1xuXG4vLyBDaGVjayBmb3IgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuXG5jb25zdCBjc3NSZXNlcnZlZFByb3BlcnRpZXMgPSBbJ29wYWNpdHknLCAncm90YXRlJywgJ292ZXJmbG93JywgJ2NvbG9yJ107XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVmFsaWRTVkdBdHRyaWJ1dGUgPSAoZWwsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAvLyBSZXR1cm4gZWFybHkgYW5kIHVzZSBDU1Mgb3BhY2l0eSBhbmltYXRpb24gaW5zdGVhZCAoYWxyZWFkeSBiZXR0ZXIgZGVmYXVsdCB2YWx1ZXMgKG9wYWNpdHk6IDEgaW5zdGVhZCBvZiAwKSkgYW5kIHJvdGF0ZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIHRyYW5zZm9ybVxuICBpZiAoY3NzUmVzZXJ2ZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKHByb3BlcnR5TmFtZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGVsLmdldEF0dHJpYnV0ZShwcm9wZXJ0eU5hbWUpIHx8IHByb3BlcnR5TmFtZSBpbiBlbCkge1xuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdzY2FsZScpIHsgLy8gU2NhbGVcbiAgICAgIGNvbnN0IGVsUGFyZW50Tm9kZSA9IC8qKiBAdHlwZSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAqLygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oZWwpLnBhcmVudE5vZGUpO1xuICAgICAgLy8gT25seSBjb25zaWRlciBzY2FsZSBhcyBhIHZhbGlkIFNWRyBhdHRyaWJ1dGUgb24gZmlsdGVyIGVsZW1lbnRcbiAgICAgIHJldHVybiBlbFBhcmVudE5vZGUgJiYgZWxQYXJlbnROb2RlLnRhZ05hbWUgPT09ICdmaWx0ZXInO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuY29uc3Qgc3ZnID0ge1xuICBtb3JwaFRvLFxuICBjcmVhdGVNb3Rpb25QYXRoLFxuICBjcmVhdGVEcmF3YWJsZSxcbn07XG5cblxuXG5cbi8qKlxuICogUkdCIC8gUkdCQSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gcmdiVmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IHJnYlRvUmdiYSA9IHJnYlZhbHVlID0+IHtcbiAgY29uc3QgcmdiYSA9IHJnYkV4ZWNSZ3guZXhlYyhyZ2JWYWx1ZSkgfHwgcmdiYUV4ZWNSZ3guZXhlYyhyZ2JWYWx1ZSk7XG4gIGNvbnN0IGEgPSAhaXNVbmQocmdiYVs0XSkgPyArcmdiYVs0XSA6IDE7XG4gIHJldHVybiBbXG4gICAgK3JnYmFbMV0sXG4gICAgK3JnYmFbMl0sXG4gICAgK3JnYmFbM10sXG4gICAgYVxuICBdXG59O1xuXG4vKipcbiAqIEhFWDMgLyBIRVgzQSAvIEhFWDYgLyBIRVg2QSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gaGV4VmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGhleFRvUmdiYSA9IGhleFZhbHVlID0+IHtcbiAgY29uc3QgaGV4TGVuZ3RoID0gaGV4VmFsdWUubGVuZ3RoO1xuICBjb25zdCBpc1Nob3J0ID0gaGV4TGVuZ3RoID09PSA0IHx8IGhleExlbmd0aCA9PT0gNTtcbiAgcmV0dXJuIFtcbiAgICArKCcweCcgKyBoZXhWYWx1ZVsxXSArIGhleFZhbHVlW2lzU2hvcnQgPyAxIDogMl0pLFxuICAgICsoJzB4JyArIGhleFZhbHVlW2lzU2hvcnQgPyAyIDogM10gKyBoZXhWYWx1ZVtpc1Nob3J0ID8gMiA6IDRdKSxcbiAgICArKCcweCcgKyBoZXhWYWx1ZVtpc1Nob3J0ID8gMyA6IDVdICsgaGV4VmFsdWVbaXNTaG9ydCA/IDMgOiA2XSksXG4gICAgKChoZXhMZW5ndGggPT09IDUgfHwgaGV4TGVuZ3RoID09PSA5KSA/ICsoKygnMHgnICsgaGV4VmFsdWVbaXNTaG9ydCA/IDQgOiA3XSArIGhleFZhbHVlW2lzU2hvcnQgPyA0IDogOF0pIC8gMjU1KS50b0ZpeGVkKDMpIDogMSlcbiAgXVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBcbiAqIEBwYXJhbSAge051bWJlcn0gcVxuICogQHBhcmFtICB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGh1ZTJyZ2IgPSAocCwgcSwgdCkgPT4ge1xuICBpZiAodCA8IDApIHQgKz0gMTtcbiAgaWYgKHQgPiAxKSB0IC09IDE7XG4gIHJldHVybiB0IDwgMSAvIDYgPyBwICsgKHEgLSBwKSAqIDYgKiB0IDpcbiAgICAgICAgIHQgPCAxIC8gMiA/IHEgOlxuICAgICAgICAgdCA8IDIgLyAzID8gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDYgOlxuICAgICAgICAgcDtcbn07XG5cbi8qKlxuICogSFNMIC8gSFNMQSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gaHNsVmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGhzbFRvUmdiYSA9IGhzbFZhbHVlID0+IHtcbiAgY29uc3QgaHNsYSA9IGhzbEV4ZWNSZ3guZXhlYyhoc2xWYWx1ZSkgfHwgaHNsYUV4ZWNSZ3guZXhlYyhoc2xWYWx1ZSk7XG4gIGNvbnN0IGggPSAraHNsYVsxXSAvIDM2MDtcbiAgY29uc3QgcyA9ICtoc2xhWzJdIC8gMTAwO1xuICBjb25zdCBsID0gK2hzbGFbM10gLyAxMDA7XG4gIGNvbnN0IGEgPSAhaXNVbmQoaHNsYVs0XSkgPyAraHNsYVs0XSA6IDE7XG4gIGxldCByLCBnLCBiO1xuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcSA9IGwgPCAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSByb3VuZChodWUycmdiKHAsIHEsIGggKyAxIC8gMykgKiAyNTUsIDApO1xuICAgIGcgPSByb3VuZChodWUycmdiKHAsIHEsIGgpICogMjU1LCAwKTtcbiAgICBiID0gcm91bmQoaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpICogMjU1LCAwKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufTtcblxuLyoqXG4gKiBBbGwgaW4gb25lIGNvbG9yIGNvbnZlcnRlciB0aGF0IGNvbnZlcnRzIGEgY29sb3Igc3RyaW5nIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgUkdCQSB2YWx1ZXNcbiAqIEBwYXJhbSAge1N0cmluZ30gY29sb3JTdHJpbmdcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGNvbnZlcnRDb2xvclN0cmluZ1ZhbHVlc1RvUmdiYUFycmF5ID0gY29sb3JTdHJpbmcgPT4ge1xuICByZXR1cm4gaXNSZ2IoY29sb3JTdHJpbmcpID8gcmdiVG9SZ2JhKGNvbG9yU3RyaW5nKSA6XG4gICAgICAgICBpc0hleChjb2xvclN0cmluZykgPyBoZXhUb1JnYmEoY29sb3JTdHJpbmcpIDpcbiAgICAgICAgIGlzSHNsKGNvbG9yU3RyaW5nKSA/IGhzbFRvUmdiYShjb2xvclN0cmluZykgOlxuICAgICAgICAgWzAsIDAsIDAsIDFdO1xufTtcblxuXG5cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgRFxuICogQHBhcmFtIHtUfHVuZGVmaW5lZH0gdGFyZ2V0VmFsdWVcbiAqIEBwYXJhbSB7RH0gZGVmYXVsdFZhbHVlXG4gKiBAcmV0dXJuIHtUfER9XG4gKi9cbmNvbnN0IHNldFZhbHVlID0gKHRhcmdldFZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzVW5kKHRhcmdldFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHRhcmdldFZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2VlblByb3BWYWx1ZX0gdmFsdWVcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRvdGFsXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtzdG9yZV1cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgZ2V0RnVuY3Rpb25WYWx1ZSA9ICh2YWx1ZSwgdGFyZ2V0LCBpbmRleCwgdG90YWwsIHN0b3JlKSA9PiB7XG4gIGlmIChpc0ZuYyh2YWx1ZSkpIHtcbiAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkodGFyZ2V0LCBpbmRleCwgdG90YWwpO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gMCBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB1bmRlZmluZWQgLyBOYU4gLyBudWxsIC8gZmFsc2UgLyAwXG4gICAgICByZXR1cm4gIWlzTmFOKCtjb21wdXRlZCkgPyArY29tcHV0ZWQgOiBjb21wdXRlZCB8fCAwO1xuICAgIH07XG4gICAgaWYgKHN0b3JlKSB7XG4gICAgICBzdG9yZS5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7dHdlZW5UeXBlc31cbiAqL1xuY29uc3QgZ2V0VHdlZW5UeXBlID0gKHRhcmdldCwgcHJvcCkgPT4ge1xuICByZXR1cm4gIXRhcmdldFtpc0RvbVN5bWJvbF0gPyB0d2VlblR5cGVzLk9CSkVDVCA6XG4gICAgLy8gSGFuZGxlIFNWRyBhdHRyaWJ1dGVzXG4gICAgdGFyZ2V0W2lzU3ZnU3ltYm9sXSAmJiBpc1ZhbGlkU1ZHQXR0cmlidXRlKHRhcmdldCwgcHJvcCkgPyB0d2VlblR5cGVzLkFUVFJJQlVURSA6XG4gICAgLy8gSGFuZGxlIENTUyBUcmFuc2Zvcm0gcHJvcGVydGllcyBkaWZmZXJlbnRseSB0aGFuIENTUyB0byBhbGxvdyBpbmRpdmlkdWFsIGFuaW1hdGlvbnNcbiAgICB2YWxpZFRyYW5zZm9ybXMuaW5jbHVkZXMocHJvcCkgfHwgc2hvcnRUcmFuc2Zvcm1zLmdldChwcm9wKSA/IHR3ZWVuVHlwZXMuVFJBTlNGT1JNIDpcbiAgICAvLyBDU1MgdmFyaWFibGVzXG4gICAgc3RyaW5nU3RhcnRzV2l0aChwcm9wLCAnLS0nKSA/IHR3ZWVuVHlwZXMuQ1NTX1ZBUiA6XG4gICAgLy8gQWxsIG90aGVyIENTUyBwcm9wZXJ0aWVzXG4gICAgcHJvcCBpbiAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odGFyZ2V0KS5zdHlsZSA/IHR3ZWVuVHlwZXMuQ1NTIDpcbiAgICAvLyBIYW5kbGUgb3RoZXIgRE9NIEF0dHJpYnV0ZXNcbiAgICBwcm9wIGluIHRhcmdldCA/IHR3ZWVuVHlwZXMuT0JKRUNUIDpcbiAgICB0d2VlblR5cGVzLkFUVFJJQlVURTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gYW5pbWF0aW9uSW5saW5lU3R5bGVzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IGdldENTU1ZhbHVlID0gKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgPT4ge1xuICBjb25zdCBpbmxpbmVTdHlsZXMgPSB0YXJnZXQuc3R5bGVbcHJvcE5hbWVdO1xuICBpZiAoaW5saW5lU3R5bGVzICYmIGFuaW1hdGlvbklubGluZVN0eWxlcykge1xuICAgIGFuaW1hdGlvbklubGluZVN0eWxlc1twcm9wTmFtZV0gPSBpbmxpbmVTdHlsZXM7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBpbmxpbmVTdHlsZXMgfHwgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRbcHJveHlUYXJnZXRTeW1ib2xdIHx8IHRhcmdldCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSk7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gJzAnIDogdmFsdWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtIHt0d2VlblR5cGVzfSBbdHdlZW5UeXBlXVxuICogQHBhcmFtIHtPYmplY3R8dm9pZH0gW2FuaW1hdGlvbklubGluZVN0eWxlc11cbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKi9cbmNvbnN0IGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlID0gKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbWF0aW9uSW5saW5lU3R5bGVzKSA9PiB7XG4gIGNvbnN0IHR5cGUgPSAhaXNVbmQodHdlZW5UeXBlKSA/IHR3ZWVuVHlwZSA6IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgcmV0dXJuIHR5cGUgPT09IHR3ZWVuVHlwZXMuT0JKRUNUID8gdGFyZ2V0W3Byb3BOYW1lXSB8fCAwIDpcbiAgICAgICAgIHR5cGUgPT09IHR3ZWVuVHlwZXMuQVRUUklCVVRFID8gLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCkuZ2V0QXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICB0eXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSA/IHBhcnNlSW5saW5lVHJhbnNmb3JtcygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odGFyZ2V0KSwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgOlxuICAgICAgICAgdHlwZSA9PT0gdHdlZW5UeXBlcy5DU1NfVkFSID8gZ2V0Q1NTVmFsdWUoLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCksIHByb3BOYW1lLCBhbmltYXRpb25JbmxpbmVTdHlsZXMpLnRyaW1TdGFydCgpIDpcbiAgICAgICAgIGdldENTU1ZhbHVlKC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCBwcm9wTmFtZSwgYW5pbWF0aW9uSW5saW5lU3R5bGVzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSAge1N0cmluZ30gb3BlcmF0b3JcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgZ2V0UmVsYXRpdmVWYWx1ZSA9ICh4LCB5LCBvcGVyYXRvcikgPT4ge1xuICByZXR1cm4gb3BlcmF0b3IgPT09ICctJyA/IHggLSB5IDpcbiAgICAgICAgIG9wZXJhdG9yID09PSAnKycgPyB4ICsgeSA6XG4gICAgICAgICB4ICogeTtcbn07XG5cbi8qKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gKi9cbmNvbnN0IGNyZWF0ZURlY29tcG9zZWRWYWx1ZVRhcmdldE9iamVjdCA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAvKiogQHR5cGUge3ZhbHVlVHlwZXN9ICovXG4gICAgdDogdmFsdWVUeXBlcy5OVU1CRVIsXG4gICAgbjogMCxcbiAgICB1OiBudWxsLFxuICAgIG86IG51bGwsXG4gICAgZDogbnVsbCxcbiAgICBzOiBudWxsLFxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9IHJhd1ZhbHVlXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gdGFyZ2V0T2JqZWN0XG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgZGVjb21wb3NlUmF3VmFsdWUgPSAocmF3VmFsdWUsIHRhcmdldE9iamVjdCkgPT4ge1xuICAvKiogQHR5cGUge3ZhbHVlVHlwZXN9ICovXG4gIHRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5OVU1CRVI7XG4gIHRhcmdldE9iamVjdC5uID0gMDtcbiAgdGFyZ2V0T2JqZWN0LnUgPSBudWxsO1xuICB0YXJnZXRPYmplY3QubyA9IG51bGw7XG4gIHRhcmdldE9iamVjdC5kID0gbnVsbDtcbiAgdGFyZ2V0T2JqZWN0LnMgPSBudWxsO1xuICBpZiAoIXJhd1ZhbHVlKSByZXR1cm4gdGFyZ2V0T2JqZWN0O1xuICBjb25zdCBudW0gPSArcmF3VmFsdWU7XG4gIGlmICghaXNOYU4obnVtKSkge1xuICAgIC8vIEl0J3MgYSBudW1iZXJcbiAgICB0YXJnZXRPYmplY3QubiA9IG51bTtcbiAgICByZXR1cm4gdGFyZ2V0T2JqZWN0O1xuICB9IGVsc2Uge1xuICAgIC8vIGxldCBzdHIgPSAvKiogQHR5cGUge1N0cmluZ30gKi8ocmF3VmFsdWUpLnRyaW0oKTtcbiAgICBsZXQgc3RyID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHJhd1ZhbHVlKTtcbiAgICAvLyBQYXJzaW5nIG9wZXJhdG9ycyAoKz0sIC09LCAqPSkgbWFudWFsbHkgaXMgbXVjaCBmYXN0ZXIgdGhhbiB1c2luZyByZWdleCBoZXJlXG4gICAgaWYgKHN0clsxXSA9PT0gJz0nKSB7XG4gICAgICB0YXJnZXRPYmplY3QubyA9IHN0clswXTtcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgyKTtcbiAgICB9XG4gICAgLy8gU2tpcCBleGVjIHJlZ2V4IGlmIHRoZSB2YWx1ZSB0eXBlIGlzIGNvbXBsZXggb3IgY29sb3IgdG8gYXZvaWQgbG9uZyByZWdleCBiYWNrdHJhY2tpbmdcbiAgICBjb25zdCB1bml0TWF0Y2ggPSBzdHIuaW5jbHVkZXMoJyAnKSA/IGZhbHNlIDogdW5pdHNFeGVjUmd4LmV4ZWMoc3RyKTtcbiAgICBpZiAodW5pdE1hdGNoKSB7XG4gICAgICAvLyBIYXMgYSBudW1iZXIgYW5kIGEgdW5pdFxuICAgICAgdGFyZ2V0T2JqZWN0LnQgPSB2YWx1ZVR5cGVzLlVOSVQ7XG4gICAgICB0YXJnZXRPYmplY3QubiA9ICt1bml0TWF0Y2hbMV07XG4gICAgICB0YXJnZXRPYmplY3QudSA9IHVuaXRNYXRjaFsyXTtcbiAgICAgIHJldHVybiB0YXJnZXRPYmplY3Q7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRPYmplY3Qubykge1xuICAgICAgLy8gSGFzIGFuIG9wZXJhdG9yICgrPSwgLT0sICo9KVxuICAgICAgdGFyZ2V0T2JqZWN0Lm4gPSArc3RyO1xuICAgICAgcmV0dXJuIHRhcmdldE9iamVjdDtcbiAgICB9IGVsc2UgaWYgKGlzQ29sKHN0cikpIHtcbiAgICAgIC8vIElzIGEgY29sb3JcbiAgICAgIHRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5DT0xPUjtcbiAgICAgIHRhcmdldE9iamVjdC5kID0gY29udmVydENvbG9yU3RyaW5nVmFsdWVzVG9SZ2JhQXJyYXkoc3RyKTtcbiAgICAgIHJldHVybiB0YXJnZXRPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElzIGEgbW9yZSBjb21wbGV4IHN0cmluZyAoZ2VuZXJhbGx5IHN2ZyBjb29yZHMsIGNhbGMoKSBvciBmaWx0ZXJzIENTUyB2YWx1ZXMpXG4gICAgICBjb25zdCBtYXRjaGVkTnVtYmVycyA9IHN0ci5tYXRjaChkaWdpdFdpdGhFeHBvbmVudFJneCk7XG4gICAgICB0YXJnZXRPYmplY3QudCA9IHZhbHVlVHlwZXMuQ09NUExFWDtcbiAgICAgIHRhcmdldE9iamVjdC5kID0gbWF0Y2hlZE51bWJlcnMgPyBtYXRjaGVkTnVtYmVycy5tYXAoTnVtYmVyKSA6IFtdO1xuICAgICAgdGFyZ2V0T2JqZWN0LnMgPSBzdHIuc3BsaXQoZGlnaXRXaXRoRXhwb25lbnRSZ3gpIHx8IFtdO1xuICAgICAgcmV0dXJuIHRhcmdldE9iamVjdDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtICB7VHdlZW59IHR3ZWVuXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gdGFyZ2V0T2JqZWN0XG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgZGVjb21wb3NlVHdlZW5WYWx1ZSA9ICh0d2VlbiwgdGFyZ2V0T2JqZWN0KSA9PiB7XG4gIHRhcmdldE9iamVjdC50ID0gdHdlZW4uX3ZhbHVlVHlwZTtcbiAgdGFyZ2V0T2JqZWN0Lm4gPSB0d2Vlbi5fdG9OdW1iZXI7XG4gIHRhcmdldE9iamVjdC51ID0gdHdlZW4uX3VuaXQ7XG4gIHRhcmdldE9iamVjdC5vID0gbnVsbDtcbiAgdGFyZ2V0T2JqZWN0LmQgPSBjbG9uZUFycmF5KHR3ZWVuLl90b051bWJlcnMpO1xuICB0YXJnZXRPYmplY3QucyA9IGNsb25lQXJyYXkodHdlZW4uX3N0cmluZ3MpO1xuICByZXR1cm4gdGFyZ2V0T2JqZWN0O1xufTtcblxuY29uc3QgZGVjb21wb3NlZE9yaWdpbmFsVmFsdWUgPSBjcmVhdGVEZWNvbXBvc2VkVmFsdWVUYXJnZXRPYmplY3QoKTtcblxuXG5cblxuY29uc3QgbG9va3VwcyA9IHtcbiAgLyoqIEB0eXBlIHtUd2VlblJlcGxhY2VMb29rdXBzfSAqL1xuICBfcmVwOiBuZXcgV2Vha01hcCgpLFxuICAvKiogQHR5cGUge1R3ZWVuQWRkaXRpdmVMb29rdXBzfSAqL1xuICBfYWRkOiBuZXcgTWFwKCksXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0gIHtTdHJpbmd9IGxvb2t1cFxuICogQHJldHVybiB7VHdlZW5Qcm9wZXJ0eVNpYmxpbmdzfVxuICovXG5jb25zdCBnZXRUd2VlblNpYmxpbmdzID0gKHRhcmdldCwgcHJvcGVydHksIGxvb2t1cCA9ICdfcmVwJykgPT4ge1xuICBjb25zdCBsb29rdXBNYXAgPSBsb29rdXBzW2xvb2t1cF07XG4gIGxldCB0YXJnZXRMb29rdXAgPSBsb29rdXBNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghdGFyZ2V0TG9va3VwKSB7XG4gICAgdGFyZ2V0TG9va3VwID0ge307XG4gICAgbG9va3VwTWFwLnNldCh0YXJnZXQsIHRhcmdldExvb2t1cCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldExvb2t1cFtwcm9wZXJ0eV0gPyB0YXJnZXRMb29rdXBbcHJvcGVydHldIDogdGFyZ2V0TG9va3VwW3Byb3BlcnR5XSA9IHtcbiAgICBfaGVhZDogbnVsbCxcbiAgICBfdGFpbDogbnVsbCxcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gcFxuICogQHBhcmFtICB7VHdlZW59IGNcbiAqIEByZXR1cm4ge051bWJlcnxCb29sZWFufVxuICovXG5jb25zdCBhZGRUd2VlblNvcnRNZXRob2QgPSAocCwgYykgPT4ge1xuICByZXR1cm4gcC5faXNPdmVycmlkZGVuIHx8IHAuX2Fic29sdXRlU3RhcnRUaW1lID4gYy5fYWJzb2x1dGVTdGFydFRpbWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuXG4gKi9cbmNvbnN0IG92ZXJyaWRlVHdlZW4gPSB0d2VlbiA9PiB7XG4gIHR3ZWVuLl9pc092ZXJsYXBwZWQgPSAxO1xuICB0d2Vlbi5faXNPdmVycmlkZGVuID0gMTtcbiAgdHdlZW4uX2NoYW5nZUR1cmF0aW9uID0gbWluVmFsdWU7XG4gIHR3ZWVuLl9jdXJyZW50VGltZSA9IG1pblZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gdHdlZW5cbiAqIEBwYXJhbSAge1R3ZWVuUHJvcGVydHlTaWJsaW5nc30gc2libGluZ3NcbiAqIEByZXR1cm4ge1R3ZWVufVxuICovXG5jb25zdCBjb21wb3NlVHdlZW4gPSAodHdlZW4sIHNpYmxpbmdzKSA9PiB7XG5cbiAgY29uc3QgdHdlZW5Db21wb3NpdGlvblR5cGUgPSB0d2Vlbi5fY29tcG9zaXRpb247XG5cbiAgLy8gSGFuZGxlIHJlcGxhY2VkIHR3ZWVuc1xuXG4gIGlmICh0d2VlbkNvbXBvc2l0aW9uVHlwZSA9PT0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlKSB7XG5cbiAgICBjb25zdCB0d2VlbkFic1N0YXJ0VGltZSA9IHR3ZWVuLl9hYnNvbHV0ZVN0YXJ0VGltZTtcblxuICAgIGFkZENoaWxkKHNpYmxpbmdzLCB0d2VlbiwgYWRkVHdlZW5Tb3J0TWV0aG9kLCAnX3ByZXZSZXAnLCAnX25leHRSZXAnKTtcblxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdHdlZW4uX3ByZXZSZXA7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHByZXZpb3VzIHNpYmxpbmdzIGZvciBjb21wb3NpdGlvbiByZXBsYWNlIHR3ZWVuc1xuXG4gICAgaWYgKHByZXZTaWJsaW5nKSB7XG5cbiAgICAgIGNvbnN0IHByZXZQYXJlbnQgPSBwcmV2U2libGluZy5wYXJlbnQ7XG4gICAgICBjb25zdCBwcmV2QWJzRW5kVGltZSA9IHByZXZTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSArIHByZXZTaWJsaW5nLl9jaGFuZ2VEdXJhdGlvbjtcblxuICAgICAgLy8gSGFuZGxlIGxvb3BlZCBhbmltYXRpb25zIHR3ZWVuXG5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByZXZpb3VzIHR3ZWVuIGlzIGZyb20gYSBkaWZmZXJlbnQgYW5pbWF0aW9uXG4gICAgICAgIHR3ZWVuLnBhcmVudC5pZCAhPT0gcHJldlBhcmVudC5pZCAmJlxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYW5pbWF0aW9uIGhhcyBsb29wc1xuICAgICAgICBwcmV2UGFyZW50Lml0ZXJhdGlvbkNvdW50PiAxICYmXG4gICAgICAgIC8vIENoZWNrIGlmIF9hYnNvbHV0ZUNoYW5nZUVuZFRpbWUgb2YgbGFzdCBsb29wIG92ZXJsYXBzIHRoZSBjdXJyZW50IHR3ZWVuXG4gICAgICAgIHByZXZBYnNFbmRUaW1lICsgKHByZXZQYXJlbnQuZHVyYXRpb24gLSBwcmV2UGFyZW50Lml0ZXJhdGlvbkR1cmF0aW9uKSA+IHR3ZWVuQWJzU3RhcnRUaW1lXG4gICAgICApIHtcblxuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgd2F5IHRvIG9ubHkgb3ZlcnJpZGUgdGhlIGl0ZXJhdGlvbnMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgdHdlZW5cbiAgICAgICAgb3ZlcnJpZGVUd2VlbihwcmV2U2libGluZyk7XG5cbiAgICAgICAgbGV0IHByZXZQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLl9wcmV2UmVwO1xuXG4gICAgICAgIC8vIElmIHRoZSB0d2VlbiB3YXMgcGFydCBvZiBhIHNldCBvZiBrZXlmcmFtZXMsIG92ZXJyaWRlIGl0cyBzaWJsaW5nc1xuICAgICAgICB3aGlsZSAocHJldlByZXZTaWJsaW5nICYmIHByZXZQcmV2U2libGluZy5wYXJlbnQuaWQgPT09IHByZXZQYXJlbnQuaWQpIHtcbiAgICAgICAgICBvdmVycmlkZVR3ZWVuKHByZXZQcmV2U2libGluZyk7XG4gICAgICAgICAgcHJldlByZXZTaWJsaW5nID0gcHJldlByZXZTaWJsaW5nLl9wcmV2UmVwO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgY29uc3QgYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUgPSB0d2VlbkFic1N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheTtcblxuICAgICAgaWYgKHByZXZBYnNFbmRUaW1lID4gYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUpIHtcblxuICAgICAgICBjb25zdCBwcmV2Q2hhbmdlU3RhcnRUaW1lID0gcHJldlNpYmxpbmcuX3N0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgcHJldlRMT2Zmc2V0ID0gcHJldkFic0VuZFRpbWUgLSAocHJldkNoYW5nZVN0YXJ0VGltZSArIHByZXZTaWJsaW5nLl91cGRhdGVEdXJhdGlvbik7XG4gICAgICAgIC8vIFJvdW5kaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIHRvIG1pbmltaXplIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3aGVuIHdvcmtpbmcgaW4gc2Vjb25kc1xuICAgICAgICBjb25zdCB1cGRhdGVkUHJldkNoYW5nZUR1cmF0aW9uID0gcm91bmQoYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUgLSBwcmV2VExPZmZzZXQgLSBwcmV2Q2hhbmdlU3RhcnRUaW1lLCAxMik7XG5cbiAgICAgICAgcHJldlNpYmxpbmcuX2NoYW5nZUR1cmF0aW9uID0gdXBkYXRlZFByZXZDaGFuZ2VEdXJhdGlvbjtcbiAgICAgICAgcHJldlNpYmxpbmcuX2N1cnJlbnRUaW1lID0gdXBkYXRlZFByZXZDaGFuZ2VEdXJhdGlvbjtcbiAgICAgICAgcHJldlNpYmxpbmcuX2lzT3ZlcmxhcHBlZCA9IDE7XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIHByZXZpb3VzIHR3ZWVuIGlmIGl0cyBuZXcgX2NoYW5nZUR1cmF0aW9uIGlzIGxvd2VyIHRoYW4gbWluVmFsdWVcbiAgICAgICAgLy8gVE9ETzogU2VlIGlmIGl0J3MgZXZlbiBuZWNlc2VlYXJ5IHRvIHRlc3QgYWdhaW5zdCBtaW5WYWx1ZSwgY2hlY2tpbmcgZm9yIDAgbWlnaHQgYmUgZW5vdWdoXG4gICAgICAgIGlmICh1cGRhdGVkUHJldkNoYW5nZUR1cmF0aW9uIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICBvdmVycmlkZVR3ZWVuKHByZXZTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQYXVzZSAoYW5kIGNhbmNlbCkgdGhlIHBhcmVudCBpZiBpdCBvbmx5IGNvbnRhaW5zIG92ZXJsYXBwZWQgdHdlZW5zXG5cbiAgICAgIGxldCBwYXVzZVByZXZQYXJlbnRBbmltYXRpb24gPSB0cnVlO1xuXG4gICAgICBmb3JFYWNoQ2hpbGRyZW4ocHJldlBhcmVudCwgKC8qKiBAdHlwZSBUd2VlbiAqL3QpID0+IHtcbiAgICAgICAgaWYgKCF0Ll9pc092ZXJsYXBwZWQpIHBhdXNlUHJldlBhcmVudEFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChwYXVzZVByZXZQYXJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgY29uc3QgcHJldlBhcmVudFRMID0gcHJldlBhcmVudC5wYXJlbnQ7XG4gICAgICAgIGlmIChwcmV2UGFyZW50VEwpIHtcbiAgICAgICAgICBsZXQgcGF1c2VQcmV2UGFyZW50VEwgPSB0cnVlO1xuICAgICAgICAgIGZvckVhY2hDaGlsZHJlbihwcmV2UGFyZW50VEwsICgvKiogQHR5cGUgSlNBbmltYXRpb24gKi9hKSA9PiB7XG4gICAgICAgICAgICBpZiAoYSAhPT0gcHJldlBhcmVudCkge1xuICAgICAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oYSwgKC8qKiBAdHlwZSBUd2VlbiAqL3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXQuX2lzT3ZlcmxhcHBlZCkgcGF1c2VQcmV2UGFyZW50VEwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHBhdXNlUHJldlBhcmVudFRMKSB7XG4gICAgICAgICAgICBwcmV2UGFyZW50VEwuY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZQYXJlbnQuY2FuY2VsKCk7XG4gICAgICAgICAgLy8gUHJldmlvdXNseSwgY2FsbGluZyAuY2FuY2VsKCkgb24gYSB0aW1lbGluZSBjaGlsZCB3b3VsZCBhZmZlY3QgdGhlIHJlbmRlciBvcmRlciBvZiBvdGhlciBjaGlsZHJlblxuICAgICAgICAgIC8vIFdvcmtlZCBhcm91bmQgdGhpcyBieSBtYXJraW5nIGl0IGFzIC5jb21wbGV0ZWQgYW5kIHVzaW5nIC5wYXVzZSgpIGZvciBzYWZlIHJlbW92YWwgaW4gdGhlIGVuZ2luZSBsb29wXG4gICAgICAgICAgLy8gVGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIHNpbmNlIHRpbWVsaW5lIHR3ZWVuIGNvbXBvc2l0aW9uIGlzIG5vdyBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAgICAgICAvLyBLZWVwaW5nIHRoaXMgaGVyZSBmb3IgcmVmZXJlbmNlXG4gICAgICAgICAgLy8gcHJldlBhcmVudC5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIHByZXZQYXJlbnQucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gbGV0IG5leHRTaWJsaW5nID0gdHdlZW4uX25leHRSZXA7XG5cbiAgICAvLyAvLyBBbGwgdGhlIG5leHQgc2libGluZ3MgYXJlIGF1dG9tYXRpY2FsbHkgb3ZlcnJpZGRlblxuXG4gICAgLy8gaWYgKG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSA+PSB0d2VlbkFic1N0YXJ0VGltZSkge1xuICAgIC8vICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgLy8gICAgIG92ZXJyaWRlVHdlZW4obmV4dFNpYmxpbmcpO1xuICAgIC8vICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLl9uZXh0UmVwO1xuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAgIC8vIGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5fYWJzb2x1dGVTdGFydFRpbWUgPCB0d2VlbkFic1N0YXJ0VGltZSkge1xuICAgIC8vICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgLy8gICAgIG92ZXJyaWRlVHdlZW4obmV4dFNpYmxpbmcpO1xuICAgIC8vICAgICBjb25zb2xlLmxvZyh0d2Vlbi5pZCwgbmV4dFNpYmxpbmcuaWQpO1xuICAgIC8vICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLl9uZXh0UmVwO1xuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAvLyBIYW5kbGUgYWRkaXRpdmUgdHdlZW5zIGNvbXBvc2l0aW9uXG5cbiAgfSBlbHNlIGlmICh0d2VlbkNvbXBvc2l0aW9uVHlwZSA9PT0gY29tcG9zaXRpb25UeXBlcy5ibGVuZCkge1xuXG4gICAgY29uc3QgYWRkaXRpdmVUd2VlblNpYmxpbmdzID0gZ2V0VHdlZW5TaWJsaW5ncyh0d2Vlbi50YXJnZXQsIHR3ZWVuLnByb3BlcnR5LCAnX2FkZCcpO1xuICAgIGNvbnN0IGFkZGl0aXZlQW5pbWF0aW9uID0gYWRkQWRkaXRpdmVBbmltYXRpb24obG9va3Vwcy5fYWRkKTtcblxuICAgIGxldCBsb29rdXBUd2VlbiA9IGFkZGl0aXZlVHdlZW5TaWJsaW5ncy5faGVhZDtcblxuICAgIGlmICghbG9va3VwVHdlZW4pIHtcbiAgICAgIGxvb2t1cFR3ZWVuID0geyAuLi50d2VlbiB9O1xuICAgICAgbG9va3VwVHdlZW4uX2NvbXBvc2l0aW9uID0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlO1xuICAgICAgbG9va3VwVHdlZW4uX3VwZGF0ZUR1cmF0aW9uID0gbWluVmFsdWU7XG4gICAgICBsb29rdXBUd2Vlbi5fc3RhcnRUaW1lID0gMDtcbiAgICAgIGxvb2t1cFR3ZWVuLl9udW1iZXJzID0gY2xvbmVBcnJheSh0d2Vlbi5fZnJvbU51bWJlcnMpO1xuICAgICAgbG9va3VwVHdlZW4uX251bWJlciA9IDA7XG4gICAgICBsb29rdXBUd2Vlbi5fbmV4dCA9IG51bGw7XG4gICAgICBsb29rdXBUd2Vlbi5fcHJldiA9IG51bGw7XG4gICAgICBhZGRDaGlsZChhZGRpdGl2ZVR3ZWVuU2libGluZ3MsIGxvb2t1cFR3ZWVuKTtcbiAgICAgIGFkZENoaWxkKGFkZGl0aXZlQW5pbWF0aW9uLCBsb29rdXBUd2Vlbik7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0aGUgdmFsdWVzIG9mIFRPIHRvIEZST00gYW5kIHNldCBUTyB0byAwXG5cbiAgICBjb25zdCB0b051bWJlciA9IHR3ZWVuLl90b051bWJlcjtcbiAgICB0d2Vlbi5fZnJvbU51bWJlciA9IGxvb2t1cFR3ZWVuLl9mcm9tTnVtYmVyIC0gdG9OdW1iZXI7XG4gICAgdHdlZW4uX3RvTnVtYmVyID0gMDtcbiAgICB0d2Vlbi5fbnVtYmVycyA9IGNsb25lQXJyYXkodHdlZW4uX2Zyb21OdW1iZXJzKTtcbiAgICB0d2Vlbi5fbnVtYmVyID0gMDtcbiAgICBsb29rdXBUd2Vlbi5fZnJvbU51bWJlciA9IHRvTnVtYmVyO1xuXG4gICAgaWYgKHR3ZWVuLl90b051bWJlcnMpIHtcbiAgICAgIGNvbnN0IHRvTnVtYmVycyA9IGNsb25lQXJyYXkodHdlZW4uX3RvTnVtYmVycyk7XG4gICAgICBpZiAodG9OdW1iZXJzKSB7XG4gICAgICAgIHRvTnVtYmVycy5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgIHR3ZWVuLl9mcm9tTnVtYmVyc1tpXSA9IGxvb2t1cFR3ZWVuLl9mcm9tTnVtYmVyc1tpXSAtIHZhbHVlO1xuICAgICAgICAgIHR3ZWVuLl90b051bWJlcnNbaV0gPSAwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxvb2t1cFR3ZWVuLl9mcm9tTnVtYmVycyA9IHRvTnVtYmVycztcbiAgICB9XG5cbiAgICBhZGRDaGlsZChhZGRpdGl2ZVR3ZWVuU2libGluZ3MsIHR3ZWVuLCBudWxsLCAnX3ByZXZBZGQnLCAnX25leHRBZGQnKTtcblxuICB9XG5cbiAgcmV0dXJuIHR3ZWVuO1xuXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1R3ZWVufSB0d2VlblxuICogQHJldHVybiB7VHdlZW59XG4gKi9cbmNvbnN0IHJlbW92ZVR3ZWVuU2xpYmxpbmdzID0gdHdlZW4gPT4ge1xuICBjb25zdCB0d2VlbkNvbXBvc2l0aW9uID0gdHdlZW4uX2NvbXBvc2l0aW9uO1xuICBpZiAodHdlZW5Db21wb3NpdGlvbiAhPT0gY29tcG9zaXRpb25UeXBlcy5ub25lKSB7XG4gICAgY29uc3QgdHdlZW5UYXJnZXQgPSB0d2Vlbi50YXJnZXQ7XG4gICAgY29uc3QgdHdlZW5Qcm9wZXJ0eSA9IHR3ZWVuLnByb3BlcnR5O1xuICAgIGNvbnN0IHJlcGxhY2VUd2VlbnNMb29rdXAgPSBsb29rdXBzLl9yZXA7XG4gICAgY29uc3QgcmVwbGFjZVRhcmdldFByb3BzID0gcmVwbGFjZVR3ZWVuc0xvb2t1cC5nZXQodHdlZW5UYXJnZXQpO1xuICAgIGNvbnN0IHR3ZWVuUmVwbGFjZVNpYmxpbmdzID0gcmVwbGFjZVRhcmdldFByb3BzW3R3ZWVuUHJvcGVydHldO1xuICAgIHJlbW92ZUNoaWxkKHR3ZWVuUmVwbGFjZVNpYmxpbmdzLCB0d2VlbiwgJ19wcmV2UmVwJywgJ19uZXh0UmVwJyk7XG4gICAgaWYgKHR3ZWVuQ29tcG9zaXRpb24gPT09IGNvbXBvc2l0aW9uVHlwZXMuYmxlbmQpIHtcbiAgICAgIGNvbnN0IGFkZFR3ZWVuc0xvb2t1cCA9IGxvb2t1cHMuX2FkZDtcbiAgICAgIGNvbnN0IGFkZFRhcmdldFByb3BzID0gYWRkVHdlZW5zTG9va3VwLmdldCh0d2VlblRhcmdldCk7XG4gICAgICBpZiAoIWFkZFRhcmdldFByb3BzKSByZXR1cm47XG4gICAgICBjb25zdCBhZGRpdGl2ZVR3ZWVuU2libGluZ3MgPSBhZGRUYXJnZXRQcm9wc1t0d2VlblByb3BlcnR5XTtcbiAgICAgIGNvbnN0IGFkZGl0aXZlQW5pbWF0aW9uID0gYWRkaXRpdmUuYW5pbWF0aW9uO1xuICAgICAgcmVtb3ZlQ2hpbGQoYWRkaXRpdmVUd2VlblNpYmxpbmdzLCB0d2VlbiwgJ19wcmV2QWRkJywgJ19uZXh0QWRkJyk7XG4gICAgICAvLyBJZiBvbmx5IG9uZSB0d2VlbiBpcyBsZWZ0IGluIHRoZSBhZGRpdGl2ZSBsb29rdXAsIGl0J3MgdGhlIHR3ZWVuIGxvb2t1cFxuICAgICAgY29uc3QgbG9va3VwVHdlZW4gPSBhZGRpdGl2ZVR3ZWVuU2libGluZ3MuX2hlYWQ7XG4gICAgICBpZiAobG9va3VwVHdlZW4gJiYgbG9va3VwVHdlZW4gPT09IGFkZGl0aXZlVHdlZW5TaWJsaW5ncy5fdGFpbCkge1xuICAgICAgICByZW1vdmVDaGlsZChhZGRpdGl2ZVR3ZWVuU2libGluZ3MsIGxvb2t1cFR3ZWVuLCAnX3ByZXZBZGQnLCAnX25leHRBZGQnKTtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoYWRkaXRpdmVBbmltYXRpb24sIGxvb2t1cFR3ZWVuKTtcbiAgICAgICAgbGV0IHNob3VsZENsZWFuID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBhZGRUYXJnZXRQcm9wcykge1xuICAgICAgICAgIGlmIChhZGRUYXJnZXRQcm9wc1twcm9wXS5faGVhZCkge1xuICAgICAgICAgICAgc2hvdWxkQ2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkQ2xlYW4pIHtcbiAgICAgICAgICBhZGRUd2VlbnNMb29rdXAuZGVsZXRlKHR3ZWVuVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHdlZW47XG59O1xuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge1RpbWVyfSB0aW1lclxuICogQHJldHVybiB7VGltZXJ9XG4gKi9cbmNvbnN0IHJlc2V0VGltZXJQcm9wZXJ0aWVzID0gdGltZXIgPT4ge1xuICB0aW1lci5wYXVzZWQgPSB0cnVlO1xuICB0aW1lci5iZWdhbiA9IGZhbHNlO1xuICB0aW1lci5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRpbWVyO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUaW1lcn0gdGltZXJcbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCByZXZpdmVUaW1lciA9IHRpbWVyID0+IHtcbiAgaWYgKCF0aW1lci5fY2FuY2VsbGVkKSByZXR1cm4gdGltZXI7XG4gIGlmICh0aW1lci5faGFzQ2hpbGRyZW4pIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGltZXIsIHJldml2ZVRpbWVyKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGltZXIsICgvKiogQHR5cGUge1R3ZWVufSB0d2VlbiovdHdlZW4pID0+IHtcbiAgICAgIGlmICh0d2Vlbi5fY29tcG9zaXRpb24gIT09IGNvbXBvc2l0aW9uVHlwZXMubm9uZSkge1xuICAgICAgICBjb21wb3NlVHdlZW4odHdlZW4sIGdldFR3ZWVuU2libGluZ3ModHdlZW4udGFyZ2V0LCB0d2Vlbi5wcm9wZXJ0eSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRpbWVyLl9jYW5jZWxsZWQgPSAwO1xuICByZXR1cm4gdGltZXI7XG59O1xuXG5sZXQgdGltZXJJZCA9IDA7XG5cbi8qKlxuICogQmFzZSBjbGFzcyB1c2VkIHRvIGNyZWF0ZSBUaW1lcnMsIEFuaW1hdGlvbnMgYW5kIFRpbWVsaW5lc1xuICovXG5jbGFzcyBUaW1lciBleHRlbmRzIENsb2NrIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGltZXJQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICAgKiBAcGFyYW0ge1RpbWVsaW5lfSBbcGFyZW50XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmVudFBvc2l0aW9uXVxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9LCBwYXJlbnQgPSBudWxsLCBwYXJlbnRQb3NpdGlvbiA9IDApIHtcblxuICAgIHN1cGVyKDApO1xuXG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBkZWxheSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgcmV2ZXJzZWQsXG4gICAgICBhbHRlcm5hdGUsXG4gICAgICBsb29wLFxuICAgICAgbG9vcERlbGF5LFxuICAgICAgYXV0b3BsYXksXG4gICAgICBmcmFtZVJhdGUsXG4gICAgICBwbGF5YmFja1JhdGUsXG4gICAgICBvbkNvbXBsZXRlLFxuICAgICAgb25Mb29wLFxuICAgICAgb25QYXVzZSxcbiAgICAgIG9uQmVnaW4sXG4gICAgICBvbkJlZm9yZVVwZGF0ZSxcbiAgICAgIG9uVXBkYXRlLFxuICAgIH0gPSBwYXJhbWV0ZXJzO1xuXG4gICAgaWYgKHNjb3BlLmN1cnJlbnQpIHNjb3BlLmN1cnJlbnQucmVnaXN0ZXIodGhpcyk7XG5cbiAgICBjb25zdCB0aW1lckluaXRUaW1lID0gcGFyZW50ID8gMCA6IGVuZ2luZS5fZWxhcHNlZFRpbWU7XG4gICAgY29uc3QgdGltZXJEZWZhdWx0cyA9IHBhcmVudCA/IHBhcmVudC5kZWZhdWx0cyA6IGdsb2JhbHMuZGVmYXVsdHM7XG4gICAgY29uc3QgdGltZXJEZWxheSA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhpc0ZuYyhkZWxheSkgfHwgaXNVbmQoZGVsYXkpID8gdGltZXJEZWZhdWx0cy5kZWxheSA6ICtkZWxheSk7XG4gICAgY29uc3QgdGltZXJEdXJhdGlvbiA9IGlzRm5jKGR1cmF0aW9uKSB8fCBpc1VuZChkdXJhdGlvbikgPyBJbmZpbml0eSA6ICtkdXJhdGlvbjtcbiAgICBjb25zdCB0aW1lckxvb3AgPSBzZXRWYWx1ZShsb29wLCB0aW1lckRlZmF1bHRzLmxvb3ApO1xuICAgIGNvbnN0IHRpbWVyTG9vcERlbGF5ID0gc2V0VmFsdWUobG9vcERlbGF5LCB0aW1lckRlZmF1bHRzLmxvb3BEZWxheSk7XG4gICAgY29uc3QgdGltZXJJdGVyYXRpb25Db3VudCA9IHRpbWVyTG9vcCA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lckxvb3AgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqLyh0aW1lckxvb3ApIDwgMCA/IEluZmluaXR5IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRpbWVyTG9vcCkgKyAxO1xuXG5cbiAgICBsZXQgb2Zmc2V0UG9zaXRpb24gPSAwO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgb2Zmc2V0UG9zaXRpb24gPSBwYXJlbnRQb3NpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWFrZSBzdXJlIHRvIHRpY2sgdGhlIGVuZ2luZSBvbmNlIGlmIG5vdCBjdXJyZW50bHkgcnVubmluZyB0byBnZXQgdXAgdG8gZGF0ZSBlbmdpbmUuX2VsYXBzZWRUaW1lXG4gICAgICAvLyB0byBhdm9pZCBiaWcgZ2FwcyB3aXRoIHRoZSBmb2xsb3dpbmcgb2Zmc2V0UG9zaXRpb24gY2FsY3VsYXRpb25cbiAgICAgIGlmICghZW5naW5lLnJlcUlkKSBlbmdpbmUucmVxdWVzdFRpY2sobm93KCkpO1xuICAgICAgLy8gTWFrZSBzdXJlIHRvIHNjYWxlIHRoZSBvZmZzZXQgcG9zaXRpb24gd2l0aCBnbG9iYWxzLnRpbWVTY2FsZSB0byBwcm9wZXJseSBoYW5kbGUgc2Vjb25kcyB1bml0XG4gICAgICBvZmZzZXRQb3NpdGlvbiA9IChlbmdpbmUuX2VsYXBzZWRUaW1lIC0gZW5naW5lLl9zdGFydFRpbWUpICogZ2xvYmFscy50aW1lU2NhbGU7XG4gICAgfVxuXG4gICAgLy8gVGltZXIncyBwYXJhbWV0ZXJzXG4gICAgdGhpcy5pZCA9ICFpc1VuZChpZCkgPyBpZCA6ICsrdGltZXJJZDtcbiAgICAvKiogQHR5cGUge1RpbWVsaW5lfSAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIC8vIFRvdGFsIGR1cmF0aW9uIG9mIHRoZSB0aW1lclxuICAgIHRoaXMuZHVyYXRpb24gPSBjbGFtcEluZmluaXR5KCgodGltZXJEdXJhdGlvbiArIHRpbWVyTG9vcERlbGF5KSAqIHRpbWVySXRlcmF0aW9uQ291bnQpIC0gdGltZXJMb29wRGVsYXkpIHx8IG1pblZhbHVlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJhY2t3YXJkcyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuYmVnYW4gPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25CZWdpbiA9IG9uQmVnaW4gfHwgdGltZXJEZWZhdWx0cy5vbkJlZ2luO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vbkJlZm9yZVVwZGF0ZSA9IG9uQmVmb3JlVXBkYXRlIHx8IHRpbWVyRGVmYXVsdHMub25CZWZvcmVVcGRhdGU7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uVXBkYXRlID0gb25VcGRhdGUgfHwgdGltZXJEZWZhdWx0cy5vblVwZGF0ZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25Mb29wID0gb25Mb29wIHx8IHRpbWVyRGVmYXVsdHMub25Mb29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblBhdXNlID0gb25QYXVzZSB8fCB0aW1lckRlZmF1bHRzLm9uUGF1c2U7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlIHx8IHRpbWVyRGVmYXVsdHMub25Db21wbGV0ZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gdGltZXJEdXJhdGlvbjsgLy8gRHVyYXRpb24gb2Ygb25lIGxvb3BcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkNvdW50ID0gdGltZXJJdGVyYXRpb25Db3VudDsgLy8gTnVtYmVyIG9mIGxvb3BzXG4gICAgLyoqIEB0eXBlIHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuX2F1dG9wbGF5ID0gcGFyZW50ID8gZmFsc2UgOiBzZXRWYWx1ZShhdXRvcGxheSwgdGltZXJEZWZhdWx0cy5hdXRvcGxheSk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0UG9zaXRpb247XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZGVsYXkgPSB0aW1lckRlbGF5O1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2xvb3BEZWxheSA9IHRpbWVyTG9vcERlbGF5O1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2l0ZXJhdGlvblRpbWUgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24gPSAwOyAvLyBDdXJyZW50IGxvb3AgaW5kZXhcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuX3Jlc29sdmUgPSBub29wOyAvLyBVc2VkIGJ5IC50aGVuKClcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX3JldmVyc2VkID0gK3NldFZhbHVlKHJldmVyc2VkLCB0aW1lckRlZmF1bHRzLnJldmVyc2VkKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9yZXZlcnNlID0gdGhpcy5fcmV2ZXJzZWQ7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fY2FuY2VsbGVkID0gMDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5fYWx0ZXJuYXRlID0gc2V0VmFsdWUoYWx0ZXJuYXRlLCB0aW1lckRlZmF1bHRzLmFsdGVybmF0ZSk7XG4gICAgLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqL1xuICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi9cbiAgICB0aGlzLl9uZXh0ID0gbnVsbDtcblxuICAgIC8vIENsb2NrJ3MgcGFyYW1ldGVyc1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gdGltZXJJbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lckluaXRUaW1lO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2xhc3RUaW1lID0gdGltZXJJbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9mcHMgPSBzZXRWYWx1ZShmcmFtZVJhdGUsIHRpbWVyRGVmYXVsdHMuZnJhbWVSYXRlKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zcGVlZCA9IHNldFZhbHVlKHBsYXliYWNrUmF0ZSwgdGltZXJEZWZhdWx0cy5wbGF5YmFja1JhdGUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGxlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9jYW5jZWxsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxsZWQgICovXG4gIHNldCBjYW5jZWxsZWQoY2FuY2VsbGVkKSB7XG4gICAgY2FuY2VsbGVkID8gdGhpcy5jYW5jZWwoKSA6IHRoaXMucmVzZXQoMSkucGxheSgpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiBjbGFtcChyb3VuZCh0aGlzLl9jdXJyZW50VGltZSwgZ2xvYmFscy5wcmVjaXNpb24pLCAtdGhpcy5fZGVsYXksIHRoaXMuZHVyYXRpb24pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICAqL1xuICBzZXQgY3VycmVudFRpbWUodGltZSkge1xuICAgIGNvbnN0IHBhdXNlZCA9IHRoaXMucGF1c2VkO1xuICAgIC8vIFBhdXNpbmcgdGhlIHRpbWVyIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCB0aW1lIGp1bXBzIG9uIGEgcnVubmluZyBpbnN0YW5jZVxuICAgIHRoaXMucGF1c2UoKS5zZWVrKCt0aW1lKTtcbiAgICBpZiAoIXBhdXNlZCkgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGdldCBpdGVyYXRpb25DdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gcm91bmQodGhpcy5faXRlcmF0aW9uVGltZSwgZ2xvYmFscy5wcmVjaXNpb24pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICAqL1xuICBzZXQgaXRlcmF0aW9uQ3VycmVudFRpbWUodGltZSkge1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAodGhpcy5pdGVyYXRpb25EdXJhdGlvbiAqIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24pICsgdGltZTtcbiAgfVxuXG4gIGdldCBwcm9ncmVzcygpIHtcbiAgICByZXR1cm4gY2xhbXAocm91bmQodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmR1cmF0aW9uLCAxMCksIDAsIDEpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAgKi9cbiAgc2V0IHByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IHRoaXMuZHVyYXRpb24gKiBwcm9ncmVzcztcbiAgfVxuXG4gIGdldCBpdGVyYXRpb25Qcm9ncmVzcygpIHtcbiAgICByZXR1cm4gY2xhbXAocm91bmQodGhpcy5faXRlcmF0aW9uVGltZSAvIHRoaXMuaXRlcmF0aW9uRHVyYXRpb24sIDEwKSwgMCwgMSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzICAqL1xuICBzZXQgaXRlcmF0aW9uUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICBjb25zdCBpdGVyYXRpb25EdXJhdGlvbiA9IHRoaXMuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IChpdGVyYXRpb25EdXJhdGlvbiAqIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24pICsgKGl0ZXJhdGlvbkR1cmF0aW9uICogcHJvZ3Jlc3MpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRJdGVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRJdGVyYXRpb247XG4gIH1cblxuICAvKiogQHBhcmFtIHtOdW1iZXJ9IGl0ZXJhdGlvbkNvdW50ICAqL1xuICBzZXQgY3VycmVudEl0ZXJhdGlvbihpdGVyYXRpb25Db3VudCkge1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAodGhpcy5pdGVyYXRpb25EdXJhdGlvbiAqIGNsYW1wKCtpdGVyYXRpb25Db3VudCwgMCwgdGhpcy5pdGVyYXRpb25Db3VudCAtIDEpKTtcbiAgfVxuXG4gIGdldCByZXZlcnNlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yZXZlcnNlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge0Jvb2xlYW59IHJldmVyc2UgICovXG4gIHNldCByZXZlcnNlZChyZXZlcnNlKSB7XG4gICAgcmV2ZXJzZSA/IHRoaXMucmV2ZXJzZSgpIDogdGhpcy5wbGF5KCk7XG4gIH1cblxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnNwZWVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwbGF5YmFja1JhdGUgICovXG4gIHNldCBzcGVlZChwbGF5YmFja1JhdGUpIHtcbiAgICBzdXBlci5zcGVlZCA9IHBsYXliYWNrUmF0ZTtcbiAgICB0aGlzLnJlc2V0VGltZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHJlc2V0KGludGVybmFsUmVuZGVyID0gMCkge1xuICAgIC8vIElmIGNhbmNlbGxlZCwgcmV2aXZlIHRoZSB0aW1lciBiZWZvcmUgcmVuZGVyaW5nIGluIG9yZGVyIHRvIGhhdmUgcHJvcGVydGx5IGNvbXBvc2VkIHR3ZWVucyBzaWJsaW5nc1xuICAgIHJldml2ZVRpbWVyKHRoaXMpO1xuICAgIGlmICh0aGlzLl9yZXZlcnNlZCAmJiAhdGhpcy5fcmV2ZXJzZSkgdGhpcy5yZXZlcnNlZCA9IGZhbHNlO1xuICAgIC8vIFJlbmRlcmluZyBiZWZvcmUgdXBkYXRpbmcgdGhlIGNvbXBsZXRlZCBmbGFnIHRvIHByZXZlbnQgc2tpcHMgYW5kIHRvIG1ha2Ugc3VyZSB0aGUgcHJvcGVydGllcyBhcmUgbm90IG92ZXJyaWRkZW5cbiAgICAvLyBTZXR0aW5nIHRoZSBpdGVyYXRpb25UaW1lIGF0IHRoZSBlbmQgdG8gZm9yY2UgdGhlIHJlbmRlcmluZyB0byBoYXBwZW5kIGJhY2t3YXJkcywgb3RoZXJ3aXNlIGNhbGxpbmcgLnJlc2V0KCkgb24gVGltZWxpbmVzIG1pZ2h0IG5vdCByZW5kZXIgY2hpbGRyZW4gaW4gdGhlIHJpZ2h0IG9yZGVyXG4gICAgLy8gTk9URTogVGhpcyBpcyBvbmx5IHJlcXVpcmVkIGZvciBUaW1lbGluZXMgYW5kIG1pZ2h0IGJlIGJldHRlciB0byBtb3ZlIHRvIHRoZSBUaW1lbGluZSBjbGFzcz9cbiAgICB0aGlzLl9pdGVyYXRpb25UaW1lID0gdGhpcy5pdGVyYXRpb25EdXJhdGlvbjtcbiAgICAvLyBTZXQgdGlja01vZGUgdG8gdGlja01vZGVzLkZPUkNFIHRvIGZvcmNlIHJlbmRlcmluZ1xuICAgIHRpY2sodGhpcywgMCwgMSwgaW50ZXJuYWxSZW5kZXIsIHRpY2tNb2Rlcy5GT1JDRSk7XG4gICAgLy8gUmVzZXQgdGltZXIgcHJvcGVydGllcyBhZnRlciByZXZpdmUgLyByZW5kZXIgdG8gbWFrZSBzdXJlIHRoZSBwcm9wcyBhcmUgbm90IHVwZGF0ZWQgYWdhaW5cbiAgICByZXNldFRpbWVyUHJvcGVydGllcyh0aGlzKTtcbiAgICAvLyBBbHNvIHJlc2V0IGNoaWxkcmVuIHByb3BlcnRpZXNcbiAgICBpZiAodGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCByZXNldFRpbWVyUHJvcGVydGllcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGluaXQoaW50ZXJuYWxSZW5kZXIgPSAwKSB7XG4gICAgdGhpcy5mcHMgPSB0aGlzLl9mcHM7XG4gICAgdGhpcy5zcGVlZCA9IHRoaXMuX3NwZWVkO1xuICAgIC8vIE1hbnVhbGx5IGNhbGxpbmcgLmluaXQoKSBvbiB0aW1lbGluZXMgc2hvdWxkIHJlbmRlciBhbGwgY2hpbGRyZW4gaW50aWFsIHN0YXRlXG4gICAgLy8gRm9yY2VzIGFsbCBjaGlsZHJlbiB0byByZW5kZXIgb25jZSB0aGVuIHJlbmRlciB0byAwIHdoZW4gcmVzZXRlZFxuICAgIGlmICghaW50ZXJuYWxSZW5kZXIgJiYgdGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIHRpY2sodGhpcywgdGhpcy5kdXJhdGlvbiwgMSwgaW50ZXJuYWxSZW5kZXIsIHRpY2tNb2Rlcy5GT1JDRSk7XG4gICAgfVxuICAgIHRoaXMucmVzZXQoaW50ZXJuYWxSZW5kZXIpO1xuICAgIC8vIE1ha2Ugc3VyZSB0byBzZXQgYXV0b3BsYXkgdG8gZmFsc2UgdG8gY2hpbGQgdGltZXJzIHNvIGl0IGRvZXNuJ3QgYXR0ZW1wdCB0byBhdXRvcGxheSAvIGxpbmtcbiAgICBjb25zdCBhdXRvcGxheSA9IHRoaXMuX2F1dG9wbGF5O1xuICAgIGlmIChhdXRvcGxheSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKGF1dG9wbGF5ICYmICFpc1VuZCgvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqLyhhdXRvcGxheSkubGlua2VkKSkge1xuICAgICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi8oYXV0b3BsYXkpLmxpbmsodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge3RoaXN9ICovXG4gIHJlc2V0VGltZSgpIHtcbiAgICBjb25zdCB0aW1lU2NhbGUgPSAxIC8gKHRoaXMuX3NwZWVkICogZW5naW5lLl9zcGVlZCk7XG4gICAgLy8gVE9ETzogU2VlIGlmIHdlIGNhbiBzYWZlbHkgdXNlIGVuZ2luZS5fZWxhcHNlZFRpbWUgaGVyZVxuICAgIC8vIGlmICghZW5naW5lLnJlcUlkKSBlbmdpbmUucmVxdWVzdFRpY2sobm93KCkpXG4gICAgLy8gdGhpcy5fc3RhcnRUaW1lID0gZW5naW5lLl9lbGFwc2VkVGltZSAtICh0aGlzLl9jdXJyZW50VGltZSArIHRoaXMuX2RlbGF5KSAqIHRpbWVTY2FsZTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBub3coKSAtICh0aGlzLl9jdXJyZW50VGltZSArIHRoaXMuX2RlbGF5KSAqIHRpbWVTY2FsZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICBwYXVzZSgpIHtcbiAgICBpZiAodGhpcy5wYXVzZWQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9uUGF1c2UodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgLy8gV2UgY2FuIHNhZmVseSBpbWVkaWF0bHkgcmVuZGVyIGEgdGltZXIgdGhhdCBoYXMgbm8gZHVyYXRpb24gYW5kIG5vIGNoaWxkcmVuXG4gICAgaWYgKHRoaXMuZHVyYXRpb24gPD0gbWluVmFsdWUgJiYgIXRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICB0aWNrKHRoaXMsIG1pblZhbHVlLCAwLCAwLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgYWRkQ2hpbGQoZW5naW5lLCB0aGlzKTtcbiAgICAgICAgZW5naW5lLl9oYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldFRpbWUoKTtcbiAgICAgIC8vIEZvcmNlcyB0aGUgdGltZXIgdG8gYWR2YW5jZSBieSBhdCBsZWFzdCBvbmUgZnJhbWUgd2hlbiB0aGUgbmV4dCB0aWNrIG9jY3Vyc1xuICAgICAgdGhpcy5fc3RhcnRUaW1lIC09IDEyO1xuICAgICAgZW5naW5lLndha2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgcmVzdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNldCgwKS5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVcbiAgICogQHBhcmFtICB7Qm9vbGVhbnxOdW1iZXJ9IFttdXRlQ2FsbGJhY2tzXVxuICAgKiBAcGFyYW0gIHtCb29sZWFufE51bWJlcn0gW2ludGVybmFsUmVuZGVyXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2Vlayh0aW1lLCBtdXRlQ2FsbGJhY2tzID0gMCwgaW50ZXJuYWxSZW5kZXIgPSAwKSB7XG4gICAgLy8gUmVjb21wb3NlIHRoZSB0d2VlbiBzaWJsaW5ncyBpbiBjYXNlIHRoZSB0aW1lciBoYXMgYmVlbiBjYW5jZWxsZWRcbiAgICByZXZpdmVUaW1lcih0aGlzKTtcbiAgICAvLyBJZiB5b3Ugc2VlayBhIGNvbXBsZXRlZCBhbmltYXRpb24sIG90aGVyd2lzZSB0aGUgbmV4dCBwbGF5IHdpbGwgc3RhcnRzIGF0IDBcbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlzUGF1c2VkID0gdGhpcy5wYXVzZWQ7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIC8vIHRpbWVyLCB0aW1lLCBtdXRlQ2FsbGJhY2tzLCBpbnRlcm5hbFJlbmRlciwgdGlja01vZGVcbiAgICB0aWNrKHRoaXMsIHRpbWUgKyB0aGlzLl9kZWxheSwgfn5tdXRlQ2FsbGJhY2tzLCB+fmludGVybmFsUmVuZGVyLCB0aWNrTW9kZXMuQVVUTyk7XG4gICAgcmV0dXJuIGlzUGF1c2VkID8gdGhpcyA6IHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgYWx0ZXJuYXRlKCkge1xuICAgIGNvbnN0IHJldmVyc2VkID0gdGhpcy5fcmV2ZXJzZWQ7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLml0ZXJhdGlvbkNvdW50O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5pdGVyYXRpb25EdXJhdGlvbjtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1heGltdW0gaXRlcmF0aW9ucyBwb3NzaWJsZSBnaXZlbiB0aGUgaXRlcmF0aW9uIGR1cmF0aW9uXG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IGNvdW50ID09PSBJbmZpbml0eSA/IGZsb29yKG1heFZhbHVlIC8gZHVyYXRpb24pIDogY291bnQ7XG4gICAgdGhpcy5fcmV2ZXJzZWQgPSArKHRoaXMuX2FsdGVybmF0ZSAmJiAhKGl0ZXJhdGlvbnMgJSAyKSA/IHJldmVyc2VkIDogIXJldmVyc2VkKTtcbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSB7XG4gICAgICAvLyBIYW5kbGUgaW5maW5pdGUgbG9vcHMgdG8gbG9vcCBvbiB0aGVtc2VsZlxuICAgICAgdGhpcy5pdGVyYXRpb25Qcm9ncmVzcyA9IHRoaXMuX3JldmVyc2VkID8gMSAtIHRoaXMuaXRlcmF0aW9uUHJvZ3Jlc3MgOiB0aGlzLml0ZXJhdGlvblByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlZWsoKGR1cmF0aW9uICogaXRlcmF0aW9ucykgLSB0aGlzLl9jdXJyZW50VGltZSk7XG4gICAgfVxuICAgIHRoaXMucmVzZXRUaW1lKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZWQpIHRoaXMuYWx0ZXJuYXRlKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7dGhpc30gKi9cbiAgcmV2ZXJzZSgpIHtcbiAgICBpZiAoIXRoaXMuX3JldmVyc2VkKSB0aGlzLmFsdGVybmF0ZSgpO1xuICAgIHJldHVybiB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgLy8gVE9ETzogTW92ZSBhbGwgdGhlIGFuaW1hdGlvbiAvIHR3ZWVucyAvIGNoaWxkcmVuIHJlbGF0ZWQgY29kZSB0byBBbmltYXRpb24gLyBUaW1lbGluZVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi9jaGlsZCkgPT4gY2hpbGQuY2FuY2VsKCksIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgcmVtb3ZlVHdlZW5TbGlibGluZ3MpO1xuICAgIH1cbiAgICB0aGlzLl9jYW5jZWxsZWQgPSAxO1xuICAgIC8vIFBhdXNpbmcgdGhlIHRpbWVyIHJlbW92ZXMgaXQgZnJvbSB0aGUgZW5naW5lXG4gICAgcmV0dXJuIHRoaXMucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG5ld0R1cmF0aW9uXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzdHJldGNoKG5ld0R1cmF0aW9uKSB7XG4gICAgY29uc3QgY3VycmVudER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBjb25zdCBub3JtbGl6ZWREdXJhdGlvbiA9IG5vcm1hbGl6ZVRpbWUobmV3RHVyYXRpb24pO1xuICAgIGlmIChjdXJyZW50RHVyYXRpb24gPT09IG5vcm1saXplZER1cmF0aW9uKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB0aW1lU2NhbGUgPSBuZXdEdXJhdGlvbiAvIGN1cnJlbnREdXJhdGlvbjtcbiAgICBjb25zdCBpc1NldHRlciA9IG5ld0R1cmF0aW9uIDw9IG1pblZhbHVlO1xuICAgIHRoaXMuZHVyYXRpb24gPSBpc1NldHRlciA/IG1pblZhbHVlIDogbm9ybWxpemVkRHVyYXRpb247XG4gICAgdGhpcy5pdGVyYXRpb25EdXJhdGlvbiA9IGlzU2V0dGVyID8gbWluVmFsdWUgOiBub3JtYWxpemVUaW1lKHRoaXMuaXRlcmF0aW9uRHVyYXRpb24gKiB0aW1lU2NhbGUpO1xuICAgIHRoaXMuX29mZnNldCAqPSB0aW1lU2NhbGU7XG4gICAgdGhpcy5fZGVsYXkgKj0gdGltZVNjYWxlO1xuICAgIHRoaXMuX2xvb3BEZWxheSAqPSB0aW1lU2NhbGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuIC8qKlxuICAgKiBDYW5jZWxzIHRoZSB0aW1lciBieSBzZWVraW5nIGl0IGJhY2sgdG8gMCBhbmQgcmV2ZXJ0aW5nIHRoZSBhdHRhY2hlZCBzY3JvbGxlciBpZiBuZWNlc3NhcnlcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHJldmVydCgpIHtcbiAgICB0aWNrKHRoaXMsIDAsIDEsIDAsIHRpY2tNb2Rlcy5BVVRPKTtcbiAgICBjb25zdCBhcCA9IC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovKHRoaXMuX2F1dG9wbGF5KTtcbiAgICBpZiAoYXAgJiYgYXAubGlua2VkICYmIGFwLmxpbmtlZCA9PT0gdGhpcykgYXAucmV2ZXJ0KCk7XG4gICAgcmV0dXJuIHRoaXMuY2FuY2VsKCk7XG4gIH1cblxuIC8qKlxuICAgKiBJbWVkaWF0bHkgY29tcGxldGVzIHRoZSB0aW1lciwgY2FuY2VscyBpdCBhbmQgdHJpZ2dlcnMgdGhlIG9uQ29tcGxldGUgY2FsbGJhY2tcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGNvbXBsZXRlKCkge1xuICAgIHJldHVybiB0aGlzLnNlZWsodGhpcy5kdXJhdGlvbikuY2FuY2VsKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7Q2FsbGJhY2s8dGhpcz59IFtjYWxsYmFja11cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHRoZW4oY2FsbGJhY2sgPSBub29wKSB7XG4gICAgY29uc3QgdGhlbiA9IHRoaXMudGhlbjtcbiAgICBjb25zdCBvblJlc29sdmUgPSAoKSA9PiB7XG4gICAgICAvLyB0aGlzLnRoZW4gPSBudWxsIHByZXZlbnRzIGluZmluaXRlIHJlY3Vyc2lvbiBpZiByZXR1cm5lZCBieSBhbiBhc3luYyBmdW5jdGlvblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2p1bGlhbmdhcm5pZXJvcmcvYW5pbWUtYmV0YS9pc3N1ZXMvMjZcbiAgICAgIHRoaXMudGhlbiA9IG51bGw7XG4gICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgIHRoaXMudGhlbiA9IHRoZW47XG4gICAgICB0aGlzLl9yZXNvbHZlID0gbm9vcDtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSAoKSA9PiByKG9uUmVzb2x2ZSgpKTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0byByZXNvbHZlIGltZWRpYXRseSBpZiB0aGUgdGltZXIgaGFzIGFscmVhZHkgY29tcGxldGVkXG4gICAgICBpZiAodGhpcy5jb21wbGV0ZWQpIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVyUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCBjcmVhdGVUaW1lciA9IHBhcmFtZXRlcnMgPT4gbmV3IFRpbWVyKHBhcmFtZXRlcnMsIG51bGwsIDApLmluaXQoKTtcblxuXG5cblxuLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbmNvbnN0IG5vbmUgPSB0ID0+IHQ7XG5cbi8vIEN1YmljIEJlemllciBzb2x2ZXIgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2UgwqkgR2HDq3RhbiBSZW5hdWRlYXVcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFUXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFBMVxuICogQHBhcmFtICB7TnVtYmVyfSBhQTJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgY2FsY0JlemllciA9IChhVCwgYUExLCBhQTIpID0+ICgoKDEgLSAzICogYUEyICsgMyAqIGFBMSkgKiBhVCArICgzICogYUEyIC0gNiAqIGFBMSkpICogYVQgKyAoMyAqIGFBMSkpICogYVQ7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSBhWFxuICogQHBhcmFtICB7TnVtYmVyfSBtWDFcbiAqIEBwYXJhbSAge051bWJlcn0gbVgyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGJpbmFyeVN1YmRpdmlkZSA9IChhWCwgbVgxLCBtWDIpID0+IHtcbiAgbGV0IGFBID0gMCwgYUIgPSAxLCBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xuICBkbyB7XG4gICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDI7XG4gICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICBpZiAoY3VycmVudFggPiAwKSB7XG4gICAgICBhQiA9IGN1cnJlbnRUO1xuICAgIH0gZWxzZSB7XG4gICAgICBhQSA9IGN1cnJlbnRUO1xuICAgIH1cbiAgfSB3aGlsZSAoYWJzKGN1cnJlbnRYKSA+IC4wMDAwMDAxICYmICsraSA8IDEwMCk7XG4gIHJldHVybiBjdXJyZW50VDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSBbbVgxXSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludFxuICogQHBhcmFtICB7TnVtYmVyfSBbbVkxXSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludFxuICogQHBhcmFtICB7TnVtYmVyfSBbbVgyXSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnRcbiAqIEBwYXJhbSAge051bWJlcn0gW21ZMl0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50XG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuXG5jb25zdCBjdWJpY0JlemllciA9IChtWDEgPSAwLjUsIG1ZMSA9IDAuMCwgbVgyID0gMC41LCBtWTIgPSAxLjApID0+IChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgPyBub25lIDpcbiAgdCA9PiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDpcbiAgY2FsY0JlemllcihiaW5hcnlTdWJkaXZpZGUodCwgbVgxLCBtWDIpLCBtWTEsIG1ZMik7XG5cbi8qKlxuICogU3RlcHMgZWFzZSBpbXBsZW1lbnRhdGlvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9mci9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cbiAqIE9ubHkgY292ZXJzICdlbmQnIGFuZCAnc3RhcnQnIGp1bXB0ZXJtc1xuICogQHBhcmFtICB7TnVtYmVyfSBzdGVwc1xuICogQHBhcmFtICB7Qm9vbGVhbn0gW2Zyb21TdGFydF1cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBzdGVwcyA9IChzdGVwcyA9IDEwLCBmcm9tU3RhcnQpID0+IHtcbiAgY29uc3Qgcm91bmRNZXRob2QgPSBmcm9tU3RhcnQgPyBjZWlsIDogZmxvb3I7XG4gIHJldHVybiB0ID0+IHJvdW5kTWV0aG9kKGNsYW1wKHQsIDAsIDEpICogc3RlcHMpICogKDEgLyBzdGVwcyk7XG59O1xuXG4vKipcbiAqIFdpdGhvdXQgcGFyYW1ldGVycywgdGhlIGxpbmVhciBmdW5jdGlvbiBjcmVhdGVzIGEgbm9uLWVhc2VkIHRyYW5zaXRpb24uXG4gKiBQYXJhbWV0ZXJzLCBpZiB1c2VkLCBjcmVhdGVzIGEgcGllY2V3aXNlIGxpbmVhciBlYXNpbmcgYnkgaW50ZXJwb2xhdGluZyBsaW5lYXJseSBiZXR3ZWVuIHRoZSBzcGVjaWZpZWQgcG9pbnRzLlxuICogQHBhcmFtICB7Li4uKFN0cmluZ3xOdW1iZXIpfSBhcmdzIC0gUG9pbnRzXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuY29uc3QgbGluZWFyID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICBpZiAoIWFyZ3NMZW5ndGgpIHJldHVybiBub25lO1xuICBjb25zdCB0b3RhbFBvaW50cyA9IGFyZ3NMZW5ndGggLSAxO1xuICBjb25zdCBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gIGNvbnN0IGxhc3RBcmcgPSBhcmdzW3RvdGFsUG9pbnRzXTtcbiAgY29uc3QgeFBvaW50cyA9IFswXTtcbiAgY29uc3QgeVBvaW50cyA9IFtwYXJzZU51bWJlcihmaXJzdEFyZyldO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHRvdGFsUG9pbnRzOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgIGNvbnN0IHNwbGl0VmFsdWUgPSBpc1N0cihhcmcpID9cbiAgICAvKiogQHR5cGUge1N0cmluZ30gKi8oYXJnKS50cmltKCkuc3BsaXQoJyAnKSA6XG4gICAgW2FyZ107XG4gICAgY29uc3QgdmFsdWUgPSBzcGxpdFZhbHVlWzBdO1xuICAgIGNvbnN0IHBlcmNlbnQgPSBzcGxpdFZhbHVlWzFdO1xuICAgIHhQb2ludHMucHVzaCghaXNVbmQocGVyY2VudCkgPyBwYXJzZU51bWJlcihwZXJjZW50KSAvIDEwMCA6IGkgLyB0b3RhbFBvaW50cyk7XG4gICAgeVBvaW50cy5wdXNoKHBhcnNlTnVtYmVyKHZhbHVlKSk7XG4gIH1cbiAgeVBvaW50cy5wdXNoKHBhcnNlTnVtYmVyKGxhc3RBcmcpKTtcbiAgeFBvaW50cy5wdXNoKDEpO1xuICByZXR1cm4gZnVuY3Rpb24gZWFzZUxpbmVhcih0KSB7XG4gICAgZm9yIChsZXQgaSA9IDEsIGwgPSB4UG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudFggPSB4UG9pbnRzW2ldO1xuICAgICAgaWYgKHQgPD0gY3VycmVudFgpIHtcbiAgICAgICAgY29uc3QgcHJldlggPSB4UG9pbnRzW2kgLSAxXTtcbiAgICAgICAgY29uc3QgcHJldlkgPSB5UG9pbnRzW2kgLSAxXTtcbiAgICAgICAgcmV0dXJuIHByZXZZICsgKHlQb2ludHNbaV0gLSBwcmV2WSkgKiAodCAtIHByZXZYKSAvIChjdXJyZW50WCAtIHByZXZYKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHlQb2ludHNbeVBvaW50cy5sZW5ndGggLSAxXTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSByYW5kb20gc3RlcHNcbiAqIEBwYXJhbSAge051bWJlcn0gW2xlbmd0aF0gLSBUaGUgbnVtYmVyIG9mIHN0ZXBzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtyYW5kb21uZXNzXSAtIEhvdyBzdHJvbmcgdGhlIHJhbmRvbW5lc3MgaXNcbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBpcnJlZ3VsYXIgPSAobGVuZ3RoID0gMTAsIHJhbmRvbW5lc3MgPSAxKSA9PiB7XG4gIGNvbnN0IHZhbHVlcyA9IFswXTtcbiAgY29uc3QgdG90YWwgPSBsZW5ndGggLSAxO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdmFsdWVzW2kgLSAxXTtcbiAgICBjb25zdCBzcGFjaW5nID0gaSAvIHRvdGFsO1xuICAgIGNvbnN0IHNlZ21lbnRFbmQgPSAoaSArIDEpIC8gdG90YWw7XG4gICAgY29uc3QgcmFuZG9tVmFyaWF0aW9uID0gc3BhY2luZyArIChzZWdtZW50RW5kIC0gc3BhY2luZykgKiBNYXRoLnJhbmRvbSgpO1xuICAgIC8vIE1peCB0aGUgZXZlbiBzcGFjaW5nIGFuZCByYW5kb20gdmFyaWF0aW9uIGJhc2VkIG9uIHRoZSByYW5kb21uZXNzIHBhcmFtZXRlclxuICAgIGNvbnN0IHJhbmRvbVZhbHVlID0gc3BhY2luZyAqICgxIC0gcmFuZG9tbmVzcykgKyByYW5kb21WYXJpYXRpb24gKiByYW5kb21uZXNzO1xuICAgIHZhbHVlcy5wdXNoKGNsYW1wKHJhbmRvbVZhbHVlLCBwcmV2aW91c1ZhbHVlLCAxKSk7XG4gIH1cbiAgdmFsdWVzLnB1c2goMSk7XG4gIHJldHVybiBsaW5lYXIoLi4udmFsdWVzKTtcbn07XG5cbi8vIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNlIMKpIFJvYmVydCBQZW5uZXJcblxuLyoqXG4gKiBAY2FsbGJhY2sgUG93ZXJFYXNpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3Bvd2VyPTEuNjc1XVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQmFja0Vhc2luZ1xuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3ZlcnNob290PTEuNzAxNThdXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBFbGFzdGljRWFzaW5nXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFthbXBsaXR1ZGU9MV1cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3BlcmlvZD0uM11cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVhc2VGYWN0b3J5XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtwYXJhbUFdXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtwYXJhbUJdXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbnxOdW1iZXJ9XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtQb3dlckVhc2luZ3xCYWNrRWFzaW5nfEVsYXN0aWNFYXNpbmd9IEVhc2VzRmFjdG9yeSAqL1xuXG5jb25zdCBoYWxmUEkgPSBQSSAvIDI7XG5jb25zdCBkb3VibGVQSSA9IFBJICogMjtcbi8qKiBAdHlwZSB7UG93ZXJFYXNpbmd9ICovXG5jb25zdCBlYXNlSW5Qb3dlciA9IChwID0gMS42OCkgPT4gdCA9PiBwb3codCwgK3ApO1xuXG4vKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2VzRmFjdG9yeXxFYXNpbmdGdW5jdGlvbj59ICovXG5jb25zdCBlYXNlSW5GdW5jdGlvbnMgPSB7XG4gIFtlbXB0eVN0cmluZ106IGVhc2VJblBvd2VyLFxuICBRdWFkOiBlYXNlSW5Qb3dlcigyKSxcbiAgQ3ViaWM6IGVhc2VJblBvd2VyKDMpLFxuICBRdWFydDogZWFzZUluUG93ZXIoNCksXG4gIFF1aW50OiBlYXNlSW5Qb3dlcig1KSxcbiAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgU2luZTogdCA9PiAxIC0gY29zKHQgKiBoYWxmUEkpLFxuICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICBDaXJjOiB0ID0+IDEgLSBzcXJ0KDEgLSB0ICogdCksXG4gIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gIEV4cG86IHQgPT4gdCA/IHBvdygyLCAxMCAqIHQgLSAxMCkgOiAwLFxuICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICBCb3VuY2U6IHQgPT4ge1xuICAgIGxldCBwb3cyLCBiID0gNDtcbiAgICB3aGlsZSAodCA8ICgocG93MiA9IHBvdygyLCAtLWIpKSAtIDEpIC8gMTEpO1xuICAgIHJldHVybiAxIC8gcG93KDQsIDMgLSBiKSAtIDcuNTYyNSAqIHBvdygocG93MiAqIDMgLSAyKSAvIDIyIC0gdCwgMik7XG4gIH0sXG4gIC8qKiBAdHlwZSB7QmFja0Vhc2luZ30gKi9cbiAgQmFjazogKG92ZXJzaG9vdCA9IDEuNzAxNTgpID0+IHQgPT4gKCtvdmVyc2hvb3QgKyAxKSAqIHQgKiB0ICogdCAtICtvdmVyc2hvb3QgKiB0ICogdCxcbiAgLyoqIEB0eXBlIHtFbGFzdGljRWFzaW5nfSAqL1xuICBFbGFzdGljOiAoYW1wbGl0dWRlID0gMSwgcGVyaW9kID0gLjMpID0+IHtcbiAgICBjb25zdCBhID0gY2xhbXAoK2FtcGxpdHVkZSwgMSwgMTApO1xuICAgIGNvbnN0IHAgPSBjbGFtcCgrcGVyaW9kLCBtaW5WYWx1ZSwgMik7XG4gICAgY29uc3QgcyA9IChwIC8gZG91YmxlUEkpICogYXNpbigxIC8gYSk7XG4gICAgY29uc3QgZSA9IGRvdWJsZVBJIC8gcDtcbiAgICByZXR1cm4gdCA9PiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDogLWEgKiBwb3coMiwgLTEwICogKDEgLSB0KSkgKiBzaW4oKCgxIC0gdCkgLSBzKSAqIGUpO1xuICB9XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBFYXNlVHlwZVxuICogQHBhcmFtIHtFYXNpbmdGdW5jdGlvbn0gRWFzZVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cblxuLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBFYXNlVHlwZT59ICovXG5jb25zdCBlYXNlVHlwZXMgPSB7XG4gIGluOiBlYXNlSW4gPT4gdCA9PiBlYXNlSW4odCksXG4gIG91dDogZWFzZUluID0+IHQgPT4gMSAtIGVhc2VJbigxIC0gdCksXG4gIGluT3V0OiBlYXNlSW4gPT4gdCA9PiB0IDwgLjUgPyBlYXNlSW4odCAqIDIpIC8gMiA6IDEgLSBlYXNlSW4odCAqIC0yICsgMikgLyAyLFxuICBvdXRJbjogZWFzZUluID0+IHQgPT4gdCA8IC41ID8gKDEgLSBlYXNlSW4oMSAtIHQgKiAyKSkgLyAyIDogKGVhc2VJbih0ICogMiAtIDEpICsgMSkgLyAyLFxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtICB7UmVjb3JkPFN0cmluZywgRWFzZXNGYWN0b3J5fEVhc2luZ0Z1bmN0aW9uPn0gZWFzZXNGdW5jdGlvbnNcbiAqIEBwYXJhbSAge09iamVjdH0gZWFzZXNMb29rdXBzXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuY29uc3QgcGFyc2VFYXNlU3RyaW5nID0gKHN0cmluZywgZWFzZXNGdW5jdGlvbnMsIGVhc2VzTG9va3VwcykgPT4ge1xuICBpZiAoZWFzZXNMb29rdXBzW3N0cmluZ10pIHJldHVybiBlYXNlc0xvb2t1cHNbc3RyaW5nXTtcbiAgaWYgKHN0cmluZy5pbmRleE9mKCcoJykgPD0gLTEpIHtcbiAgICBjb25zdCBoYXNQYXJhbXMgPSBlYXNlVHlwZXNbc3RyaW5nXSB8fCBzdHJpbmcuaW5jbHVkZXMoJ0JhY2snKSB8fCBzdHJpbmcuaW5jbHVkZXMoJ0VsYXN0aWMnKTtcbiAgICBjb25zdCBwYXJzZWRGbiA9IC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovKGhhc1BhcmFtcyA/IC8qKiBAdHlwZSB7RWFzZXNGYWN0b3J5fSAqLyhlYXNlc0Z1bmN0aW9uc1tzdHJpbmddKSgpIDogZWFzZXNGdW5jdGlvbnNbc3RyaW5nXSk7XG4gICAgcmV0dXJuIHBhcnNlZEZuID8gZWFzZXNMb29rdXBzW3N0cmluZ10gPSBwYXJzZWRGbiA6IG5vbmU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3BsaXQgPSBzdHJpbmcuc2xpY2UoMCwgLTEpLnNwbGl0KCcoJyk7XG4gICAgY29uc3QgcGFyc2VkRm4gPSAvKiogQHR5cGUge0Vhc2VzRmFjdG9yeX0gKi8oZWFzZXNGdW5jdGlvbnNbc3BsaXRbMF1dKTtcbiAgICByZXR1cm4gcGFyc2VkRm4gPyBlYXNlc0xvb2t1cHNbc3RyaW5nXSA9IHBhcnNlZEZuKC4uLnNwbGl0WzFdLnNwbGl0KCcsJykpIDogbm9uZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiAge09iamVjdH0gRWFzZXNGdW5jdGlvbnNcbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGxpbmVhcn0gbGluZWFyXG4gKiBAcHJvcGVydHkge3R5cGVvZiBpcnJlZ3VsYXJ9IGlycmVndWxhclxuICogQHByb3BlcnR5IHt0eXBlb2Ygc3RlcHN9IHN0ZXBzXG4gKiBAcHJvcGVydHkge3R5cGVvZiBjdWJpY0Jlemllcn0gY3ViaWNCZXppZXJcbiAqIEBwcm9wZXJ0eSB7UG93ZXJFYXNpbmd9IGluXG4gKiBAcHJvcGVydHkge1Bvd2VyRWFzaW5nfSBvdXRcbiAqIEBwcm9wZXJ0eSB7UG93ZXJFYXNpbmd9IGluT3V0XG4gKiBAcHJvcGVydHkge1Bvd2VyRWFzaW5nfSBvdXRJblxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5RdWFkXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRRdWFkXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dFF1YWRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluUXVhZFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5DdWJpY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0Q3ViaWNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0Q3ViaWNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluQ3ViaWNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluUXVhcnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dFF1YXJ0XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dFF1YXJ0XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRJblF1YXJ0XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpblF1aW50XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRRdWludFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5PdXRRdWludFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5RdWludFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5TaW5lXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRTaW5lXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dFNpbmVcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluU2luZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5DaXJjXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRDaXJjXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dENpcmNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluQ2lyY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5FeHBvXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRFeHBvXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dEV4cG9cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluRXhwb1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5Cb3VuY2VcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEJvdW5jZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5PdXRCb3VuY2VcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluQm91bmNlXG4gKiBAcHJvcGVydHkge0JhY2tFYXNpbmd9IGluQmFja1xuICogQHByb3BlcnR5IHtCYWNrRWFzaW5nfSBvdXRCYWNrXG4gKiBAcHJvcGVydHkge0JhY2tFYXNpbmd9IGluT3V0QmFja1xuICogQHByb3BlcnR5IHtCYWNrRWFzaW5nfSBvdXRJbkJhY2tcbiAqIEBwcm9wZXJ0eSB7RWxhc3RpY0Vhc2luZ30gaW5FbGFzdGljXG4gKiBAcHJvcGVydHkge0VsYXN0aWNFYXNpbmd9IG91dEVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RWxhc3RpY0Vhc2luZ30gaW5PdXRFbGFzdGljXG4gKiBAcHJvcGVydHkge0VsYXN0aWNFYXNpbmd9IG91dEluRWxhc3RpY1xuICovXG5cbmNvbnN0IGVhc2VzID0gKC8qI19fUFVSRV9fKi8gKCgpID0+IHtcbiAgY29uc3QgbGlzdCA9IHsgbGluZWFyLCBpcnJlZ3VsYXIsIHN0ZXBzLCBjdWJpY0JlemllciB9O1xuICBmb3IgKGxldCB0eXBlIGluIGVhc2VUeXBlcykge1xuICAgIGZvciAobGV0IG5hbWUgaW4gZWFzZUluRnVuY3Rpb25zKSB7XG4gICAgICBjb25zdCBlYXNlSW4gPSBlYXNlSW5GdW5jdGlvbnNbbmFtZV07XG4gICAgICBjb25zdCBlYXNlVHlwZSA9IGVhc2VUeXBlc1t0eXBlXTtcbiAgICAgIGxpc3RbdHlwZSArIG5hbWVdID0gLyoqIEB0eXBlIHtFYXNlc0ZhY3Rvcnl8RWFzaW5nRnVuY3Rpb259ICovKFxuICAgICAgICBuYW1lID09PSBlbXB0eVN0cmluZyB8fCBuYW1lID09PSAnQmFjaycgfHwgbmFtZSA9PT0gJ0VsYXN0aWMnID9cbiAgICAgICAgKGEsIGIpID0+IGVhc2VUeXBlKC8qKiBAdHlwZSB7RWFzZXNGYWN0b3J5fSAqLyhlYXNlSW4pKGEsIGIpKSA6XG4gICAgICAgIGVhc2VUeXBlKC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovKGVhc2VJbikpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtFYXNlc0Z1bmN0aW9uc30gKi8obGlzdCk7XG59KSgpKTtcblxuLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBFYXNpbmdGdW5jdGlvbj59ICovXG5jb25zdCBKU0Vhc2VzTG9va3VwcyA9IHsgbGluZWFyOiBub25lIH07XG5cbi8qKlxuICogQHBhcmFtICB7RWFzaW5nUGFyYW19IGVhc2VcbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBwYXJzZUVhc2luZ3MgPSBlYXNlID0+IGlzRm5jKGVhc2UpID8gZWFzZSA6XG4gIGlzU3RyKGVhc2UpID8gcGFyc2VFYXNlU3RyaW5nKC8qKiBAdHlwZSB7U3RyaW5nfSAqLyhlYXNlKSwgZWFzZXMsIEpTRWFzZXNMb29rdXBzKSA6XG4gIG5vbmU7XG5cblxuXG5cbmNvbnN0IHByb3BlcnR5TmFtZXNDYWNoZSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHlOYW1lXG4gKiBAcGFyYW0gIHtUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtICB7dHdlZW5UeXBlc30gdHdlZW5UeXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHNhbml0aXplUHJvcGVydHlOYW1lID0gKHByb3BlcnR5TmFtZSwgdGFyZ2V0LCB0d2VlblR5cGUpID0+IHtcbiAgaWYgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk0pIHtcbiAgICBjb25zdCB0ID0gc2hvcnRUcmFuc2Zvcm1zLmdldChwcm9wZXJ0eU5hbWUpO1xuICAgIHJldHVybiB0ID8gdCA6IHByb3BlcnR5TmFtZTtcbiAgfSBlbHNlIGlmIChcbiAgICB0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuQ1NTIHx8XG4gICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXMgd2hlcmUgcHJvcGVydGllcyBsaWtlIFwic3Ryb2tlRGFzaG9mZnNldFwiIG5lZWRzIHRvIGJlIHNldCBhcyBcInN0cm9rZS1kYXNob2Zmc2V0XCJcbiAgICAvLyBidXQgcHJvcGVydGllcyBsaWtlIFwiYmFzZUZyZXF1ZW5jeVwiIHNob3VsZCBzdGF5IGluIGxvd2VyQ2FtZWxDYXNlXG4gICAgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5BVFRSSUJVVEUgJiYgKGlzU3ZnKHRhcmdldCkgJiYgcHJvcGVydHlOYW1lIGluIC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLnN0eWxlKSlcbiAgKSB7XG4gICAgY29uc3QgY2FjaGVkUHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc0NhY2hlW3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKGNhY2hlZFByb3BlcnR5TmFtZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb3BlcnR5TmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IHByb3BlcnR5TmFtZSA/IHRvTG93ZXJDYXNlKHByb3BlcnR5TmFtZSkgOiBwcm9wZXJ0eU5hbWU7XG4gICAgICBwcm9wZXJ0eU5hbWVzQ2FjaGVbcHJvcGVydHlOYW1lXSA9IGxvd2VyQ2FzZU5hbWU7XG4gICAgICByZXR1cm4gbG93ZXJDYXNlTmFtZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByb3BlcnR5TmFtZTtcbiAgfVxufTtcblxuXG5cblxuY29uc3QgYW5nbGVVbml0c01hcCA9IHsgJ2RlZyc6IDEsICdyYWQnOiAxODAgLyBQSSwgJ3R1cm4nOiAzNjAgfTtcbmNvbnN0IGNvbnZlcnRlZFZhbHVlc0NhY2hlID0ge307XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSBlbFxuICogQHBhcmFtICB7VHdlZW5EZWNvbXBvc2VkVmFsdWV9IGRlY29tcG9zZWRWYWx1ZVxuICogQHBhcmFtICB7U3RyaW5nfSB1bml0XG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZm9yY2VdXG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgY29udmVydFZhbHVlVW5pdCA9IChlbCwgZGVjb21wb3NlZFZhbHVlLCB1bml0LCBmb3JjZSA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRVbml0ID0gZGVjb21wb3NlZFZhbHVlLnU7XG4gIGNvbnN0IGN1cnJlbnROdW1iZXIgPSBkZWNvbXBvc2VkVmFsdWUubjtcbiAgaWYgKGRlY29tcG9zZWRWYWx1ZS50ID09PSB2YWx1ZVR5cGVzLlVOSVQgJiYgY3VycmVudFVuaXQgPT09IHVuaXQpIHsgLy8gVE9ETzogQ2hlY2sgaWYgY2hlY2tpbmcgYWdhaW5zdCB0aGUgc2FtZSB1bml0IHN0cmluZyBpcyBuZWNlc3NhcnlcbiAgICByZXR1cm4gZGVjb21wb3NlZFZhbHVlO1xuICB9XG4gIGNvbnN0IGNhY2hlZEtleSA9IGN1cnJlbnROdW1iZXIgKyBjdXJyZW50VW5pdCArIHVuaXQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNvbnZlcnRlZFZhbHVlc0NhY2hlW2NhY2hlZEtleV07XG4gIGlmICghaXNVbmQoY2FjaGVkKSAmJiAhZm9yY2UpIHtcbiAgICBkZWNvbXBvc2VkVmFsdWUubiA9IGNhY2hlZDtcbiAgfSBlbHNlIHtcbiAgICBsZXQgY29udmVydGVkVmFsdWU7XG4gICAgaWYgKGN1cnJlbnRVbml0IGluIGFuZ2xlVW5pdHNNYXApIHtcbiAgICAgIGNvbnZlcnRlZFZhbHVlID0gY3VycmVudE51bWJlciAqIGFuZ2xlVW5pdHNNYXBbY3VycmVudFVuaXRdIC8gYW5nbGVVbml0c01hcFt1bml0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFzZWxpbmUgPSAxMDA7XG4gICAgICBjb25zdCB0ZW1wRWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oZWwuY2xvbmVOb2RlKCkpO1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBwYXJlbnRFbCA9IChwYXJlbnROb2RlICYmIChwYXJlbnROb2RlICE9PSBkb2MpKSA/IHBhcmVudE5vZGUgOiBkb2MuYm9keTtcbiAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKHRlbXBFbCk7XG4gICAgICBjb25zdCBlbFN0eWxlID0gdGVtcEVsLnN0eWxlO1xuICAgICAgZWxTdHlsZS53aWR0aCA9IGJhc2VsaW5lICsgY3VycmVudFVuaXQ7XG4gICAgICBjb25zdCBjdXJyZW50VW5pdFdpZHRoID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8odGVtcEVsKS5vZmZzZXRXaWR0aCB8fCBiYXNlbGluZTtcbiAgICAgIGVsU3R5bGUud2lkdGggPSBiYXNlbGluZSArIHVuaXQ7XG4gICAgICBjb25zdCBuZXdVbml0V2lkdGggPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyh0ZW1wRWwpLm9mZnNldFdpZHRoIHx8IGJhc2VsaW5lO1xuICAgICAgY29uc3QgZmFjdG9yID0gY3VycmVudFVuaXRXaWR0aCAvIG5ld1VuaXRXaWR0aDtcbiAgICAgIHBhcmVudEVsLnJlbW92ZUNoaWxkKHRlbXBFbCk7XG4gICAgICBjb252ZXJ0ZWRWYWx1ZSA9IGZhY3RvciAqIGN1cnJlbnROdW1iZXI7XG4gICAgfVxuICAgIGRlY29tcG9zZWRWYWx1ZS5uID0gY29udmVydGVkVmFsdWU7XG4gICAgY29udmVydGVkVmFsdWVzQ2FjaGVbY2FjaGVkS2V5XSA9IGNvbnZlcnRlZFZhbHVlO1xuICB9XG4gIGRlY29tcG9zZWRWYWx1ZS50ID09PSB2YWx1ZVR5cGVzLlVOSVQ7XG4gIGRlY29tcG9zZWRWYWx1ZS51ID0gdW5pdDtcbiAgcmV0dXJuIGRlY29tcG9zZWRWYWx1ZTtcbn07XG5cblxuXG5cbi8qKlxuICogQHRlbXBsYXRlIHtSZW5kZXJhYmxlfSBUXG4gKiBAcGFyYW0ge1R9IHJlbmRlcmFibGVcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmNvbnN0IGNsZWFuSW5saW5lU3R5bGVzID0gcmVuZGVyYWJsZSA9PiB7XG4gIC8vIEFsbG93IGNsZWFuSW5saW5lU3R5bGVzKCkgdG8gYmUgY2FsbGVkIG9uIHRpbWVsaW5lc1xuICBpZiAocmVuZGVyYWJsZS5faGFzQ2hpbGRyZW4pIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4ocmVuZGVyYWJsZSwgY2xlYW5JbmxpbmVTdHlsZXMsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKHJlbmRlcmFibGUpO1xuICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIGZvckVhY2hDaGlsZHJlbihhbmltYXRpb24sICgvKiogQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgICBjb25zdCB0d2VlblByb3BlcnR5ID0gdHdlZW4ucHJvcGVydHk7XG4gICAgICBjb25zdCB0d2VlblRhcmdldCA9IHR3ZWVuLnRhcmdldDtcbiAgICAgIGlmICh0d2VlblRhcmdldFtpc0RvbVN5bWJvbF0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3R5bGUgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odHdlZW5UYXJnZXQpLnN0eWxlO1xuICAgICAgICBjb25zdCBvcmlnaW5hbElubGluZWRWYWx1ZSA9IGFuaW1hdGlvbi5faW5saW5lU3R5bGVzW3R3ZWVuUHJvcGVydHldO1xuICAgICAgICBpZiAodHdlZW4uX3R3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk0pIHtcbiAgICAgICAgICBjb25zdCBjYWNoZWRUcmFuc2Zvcm1zID0gdHdlZW5UYXJnZXRbdHJhbnNmb3Jtc1N5bWJvbF07XG4gICAgICAgICAgaWYgKGlzVW5kKG9yaWdpbmFsSW5saW5lZFZhbHVlKSB8fCBvcmlnaW5hbElubGluZWRWYWx1ZSA9PT0gZW1wdHlTdHJpbmcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZWRUcmFuc2Zvcm1zW3R3ZWVuUHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRUcmFuc2Zvcm1zW3R3ZWVuUHJvcGVydHldID0gb3JpZ2luYWxJbmxpbmVkVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0d2Vlbi5fcmVuZGVyVHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhjYWNoZWRUcmFuc2Zvcm1zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0U3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IHN0ciA9IGVtcHR5U3RyaW5nO1xuICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gY2FjaGVkVHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgICAgIHN0ciArPSB0cmFuc2Zvcm1zRnJhZ21lbnRTdHJpbmdzW2tleV0gKyBjYWNoZWRUcmFuc2Zvcm1zW2tleV0gKyAnKSAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldFN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzVW5kKG9yaWdpbmFsSW5saW5lZFZhbHVlKSB8fCBvcmlnaW5hbElubGluZWRWYWx1ZSA9PT0gZW1wdHlTdHJpbmcpIHtcbiAgICAgICAgICAgIHRhcmdldFN0eWxlLnJlbW92ZVByb3BlcnR5KHR3ZWVuUHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRTdHlsZVt0d2VlblByb3BlcnR5XSA9IG9yaWdpbmFsSW5saW5lZFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uLl90YWlsID09PSB0d2Vlbikge1xuICAgICAgICAgIGFuaW1hdGlvbi50YXJnZXRzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICBpZiAodC5nZXRBdHRyaWJ1dGUgJiYgdC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgPT09IGVtcHR5U3RyaW5nKSB7XG4gICAgICAgICAgICAgIHQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgfSAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZW5kZXJhYmxlO1xufTtcblxuLy8gRGVmaW5lcyBkZWNvbXBvc2VkIHZhbHVlcyB0YXJnZXQgb2JqZWN0cyBvbmx5IG9uY2UgYW5kIG11dGF0ZSB0aGVpciBwcm9wZXJ0aWVzIGxhdGVyIHRvIGF2b2lkIEdDXG4vLyBUT0RPOiBNYXliZSBtb3ZlIHRoZSBvYmplY3RzIGNyZWF0aW9uIHRvIHZhbHVlcy5qcyBhbmQgdXNlIHRoZSBkZWNvbXBvc2UgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBiYXNlIG9iamVjdFxuY29uc3QgZnJvbVRhcmdldE9iamVjdCA9IGNyZWF0ZURlY29tcG9zZWRWYWx1ZVRhcmdldE9iamVjdCgpO1xuY29uc3QgdG9UYXJnZXRPYmplY3QgPSBjcmVhdGVEZWNvbXBvc2VkVmFsdWVUYXJnZXRPYmplY3QoKTtcbmNvbnN0IHRvRnVuY3Rpb25TdG9yZSA9IHsgZnVuYzogbnVsbCB9O1xuY29uc3Qga2V5ZnJhbWVzVGFyZ2V0QXJyYXkgPSBbbnVsbF07XG5jb25zdCBmYXN0U2V0VmFsdWVzQXJyYXkgPSBbbnVsbCwgbnVsbF07XG4vKiogQHR5cGUge1R3ZWVuS2V5VmFsdWV9ICovXG5jb25zdCBrZXlPYmplY3RUYXJnZXQgPSB7IHRvOiBudWxsIH07XG5cbmxldCB0d2VlbklkID0gMDtcbmxldCBrZXlmcmFtZXM7XG4vKiogQHR5cGUge1R3ZWVuUGFyYW1zT3B0aW9ucyAmIFR3ZWVuVmFsdWVzfSAqL1xubGV0IGtleTtcblxuLyoqXG4gKiBAcGFyYW0ge0R1cmF0aW9uS2V5ZnJhbWVzIHwgUGVyY2VudGFnZUtleWZyYW1lc30ga2V5ZnJhbWVzXG4gKiBAcGFyYW0ge0FuaW1hdGlvblBhcmFtc30gcGFyYW1ldGVyc1xuICogQHJldHVybiB7QW5pbWF0aW9uUGFyYW1zfVxuICovXG5jb25zdCBnZW5lcmF0ZUtleWZyYW1lcyA9IChrZXlmcmFtZXMsIHBhcmFtZXRlcnMpID0+IHtcbiAgLyoqIEB0eXBlIHtBbmltYXRpb25QYXJhbXN9ICovXG4gIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgaWYgKGlzQXJyKGtleWZyYW1lcykpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gW10uY29uY2F0KC4uLi8qKiBAdHlwZSB7RHVyYXRpb25LZXlmcmFtZXN9ICovKGtleWZyYW1lcykubWFwKGtleSA9PiBPYmplY3Qua2V5cyhrZXkpKSkuZmlsdGVyKGlzS2V5KTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9wTmFtZSA9IHByb3BlcnR5TmFtZXNbaV07XG4gICAgICBjb25zdCBwcm9wQXJyYXkgPSAvKiogQHR5cGUge0R1cmF0aW9uS2V5ZnJhbWVzfSAqLyhrZXlmcmFtZXMpLm1hcChrZXkgPT4ge1xuICAgICAgICAvKiogQHR5cGUge1R3ZWVuS2V5VmFsdWV9ICovXG4gICAgICAgIGNvbnN0IG5ld0tleSA9IHt9O1xuICAgICAgICBmb3IgKGxldCBwIGluIGtleSkge1xuICAgICAgICAgIGNvbnN0IGtleVZhbHVlID0gLyoqIEB0eXBlIHtUd2VlblByb3BWYWx1ZX0gKi8oa2V5W3BdKTtcbiAgICAgICAgICBpZiAoaXNLZXkocCkpIHtcbiAgICAgICAgICAgIGlmIChwID09PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICBuZXdLZXkudG8gPSBrZXlWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3S2V5W3BdID0ga2V5VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgICB9KTtcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gLyoqIEB0eXBlIHtBcnJheVN5bnRheFZhbHVlfSAqLyhwcm9wQXJyYXkpO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSAvKiogQHR5cGUge051bWJlcn0gKi8oc2V0VmFsdWUocGFyYW1ldGVycy5kdXJhdGlvbiwgZ2xvYmFscy5kZWZhdWx0cy5kdXJhdGlvbikpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhrZXlmcmFtZXMpXG4gICAgLm1hcChrZXkgPT4geyByZXR1cm4ge286IHBhcnNlRmxvYXQoa2V5KSAvIDEwMCwgcDoga2V5ZnJhbWVzW2tleV19IH0pXG4gICAgLnNvcnQoKGEsIGIpID0+IGEubyAtIGIubyk7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBrZXkubztcbiAgICAgIGNvbnN0IHByb3AgPSBrZXkucDtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJvcCkge1xuICAgICAgICBpZiAoaXNLZXkobmFtZSkpIHtcbiAgICAgICAgICBsZXQgcHJvcEFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8ocHJvcGVydGllc1tuYW1lXSk7XG4gICAgICAgICAgaWYgKCFwcm9wQXJyYXkpIHByb3BBcnJheSA9IHByb3BlcnRpZXNbbmFtZV0gPSBbXTtcbiAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IG9mZnNldCAqIHRvdGFsRHVyYXRpb247XG4gICAgICAgICAgbGV0IGxlbmd0aCA9IHByb3BBcnJheS5sZW5ndGg7XG4gICAgICAgICAgbGV0IHByZXZLZXkgPSBwcm9wQXJyYXlbbGVuZ3RoIC0gMV07XG4gICAgICAgICAgY29uc3Qga2V5T2JqID0geyB0bzogcHJvcFtuYW1lXSB9O1xuICAgICAgICAgIGxldCBkdXJQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZHVyUHJvZ3Jlc3MgKz0gcHJvcEFycmF5W2ldLmR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBrZXlPYmouZnJvbSA9IHByZXZLZXkudG87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wLmVhc2UpIHtcbiAgICAgICAgICAgIGtleU9iai5lYXNlID0gcHJvcC5lYXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlPYmouZHVyYXRpb24gPSBkdXJhdGlvbiAtIChsZW5ndGggPyBkdXJQcm9ncmVzcyA6IDApO1xuICAgICAgICAgIHByb3BBcnJheS5wdXNoKGtleU9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBuYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGNvbnN0IHByb3BBcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKHByb3BlcnRpZXNbbmFtZV0pO1xuICAgICAgbGV0IHByZXZFYXNlO1xuICAgICAgLy8gbGV0IGR1clByb2dyZXNzID0gMFxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wQXJyYXlbaV07XG4gICAgICAgIC8vIEVtdWxhdGUgV0FQUEkgZWFzaW5nIHBhcmFtZXRlciBwb3NpdGlvblxuICAgICAgICBjb25zdCBjdXJyZW50RWFzZSA9IHByb3AuZWFzZTtcbiAgICAgICAgcHJvcC5lYXNlID0gcHJldkVhc2UgPyBwcmV2RWFzZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcHJldkVhc2UgPSBjdXJyZW50RWFzZTtcbiAgICAgICAgLy8gZHVyUHJvZ3Jlc3MgKz0gcHJvcC5kdXJhdGlvbjtcbiAgICAgICAgLy8gaWYgKGkgPT09IGwgLSAxICYmIGR1clByb2dyZXNzICE9PSB0b3RhbER1cmF0aW9uKSB7XG4gICAgICAgIC8vICAgcHJvcEFycmF5LnB1c2goeyBmcm9tOiBwcm9wLnRvLCBlYXNlOiBwcm9wLmVhc2UsIGR1cmF0aW9uOiB0b3RhbER1cmF0aW9uIC0gZHVyUHJvZ3Jlc3MgfSlcbiAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9wQXJyYXlbMF0uZHVyYXRpb24pIHtcbiAgICAgICAgcHJvcEFycmF5LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gcHJvcGVydGllcztcbn07XG5cbmNsYXNzIEpTQW5pbWF0aW9uIGV4dGVuZHMgVGltZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAgICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtUaW1lbGluZX0gW3BhcmVudF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJlbnRQb3NpdGlvbl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZmFzdFNldD1mYWxzZV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleD0wXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2xlbmd0aD0wXVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgdGFyZ2V0cyxcbiAgICBwYXJhbWV0ZXJzLFxuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQb3NpdGlvbixcbiAgICBmYXN0U2V0ID0gZmFsc2UsXG4gICAgaW5kZXggPSAwLFxuICAgIGxlbmd0aCA9IDBcbiAgKSB7XG5cbiAgICBzdXBlcigvKiogQHR5cGUge1RpbWVyUGFyYW1zJkFuaW1hdGlvblBhcmFtc30gKi8ocGFyYW1ldGVycyksIHBhcmVudCwgcGFyZW50UG9zaXRpb24pO1xuXG4gICAgY29uc3QgcGFyc2VkVGFyZ2V0cyA9IHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICBjb25zdCB0YXJnZXRzTGVuZ3RoID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICAvLyBJZiB0aGUgcGFyYW1ldGVycyBvYmplY3QgY29udGFpbnMgYSBcImtleWZyYW1lc1wiIHByb3BlcnR5LCBjb252ZXJ0IGFsbCB0aGUga2V5ZnJhbWVzIHZhbHVlcyB0byByZWd1bGFyIHByb3BlcnRpZXNcblxuICAgIGNvbnN0IGtmUGFyYW1zID0gLyoqIEB0eXBlIHtBbmltYXRpb25QYXJhbXN9ICovKHBhcmFtZXRlcnMpLmtleWZyYW1lcztcbiAgICBjb25zdCBwYXJhbXMgPSAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi8oa2ZQYXJhbXMgPyBtZXJnZU9iamVjdHMoZ2VuZXJhdGVLZXlmcmFtZXMoLyoqIEB0eXBlIHtEdXJhdGlvbktleWZyYW1lc30gKi8oa2ZQYXJhbXMpLCBwYXJhbWV0ZXJzKSwgcGFyYW1ldGVycykgOiBwYXJhbWV0ZXJzKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGRlbGF5LFxuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNlLFxuICAgICAgcGxheWJhY2tFYXNlLFxuICAgICAgbW9kaWZpZXIsXG4gICAgICBjb21wb3NpdGlvbixcbiAgICAgIG9uUmVuZGVyLFxuICAgIH0gPSBwYXJhbXM7XG5cbiAgICBjb25zdCBhbmltRGVmYXVsdHMgPSBwYXJlbnQgPyBwYXJlbnQuZGVmYXVsdHMgOiBnbG9iYWxzLmRlZmF1bHRzO1xuICAgIGNvbnN0IGFuaW1hUGxheWJhY2tFYXNlID0gc2V0VmFsdWUocGxheWJhY2tFYXNlLCBhbmltRGVmYXVsdHMucGxheWJhY2tFYXNlKTtcbiAgICBjb25zdCBhbmltRWFzZSA9IGFuaW1hUGxheWJhY2tFYXNlID8gcGFyc2VFYXNpbmdzKGFuaW1hUGxheWJhY2tFYXNlKSA6IG51bGw7XG4gICAgY29uc3QgaGFzU3ByaW5nID0gIWlzVW5kKGVhc2UpICYmICFpc1VuZCgvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSk7XG4gICAgY29uc3QgdEVhc2luZyA9IGhhc1NwcmluZyA/IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlIDogc2V0VmFsdWUoZWFzZSwgYW5pbUVhc2UgPyAnbGluZWFyJyA6IGFuaW1EZWZhdWx0cy5lYXNlKTtcbiAgICBjb25zdCB0RHVyYXRpb24gPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZHVyYXRpb24gOiBzZXRWYWx1ZShkdXJhdGlvbiwgYW5pbURlZmF1bHRzLmR1cmF0aW9uKTtcbiAgICBjb25zdCB0RGVsYXkgPSBzZXRWYWx1ZShkZWxheSwgYW5pbURlZmF1bHRzLmRlbGF5KTtcbiAgICBjb25zdCB0TW9kaWZpZXIgPSBtb2RpZmllciB8fCBhbmltRGVmYXVsdHMubW9kaWZpZXI7XG4gICAgLy8gSWYgbm8gY29tcG9zaXRpb24gaXMgZGVmaW5lZCBhbmQgdGhlIHRhcmdldHMgbGVuZ3RoIGlzIGhpZ2ggKD49IDEwMDApIHNldCB0aGUgY29tcG9zaXRpb24gdG8gJ25vbmUnICgwKSBmb3IgZmFzdGVyIHR3ZWVuIGNyZWF0aW9uXG4gICAgY29uc3QgdENvbXBvc2l0aW9uID0gaXNVbmQoY29tcG9zaXRpb24pICYmIHRhcmdldHNMZW5ndGggPj0gSyA/IGNvbXBvc2l0aW9uVHlwZXMubm9uZSA6ICFpc1VuZChjb21wb3NpdGlvbikgPyBjb21wb3NpdGlvbiA6IGFuaW1EZWZhdWx0cy5jb21wb3NpdGlvbjtcbiAgICAvLyBUT0RPOiBEbyBub3QgY3JlYXRlIGFuIGVtcHR5IG9iamVjdCB1bnRpbCB3ZSBrbm93IHRoZSBhbmltYXRpb24gd2lsbCBnZW5lcmF0ZSBpbmxpbmUgc3R5bGVzXG4gICAgY29uc3QgYW5pbUlubGluZVN0eWxlcyA9IHt9O1xuICAgIC8vIGNvbnN0IGFic29sdXRlT2Zmc2V0VGltZSA9IHRoaXMuX29mZnNldDtcbiAgICBjb25zdCBhYnNvbHV0ZU9mZnNldFRpbWUgPSB0aGlzLl9vZmZzZXQgKyAocGFyZW50ID8gcGFyZW50Ll9vZmZzZXQgOiAwKTtcblxuICAgIGxldCBpdGVyYXRpb25EdXJhdGlvbiA9IE5hTjtcbiAgICBsZXQgaXRlcmF0aW9uRGVsYXkgPSBOYU47XG4gICAgbGV0IGFuaW1hdGlvbkFuaW1hdGlvbkxlbmd0aCA9IDA7XG4gICAgbGV0IHNob3VsZFRyaWdnZXJSZW5kZXIgPSAwO1xuXG4gICAgZm9yIChsZXQgdGFyZ2V0SW5kZXggPSAwOyB0YXJnZXRJbmRleCA8IHRhcmdldHNMZW5ndGg7IHRhcmdldEluZGV4KyspIHtcblxuICAgICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VkVGFyZ2V0c1t0YXJnZXRJbmRleF07XG4gICAgICBjb25zdCB0aSA9IGluZGV4IHx8IHRhcmdldEluZGV4O1xuICAgICAgY29uc3QgdGwgPSBsZW5ndGggfHwgdGFyZ2V0c0xlbmd0aDtcblxuICAgICAgbGV0IGxhc3RUcmFuc2Zvcm1Hcm91cEluZGV4ID0gTmFOO1xuICAgICAgbGV0IGxhc3RUcmFuc2Zvcm1Hcm91cExlbmd0aCA9IE5hTjtcblxuICAgICAgZm9yIChsZXQgcCBpbiBwYXJhbXMpIHtcblxuICAgICAgICBpZiAoaXNLZXkocCkpIHtcblxuICAgICAgICAgIGNvbnN0IHR3ZWVuVHlwZSA9IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHApO1xuXG4gICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBzYW5pdGl6ZVByb3BlcnR5TmFtZShwLCB0YXJnZXQsIHR3ZWVuVHlwZSk7XG5cbiAgICAgICAgICBsZXQgcHJvcFZhbHVlID0gcGFyYW1zW3BdO1xuXG4gICAgICAgICAgY29uc3QgaXNQcm9wVmFsdWVBcnJheSA9IGlzQXJyKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgICBpZiAoZmFzdFNldCAmJiAhaXNQcm9wVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgZmFzdFNldFZhbHVlc0FycmF5WzBdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgZmFzdFNldFZhbHVlc0FycmF5WzFdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgcHJvcFZhbHVlID0gZmFzdFNldFZhbHVlc0FycmF5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE86IEFsbG93IG5lc3RlZCBrZXlmcmFtZXMgaW5zaWRlIE9iamVjdFZhbHVlIHZhbHVlIChwcm9wOiB7IHRvOiBbLjUsIDEsIC43NSwgMiwgM10gfSlcbiAgICAgICAgICAvLyBOb3JtYWxpemUgcHJvcGVydHkgdmFsdWVzIHRvIHZhbGlkIGtleWZyYW1lIHN5bnRheDpcbiAgICAgICAgICAvLyBbeCwgeV0gdG8gW3t0bzogW3gsIHldfV0gb3Ige3RvOiB4fSB0byBbe3RvOiB4fV0gb3Iga2VlcCBrZXlzIHN5bnRheCBbe30sIHt9LCB7fS4uLl1cbiAgICAgICAgICAvLyBjb25zdCBrZXlmcmFtZXMgPSBpc0Fycihwcm9wVmFsdWUpID8gcHJvcFZhbHVlLmxlbmd0aCA9PT0gMiAmJiAhaXNPYmoocHJvcFZhbHVlWzBdKSA/IFt7IHRvOiBwcm9wVmFsdWUgfV0gOiBwcm9wVmFsdWUgOiBbcHJvcFZhbHVlXTtcbiAgICAgICAgICBpZiAoaXNQcm9wVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSAvKiogQHR5cGUge0FycmF5fSAqLyhwcm9wVmFsdWUpLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGlzTm90T2JqZWN0VmFsdWUgPSAhaXNPYmoocHJvcFZhbHVlWzBdKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgW3gsIHldIHRvIFt7dG86IFt4LCB5XX1dXG4gICAgICAgICAgICBpZiAoYXJyYXlMZW5ndGggPT09IDIgJiYgaXNOb3RPYmplY3RWYWx1ZSkge1xuICAgICAgICAgICAgICBrZXlPYmplY3RUYXJnZXQudG8gPSAvKiogQHR5cGUge1R3ZWVuUGFyYW1WYWx1ZX0gKi8oLyoqIEB0eXBlIHt1bmtub3dufSAqLyhwcm9wVmFsdWUpKTtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzVGFyZ2V0QXJyYXlbMF0gPSBrZXlPYmplY3RUYXJnZXQ7XG4gICAgICAgICAgICAgIGtleWZyYW1lcyA9IGtleWZyYW1lc1RhcmdldEFycmF5O1xuICAgICAgICAgICAgLy8gQ29udmVydCBbeCwgeSwgel0gdG8gW1t4LCB5XSwgel1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyYXlMZW5ndGggPiAyICYmIGlzTm90T2JqZWN0VmFsdWUpIHtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzID0gW107XG4gICAgICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPE51bWJlcj59ICovKHByb3BWYWx1ZSkuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgICAgZmFzdFNldFZhbHVlc0FycmF5WzBdID0gdjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGZhc3RTZXRWYWx1ZXNBcnJheVsxXSA9IHY7XG4gICAgICAgICAgICAgICAgICBrZXlmcmFtZXMucHVzaChmYXN0U2V0VmFsdWVzQXJyYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBrZXlmcmFtZXMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzID0gLyoqIEB0eXBlIHtBcnJheS48VHdlZW5LZXlWYWx1ZT59ICovKHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleWZyYW1lc1RhcmdldEFycmF5WzBdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAga2V5ZnJhbWVzID0ga2V5ZnJhbWVzVGFyZ2V0QXJyYXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHNpYmxpbmdzID0gbnVsbDtcbiAgICAgICAgICBsZXQgcHJldlR3ZWVuID0gbnVsbDtcbiAgICAgICAgICBsZXQgZmlyc3RUd2VlbkNoYW5nZVN0YXJ0VGltZSA9IE5hTjtcbiAgICAgICAgICBsZXQgbGFzdFR3ZWVuQ2hhbmdlRW5kVGltZSA9IDA7XG4gICAgICAgICAgbGV0IHR3ZWVuSW5kZXggPSAwO1xuXG4gICAgICAgICAgZm9yIChsZXQgbCA9IGtleWZyYW1lcy5sZW5ndGg7IHR3ZWVuSW5kZXggPCBsOyB0d2VlbkluZGV4KyspIHtcblxuICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBrZXlmcmFtZXNbdHdlZW5JbmRleF07XG5cbiAgICAgICAgICAgIGlmIChpc09iaihrZXlmcmFtZSkpIHtcbiAgICAgICAgICAgICAga2V5ID0ga2V5ZnJhbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBrZXlPYmplY3RUYXJnZXQudG8gPSAvKiogQHR5cGUge1R3ZWVuUGFyYW1WYWx1ZX0gKi8oa2V5ZnJhbWUpO1xuICAgICAgICAgICAgICBrZXkgPSBrZXlPYmplY3RUYXJnZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvRnVuY3Rpb25TdG9yZS5mdW5jID0gbnVsbDtcblxuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRUb1ZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZShrZXkudG8sIHRhcmdldCwgdGksIHRsLCB0b0Z1bmN0aW9uU3RvcmUpO1xuXG4gICAgICAgICAgICBsZXQgdHdlZW5Ub1ZhbHVlO1xuICAgICAgICAgICAgLy8gQWxsb3dzIGZ1bmN0aW9uIGJhc2VkIHZhbHVlcyB0byByZXR1cm4gYW4gb2JqZWN0IHN5bnRheCB2YWx1ZSAoe3RvOiB2fSlcbiAgICAgICAgICAgIGlmIChpc09iaihjb21wdXRlZFRvVmFsdWUpICYmICFpc1VuZChjb21wdXRlZFRvVmFsdWUudG8pKSB7XG4gICAgICAgICAgICAgIGtleSA9IGNvbXB1dGVkVG9WYWx1ZTtcbiAgICAgICAgICAgICAgdHdlZW5Ub1ZhbHVlID0gY29tcHV0ZWRUb1ZhbHVlLnRvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW5Ub1ZhbHVlID0gY29tcHV0ZWRUb1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHdlZW5Gcm9tVmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKGtleS5mcm9tLCB0YXJnZXQsIHRpLCB0bCk7XG4gICAgICAgICAgICBjb25zdCBrZXlFYXNpbmcgPSBrZXkuZWFzZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1NwcmluZyA9ICFpc1VuZChrZXlFYXNpbmcpICYmICFpc1VuZCgvKiogQHR5cGUge1NwcmluZ30gKi8oa2V5RWFzaW5nKS5lYXNlKTtcbiAgICAgICAgICAgIC8vIEVhc2luZyBhcmUgdHJlYXRlZCBkaWZmZXJlbnRseSBhbmQgZG9uJ3QgYWNjZXB0IGZ1bmN0aW9uIGJhc2VkIHZhbHVlIHRvIHByZXZlbnQgaGF2aW5nIHRvIHBhc3MgYSBmdW5jdGlvbiB3cmFwcGVyIHRoYXQgcmV0dXJucyBhbiBvdGhlciBmdW5jdGlvbiBhbGwgdGhlIHRpbWVcbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuRWFzaW5nID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGtleUVhc2luZykuZWFzZSA6IGtleUVhc2luZyB8fCB0RWFzaW5nO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGRlZmF1bHQgaW5kaXZpZHVhbCBrZXlmcmFtZSBkdXJhdGlvbiBieSBkaXZpZGluZyB0aGUgdGwgb2Yga2V5ZnJhbWVzXG4gICAgICAgICAgICBjb25zdCB0d2VlbkR1cmF0aW9uID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGtleUVhc2luZykuZHVyYXRpb24gOiBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKGtleS5kdXJhdGlvbiwgKGwgPiAxID8gZ2V0RnVuY3Rpb25WYWx1ZSh0RHVyYXRpb24sIHRhcmdldCwgdGksIHRsKSAvIGwgOiB0RHVyYXRpb24pKSwgdGFyZ2V0LCB0aSwgdGwpO1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBkZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBmaXJzdCB0d2VlblxuICAgICAgICAgICAgY29uc3QgdHdlZW5EZWxheSA9IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUoa2V5LmRlbGF5LCAoIXR3ZWVuSW5kZXggPyB0RGVsYXkgOiAwKSksIHRhcmdldCwgdGksIHRsKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkQ29tcG9zaXRpb24gPSBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKGtleS5jb21wb3NpdGlvbiwgdENvbXBvc2l0aW9uKSwgdGFyZ2V0LCB0aSwgdGwpO1xuICAgICAgICAgICAgY29uc3QgdHdlZW5Db21wb3NpdGlvbiA9IGlzTnVtKGNvbXB1dGVkQ29tcG9zaXRpb24pID8gY29tcHV0ZWRDb21wb3NpdGlvbiA6IGNvbXBvc2l0aW9uVHlwZXNbY29tcHV0ZWRDb21wb3NpdGlvbl07XG4gICAgICAgICAgICAvLyBNb2RpZmllcnMgYXJlIHRyZWF0ZWQgZGlmZmVyZW50bHkgYW5kIGRvbid0IGFjY2VwdCBmdW5jdGlvbiBiYXNlZCB2YWx1ZSB0byBwcmV2ZW50IGhhdmluZyB0byBwYXNzIGEgZnVuY3Rpb24gd3JhcHBlclxuICAgICAgICAgICAgY29uc3QgdHdlZW5Nb2RpZmllciA9IGtleS5tb2RpZmllciB8fCB0TW9kaWZpZXI7XG4gICAgICAgICAgICBjb25zdCBoYXNGcm9tdmFsdWUgPSAhaXNVbmQodHdlZW5Gcm9tVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgaGFzVG9WYWx1ZSA9ICFpc1VuZCh0d2VlblRvVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgaXNGcm9tVG9BcnJheSA9IGlzQXJyKHR3ZWVuVG9WYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBpc0Zyb21Ub1ZhbHVlID0gaXNGcm9tVG9BcnJheSB8fCAoaGFzRnJvbXZhbHVlICYmIGhhc1RvVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdHdlZW5TdGFydFRpbWUgPSBwcmV2VHdlZW4gPyBsYXN0VHdlZW5DaGFuZ2VFbmRUaW1lICsgdHdlZW5EZWxheSA6IHR3ZWVuRGVsYXk7XG4gICAgICAgICAgICAvLyBSb3VuZGluZyBpcyBuZWNlc3NhcnkgaGVyZSB0byBtaW5pbWl6ZSBmbG9hdGluZyBwb2ludCBlcnJvcnMgd2hlbiB3b3JraW5nIGluIHNlY29uZHNcbiAgICAgICAgICAgIGNvbnN0IGFic29sdXRlU3RhcnRUaW1lID0gcm91bmQoYWJzb2x1dGVPZmZzZXRUaW1lICsgdHdlZW5TdGFydFRpbWUsIDEyKTtcblxuICAgICAgICAgICAgLy8gRm9yY2UgYSBvblJlbmRlciBjYWxsYmFjayBpZiB0aGUgYW5pbWF0aW9uIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBmcm9tIHZhbHVlIGFuZCBhdXRvcGxheSBpcyBzZXQgdG8gZmFsc2VcbiAgICAgICAgICAgIGlmICghc2hvdWxkVHJpZ2dlclJlbmRlciAmJiAoaGFzRnJvbXZhbHVlIHx8IGlzRnJvbVRvQXJyYXkpKSBzaG91bGRUcmlnZ2VyUmVuZGVyID0gMTtcblxuICAgICAgICAgICAgbGV0IHByZXZTaWJsaW5nID0gcHJldlR3ZWVuO1xuXG4gICAgICAgICAgICBpZiAodHdlZW5Db21wb3NpdGlvbiAhPT0gY29tcG9zaXRpb25UeXBlcy5ub25lKSB7XG4gICAgICAgICAgICAgIGlmICghc2libGluZ3MpIHNpYmxpbmdzID0gZ2V0VHdlZW5TaWJsaW5ncyh0YXJnZXQsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gc2libGluZ3MuX2hlYWQ7XG4gICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdHJvdWdoIGFsbCB0aGUgbmV4dCBzaWJsaW5ncyB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyB3aXRoIGFuIGVxdWFsIG9yIGluZmVyaW9yIHN0YXJ0IHRpbWVcbiAgICAgICAgICAgICAgd2hpbGUgKG5leHRTaWJsaW5nICYmICFuZXh0U2libGluZy5faXNPdmVycmlkZGVuICYmIG5leHRTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSA8PSBhYnNvbHV0ZVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5fbmV4dFJlcDtcbiAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgYWxsIHRoZSBuZXh0IHNpYmxpbmdzIGlmIHRoZSBuZXh0IHNpYmxpbmcgc3RhcnRzIGF0IHRoZSBzYW1lIHRpbWUgb2YgYWZ0ZXIgYXMgdGhlIG5ldyB0d2VlbiBzdGFydCB0aW1lXG4gICAgICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSA+PSBhYnNvbHV0ZVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlVHdlZW4obmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgZW5kcyBib3RoIHRoZSBjdXJyZW50IHdoaWxlIGxvb3AgYW5kIHRoZSB1cHBlciBvbmUgb25jZSBhbGwgdGhlIG5leHQgc2libGxpbmdzIGhhdmUgYmVlbiBvdmVycmlkZW5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5fbmV4dFJlcDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVjb21wb3NlIHZhbHVlc1xuICAgICAgICAgICAgaWYgKGlzRnJvbVRvVmFsdWUpIHtcbiAgICAgICAgICAgICAgZGVjb21wb3NlUmF3VmFsdWUoaXNGcm9tVG9BcnJheSA/IGdldEZ1bmN0aW9uVmFsdWUodHdlZW5Ub1ZhbHVlWzBdLCB0YXJnZXQsIHRpLCB0bCkgOiB0d2VlbkZyb21WYWx1ZSwgZnJvbVRhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKGlzRnJvbVRvQXJyYXkgPyBnZXRGdW5jdGlvblZhbHVlKHR3ZWVuVG9WYWx1ZVsxXSwgdGFyZ2V0LCB0aSwgdGwsIHRvRnVuY3Rpb25TdG9yZSkgOiB0d2VlblRvVmFsdWUsIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgaWYgKGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmV2U2libGluZy5fdmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLlVOSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5VTklUO1xuICAgICAgICAgICAgICAgICAgICBmcm9tVGFyZ2V0T2JqZWN0LnUgPSBwcmV2U2libGluZy5fdW5pdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGVjb21wb3NlUmF3VmFsdWUoXG4gICAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbUlubGluZVN0eWxlcyksXG4gICAgICAgICAgICAgICAgICAgIGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tVGFyZ2V0T2JqZWN0LnQgPSB2YWx1ZVR5cGVzLlVOSVQ7XG4gICAgICAgICAgICAgICAgICAgIGZyb21UYXJnZXRPYmplY3QudSA9IGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaGFzVG9WYWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKHR3ZWVuVG9WYWx1ZSwgdG9UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2VHdlZW4pIHtcbiAgICAgICAgICAgICAgICAgIGRlY29tcG9zZVR3ZWVuVmFsdWUocHJldlR3ZWVuLCB0b1RhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZ2V0IGFuZCBwYXJzZSB0aGUgb3JpZ2luYWwgdmFsdWUgaWYgdGhlIHR3ZWVuIGlzIHBhcnQgb2YgYSB0aW1lbGluZSBhbmQgaGFzIGEgcHJldmlvdXMgc2libGluZyBwYXJ0IG9mIHRoZSBzYW1lIHRpbWVsaW5lXG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZShwYXJlbnQgJiYgcHJldlNpYmxpbmcgJiYgcHJldlNpYmxpbmcucGFyZW50LnBhcmVudCA9PT0gcGFyZW50ID8gcHJldlNpYmxpbmcuX3ZhbHVlIDpcbiAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbUlubGluZVN0eWxlcyksIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGhhc0Zyb212YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKHR3ZWVuRnJvbVZhbHVlLCBmcm9tVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlR3ZWVuKSB7XG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VUd2VlblZhbHVlKHByZXZUd2VlbiwgZnJvbVRhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKHBhcmVudCAmJiBwcmV2U2libGluZyAmJiBwcmV2U2libGluZy5wYXJlbnQucGFyZW50ID09PSBwYXJlbnQgPyBwcmV2U2libGluZy5fdmFsdWUgOlxuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBnZXQgYW5kIHBhcnNlIHRoZSBvcmlnaW5hbCB2YWx1ZSBpZiB0aGUgdHdlZW4gaXMgcGFydCBvZiBhIHRpbWVsaW5lIGFuZCBoYXMgYSBwcmV2aW91cyBzaWJsaW5nIHBhcnQgb2YgdGhlIHNhbWUgdGltZWxpbmVcbiAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbUlubGluZVN0eWxlcyksIGZyb21UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBvcGVyYXRvcnNcbiAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0Lm8pIHtcbiAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC5uID0gZ2V0UmVsYXRpdmVWYWx1ZShcbiAgICAgICAgICAgICAgICAhcHJldlNpYmxpbmcgPyBkZWNvbXBvc2VSYXdWYWx1ZShcbiAgICAgICAgICAgICAgICAgIGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbUlubGluZVN0eWxlcyksXG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZVxuICAgICAgICAgICAgICAgICkubiA6IHByZXZTaWJsaW5nLl90b051bWJlcixcbiAgICAgICAgICAgICAgICBmcm9tVGFyZ2V0T2JqZWN0Lm4sXG4gICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC5vXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b1RhcmdldE9iamVjdC5vKSB7XG4gICAgICAgICAgICAgIHRvVGFyZ2V0T2JqZWN0Lm4gPSBnZXRSZWxhdGl2ZVZhbHVlKGZyb21UYXJnZXRPYmplY3QubiwgdG9UYXJnZXRPYmplY3QubiwgdG9UYXJnZXRPYmplY3Qubyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZhbHVlcyBvbW9nZW5pc2F0aW9uIGluIGNhc2VzIG9mIHR5cGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFwiZnJvbVwiIGFuZCBcInRvXCJcbiAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnQgIT09IHRvVGFyZ2V0T2JqZWN0LnQpIHtcbiAgICAgICAgICAgICAgaWYgKGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT01QTEVYIHx8IHRvVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09NUExFWCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXhWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT01QTEVYID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdENvbXBsZXhWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT01QTEVYID8gdG9UYXJnZXRPYmplY3QgOiBmcm9tVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIG5vdENvbXBsZXhWYWx1ZS50ID0gdmFsdWVUeXBlcy5DT01QTEVYO1xuICAgICAgICAgICAgICAgIG5vdENvbXBsZXhWYWx1ZS5zID0gY2xvbmVBcnJheShjb21wbGV4VmFsdWUucyk7XG4gICAgICAgICAgICAgICAgbm90Q29tcGxleFZhbHVlLmQgPSBjb21wbGV4VmFsdWUuZC5tYXAoKCkgPT4gbm90Q29tcGxleFZhbHVlLm4pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5VTklUIHx8IHRvVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuVU5JVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuaXRWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5VTklUID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdFVuaXRWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5VTklUID8gdG9UYXJnZXRPYmplY3QgOiBmcm9tVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIG5vdFVuaXRWYWx1ZS50ID0gdmFsdWVUeXBlcy5VTklUO1xuICAgICAgICAgICAgICAgIG5vdFVuaXRWYWx1ZS51ID0gdW5pdFZhbHVlLnU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbVRhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTE9SIHx8IHRvVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09MT1IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvclZhbHVlID0gZnJvbVRhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTE9SID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdENvbG9yVmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09MT1IgPyB0b1RhcmdldE9iamVjdCA6IGZyb21UYXJnZXRPYmplY3Q7XG4gICAgICAgICAgICAgICAgbm90Q29sb3JWYWx1ZS50ID0gdmFsdWVUeXBlcy5DT0xPUjtcbiAgICAgICAgICAgICAgICBub3RDb2xvclZhbHVlLnMgPSBjb2xvclZhbHVlLnM7XG4gICAgICAgICAgICAgICAgbm90Q29sb3JWYWx1ZS5kID0gWzAsIDAsIDAsIDFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVuaXQgY29udmVyc2lvblxuICAgICAgICAgICAgaWYgKGZyb21UYXJnZXRPYmplY3QudSAhPT0gdG9UYXJnZXRPYmplY3QudSkge1xuICAgICAgICAgICAgICBsZXQgdmFsdWVUb0NvbnZlcnQgPSB0b1RhcmdldE9iamVjdC51ID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICB2YWx1ZVRvQ29udmVydCA9IGNvbnZlcnRWYWx1ZVVuaXQoLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCksIHZhbHVlVG9Db252ZXJ0LCB0b1RhcmdldE9iamVjdC51ID8gdG9UYXJnZXRPYmplY3QudSA6IGZyb21UYXJnZXRPYmplY3QudSwgZmFsc2UpO1xuICAgICAgICAgICAgICAvLyBUT0RPOlxuICAgICAgICAgICAgICAvLyBjb252ZXJ0VmFsdWVVbml0KHRhcmdldCwgdG8udSA/IGZyb20gOiB0bywgdG8udSA/IHRvLnUgOiBmcm9tLnUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIGluIG5vbiBleGlzdGluZyBjb21wbGV4IHZhbHVlc1xuICAgICAgICAgICAgaWYgKHRvVGFyZ2V0T2JqZWN0LmQgJiYgZnJvbVRhcmdldE9iamVjdC5kICYmICh0b1RhcmdldE9iamVjdC5kLmxlbmd0aCAhPT0gZnJvbVRhcmdldE9iamVjdC5kLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgbG9uZ2VzdFZhbHVlID0gZnJvbVRhcmdldE9iamVjdC5kLmxlbmd0aCA+IHRvVGFyZ2V0T2JqZWN0LmQubGVuZ3RoID8gZnJvbVRhcmdldE9iamVjdCA6IHRvVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICBjb25zdCBzaG9ydGVzdFZhbHVlID0gbG9uZ2VzdFZhbHVlID09PSBmcm9tVGFyZ2V0T2JqZWN0ID8gdG9UYXJnZXRPYmplY3QgOiBmcm9tVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiBuIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgMCBmb3IgZGVmYXVsdCBjb21wbGV4IHZhbHVlc1xuICAgICAgICAgICAgICBzaG9ydGVzdFZhbHVlLmQgPSBsb25nZXN0VmFsdWUuZC5tYXAoKF8sIGkpID0+IGlzVW5kKHNob3J0ZXN0VmFsdWUuZFtpXSkgPyAwIDogc2hvcnRlc3RWYWx1ZS5kW2ldKTtcbiAgICAgICAgICAgICAgc2hvcnRlc3RWYWx1ZS5zID0gY2xvbmVBcnJheShsb25nZXN0VmFsdWUucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFR3ZWVuIGZhY3RvcnlcblxuICAgICAgICAgICAgLy8gUm91bmRpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgdG8gbWluaW1pemUgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHdoZW4gd29ya2luZyBpbiBzZWNvbmRzXG4gICAgICAgICAgICBjb25zdCB0d2VlblVwZGF0ZUR1cmF0aW9uID0gcm91bmQoK3R3ZWVuRHVyYXRpb24gfHwgbWluVmFsdWUsIDEyKTtcblxuICAgICAgICAgICAgLyoqIEB0eXBlIHtUd2Vlbn0gKi9cbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuID0ge1xuICAgICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgIGlkOiB0d2VlbklkKyssXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgIF92YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgX2Z1bmM6IHRvRnVuY3Rpb25TdG9yZS5mdW5jLFxuICAgICAgICAgICAgICBfZWFzZTogcGFyc2VFYXNpbmdzKHR3ZWVuRWFzaW5nKSxcbiAgICAgICAgICAgICAgX2Zyb21OdW1iZXJzOiBjbG9uZUFycmF5KGZyb21UYXJnZXRPYmplY3QuZCksXG4gICAgICAgICAgICAgIF90b051bWJlcnM6IGNsb25lQXJyYXkodG9UYXJnZXRPYmplY3QuZCksXG4gICAgICAgICAgICAgIF9zdHJpbmdzOiBjbG9uZUFycmF5KHRvVGFyZ2V0T2JqZWN0LnMpLFxuICAgICAgICAgICAgICBfZnJvbU51bWJlcjogZnJvbVRhcmdldE9iamVjdC5uLFxuICAgICAgICAgICAgICBfdG9OdW1iZXI6IHRvVGFyZ2V0T2JqZWN0Lm4sXG4gICAgICAgICAgICAgIF9udW1iZXJzOiBjbG9uZUFycmF5KGZyb21UYXJnZXRPYmplY3QuZCksIC8vIEZvciBhZGRpdGl2ZSB0d2VlbiBhbmQgYW5pbWF0YWJsZXNcbiAgICAgICAgICAgICAgX251bWJlcjogZnJvbVRhcmdldE9iamVjdC5uLCAvLyBGb3IgYWRkaXRpdmUgdHdlZW4gYW5kIGFuaW1hdGFibGVzXG4gICAgICAgICAgICAgIF91bml0OiB0b1RhcmdldE9iamVjdC51LFxuICAgICAgICAgICAgICBfbW9kaWZpZXI6IHR3ZWVuTW9kaWZpZXIsXG4gICAgICAgICAgICAgIF9jdXJyZW50VGltZTogMCxcbiAgICAgICAgICAgICAgX3N0YXJ0VGltZTogdHdlZW5TdGFydFRpbWUsXG4gICAgICAgICAgICAgIF9kZWxheTogK3R3ZWVuRGVsYXksXG4gICAgICAgICAgICAgIF91cGRhdGVEdXJhdGlvbjogdHdlZW5VcGRhdGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgX2NoYW5nZUR1cmF0aW9uOiB0d2VlblVwZGF0ZUR1cmF0aW9uLFxuICAgICAgICAgICAgICBfYWJzb2x1dGVTdGFydFRpbWU6IGFic29sdXRlU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAvLyBOT1RFOiBJbnZlc3RpZ2F0ZSBiaXQgcGFja2luZyB0byBzdG9yZXMgRU5VTSAvIEJPT0xcbiAgICAgICAgICAgICAgX3R3ZWVuVHlwZTogdHdlZW5UeXBlLFxuICAgICAgICAgICAgICBfdmFsdWVUeXBlOiB0b1RhcmdldE9iamVjdC50LFxuICAgICAgICAgICAgICBfY29tcG9zaXRpb246IHR3ZWVuQ29tcG9zaXRpb24sXG4gICAgICAgICAgICAgIF9pc092ZXJsYXBwZWQ6IDAsXG4gICAgICAgICAgICAgIF9pc092ZXJyaWRkZW46IDAsXG4gICAgICAgICAgICAgIF9yZW5kZXJUcmFuc2Zvcm1zOiAwLFxuICAgICAgICAgICAgICBfcHJldlJlcDogbnVsbCwgLy8gRm9yIHJlcGxhY2VkIHR3ZWVuXG4gICAgICAgICAgICAgIF9uZXh0UmVwOiBudWxsLCAvLyBGb3IgcmVwbGFjZWQgdHdlZW5cbiAgICAgICAgICAgICAgX3ByZXZBZGQ6IG51bGwsIC8vIEZvciBhZGRpdGl2ZSB0d2VlblxuICAgICAgICAgICAgICBfbmV4dEFkZDogbnVsbCwgLy8gRm9yIGFkZGl0aXZlIHR3ZWVuXG4gICAgICAgICAgICAgIF9wcmV2OiBudWxsLFxuICAgICAgICAgICAgICBfbmV4dDogbnVsbCxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLm5vbmUpIHtcbiAgICAgICAgICAgICAgY29tcG9zZVR3ZWVuKHR3ZWVuLCBzaWJsaW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc05hTihmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lKSkge1xuICAgICAgICAgICAgICBmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lID0gdHdlZW4uX3N0YXJ0VGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIHRvIG1pbmltaXplIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3aGVuIHdvcmtpbmcgaW4gc2Vjb25kc1xuICAgICAgICAgICAgbGFzdFR3ZWVuQ2hhbmdlRW5kVGltZSA9IHJvdW5kKHR3ZWVuU3RhcnRUaW1lICsgdHdlZW5VcGRhdGVEdXJhdGlvbiwgMTIpO1xuICAgICAgICAgICAgcHJldlR3ZWVuID0gdHdlZW47XG4gICAgICAgICAgICBhbmltYXRpb25BbmltYXRpb25MZW5ndGgrKztcblxuICAgICAgICAgICAgYWRkQ2hpbGQodGhpcywgdHdlZW4pO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIGFuaW1hdGlvbiB0aW1pbmdzIHdpdGggdGhlIGFkZGVkIHR3ZWVucyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgICBpZiAoaXNOYU4oaXRlcmF0aW9uRGVsYXkpIHx8IGZpcnN0VHdlZW5DaGFuZ2VTdGFydFRpbWUgPCBpdGVyYXRpb25EZWxheSkge1xuICAgICAgICAgICAgaXRlcmF0aW9uRGVsYXkgPSBmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc05hTihpdGVyYXRpb25EdXJhdGlvbikgfHwgbGFzdFR3ZWVuQ2hhbmdlRW5kVGltZSA+IGl0ZXJhdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpdGVyYXRpb25EdXJhdGlvbiA9IGxhc3RUd2VlbkNoYW5nZUVuZFRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogRmluZCBhIHdheSB0byBpbmxpbmUgdHdlZW4uX3JlbmRlclRyYW5zZm9ybXMgPSAxIGhlcmVcbiAgICAgICAgICBpZiAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSkge1xuICAgICAgICAgICAgbGFzdFRyYW5zZm9ybUdyb3VwSW5kZXggPSBhbmltYXRpb25BbmltYXRpb25MZW5ndGggLSB0d2VlbkluZGV4O1xuICAgICAgICAgICAgbGFzdFRyYW5zZm9ybUdyb3VwTGVuZ3RoID0gYW5pbWF0aW9uQW5pbWF0aW9uTGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gU2V0IF9yZW5kZXJUcmFuc2Zvcm1zIHRvIGxhc3QgdHJhbnNmb3JtIHByb3BlcnR5IHRvIGNvcnJlY3RseSByZW5kZXIgdGhlIHRyYW5zZm9ybXMgbGlzdFxuICAgICAgaWYgKCFpc05hTihsYXN0VHJhbnNmb3JtR3JvdXBJbmRleCkpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7VHdlZW59ICovdHdlZW4pID0+IHtcbiAgICAgICAgICBpZiAoaSA+PSBsYXN0VHJhbnNmb3JtR3JvdXBJbmRleCAmJiBpIDwgbGFzdFRyYW5zZm9ybUdyb3VwTGVuZ3RoKSB7XG4gICAgICAgICAgICB0d2Vlbi5fcmVuZGVyVHJhbnNmb3JtcyA9IDE7XG4gICAgICAgICAgICBpZiAodHdlZW4uX2NvbXBvc2l0aW9uID09PSBjb21wb3NpdGlvblR5cGVzLmJsZW5kKSB7XG4gICAgICAgICAgICAgIGZvckVhY2hDaGlsZHJlbihhZGRpdGl2ZS5hbmltYXRpb24sICgvKiogQHR5cGUge1R3ZWVufSAqL2FkZGl0aXZlVHdlZW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpdmVUd2Vlbi5pZCA9PT0gdHdlZW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgIGFkZGl0aXZlVHdlZW4uX3JlbmRlclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldHNMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTm8gdGFyZ2V0IGZvdW5kLiBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgeW91J3JlIHRyeWluZyB0byBhbmltYXRlIGlzIGFjY2Vzc2libGUgYmVmb3JlIGNyZWF0aW5nIHlvdXIgYW5pbWF0aW9uLmApO1xuICAgIH1cblxuICAgIGlmIChpdGVyYXRpb25EZWxheSkge1xuICAgICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgICAgIC8vIElmIChzdGFydFRpbWUgLSBkZWxheSkgZXF1YWxzIDAsIHRoaXMgbWVhbnMgdGhlIHR3ZWVuIGlzIGF0IHRoZSBiZWdpbmluZyBvZiB0aGUgYW5pbWF0aW9uIHNvIHdlIG5lZWQgdG8gdHJpbSB0aGUgZGVsYXkgdG9vXG4gICAgICAgIGlmICghKHR3ZWVuLl9zdGFydFRpbWUgLSB0d2Vlbi5fZGVsYXkpKSB7XG4gICAgICAgICAgdHdlZW4uX2RlbGF5IC09IGl0ZXJhdGlvbkRlbGF5O1xuICAgICAgICB9XG4gICAgICAgIHR3ZWVuLl9zdGFydFRpbWUgLT0gaXRlcmF0aW9uRGVsYXk7XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGlvbkR1cmF0aW9uIC09IGl0ZXJhdGlvbkRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRpb25EZWxheSA9IDA7XG4gICAgfVxuXG4gICAgLy8gUHJldmVudHMgaXRlcmF0aW9uRHVyYXRpb24gdG8gYmUgTmFOIGlmIG5vIHZhbGlkIGFuaW1hdGFibGUgcHJvcHMgaGF2ZSBiZWVuIHByb3ZpZGVkXG4gICAgLy8gUHJldmVudHMgX2l0ZXJhdGlvbkNvdW50IHRvIGJlIE5hTiBpZiBubyB2YWxpZCBhbmltYXRhYmxlIHByb3BzIGhhdmUgYmVlbiBwcm92aWRlZFxuICAgIGlmICghaXRlcmF0aW9uRHVyYXRpb24pIHtcbiAgICAgIGl0ZXJhdGlvbkR1cmF0aW9uID0gbWluVmFsdWU7XG4gICAgICB0aGlzLml0ZXJhdGlvbkNvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtUYXJnZXRzQXJyYXl9ICovXG4gICAgdGhpcy50YXJnZXRzID0gcGFyc2VkVGFyZ2V0cztcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmR1cmF0aW9uID0gaXRlcmF0aW9uRHVyYXRpb24gPT09IG1pblZhbHVlID8gbWluVmFsdWUgOiBjbGFtcEluZmluaXR5KCgoaXRlcmF0aW9uRHVyYXRpb24gKyB0aGlzLl9sb29wRGVsYXkpICogdGhpcy5pdGVyYXRpb25Db3VudCkgLSB0aGlzLl9sb29wRGVsYXkpIHx8IG1pblZhbHVlO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblJlbmRlciA9IG9uUmVuZGVyIHx8IGFuaW1EZWZhdWx0cy5vblJlbmRlcjtcbiAgICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuX2Vhc2UgPSBhbmltRWFzZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9kZWxheSA9IGl0ZXJhdGlvbkRlbGF5O1xuICAgIC8vIE5PVEU6IEknbSBrZWVwaW5nIGRlbGF5IHZhbHVlcyBzZXBhcmF0ZWQgZnJvbSBvZmZzZXRzIGluIHRpbWVsaW5lcyBiZWNhdXNlIGRlbGF5cyBjYW4gb3ZlcnJpZGUgcHJldmlvdXMgdHdlZW5zIGFuZCBpdCBjb3VsZCBiZSBjb25mdXNpbmcgdG8gZGVidWcgYSB0aW1lbGluZSB3aXRoIG92ZXJyaWRkZW4gdHdlZW5zIGFuZCBubyBhc3NvY2lhdGVkIHZpc2libGUgZGVsYXlzLlxuICAgIC8vIHRoaXMuX2RlbGF5ID0gcGFyZW50ID8gMCA6IGl0ZXJhdGlvbkRlbGF5O1xuICAgIC8vIHRoaXMuX29mZnNldCArPSBwYXJlbnQgPyBpdGVyYXRpb25EZWxheSA6IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5pdGVyYXRpb25EdXJhdGlvbiA9IGl0ZXJhdGlvbkR1cmF0aW9uO1xuICAgIC8qKiBAdHlwZSB7e319ICovXG4gICAgdGhpcy5faW5saW5lU3R5bGVzID0gYW5pbUlubGluZVN0eWxlcztcblxuICAgIGlmICghdGhpcy5fYXV0b3BsYXkgJiYgc2hvdWxkVHJpZ2dlclJlbmRlcikgdGhpcy5vblJlbmRlcih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG5ld0R1cmF0aW9uXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzdHJldGNoKG5ld0R1cmF0aW9uKSB7XG4gICAgY29uc3QgY3VycmVudER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBpZiAoY3VycmVudER1cmF0aW9uID09PSBub3JtYWxpemVUaW1lKG5ld0R1cmF0aW9uKSkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdGltZVNjYWxlID0gbmV3RHVyYXRpb24gLyBjdXJyZW50RHVyYXRpb247XG4gICAgLy8gTk9URTogRmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoZSBzdHJldGNoIG9mIGFuIGFuaW1hdGlvbiBhZnRlciBzdHJldGNoID0gMFxuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi90d2VlbikgPT4ge1xuICAgICAgLy8gUm91bmRpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgdG8gbWluaW1pemUgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gICAgICB0d2Vlbi5fdXBkYXRlRHVyYXRpb24gPSBub3JtYWxpemVUaW1lKHR3ZWVuLl91cGRhdGVEdXJhdGlvbiAqIHRpbWVTY2FsZSk7XG4gICAgICB0d2Vlbi5fY2hhbmdlRHVyYXRpb24gPSBub3JtYWxpemVUaW1lKHR3ZWVuLl9jaGFuZ2VEdXJhdGlvbiAqIHRpbWVTY2FsZSk7XG4gICAgICB0d2Vlbi5fY3VycmVudFRpbWUgKj0gdGltZVNjYWxlO1xuICAgICAgdHdlZW4uX3N0YXJ0VGltZSAqPSB0aW1lU2NhbGU7XG4gICAgICB0d2Vlbi5fYWJzb2x1dGVTdGFydFRpbWUgKj0gdGltZVNjYWxlO1xuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5zdHJldGNoKG5ld0R1cmF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7VHdlZW59ICovdHdlZW4pID0+IHtcbiAgICAgIGNvbnN0IHR3ZWVuRnVuYyA9IHR3ZWVuLl9mdW5jO1xuICAgICAgaWYgKHR3ZWVuRnVuYykge1xuICAgICAgICBjb25zdCBvZ1ZhbHVlID0gZ2V0T3JpZ2luYWxBbmltYXRhYmxlVmFsdWUodHdlZW4udGFyZ2V0LCB0d2Vlbi5wcm9wZXJ0eSwgdHdlZW4uX3R3ZWVuVHlwZSk7XG4gICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKG9nVmFsdWUsIGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlKTtcbiAgICAgICAgZGVjb21wb3NlUmF3VmFsdWUodHdlZW5GdW5jKCksIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXJzID0gY2xvbmVBcnJheShkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5kKTtcbiAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXIgPSBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5uO1xuICAgICAgICB0d2Vlbi5fdG9OdW1iZXJzID0gY2xvbmVBcnJheSh0b1RhcmdldE9iamVjdC5kKTtcbiAgICAgICAgdHdlZW4uX3N0cmluZ3MgPSBjbG9uZUFycmF5KHRvVGFyZ2V0T2JqZWN0LnMpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gYXBwbHkgcmVsYXRpdmUgb3BlcmF0b3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWxpYW5nYXJuaWVyL2FuaW1lL2lzc3Vlcy8xMDI1XG4gICAgICAgIHR3ZWVuLl90b051bWJlciA9IHRvVGFyZ2V0T2JqZWN0Lm8gPyBnZXRSZWxhdGl2ZVZhbHVlKGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLm4sIHRvVGFyZ2V0T2JqZWN0Lm4sIHRvVGFyZ2V0T2JqZWN0Lm8pIDogdG9UYXJnZXRPYmplY3QubjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIGFuaW1hdGlvbiBhbmQgcmV2ZXJ0IGFsbCB0aGUgdmFsdWVzIGFmZmVjdGVkIGJ5IHRoaXMgYW5pbWF0aW9uIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZXZlcnQoKSB7XG4gICAgc3VwZXIucmV2ZXJ0KCk7XG4gICAgcmV0dXJuIGNsZWFuSW5saW5lU3R5bGVzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbGxiYWNrPHRoaXM+fSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB0aGVuKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRoZW4oY2FsbGJhY2spO1xuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0pTQW5pbWF0aW9ufVxuICovXG5jb25zdCBhbmltYXRlID0gKHRhcmdldHMsIHBhcmFtZXRlcnMpID0+IG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLCBwYXJhbWV0ZXJzLCBudWxsLCAwLCBmYWxzZSkuaW5pdCgpO1xuXG5cblxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGVhc2luZyBmdW5jdGlvbiBpbnRvIGEgdmFsaWQgQ1NTIGxpbmVhcigpIHRpbWluZyBmdW5jdGlvbiBzdHJpbmdcbiAqIEBwYXJhbSB7RWFzaW5nRnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9MTAwXVxuICogQHJldHVybnMge3N0cmluZ30gQ1NTIGxpbmVhcigpIHRpbWluZyBmdW5jdGlvblxuICovXG5jb25zdCBlYXNpbmdUb0xpbmVhciA9IChmbiwgc2FtcGxlcyA9IDEwMCkgPT4ge1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2FtcGxlczsgaSsrKSBwb2ludHMucHVzaChmbihpIC8gc2FtcGxlcykpO1xuICByZXR1cm4gYGxpbmVhcigke3BvaW50cy5qb2luKCcsICcpfSlgO1xufTtcblxuY29uc3QgV0FBUElFYXNlc0xvb2t1cHMgPSB7XG4gIGluOiAnZWFzZS1pbicsXG4gIG91dDogJ2Vhc2Utb3V0JyxcbiAgaW5PdXQ6ICdlYXNlLWluLW91dCcsXG59O1xuXG5jb25zdCBXQUFQSWVhc2VzID0gLyojX19QVVJFX18qLygoKSA9PiB7XG4gIGNvbnN0IGxpc3QgPSB7fTtcbiAgZm9yIChsZXQgdHlwZSBpbiBlYXNlVHlwZXMpIGxpc3RbdHlwZV0gPSAoLyoqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfSAqL3ApID0+IGVhc2VUeXBlc1t0eXBlXShlYXNlSW5Qb3dlcihwKSk7XG4gIHJldHVybiAvKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2luZ0Z1bmN0aW9uPn0gKi8obGlzdCk7XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSAge0Vhc2luZ1BhcmFtfSBlYXNlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhcnNlV0FBUElFYXNpbmcgPSAoZWFzZSkgPT4ge1xuICBsZXQgcGFyc2VkRWFzZSA9IFdBQVBJRWFzZXNMb29rdXBzW2Vhc2VdO1xuICBpZiAocGFyc2VkRWFzZSkgcmV0dXJuIHBhcnNlZEVhc2U7XG4gIHBhcnNlZEVhc2UgPSAnbGluZWFyJztcbiAgaWYgKGlzU3RyKGVhc2UpKSB7XG4gICAgaWYgKFxuICAgICAgc3RyaW5nU3RhcnRzV2l0aChlYXNlLCAnbGluZWFyJykgfHxcbiAgICAgIHN0cmluZ1N0YXJ0c1dpdGgoZWFzZSwgJ2N1YmljLScpIHx8XG4gICAgICBzdHJpbmdTdGFydHNXaXRoKGVhc2UsICdzdGVwcycpIHx8XG4gICAgICBzdHJpbmdTdGFydHNXaXRoKGVhc2UsICdlYXNlJylcbiAgICApIHtcbiAgICAgIHBhcnNlZEVhc2UgPSBlYXNlO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nU3RhcnRzV2l0aChlYXNlLCAnY3ViaWNCJykpIHtcbiAgICAgIHBhcnNlZEVhc2UgPSB0b0xvd2VyQ2FzZShlYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VFYXNlU3RyaW5nKGVhc2UsIFdBQVBJZWFzZXMsIFdBQVBJRWFzZXNMb29rdXBzKTtcbiAgICAgIGlmIChpc0ZuYyhwYXJzZWQpKSBwYXJzZWRFYXNlID0gcGFyc2VkID09PSBub25lID8gJ2xpbmVhcicgOiBlYXNpbmdUb0xpbmVhcihwYXJzZWQpO1xuICAgIH1cbiAgICBXQUFQSUVhc2VzTG9va3Vwc1tlYXNlXSA9IHBhcnNlZEVhc2U7XG4gIH0gZWxzZSBpZiAoaXNGbmMoZWFzZSkpIHtcbiAgICBjb25zdCBlYXNpbmcgPSBlYXNpbmdUb0xpbmVhcihlYXNlKTtcbiAgICBpZiAoZWFzaW5nKSBwYXJzZWRFYXNlID0gZWFzaW5nO1xuICB9IGVsc2UgaWYgKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKSB7XG4gICAgcGFyc2VkRWFzZSA9IGVhc2luZ1RvTGluZWFyKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkRWFzZTtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybXNTaG9ydGhhbmRzID0gWyd4JywgJ3knLCAneiddO1xuY29uc3QgY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcyA9IFtcbiAgJ3BlcnNwZWN0aXZlJyxcbiAgJ3dpZHRoJyxcbiAgJ2hlaWdodCcsXG4gICdtYXJnaW4nLFxuICAncGFkZGluZycsXG4gICd0b3AnLFxuICAncmlnaHQnLFxuICAnYm90dG9tJyxcbiAgJ2xlZnQnLFxuICAnYm9yZGVyV2lkdGgnLFxuICAnZm9udFNpemUnLFxuICAnYm9yZGVyUmFkaXVzJyxcbiAgLi4udHJhbnNmb3Jtc1Nob3J0aGFuZHNcbl07XG5cbmNvbnN0IHZhbGlkSW5kaXZpZHVhbFRyYW5zZm9ybXMgPSAvKiNfX1BVUkVfXyovICgoKSA9PiBbLi4udHJhbnNmb3Jtc1Nob3J0aGFuZHMsIC4uLnZhbGlkVHJhbnNmb3Jtcy5maWx0ZXIodCA9PiBbJ1gnLCAnWScsICdaJ10uc29tZShheGlzID0+IHQuZW5kc1dpdGgoYXhpcykpKV0pKCk7XG5cbmxldCB0cmFuc2Zvcm1zUHJvcGVydGllc1JlZ2lzdGVyZWQgPSBudWxsO1xuXG5jb25zdCBXQUFQSUFuaW1hdGlvbnNMb29rdXBzID0ge1xuICBfaGVhZDogbnVsbCxcbiAgX3RhaWw6IG51bGwsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldXG4gKiBAcGFyYW0ge1dBQVBJQW5pbWF0aW9ufSBbcGFyZW50XVxuICovXG5jb25zdCByZW1vdmVXQUFQSUFuaW1hdGlvbiA9ICgkZWwsIHByb3BlcnR5LCBwYXJlbnQpID0+IHtcbiAgbGV0IG5leHRMb29rdXAgPSBXQUFQSUFuaW1hdGlvbnNMb29rdXBzLl9oZWFkO1xuICB3aGlsZSAobmV4dExvb2t1cCkge1xuICAgIGNvbnN0IG5leHQgPSBuZXh0TG9va3VwLl9uZXh0O1xuICAgIGNvbnN0IG1hdGNoVGFyZ2V0ID0gbmV4dExvb2t1cC4kZWwgPT09ICRlbDtcbiAgICBjb25zdCBtYXRjaFByb3BlcnR5ID0gIXByb3BlcnR5IHx8IG5leHRMb29rdXAucHJvcGVydHkgPT09IHByb3BlcnR5O1xuICAgIGNvbnN0IG1hdGNoUGFyZW50ID0gIXBhcmVudCB8fCBuZXh0TG9va3VwLnBhcmVudCA9PT0gcGFyZW50O1xuICAgIGlmIChtYXRjaFRhcmdldCAmJiBtYXRjaFByb3BlcnR5ICYmIG1hdGNoUGFyZW50KSB7XG4gICAgICBjb25zdCBhbmltID0gbmV4dExvb2t1cC5hbmltYXRpb247XG4gICAgICB0cnkgeyBhbmltLmNvbW1pdFN0eWxlcygpOyB9IGNhdGNoIHt9ICAgICAgYW5pbS5jYW5jZWwoKTtcbiAgICAgIHJlbW92ZUNoaWxkKFdBQVBJQW5pbWF0aW9uc0xvb2t1cHMsIG5leHRMb29rdXApO1xuICAgICAgY29uc3QgbG9va3VwUGFyZW50ID0gbmV4dExvb2t1cC5wYXJlbnQ7XG4gICAgICBpZiAobG9va3VwUGFyZW50KSB7XG4gICAgICAgIGxvb2t1cFBhcmVudC5fY29tcGxldGVkKys7XG4gICAgICAgIGlmIChsb29rdXBQYXJlbnQuYW5pbWF0aW9ucy5sZW5ndGggPT09IGxvb2t1cFBhcmVudC5fY29tcGxldGVkKSB7XG4gICAgICAgICAgbG9va3VwUGFyZW50LmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFsb29rdXBQYXJlbnQubXV0ZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgbG9va3VwUGFyZW50LnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBsb29rdXBQYXJlbnQub25Db21wbGV0ZShsb29rdXBQYXJlbnQpO1xuICAgICAgICAgICAgbG9va3VwUGFyZW50Ll9yZXNvbHZlKGxvb2t1cFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5leHRMb29rdXAgPSBuZXh0O1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7V0FBUElBbmltYXRpb259IHBhcmVudFxuICogQHBhcmFtIHtET01UYXJnZXR9ICRlbFxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge1Byb3BlcnR5SW5kZXhlZEtleWZyYW1lc30ga2V5ZnJhbWVzXG4gKiBAcGFyYW0ge0tleWZyYW1lQW5pbWF0aW9uT3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dW4ge0FuaW1hdGlvbn1cbiAqL1xuY29uc3QgYWRkV0FBUElBbmltYXRpb24gPSAocGFyZW50LCAkZWwsIHByb3BlcnR5LCBrZXlmcmFtZXMsIHBhcmFtcykgPT4ge1xuICBjb25zdCBhbmltYXRpb24gPSAkZWwuYW5pbWF0ZShrZXlmcmFtZXMsIHBhcmFtcyk7XG4gIGNvbnN0IGFuaW1Ub3RhbER1cmF0aW9uID0gcGFyYW1zLmRlbGF5ICsgKCtwYXJhbXMuZHVyYXRpb24gKiBwYXJhbXMuaXRlcmF0aW9ucyk7XG4gIGFuaW1hdGlvbi5wbGF5YmFja1JhdGUgPSBwYXJlbnQuX3NwZWVkO1xuICBpZiAocGFyZW50LnBhdXNlZCkgYW5pbWF0aW9uLnBhdXNlKCk7XG4gIGlmIChwYXJlbnQuZHVyYXRpb24gPCBhbmltVG90YWxEdXJhdGlvbikge1xuICAgIHBhcmVudC5kdXJhdGlvbiA9IGFuaW1Ub3RhbER1cmF0aW9uO1xuICAgIHBhcmVudC5jb250cm9sQW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICB9XG4gIHBhcmVudC5hbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgcmVtb3ZlV0FBUElBbmltYXRpb24oJGVsLCBwcm9wZXJ0eSk7XG4gIGFkZENoaWxkKFdBQVBJQW5pbWF0aW9uc0xvb2t1cHMsIHsgcGFyZW50LCBhbmltYXRpb24sICRlbCwgcHJvcGVydHksIF9uZXh0OiBudWxsLCBfcHJldjogbnVsbCB9KTtcbiAgY29uc3QgaGFuZGxlUmVtb3ZlID0gKCkgPT4geyByZW1vdmVXQUFQSUFuaW1hdGlvbigkZWwsIHByb3BlcnR5LCBwYXJlbnQpOyB9O1xuICBhbmltYXRpb24ub25yZW1vdmUgPSBoYW5kbGVSZW1vdmU7XG4gIGFuaW1hdGlvbi5vbmZpbmlzaCA9IGhhbmRsZVJlbW92ZTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtICB7V0FBUElLZXlmcmFtZVZhbHVlfSB2YWx1ZVxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSB0YXJnZXRzTGVuZ3RoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVR3ZWVuVmFsdWUgPSAocHJvcE5hbWUsIHZhbHVlLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpID0+IHtcbiAgbGV0IHYgPSBnZXRGdW5jdGlvblZhbHVlKC8qKiBAdHlwZSB7YW55fSAqLyh2YWx1ZSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gIGlmICghaXNOdW0odikpIHJldHVybiB2O1xuICBpZiAoY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcy5pbmNsdWRlcyhwcm9wTmFtZSkgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3RyYW5zbGF0ZScpKSByZXR1cm4gYCR7dn1weGA7XG4gIGlmIChzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3NrZXcnKSkgcmV0dXJuIGAke3Z9ZGVnYDtcbiAgcmV0dXJuIGAke3Z9YDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge1dBQVBJS2V5ZnJhbWVWYWx1ZX0gZnJvbVxuICogQHBhcmFtICB7V0FBUElLZXlmcmFtZVZhbHVlfSB0b1xuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRhcmdldHNMZW5ndGhcbiAqIEByZXR1cm4ge1dBQVBJVHdlZW5WYWx1ZX1cbiAqL1xuY29uc3QgcGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSA9ICgkZWwsIHByb3BOYW1lLCBmcm9tLCB0bywgaSwgdGFyZ2V0c0xlbmd0aCkgPT4ge1xuICAvKiogQHR5cGUge1dBQVBJVHdlZW5WYWx1ZX0gKi9cbiAgbGV0IHR3ZWVuVmFsdWUgPSAnMCc7XG4gIGNvbnN0IGNvbXB1dGVkVG8gPSAhaXNVbmQodG8pID8gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgdG8sICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkgOiBnZXRDb21wdXRlZFN0eWxlKCRlbClbcHJvcE5hbWVdO1xuICBpZiAoIWlzVW5kKGZyb20pKSB7XG4gICAgY29uc3QgY29tcHV0ZWRGcm9tID0gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgZnJvbSwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKTtcbiAgICB0d2VlblZhbHVlID0gW2NvbXB1dGVkRnJvbSwgY29tcHV0ZWRUb107XG4gIH0gZWxzZSB7XG4gICAgdHdlZW5WYWx1ZSA9IGlzQXJyKHRvKSA/IHRvLm1hcCgoLyoqIEB0eXBlIHthbnl9ICovdikgPT4gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgdiwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKSkgOiBjb21wdXRlZFRvO1xuICB9XG4gIHJldHVybiB0d2VlblZhbHVlO1xufTtcblxuY2xhc3MgV0FBUElBbmltYXRpb24ge1xuLyoqXG4gKiBAcGFyYW0ge0RPTVRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtIHtXQUFQSUFuaW1hdGlvblBhcmFtc30gcGFyYW1zXG4gKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0cywgcGFyYW1zKSB7XG5cbiAgICBpZiAoc2NvcGUuY3VycmVudCkgc2NvcGUuY3VycmVudC5yZWdpc3Rlcih0aGlzKTtcblxuICAgIC8vIFNraXAgdGhlIHJlZ2lzdHJhdGlvbiBhbmQgZmFsbGJhY2sgdG8gbm8gYW5pbWF0aW9uIGluIGNhc2UgQ1NTLnJlZ2lzdGVyUHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZFxuICAgIGlmIChpc05pbCh0cmFuc2Zvcm1zUHJvcGVydGllc1JlZ2lzdGVyZWQpKSB7XG4gICAgICBpZiAoaXNCcm93c2VyICYmIChpc1VuZChDU1MpIHx8ICFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChDU1MsICdyZWdpc3RlclByb3BlcnR5JykpKSB7XG4gICAgICAgIHRyYW5zZm9ybXNQcm9wZXJ0aWVzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRUcmFuc2Zvcm1zLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgY29uc3QgaXNTa2V3ID0gc3RyaW5nU3RhcnRzV2l0aCh0LCAnc2tldycpO1xuICAgICAgICAgIGNvbnN0IGlzU2NhbGUgPSBzdHJpbmdTdGFydHNXaXRoKHQsICdzY2FsZScpO1xuICAgICAgICAgIGNvbnN0IGlzUm90YXRlID0gc3RyaW5nU3RhcnRzV2l0aCh0LCAncm90YXRlJyk7XG4gICAgICAgICAgY29uc3QgaXNUcmFuc2xhdGUgPSBzdHJpbmdTdGFydHNXaXRoKHQsICd0cmFuc2xhdGUnKTtcbiAgICAgICAgICBjb25zdCBpc0FuZ2xlID0gaXNSb3RhdGUgfHwgaXNTa2V3O1xuICAgICAgICAgIGNvbnN0IHN5bnRheCA9IGlzQW5nbGUgPyAnPGFuZ2xlPicgOiBpc1NjYWxlID8gXCI8bnVtYmVyPlwiIDogaXNUcmFuc2xhdGUgPyBcIjxsZW5ndGgtcGVyY2VudGFnZT5cIiA6IFwiKlwiO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBDU1MucmVnaXN0ZXJQcm9wZXJ0eSh7XG4gICAgICAgICAgICAgIG5hbWU6ICctLScgKyB0LFxuICAgICAgICAgICAgICBzeW50YXgsXG4gICAgICAgICAgICAgIGluaGVyaXRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiBpc1RyYW5zbGF0ZSA/ICcwcHgnIDogaXNBbmdsZSA/ICcwZGVnJyA6IGlzU2NhbGUgPyAnMScgOiAnMCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIHt9ICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNmb3Jtc1Byb3BlcnRpZXNSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRUYXJnZXRzID0gcmVnaXN0ZXJUYXJnZXRzKHRhcmdldHMpO1xuICAgIGNvbnN0IHRhcmdldHNMZW5ndGggPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblxuICAgIGlmICghdGFyZ2V0c0xlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKGBObyB0YXJnZXQgZm91bmQuIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCB5b3UncmUgdHJ5aW5nIHRvIGFuaW1hdGUgaXMgYWNjZXNzaWJsZSBiZWZvcmUgY3JlYXRpbmcgeW91ciBhbmltYXRpb24uYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZWFzZSA9IHNldFZhbHVlKHBhcmFtcy5lYXNlLCBwYXJzZVdBQVBJRWFzaW5nKGdsb2JhbHMuZGVmYXVsdHMuZWFzZSkpO1xuICAgIGNvbnN0IHNwcmluZyA9IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlICYmIGVhc2U7XG4gICAgY29uc3QgYXV0b3BsYXkgPSBzZXRWYWx1ZShwYXJhbXMuYXV0b3BsYXksIGdsb2JhbHMuZGVmYXVsdHMuYXV0b3BsYXkpO1xuICAgIGNvbnN0IHNjcm9sbCA9IGF1dG9wbGF5ICYmIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovKGF1dG9wbGF5KS5saW5rID8gYXV0b3BsYXkgOiBmYWxzZTtcbiAgICBjb25zdCBhbHRlcm5hdGUgPSBwYXJhbXMuYWx0ZXJuYXRlICYmIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi8ocGFyYW1zLmFsdGVybmF0ZSkgPT09IHRydWU7XG4gICAgY29uc3QgcmV2ZXJzZWQgPSBwYXJhbXMucmV2ZXJzZWQgJiYgLyoqIEB0eXBlIHtCb29sZWFufSAqLyhwYXJhbXMucmV2ZXJzZWQpID09PSB0cnVlO1xuICAgIGNvbnN0IGxvb3AgPSBzZXRWYWx1ZShwYXJhbXMubG9vcCwgZ2xvYmFscy5kZWZhdWx0cy5sb29wKTtcbiAgICBjb25zdCBpdGVyYXRpb25zID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKChsb29wID09PSB0cnVlIHx8IGxvb3AgPT09IEluZmluaXR5KSA/IEluZmluaXR5IDogaXNOdW0obG9vcCkgPyBsb29wICsgMSA6IDEpO1xuICAgIC8qKiBAdHlwZSB7UGxheWJhY2tEaXJlY3Rpb259ICovXG4gICAgY29uc3QgZGlyZWN0aW9uID0gYWx0ZXJuYXRlID8gcmV2ZXJzZWQgPyAnYWx0ZXJuYXRlLXJldmVyc2UnIDogJ2FsdGVybmF0ZScgOiByZXZlcnNlZCA/ICdyZXZlcnNlJyA6ICdub3JtYWwnO1xuICAgIC8qKiBAdHlwZSB7RmlsbE1vZGV9ICovXG4gICAgY29uc3QgZmlsbCA9ICdmb3J3YXJkcyc7XG4gICAgLyoqIEB0eXBlIHtTdHJpbmd9ICovXG4gICAgY29uc3QgZWFzaW5nID0gcGFyc2VXQUFQSUVhc2luZyhlYXNlKTtcbiAgICBjb25zdCB0aW1lU2NhbGUgPSAoZ2xvYmFscy50aW1lU2NhbGUgPT09IDEgPyAxIDogSyk7XG5cbiAgICAvKiogQHR5cGUge0RPTVRhcmdldHNBcnJheX1dICovXG4gICAgdGhpcy50YXJnZXRzID0gcGFyc2VkVGFyZ2V0cztcbiAgICAvKiogQHR5cGUge0FycmF5PGdsb2JhbFRoaXMuQW5pbWF0aW9uPn1dICovXG4gICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgLyoqIEB0eXBlIHtnbG9iYWxUaGlzLkFuaW1hdGlvbn1dICovXG4gICAgdGhpcy5jb250cm9sQW5pbWF0aW9uID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25Db21wbGV0ZSA9IHBhcmFtcy5vbkNvbXBsZXRlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMubXV0ZUNhbGxiYWNrcyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnBhdXNlZCA9ICFhdXRvcGxheSB8fCBzY3JvbGwgIT09IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnJldmVyc2VkID0gcmV2ZXJzZWQ7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuYXV0b3BsYXkgPSBhdXRvcGxheTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zcGVlZCA9IHNldFZhbHVlKHBhcmFtcy5wbGF5YmFja1JhdGUsIGdsb2JhbHMuZGVmYXVsdHMucGxheWJhY2tSYXRlKTtcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuX3Jlc29sdmUgPSBub29wOyAvLyBVc2VkIGJ5IC50aGVuKClcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9jb21wbGV0ZWQgPSAwO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8T2JqZWN0Pn1dICovXG4gICAgdGhpcy5faW5saW5lU3R5bGVzID0gcGFyc2VkVGFyZ2V0cy5tYXAoJGVsID0+ICRlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuXG4gICAgcGFyc2VkVGFyZ2V0cy5mb3JFYWNoKCgkZWwsIGkpID0+IHtcblxuICAgICAgY29uc3QgY2FjaGVkVHJhbnNmb3JtcyA9ICRlbFt0cmFuc2Zvcm1zU3ltYm9sXTtcblxuICAgICAgY29uc3QgaGFzSW5kaXZpZHVhbFRyYW5zZm9ybXMgPSB2YWxpZEluZGl2aWR1YWxUcmFuc2Zvcm1zLnNvbWUodCA9PiBwYXJhbXMuaGFzT3duUHJvcGVydHkodCkpO1xuXG4gICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gKHNwcmluZyA/IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhzcHJpbmcpLmR1cmF0aW9uIDogZ2V0RnVuY3Rpb25WYWx1ZShzZXRWYWx1ZShwYXJhbXMuZHVyYXRpb24sIGdsb2JhbHMuZGVmYXVsdHMuZHVyYXRpb24pLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpKSAqIHRpbWVTY2FsZTtcbiAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgICAgY29uc3QgZGVsYXkgPSBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKHBhcmFtcy5kZWxheSwgZ2xvYmFscy5kZWZhdWx0cy5kZWxheSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkgKiB0aW1lU2NhbGU7XG4gICAgICAvKiogQHR5cGUge0NvbXBvc2l0ZU9wZXJhdGlvbn0gKi9cbiAgICAgIGNvbnN0IGNvbXBvc2l0ZSA9IC8qKiBAdHlwZSB7Q29tcG9zaXRlT3BlcmF0aW9ufSAqLyhzZXRWYWx1ZShwYXJhbXMuY29tcG9zaXRpb24sICdyZXBsYWNlJykpO1xuXG4gICAgICBmb3IgKGxldCBuYW1lIGluIHBhcmFtcykge1xuICAgICAgICBpZiAoIWlzS2V5KG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgLyoqIEB0eXBlIHtQcm9wZXJ0eUluZGV4ZWRLZXlmcmFtZXN9ICovXG4gICAgICAgIGNvbnN0IGtleWZyYW1lcyA9IHt9O1xuICAgICAgICAvKiogQHR5cGUge0tleWZyYW1lQW5pbWF0aW9uT3B0aW9uc30gKi9cbiAgICAgICAgY29uc3QgdHdlZW5QYXJhbXMgPSB7IGl0ZXJhdGlvbnMsIGRpcmVjdGlvbiwgZmlsbCwgZWFzaW5nLCBkdXJhdGlvbiwgZGVsYXksIGNvbXBvc2l0ZSB9O1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gcGFyYW1zW25hbWVdO1xuICAgICAgICBjb25zdCBpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHkgPSBoYXNJbmRpdmlkdWFsVHJhbnNmb3JtcyA/IHZhbGlkVHJhbnNmb3Jtcy5pbmNsdWRlcyhuYW1lKSA/IG5hbWUgOiBzaG9ydFRyYW5zZm9ybXMuZ2V0KG5hbWUpIDogZmFsc2U7XG4gICAgICAgIGxldCBwYXJzZWRQcm9wZXJ0eVZhbHVlO1xuICAgICAgICBpZiAoaXNPYmoocHJvcGVydHlWYWx1ZSkpIHtcbiAgICAgICAgICBjb25zdCB0d2Vlbk9wdGlvbnMgPSAvKiogQHR5cGUge1dBQVBJVHdlZW5PcHRpb25zfSAqLyhwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICBjb25zdCB0d2Vlbk9wdGlvbnNFYXNlID0gc2V0VmFsdWUodHdlZW5PcHRpb25zLmVhc2UsIGVhc2UpO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuT3B0aW9uc1NwcmluZyA9IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyh0d2Vlbk9wdGlvbnNFYXNlKS5lYXNlICYmIHR3ZWVuT3B0aW9uc0Vhc2U7XG4gICAgICAgICAgY29uc3QgdG8gPSAvKiogQHR5cGUge1dBQVBJVHdlZW5PcHRpb25zfSAqLyh0d2Vlbk9wdGlvbnMpLnRvO1xuICAgICAgICAgIGNvbnN0IGZyb20gPSAvKiogQHR5cGUge1dBQVBJVHdlZW5PcHRpb25zfSAqLyh0d2Vlbk9wdGlvbnMpLmZyb207XG4gICAgICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgICAgICAgdHdlZW5QYXJhbXMuZHVyYXRpb24gPSAodHdlZW5PcHRpb25zU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKHR3ZWVuT3B0aW9uc1NwcmluZykuZHVyYXRpb24gOiBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKHR3ZWVuT3B0aW9ucy5kdXJhdGlvbiwgZHVyYXRpb24pLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpKSAqIHRpbWVTY2FsZTtcbiAgICAgICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICAgICB0d2VlblBhcmFtcy5kZWxheSA9IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUodHdlZW5PcHRpb25zLmRlbGF5LCBkZWxheSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkgKiB0aW1lU2NhbGU7XG4gICAgICAgICAgLyoqIEB0eXBlIHtDb21wb3NpdGVPcGVyYXRpb259ICovXG4gICAgICAgICAgdHdlZW5QYXJhbXMuY29tcG9zaXRlID0gLyoqIEB0eXBlIHtDb21wb3NpdGVPcGVyYXRpb259ICovKHNldFZhbHVlKHR3ZWVuT3B0aW9ucy5jb21wb3NpdGlvbiwgY29tcG9zaXRlKSk7XG4gICAgICAgICAgLyoqIEB0eXBlIHtTdHJpbmd9ICovXG4gICAgICAgICAgdHdlZW5QYXJhbXMuZWFzaW5nID0gcGFyc2VXQUFQSUVhc2luZyh0d2Vlbk9wdGlvbnNFYXNlKTtcbiAgICAgICAgICBwYXJzZWRQcm9wZXJ0eVZhbHVlID0gcGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSgkZWwsIG5hbWUsIGZyb20sIHRvLCBpLCB0YXJnZXRzTGVuZ3RoKTtcbiAgICAgICAgICBpZiAoaW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5KSB7XG4gICAgICAgICAgICBrZXlmcmFtZXNbYC0tJHtpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHl9YF0gPSBwYXJzZWRQcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgY2FjaGVkVHJhbnNmb3Jtc1tpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHldID0gcGFyc2VkUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ZnJhbWVzW25hbWVdID0gcGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSgkZWwsIG5hbWUsIGZyb20sIHRvLCBpLCB0YXJnZXRzTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkV0FBUElBbmltYXRpb24odGhpcywgJGVsLCBuYW1lLCBrZXlmcmFtZXMsIHR3ZWVuUGFyYW1zKTtcbiAgICAgICAgICBpZiAoIWlzVW5kKGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWluZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAkZWwuc3R5bGVbbmFtZV0gPSBrZXlmcmFtZXNbbmFtZV1bMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgLS0ke2luZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eX1gO1xuICAgICAgICAgICAgICAkZWwuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCBrZXlmcmFtZXNba2V5XVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlZFByb3BlcnR5VmFsdWUgPSBpc0Fycihwcm9wZXJ0eVZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5VmFsdWUubWFwKCgvKiogQHR5cGUge2FueX0gKi92KSA9PiBub3JtYWxpemVUd2VlblZhbHVlKG5hbWUsIHYsICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplVHdlZW5WYWx1ZShuYW1lLCAvKiogQHR5cGUge2FueX0gKi8ocHJvcGVydHlWYWx1ZSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gICAgICAgICAgaWYgKGluZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eSkge1xuICAgICAgICAgICAga2V5ZnJhbWVzW2AtLSR7aW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5fWBdID0gcGFyc2VkUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgIGNhY2hlZFRyYW5zZm9ybXNbaW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5XSA9IHBhcnNlZFByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleWZyYW1lc1tuYW1lXSA9IHBhcnNlZFByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZFdBQVBJQW5pbWF0aW9uKHRoaXMsICRlbCwgbmFtZSwga2V5ZnJhbWVzLCB0d2VlblBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNJbmRpdmlkdWFsVHJhbnNmb3Jtcykge1xuICAgICAgICBsZXQgdHJhbnNmb3JtcyA9IGVtcHR5U3RyaW5nO1xuICAgICAgICBmb3IgKGxldCB0IGluIGNhY2hlZFRyYW5zZm9ybXMpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zICs9IGAke3RyYW5zZm9ybXNGcmFnbWVudFN0cmluZ3NbdF19dmFyKC0tJHt0fSkpIGA7XG4gICAgICAgIH1cbiAgICAgICAgJGVsLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybXM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqLyh0aGlzLmF1dG9wbGF5KS5saW5rKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgZm9yRWFjaENhbGxiYWNrXG4gICAqIEBwYXJhbSB7Z2xvYmFsVGhpcy5BbmltYXRpb259IGFuaW1hdGlvblxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtICB7Zm9yRWFjaENhbGxiYWNrfFN0cmluZ30gY2FsbGJhY2tcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBjb25zdCBjYiA9IGlzU3RyKGNhbGxiYWNrKSA/ICgvKiogQHR5cGUge2dsb2JhbFRoaXMuQW5pbWF0aW9ufSAqL2EpID0+IGFbY2FsbGJhY2tdKCkgOiBjYWxsYmFjaztcbiAgICB0aGlzLmFuaW1hdGlvbnMuZm9yRWFjaChjYik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwZWVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZCAqL1xuICBzZXQgc3BlZWQoc3BlZWQpIHtcbiAgICB0aGlzLl9zcGVlZCA9ICtzcGVlZDtcbiAgICB0aGlzLmZvckVhY2goYW5pbSA9PiBhbmltLnBsYXliYWNrUmF0ZSA9IHNwZWVkKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICBjb25zdCBjb250cm9sQW5pbWF0aW9uID0gdGhpcy5jb250cm9sQW5pbWF0aW9uO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IGdsb2JhbHMudGltZVNjYWxlO1xuICAgIHJldHVybiB0aGlzLmNvbXBsZXRlZCA/IHRoaXMuZHVyYXRpb24gOiBjb250cm9sQW5pbWF0aW9uID8gK2NvbnRyb2xBbmltYXRpb24uY3VycmVudFRpbWUgKiAodGltZVNjYWxlID09PSAxID8gMSA6IHRpbWVTY2FsZSkgOiAwO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICovXG4gIHNldCBjdXJyZW50VGltZSh0aW1lKSB7XG4gICAgY29uc3QgdCA9IHRpbWUgKiAoZ2xvYmFscy50aW1lU2NhbGUgPT09IDEgPyAxIDogSyk7XG4gICAgdGhpcy5mb3JFYWNoKGFuaW0gPT4ge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb24gcGxheVN0YXRlIGlzIG5vdCAncGF1c2VkJyBpbiBvcmRlciB0byBwcm9wZXJseSB0cmlnZ2VyIGFuIG9uZmluaXNoIGNhbGxiYWNrLlxuICAgICAgLy8gVGhlIFwicGF1c2VkXCIgcGxheSBzdGF0ZSBzdXBlcnNlZGVzIHRoZSBcImZpbmlzaGVkXCIgcGxheSBzdGF0ZTsgaWYgdGhlIGFuaW1hdGlvbiBpcyBib3RoIHBhdXNlZCBhbmQgZmluaXNoZWQsIHRoZSBcInBhdXNlZFwiIHN0YXRlIGlzIHRoZSBvbmUgdGhhdCB3aWxsIGJlIHJlcG9ydGVkLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbi9maW5pc2hfZXZlbnRcbiAgICAgIGlmICh0ID49IHRoaXMuZHVyYXRpb24pIGFuaW0ucGxheSgpO1xuICAgICAgYW5pbS5jdXJyZW50VGltZSA9IHQ7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUgLyB0aGlzLmR1cmF0aW9uO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAqL1xuICBzZXQgcHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmZvckVhY2goYW5pbSA9PiBhbmltLmN1cnJlbnRUaW1lID0gcHJvZ3Jlc3MgKiB0aGlzLmR1cmF0aW9uIHx8IDApO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgLy8gVE9ETzogU3RvcmUgdGhlIGN1cnJlbnQgdGltZSwgYW5kIHNlZWsgYmFjayB0byB0aGUgbGFzdCBwb3NpdGlvblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ3BsYXknKTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLnBhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ3BhdXNlJyk7XG4gIH1cblxuICBhbHRlcm5hdGUoKSB7XG4gICAgdGhpcy5yZXZlcnNlZCA9ICF0aGlzLnJldmVyc2VkO1xuICAgIHRoaXMuZm9yRWFjaCgncmV2ZXJzZScpO1xuICAgIGlmICh0aGlzLnBhdXNlZCkgdGhpcy5mb3JFYWNoKCdwYXVzZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5yZXZlcnNlZCkgdGhpcy5hbHRlcm5hdGUoKTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldmVyc2UoKSB7XG4gICAgaWYgKCF0aGlzLnJldmVyc2VkKSB0aGlzLmFsdGVybmF0ZSgpO1xuICAgIHJldHVybiB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAvKipcbiAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gbXV0ZUNhbGxiYWNrc1xuICAqL1xuICBzZWVrKHRpbWUsIG11dGVDYWxsYmFja3MgPSBmYWxzZSkge1xuICAgIGlmIChtdXRlQ2FsbGJhY2tzKSB0aGlzLm11dGVDYWxsYmFja3MgPSB0cnVlO1xuICAgIGlmICh0aW1lIDwgdGhpcy5kdXJhdGlvbikgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZTtcbiAgICB0aGlzLm11dGVDYWxsYmFja3MgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXVzZWQpIHRoaXMucGF1c2UoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlc3RhcnQoKSB7XG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zZWVrKDAsIHRydWUpLnJlc3VtZSgpO1xuICB9XG5cbiAgY29tbWl0U3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ2NvbW1pdFN0eWxlcycpO1xuICB9XG5cbiAgY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vlayh0aGlzLmR1cmF0aW9uKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmZvckVhY2goJ2NhbmNlbCcpO1xuICAgIHJldHVybiB0aGlzLnBhdXNlKCk7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcbiAgICB0aGlzLnRhcmdldHMuZm9yRWFjaCgoJGVsLCBpKSA9PiAkZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuX2lubGluZVN0eWxlc1tpXSkgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtXQUFQSUNhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB0aGVuKGNhbGxiYWNrID0gbm9vcCkge1xuICAgIGNvbnN0IHRoZW4gPSB0aGlzLnRoZW47XG4gICAgY29uc3Qgb25SZXNvbHZlID0gKCkgPT4ge1xuICAgICAgdGhpcy50aGVuID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgdGhpcy50aGVuID0gdGhlbjtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBub29wO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHIgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9ICgpID0+IHIob25SZXNvbHZlKCkpO1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVkKSB0aGlzLl9yZXNvbHZlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCB3YWFwaSA9IHtcbi8qKlxuICogQHBhcmFtIHtET01UYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEBwYXJhbSB7V0FBUElBbmltYXRpb25QYXJhbXN9IHBhcmFtc1xuICogQHJldHVybiB7V0FBUElBbmltYXRpb259XG4gKi9cbiAgYW5pbWF0ZTogKHRhcmdldHMsIHBhcmFtcykgPT4gbmV3IFdBQVBJQW5pbWF0aW9uKHRhcmdldHMsIHBhcmFtcyksXG4gIGNvbnZlcnRFYXNlOiBlYXNpbmdUb0xpbmVhclxufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtDYWxsYmFjazxUaW1lcj59IFtjYWxsYmFja11cbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCBzeW5jID0gKGNhbGxiYWNrID0gbm9vcCkgPT4ge1xuICByZXR1cm4gbmV3IFRpbWVyKHsgZHVyYXRpb246IDEgKiBnbG9iYWxzLnRpbWVTY2FsZSwgb25Db21wbGV0ZTogY2FsbGJhY2sgfSwgbnVsbCwgMCkucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0U2VsZWN0b3J9IHRhcmdldFNlbGVjdG9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgcHJvcE5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0pTVGFyZ2V0c1BhcmFtfSB0YXJnZXRTZWxlY3RvclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgIHByb3BOYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfSB0YXJnZXRTZWxlY3RvclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICBwcm9wTmFtZVxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICB1bml0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldFNlbGVjdG9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIHByb3BOYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgIHVuaXRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19ICAgdGFyZ2V0U2VsZWN0b3JcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICBwcm9wTmFtZVxuICogQHBhcmFtICB7U3RyaW5nfEJvb2xlYW59IFt1bml0XVxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRWYWx1ZSh0YXJnZXRTZWxlY3RvciwgcHJvcE5hbWUsIHVuaXQpIHtcbiAgY29uc3QgdGFyZ2V0cyA9IHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRTZWxlY3Rvcik7XG4gIGlmICghdGFyZ2V0cy5sZW5ndGgpIHJldHVybjtcbiAgY29uc3QgWyB0YXJnZXQgXSA9IHRhcmdldHM7XG4gIGNvbnN0IHR3ZWVuVHlwZSA9IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgY29uc3Qgbm9ybWFsaXplUHJvcE5hbWUgPSBzYW5pdGl6ZVByb3BlcnR5TmFtZShwcm9wTmFtZSwgdGFyZ2V0LCB0d2VlblR5cGUpO1xuICBsZXQgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgbm9ybWFsaXplUHJvcE5hbWUpO1xuICBpZiAoaXNVbmQodW5pdCkpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBkZWNvbXBvc2VSYXdWYWx1ZShvcmlnaW5hbFZhbHVlLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSk7XG4gICAgaWYgKGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuTlVNQkVSIHx8IGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVCkge1xuICAgICAgaWYgKHVuaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0VmFsdWVVbml0KC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSwgLyoqIEB0eXBlIHtTdHJpbmd9ICovKHVuaXQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBgJHtyb3VuZChjb252ZXJ0ZWRWYWx1ZS5uLCBnbG9iYWxzLnByZWNpc2lvbil9JHtjb252ZXJ0ZWRWYWx1ZS51fWA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSAgICB0YXJnZXRzXG4gKiBAcGFyYW0gIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0pTQW5pbWF0aW9ufVxuICovXG5jb25zdCBzZXRUYXJnZXRWYWx1ZXMgPSAodGFyZ2V0cywgcGFyYW1ldGVycykgPT4ge1xuICBpZiAoaXNVbmQocGFyYW1ldGVycykpIHJldHVybjtcbiAgcGFyYW1ldGVycy5kdXJhdGlvbiA9IG1pblZhbHVlO1xuICAvLyBEbyBub3Qgb3ZlcnJpZGVzIGN1cnJlbnRseSBhY3RpdmUgdHdlZW5zIGJ5IGRlZmF1bHRcbiAgcGFyYW1ldGVycy5jb21wb3NpdGlvbiA9IHNldFZhbHVlKHBhcmFtZXRlcnMuY29tcG9zaXRpb24sIGNvbXBvc2l0aW9uVHlwZXMubm9uZSk7XG4gIC8vIFNraXAgaW5pdCgpIGFuZCBmb3JjZSByZW5kZXJpbmcgYnkgcGxheWluZyB0aGUgYW5pbWF0aW9uXG4gIHJldHVybiBuZXcgSlNBbmltYXRpb24odGFyZ2V0cywgcGFyYW1ldGVycywgbnVsbCwgMCwgdHJ1ZSkucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNBcnJheX0gdGFyZ2V0c0FycmF5XG4gKiBAcGFyYW0gIHtKU0FuaW1hdGlvbn0gICAgYW5pbWF0aW9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIFtwcm9wZXJ0eU5hbWVdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbiA9ICh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbiwgcHJvcGVydHlOYW1lKSA9PiB7XG4gIGxldCB0d2VlbnNNYXRjaGVzVGFyZ2V0cyA9IGZhbHNlO1xuICBmb3JFYWNoQ2hpbGRyZW4oYW5pbWF0aW9uLCAoLyoqQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgY29uc3QgdHdlZW5UYXJnZXQgPSB0d2Vlbi50YXJnZXQ7XG4gICAgaWYgKHRhcmdldHNBcnJheS5pbmNsdWRlcyh0d2VlblRhcmdldCkpIHtcbiAgICAgIGNvbnN0IHR3ZWVuTmFtZSA9IHR3ZWVuLnByb3BlcnR5O1xuICAgICAgY29uc3QgdHdlZW5UeXBlID0gdHdlZW4uX3R3ZWVuVHlwZTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZVByb3BOYW1lID0gc2FuaXRpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lLCB0d2VlblRhcmdldCwgdHdlZW5UeXBlKTtcbiAgICAgIGlmICghbm9ybWFsaXplUHJvcE5hbWUgfHwgbm9ybWFsaXplUHJvcE5hbWUgJiYgbm9ybWFsaXplUHJvcE5hbWUgPT09IHR3ZWVuTmFtZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gZmxhZyB0aGUgcHJldmlvdXMgQ1NTIHRyYW5zZm9ybSB0d2VlbiB0byByZW5kZXJUcmFuc2Zvcm1cbiAgICAgICAgaWYgKHR3ZWVuLnBhcmVudC5fdGFpbCA9PT0gdHdlZW4gJiZcbiAgICAgICAgICAgIHR3ZWVuLl90d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuVFJBTlNGT1JNICYmXG4gICAgICAgICAgICB0d2Vlbi5fcHJldiAmJlxuICAgICAgICAgICAgdHdlZW4uX3ByZXYuX3R3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk1cbiAgICAgICAgKSB7XG4gICAgICAgICAgdHdlZW4uX3ByZXYuX3JlbmRlclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIHR3ZWVuIGZyb20gdGhlIHNlbGVjdGVkIGFuaW1hdGlvblxuICAgICAgICByZW1vdmVDaGlsZChhbmltYXRpb24sIHR3ZWVuKTtcbiAgICAgICAgLy8gRGV0YWNoIHRoZSB0d2VlbiBmcm9tIGl0cyBzaWJsaW5ncyB0byBtYWtlIHN1cmUgYmxlbmRlZCB0d2VlbnMgYXJlIGNvcnJlY3RsbHkgcmVtb3ZlZFxuICAgICAgICByZW1vdmVUd2VlblNsaWJsaW5ncyh0d2Vlbik7XG4gICAgICAgIHR3ZWVuc01hdGNoZXNUYXJnZXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUpO1xuICByZXR1cm4gdHdlZW5zTWF0Y2hlc1RhcmdldHM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtICB7UmVuZGVyYWJsZXxXQUFQSUFuaW1hdGlvbn0gW3JlbmRlcmFibGVdXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICBbcHJvcGVydHlOYW1lXVxuICogQHJldHVybiB7VGFyZ2V0c0FycmF5fVxuICovXG5jb25zdCByZW1vdmUgPSAodGFyZ2V0cywgcmVuZGVyYWJsZSwgcHJvcGVydHlOYW1lKSA9PiB7XG4gIGNvbnN0IHRhcmdldHNBcnJheSA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtSZW5kZXJhYmxlfHR5cGVvZiBlbmdpbmV9ICoqLyhyZW5kZXJhYmxlID8gcmVuZGVyYWJsZSA6IGVuZ2luZSk7XG4gIGNvbnN0IHdhYXBpQW5pbWF0aW9uID0gcmVuZGVyYWJsZSAmJiAvKiogQHR5cGUge1dBQVBJQW5pbWF0aW9ufSAqLyhyZW5kZXJhYmxlKS5jb250cm9sQW5pbWF0aW9uICYmIC8qKiBAdHlwZSB7V0FBUElBbmltYXRpb259ICovKHJlbmRlcmFibGUpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHRhcmdldHNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCAkZWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gICovKHRhcmdldHNBcnJheVtpXSk7XG4gICAgcmVtb3ZlV0FBUElBbmltYXRpb24oJGVsLCBwcm9wZXJ0eU5hbWUsIHdhYXBpQW5pbWF0aW9uKTtcbiAgfVxuICBsZXQgcmVtb3ZlTWF0Y2hlcztcbiAgaWYgKHBhcmVudC5faGFzQ2hpbGRyZW4pIHtcbiAgICBsZXQgaXRlcmF0aW9uRHVyYXRpb24gPSAwO1xuICAgIGZvckVhY2hDaGlsZHJlbihwYXJlbnQsICgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQuX2hhc0NoaWxkcmVuKSB7XG4gICAgICAgIHJlbW92ZU1hdGNoZXMgPSByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbih0YXJnZXRzQXJyYXksIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKGNoaWxkKSwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBmcm9tIGl0cyBwYXJlbnQgaWYgbm8gdHdlZW5zIGFuZCBubyBjaGlsZHJlbiBsZWZ0IGFmdGVyIHRoZSByZW1vdmFsXG4gICAgICAgIGlmIChyZW1vdmVNYXRjaGVzICYmICFjaGlsZC5faGVhZCkge1xuICAgICAgICAgIGNoaWxkLmNhbmNlbCgpO1xuICAgICAgICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IGl0ZXJhdGlvbkR1cmF0aW9uIHZhbHVlIHRvIGhhbmRsZSBvbkNvbXBsZXRlIHdpdGggbGFzdCBjaGlsZCBpbiByZW5kZXIoKVxuICAgICAgICAgIGNvbnN0IGNoaWxkVExPZmZzZXQgPSBjaGlsZC5fb2Zmc2V0ICsgY2hpbGQuX2RlbGF5O1xuICAgICAgICAgIGNvbnN0IGNoaWxkRHVyID0gY2hpbGRUTE9mZnNldCArIGNoaWxkLmR1cmF0aW9uO1xuICAgICAgICAgIGlmIChjaGlsZER1ciA+IGl0ZXJhdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpdGVyYXRpb25EdXJhdGlvbiA9IGNoaWxkRHVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIHRvIGFsc28gcmVtb3ZlIGVuZ2luZSdzIGNoaWxkcmVuIHRhcmdldHNcbiAgICAgIC8vIE5PVEU6IEF2b2lkIHJlY3Vyc2lvbj9cbiAgICAgIGlmIChjaGlsZC5faGVhZCkge1xuICAgICAgICByZW1vdmUodGFyZ2V0cywgY2hpbGQsIHByb3BlcnR5TmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcbiAgICAvLyBVcGRhdGUgaXRlcmF0aW9uRHVyYXRpb24gdmFsdWUgdG8gaGFuZGxlIG9uQ29tcGxldGUgd2l0aCBsYXN0IGNoaWxkIGluIHJlbmRlcigpXG4gICAgaWYgKCFpc1VuZCgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovKHBhcmVudCkuaXRlcmF0aW9uRHVyYXRpb24pKSB7XG4gICAgICAvKiogQHR5cGUge1JlbmRlcmFibGV9ICovKHBhcmVudCkuaXRlcmF0aW9uRHVyYXRpb24gPSBpdGVyYXRpb25EdXJhdGlvbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlTWF0Y2hlcyA9IHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9uKFxuICAgICAgdGFyZ2V0c0FycmF5LFxuICAgICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8ocGFyZW50KSxcbiAgICAgIHByb3BlcnR5TmFtZVxuICAgICk7XG4gIH1cblxuICBpZiAocmVtb3ZlTWF0Y2hlcyAmJiAhcGFyZW50Ll9oZWFkKSB7XG4gICAgcGFyZW50Ll9oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICAgIC8vIENhbmNlbCB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyB0d2VlbnMgYW5kIG5vIGNoaWxkcmVuIGxlZnQgYWZ0ZXIgdGhlIHJlbW92YWxcbiAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIHRoZSAuY2FuY2VsKCkgbWV0aG9kIGV4aXN0IHRvIGhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIHRoZSBlbmdpbmUgaXRzZWxmXG4gICAgaWYgKC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi8ocGFyZW50KS5jYW5jZWwpIC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi8ocGFyZW50KS5jYW5jZWwoKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRzQXJyYXk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAgeyguLi5hcmdzOiBhbnlbXSkgPT4gVGlja2FibGV9IGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHsoLi4uYXJnczogYW55W10pID0+IFRpY2thYmxlfVxuICovXG5jb25zdCBrZWVwVGltZSA9IGNyZWF0ZVJlZnJlc2hhYmxlO1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gaXRlbXNcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgcmFuZG9tUGljayA9IGl0ZW1zID0+IGl0ZW1zW3JhbmRvbSgwLCBpdGVtcy5sZW5ndGggLSAxKV07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gdlxuICogQHBhcmFtICB7TnVtYmVyfSBkZWNpbWFsTGVuZ3RoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHJvdW5kUGFkID0gKHYsIGRlY2ltYWxMZW5ndGgpID0+ICgrdikudG9GaXhlZChkZWNpbWFsTGVuZ3RoKTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcn0gdG90YWxMZW5ndGhcbiAqIEBwYXJhbSAge1N0cmluZ30gcGFkU3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhZFN0YXJ0ID0gKHYsIHRvdGFsTGVuZ3RoLCBwYWRTdHJpbmcpID0+IGAke3Z9YC5wYWRTdGFydCh0b3RhbExlbmd0aCwgcGFkU3RyaW5nKTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcn0gdG90YWxMZW5ndGhcbiAqIEBwYXJhbSAge1N0cmluZ30gcGFkU3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhZEVuZCA9ICh2LCB0b3RhbExlbmd0aCwgcGFkU3RyaW5nKSA9PiBgJHt2fWAucGFkRW5kKHRvdGFsTGVuZ3RoLCBwYWRTdHJpbmcpO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdlxuICogQHBhcmFtICB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IHdyYXAgPSAodiwgbWluLCBtYXgpID0+ICgoKHYgLSBtaW4pICUgKG1heCAtIG1pbikgKyAobWF4IC0gbWluKSkgJSAobWF4IC0gbWluKSkgKyBtaW47XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtICB7TnVtYmVyfSBpbkxvd1xuICogQHBhcmFtICB7TnVtYmVyfSBpbkhpZ2hcbiAqIEBwYXJhbSAge051bWJlcn0gb3V0TG93XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG91dEhpZ2hcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgbWFwUmFuZ2UgPSAodmFsdWUsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkgPT4gb3V0TG93ICsgKCh2YWx1ZSAtIGluTG93KSAvIChpbkhpZ2ggLSBpbkxvdykpICogKG91dEhpZ2ggLSBvdXRMb3cpO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gZGVncmVlc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBkZWdUb1JhZCA9IGRlZ3JlZXMgPT4gZGVncmVlcyAqIFBJIC8gMTgwO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gcmFkaWFuc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCByYWRUb0RlZyA9IHJhZGlhbnMgPT4gcmFkaWFucyAqIDE4MCAvIFBJO1xuXG4vKipcbiAqIGh0dHBzOi8vd3d3LnJvcnlkcmlzY29sbC5jb20vMjAxNi8wMy8wNy9mcmFtZS1yYXRlLWluZGVwZW5kZW50LWRhbXBpbmctdXNpbmctbGVycC9cbiAqIEBwYXJhbSAge051bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSAge051bWJlcn0gZW5kXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFtb3VudFxuICogQHBhcmFtICB7UmVuZGVyYWJsZXxCb29sZWFufSBbcmVuZGVyYWJsZV1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgbGVycCA9IChzdGFydCwgZW5kLCBhbW91bnQsIHJlbmRlcmFibGUpID0+IHtcbiAgbGV0IGR0ID0gSyAvIGdsb2JhbHMuZGVmYXVsdHMuZnJhbWVSYXRlO1xuICBpZiAocmVuZGVyYWJsZSAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCB0aWNrZXIgPSAvKiogQHR5cGUgUmVuZGVyYWJsZSAqL1xuICAgICAgICAgICAgICAgICAgIChyZW5kZXJhYmxlKSB8fFxuICAgICAgICAgICAgICAgICAgIChlbmdpbmUuX2hhc0NoaWxkcmVuICYmIGVuZ2luZSk7XG4gICAgaWYgKHRpY2tlciAmJiB0aWNrZXIuZGVsdGFUaW1lKSB7XG4gICAgICBkdCA9IHRpY2tlci5kZWx0YVRpbWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IHQgPSAxIC0gTWF0aC5leHAoLWFtb3VudCAqIGR0ICogLjEpO1xuICByZXR1cm4gIWFtb3VudCA/IHN0YXJ0IDogYW1vdW50ID09PSAxID8gZW5kIDogKDEgLSB0KSAqIHN0YXJ0ICsgdCAqIGVuZDtcbn07XG5cbi8vIENoYWluLWFibGUgdXRpbGl0aWVzXG5cbi8qKlxuICogQGNhbGxiYWNrIFV0aWxpdHlGdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICpcbiAqIEBwYXJhbSB7VXRpbGl0eUZ1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IFtsYXN0PTBdXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi4oTnVtYmVyfFN0cmluZykpOiBmdW5jdGlvbihOdW1iZXJ8U3RyaW5nKTogKE51bWJlcnxTdHJpbmcpfVxuICovXG5jb25zdCBjdXJyeSA9IChmbiwgbGFzdCA9IDApID0+ICguLi5hcmdzKSA9PiBsYXN0ID8gdiA9PiBmbiguLi5hcmdzLCB2KSA6IHYgPT4gZm4odiwgLi4uYXJncyk7XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLihOdW1iZXJ8U3RyaW5nKSl9XG4gKi9cbmNvbnN0IGNoYWluID0gZm4gPT4ge1xuICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgcmV0dXJuIG5ldyBQcm94eShub29wLCB7XG4gICAgICBhcHBseTogKF8sIF9fLCBbdl0pID0+IHJlc3VsdCh2KSxcbiAgICAgIGdldDogKF8sIHByb3ApID0+IGNoYWluKC8qKkBwYXJhbSB7Li4uTnVtYmVyfFN0cmluZ30gbmV4dEFyZ3MgKi8oLi4ubmV4dEFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dFJlc3VsdCA9IHV0aWxzW3Byb3BdKC4uLm5leHRBcmdzKTtcbiAgICAgICAgcmV0dXJuICgvKipAdHlwZSB7TnVtYmVyfFN0cmluZ30gKi92KSA9PiBuZXh0UmVzdWx0KHJlc3VsdCh2KSk7XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VXRpbGl0eUZ1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IFtyaWdodF1cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLihOdW1iZXJ8U3RyaW5nKSk6IFV0aWxpdHlGdW5jdGlvbn1cbiAqL1xuY29uc3QgbWFrZUNoYWluYWJsZSA9IChmbiwgcmlnaHQgPSAwKSA9PiAoLi4uYXJncykgPT4gKGFyZ3MubGVuZ3RoIDwgZm4ubGVuZ3RoID8gY2hhaW4oY3VycnkoZm4sIHJpZ2h0KSkgOiBmbikoLi4uYXJncyk7XG5cbi8qKlxuICogQGNhbGxiYWNrIENoYWluZWRVdGlsc1Jlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhaW5hYmxlVXRpbHNcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZENsYW1wfSBjbGFtcFxuICogQHByb3BlcnR5IHtDaGFpbmVkUm91bmR9IHJvdW5kXG4gKiBAcHJvcGVydHkge0NoYWluZWRTbmFwfSBzbmFwXG4gKiBAcHJvcGVydHkge0NoYWluZWRXcmFwfSB3cmFwXG4gKiBAcHJvcGVydHkge0NoYWluZWRJbnRlcnBvbGF0ZX0gaW50ZXJwb2xhdGVcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZE1hcFJhbmdlfSBtYXBSYW5nZVxuICogQHByb3BlcnR5IHtDaGFpbmVkUm91bmRQYWR9IHJvdW5kUGFkXG4gKiBAcHJvcGVydHkge0NoYWluZWRQYWRTdGFydH0gcGFkU3RhcnRcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZFBhZEVuZH0gcGFkRW5kXG4gKiBAcHJvcGVydHkge0NoYWluZWREZWdUb1JhZH0gZGVnVG9SYWRcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZFJhZFRvRGVnfSByYWRUb0RlZ1xuICpcbiAqIEB0eXBlZGVmIHtDaGFpbmFibGVVdGlscyAmIENoYWluZWRVdGlsc1Jlc3VsdH0gQ2hhaW5hYmxlVXRpbFxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkQ2xhbXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRSb3VuZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlY2ltYWxMZW5ndGhcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRTbmFwXG4gKiBAcGFyYW0ge051bWJlcn0gaW5jcmVtZW50XG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkV3JhcFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pblxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZEludGVycG9sYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRNYXBSYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IGluTG93XG4gKiBAcGFyYW0ge051bWJlcn0gaW5IaWdoXG4gKiBAcGFyYW0ge051bWJlcn0gb3V0TG93XG4gKiBAcGFyYW0ge051bWJlcn0gb3V0SGlnaFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZFJvdW5kUGFkXG4gKiBAcGFyYW0ge051bWJlcn0gZGVjaW1hbExlbmd0aFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZFBhZFN0YXJ0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWRTdHJpbmdcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRQYWRFbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHBhZFN0cmluZ1xuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZERlZ1RvUmFkXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkUmFkVG9EZWdcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKi9cblxuY29uc3QgdXRpbHMgPSB7XG4gICQ6IHJlZ2lzdGVyVGFyZ2V0cyxcbiAgZ2V0OiBnZXRUYXJnZXRWYWx1ZSxcbiAgc2V0OiBzZXRUYXJnZXRWYWx1ZXMsXG4gIHJlbW92ZSxcbiAgY2xlYW5JbmxpbmVTdHlsZXMsXG4gIHJhbmRvbSxcbiAgcmFuZG9tUGljayxcbiAgc2h1ZmZsZSxcbiAgbGVycCxcbiAgc3luYyxcbiAga2VlcFRpbWUsXG4gIGNsYW1wOiAvKiogQHR5cGUge3R5cGVvZiBjbGFtcCAmIENoYWluZWRDbGFtcH0gKi8obWFrZUNoYWluYWJsZShjbGFtcCkpLFxuICByb3VuZDogLyoqIEB0eXBlIHt0eXBlb2Ygcm91bmQgJiBDaGFpbmVkUm91bmR9ICovKG1ha2VDaGFpbmFibGUocm91bmQpKSxcbiAgc25hcDogLyoqIEB0eXBlIHt0eXBlb2Ygc25hcCAmIENoYWluZWRTbmFwfSAqLyhtYWtlQ2hhaW5hYmxlKHNuYXApKSxcbiAgd3JhcDogLyoqIEB0eXBlIHt0eXBlb2Ygd3JhcCAmIENoYWluZWRXcmFwfSAqLyhtYWtlQ2hhaW5hYmxlKHdyYXApKSxcbiAgaW50ZXJwb2xhdGU6IC8qKiBAdHlwZSB7dHlwZW9mIGludGVycG9sYXRlICYgQ2hhaW5lZEludGVycG9sYXRlfSAqLyhtYWtlQ2hhaW5hYmxlKGludGVycG9sYXRlLCAxKSksXG4gIG1hcFJhbmdlOiAvKiogQHR5cGUge3R5cGVvZiBtYXBSYW5nZSAmIENoYWluZWRNYXBSYW5nZX0gKi8obWFrZUNoYWluYWJsZShtYXBSYW5nZSkpLFxuICByb3VuZFBhZDogLyoqIEB0eXBlIHt0eXBlb2Ygcm91bmRQYWQgJiBDaGFpbmVkUm91bmRQYWR9ICovKG1ha2VDaGFpbmFibGUocm91bmRQYWQpKSxcbiAgcGFkU3RhcnQ6IC8qKiBAdHlwZSB7dHlwZW9mIHBhZFN0YXJ0ICYgQ2hhaW5lZFBhZFN0YXJ0fSAqLyhtYWtlQ2hhaW5hYmxlKHBhZFN0YXJ0KSksXG4gIHBhZEVuZDogLyoqIEB0eXBlIHt0eXBlb2YgcGFkRW5kICYgQ2hhaW5lZFBhZEVuZH0gKi8obWFrZUNoYWluYWJsZShwYWRFbmQpKSxcbiAgZGVnVG9SYWQ6IC8qKiBAdHlwZSB7dHlwZW9mIGRlZ1RvUmFkICYgQ2hhaW5lZERlZ1RvUmFkfSAqLyhtYWtlQ2hhaW5hYmxlKGRlZ1RvUmFkKSksXG4gIHJhZFRvRGVnOiAvKiogQHR5cGUge3R5cGVvZiByYWRUb0RlZyAmIENoYWluZWRSYWRUb0RlZ30gKi8obWFrZUNoYWluYWJsZShyYWRUb0RlZykpLFxufTtcblxuXG5cblxuLyoqXG4gKiBUaW1lbGluZSdzIGNoaWxkcmVuIG9mZnNldHMgcG9zaXRpb25zIHBhcnNlclxuICogQHBhcmFtICB7VGltZWxpbmV9IHRpbWVsaW5lXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHRpbWVQb3NpdGlvblxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBnZXRQcmV2Q2hpbGRPZmZzZXQgPSAodGltZWxpbmUsIHRpbWVQb3NpdGlvbikgPT4ge1xuICBpZiAoc3RyaW5nU3RhcnRzV2l0aCh0aW1lUG9zaXRpb24sICc8JykpIHtcbiAgICBjb25zdCBnb1RvUHJldkFuaW1hdGlvbk9mZnNldCA9IHRpbWVQb3NpdGlvblsxXSA9PT0gJzwnO1xuICAgIGNvbnN0IHByZXZBbmltYXRpb24gPSAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0aW1lbGluZS5fdGFpbCk7XG4gICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZBbmltYXRpb24gPyBwcmV2QW5pbWF0aW9uLl9vZmZzZXQgKyBwcmV2QW5pbWF0aW9uLl9kZWxheSA6IDA7XG4gICAgcmV0dXJuIGdvVG9QcmV2QW5pbWF0aW9uT2Zmc2V0ID8gcHJldk9mZnNldCA6IHByZXZPZmZzZXQgKyBwcmV2QW5pbWF0aW9uLmR1cmF0aW9uO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RpbWVsaW5lfSB0aW1lbGluZVxuICogQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gW3RpbWVQb3NpdGlvbl1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcGFyc2VUaW1lbGluZVBvc2l0aW9uID0gKHRpbWVsaW5lLCB0aW1lUG9zaXRpb24pID0+IHtcbiAgbGV0IHRsRHVyYXRpb24gPSB0aW1lbGluZS5pdGVyYXRpb25EdXJhdGlvbjtcbiAgaWYgKHRsRHVyYXRpb24gPT09IG1pblZhbHVlKSB0bER1cmF0aW9uID0gMDtcbiAgaWYgKGlzVW5kKHRpbWVQb3NpdGlvbikpIHJldHVybiB0bER1cmF0aW9uO1xuICBpZiAoaXNOdW0oK3RpbWVQb3NpdGlvbikpIHJldHVybiArdGltZVBvc2l0aW9uO1xuICBjb25zdCB0aW1lUG9zU3RyID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHRpbWVQb3NpdGlvbik7XG4gIGNvbnN0IHRsTGFiZWxzID0gdGltZWxpbmUgPyB0aW1lbGluZS5sYWJlbHMgOiBudWxsO1xuICBjb25zdCBoYXNMYWJlbHMgPSAhaXNOaWwodGxMYWJlbHMpO1xuICBjb25zdCBwcmV2T2Zmc2V0ID0gZ2V0UHJldkNoaWxkT2Zmc2V0KHRpbWVsaW5lLCB0aW1lUG9zU3RyKTtcbiAgY29uc3QgaGFzU2libGluZyA9ICFpc1VuZChwcmV2T2Zmc2V0KTtcbiAgY29uc3QgbWF0Y2hlZFJlbGF0aXZlT3BlcmF0b3IgPSByZWxhdGl2ZVZhbHVlc0V4ZWNSZ3guZXhlYyh0aW1lUG9zU3RyKTtcbiAgaWYgKG1hdGNoZWRSZWxhdGl2ZU9wZXJhdG9yKSB7XG4gICAgY29uc3QgZnVsbE9wZXJhdG9yID0gbWF0Y2hlZFJlbGF0aXZlT3BlcmF0b3JbMF07XG4gICAgY29uc3Qgc3BsaXQgPSB0aW1lUG9zU3RyLnNwbGl0KGZ1bGxPcGVyYXRvcik7XG4gICAgY29uc3QgbGFiZWxPZmZzZXQgPSBoYXNMYWJlbHMgJiYgc3BsaXRbMF0gPyB0bExhYmVsc1tzcGxpdFswXV0gOiB0bER1cmF0aW9uO1xuICAgIGNvbnN0IHBhcnNlZE9mZnNldCA9IGhhc1NpYmxpbmcgPyBwcmV2T2Zmc2V0IDogaGFzTGFiZWxzID8gbGFiZWxPZmZzZXQgOiB0bER1cmF0aW9uO1xuICAgIGNvbnN0IHBhcnNlZE51bWVyaWNhbE9mZnNldCA9ICtzcGxpdFsxXTtcbiAgICByZXR1cm4gZ2V0UmVsYXRpdmVWYWx1ZShwYXJzZWRPZmZzZXQsIHBhcnNlZE51bWVyaWNhbE9mZnNldCwgZnVsbE9wZXJhdG9yWzBdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzU2libGluZyA/IHByZXZPZmZzZXQgOlxuICAgICAgICAgICBoYXNMYWJlbHMgPyAhaXNVbmQodGxMYWJlbHNbdGltZVBvc1N0cl0pID8gdGxMYWJlbHNbdGltZVBvc1N0cl0gOlxuICAgICAgICAgICB0bER1cmF0aW9uIDogdGxEdXJhdGlvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVsaW5lfSB0bFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRUaW1lbGluZVRvdGFsRHVyYXRpb24odGwpIHtcbiAgcmV0dXJuIGNsYW1wSW5maW5pdHkoKCh0bC5pdGVyYXRpb25EdXJhdGlvbiArIHRsLl9sb29wRGVsYXkpICogdGwuaXRlcmF0aW9uQ291bnQpIC0gdGwuX2xvb3BEZWxheSkgfHwgbWluVmFsdWU7XG59XG5cbi8qKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtUaW1lclBhcmFtc30gY2hpbGRQYXJhbXNcbiAqIEBwYXJhbSAge1RpbWVsaW5lfSB0bFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lUG9zaXRpb25cbiAqIEByZXR1cm4ge1RpbWVsaW5lfVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7QW5pbWF0aW9uUGFyYW1zfSBjaGlsZFBhcmFtc1xuICogQHBhcmFtICB7VGltZWxpbmV9IHRsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVQb3NpdGlvblxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtpbmRleF1cbiAqIEBwYXJhbSAge051bWJlcn0gW2xlbmd0aF1cbiAqIEByZXR1cm4ge1RpbWVsaW5lfVxuICpcbiAqIEBwYXJhbSAge1RpbWVyUGFyYW1zfEFuaW1hdGlvblBhcmFtc30gY2hpbGRQYXJhbXNcbiAqIEBwYXJhbSAge1RpbWVsaW5lfSB0bFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lUG9zaXRpb25cbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gW3RhcmdldHNdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtpbmRleF1cbiAqIEBwYXJhbSAge051bWJlcn0gW2xlbmd0aF1cbiAqL1xuZnVuY3Rpb24gYWRkVGxDaGlsZChjaGlsZFBhcmFtcywgdGwsIHRpbWVQb3NpdGlvbiwgdGFyZ2V0cywgaW5kZXgsIGxlbmd0aCkge1xuICBjb25zdCBpc1NldHRlciA9IGlzTnVtKGNoaWxkUGFyYW1zLmR1cmF0aW9uKSAmJiAvKiogQHR5cGUge051bWJlcn0gKi8oY2hpbGRQYXJhbXMuZHVyYXRpb24pIDw9IG1pblZhbHVlO1xuICAvLyBPZmZzZXQgdGhlIHRsIHBvc2l0aW9uIHdpdGggLW1pblZhbHVlIGZvciAwIGR1cmF0aW9uIGFuaW1hdGlvbnMgb3IgLnNldCgpIGNhbGxzIGluIG9yZGVyIHRvIGFsaWduIHRoZWlyIGVuZCB2YWx1ZSB3aXRoIHRoZSBkZWZpbmVkIHBvc2l0aW9uXG4gIGNvbnN0IGFkanVzdGVkUG9zaXRpb24gPSBpc1NldHRlciA/IHRpbWVQb3NpdGlvbiAtIG1pblZhbHVlIDogdGltZVBvc2l0aW9uO1xuICB0aWNrKHRsLCBhZGp1c3RlZFBvc2l0aW9uLCAxLCAxLCB0aWNrTW9kZXMuQVVUTyk7XG4gIGNvbnN0IHRsQ2hpbGQgPSB0YXJnZXRzID9cbiAgICBuZXcgSlNBbmltYXRpb24odGFyZ2V0cywvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi8oY2hpbGRQYXJhbXMpLCB0bCwgYWRqdXN0ZWRQb3NpdGlvbiwgZmFsc2UsIGluZGV4LCBsZW5ndGgpIDpcbiAgICBuZXcgVGltZXIoLyoqIEB0eXBlIHtUaW1lclBhcmFtc30gKi8oY2hpbGRQYXJhbXMpLCB0bCwgYWRqdXN0ZWRQb3NpdGlvbik7XG4gIHRsQ2hpbGQuaW5pdCgxKTtcbiAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIHRvIGluc2VydCBhdCBhIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHN0YXJ0VGltZT9cbiAgYWRkQ2hpbGQodGwsIHRsQ2hpbGQpO1xuICBmb3JFYWNoQ2hpbGRyZW4odGwsICgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovY2hpbGQpID0+IHtcbiAgICBjb25zdCBjaGlsZFRMT2Zmc2V0ID0gY2hpbGQuX29mZnNldCArIGNoaWxkLl9kZWxheTtcbiAgICBjb25zdCBjaGlsZER1ciA9IGNoaWxkVExPZmZzZXQgKyBjaGlsZC5kdXJhdGlvbjtcbiAgICBpZiAoY2hpbGREdXIgPiB0bC5pdGVyYXRpb25EdXJhdGlvbikgdGwuaXRlcmF0aW9uRHVyYXRpb24gPSBjaGlsZER1cjtcbiAgfSk7XG4gIHRsLmR1cmF0aW9uID0gZ2V0VGltZWxpbmVUb3RhbER1cmF0aW9uKHRsKTtcbiAgcmV0dXJuIHRsO1xufVxuXG5jbGFzcyBUaW1lbGluZSBleHRlbmRzIFRpbWVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtUaW1lbGluZVBhcmFtc30gW3BhcmFtZXRlcnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBzdXBlcigvKiogQHR5cGUge1RpbWVyUGFyYW1zJlRpbWVsaW5lUGFyYW1zfSAqLyhwYXJhbWV0ZXJzKSwgbnVsbCwgMCk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7IC8vIFRMIGR1cmF0aW9uIHN0YXJ0cyBhdCAwIGFuZCBncm93cyB3aGVuIGFkZGluZyBjaGlsZHJlblxuICAgIC8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgTnVtYmVyPn0gKi9cbiAgICB0aGlzLmxhYmVscyA9IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRzUGFyYW1zID0gcGFyYW1ldGVycy5kZWZhdWx0cztcbiAgICBjb25zdCBnbG9iYWxEZWZhdWx0cyA9IGdsb2JhbHMuZGVmYXVsdHM7XG4gICAgLyoqIEB0eXBlIHtEZWZhdWx0c1BhcmFtc30gKi9cbiAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHNQYXJhbXMgPyBtZXJnZU9iamVjdHMoZGVmYXVsdHNQYXJhbXMsIGdsb2JhbERlZmF1bHRzKSA6IGdsb2JhbERlZmF1bHRzO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblJlbmRlciA9IHBhcmFtZXRlcnMub25SZW5kZXIgfHwgZ2xvYmFsRGVmYXVsdHMub25SZW5kZXI7XG4gICAgY29uc3QgdGxQbGF5YmFja0Vhc2UgPSBzZXRWYWx1ZShwYXJhbWV0ZXJzLnBsYXliYWNrRWFzZSwgZ2xvYmFsRGVmYXVsdHMucGxheWJhY2tFYXNlKTtcbiAgICB0aGlzLl9lYXNlID0gdGxQbGF5YmFja0Vhc2UgPyBwYXJzZUVhc2luZ3ModGxQbGF5YmFja0Vhc2UpIDogbnVsbDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IGExXG4gICAqIEBwYXJhbSB7QW5pbWF0aW9uUGFyYW1zfSBhMlxuICAgKiBAcGFyYW0ge1RpbWVsaW5lUG9zaXRpb258U3RhZ2dlckZ1bmN0aW9uPE51bWJlcnxTdHJpbmc+fSBbYTNdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1RpbWVyUGFyYW1zfSBhMVxuICAgKiBAcGFyYW0ge1RpbWVsaW5lUG9zaXRpb259IFthMl1cbiAgICogQHJldHVybiB7dGhpc31cbiAgICpcbiAgICogQHBhcmFtIHtUYXJnZXRzUGFyYW18VGltZXJQYXJhbXN9IGExXG4gICAqIEBwYXJhbSB7VGltZWxpbmVQb3NpdGlvbnxBbmltYXRpb25QYXJhbXN9IGEyXG4gICAqIEBwYXJhbSB7VGltZWxpbmVQb3NpdGlvbnxTdGFnZ2VyRnVuY3Rpb248TnVtYmVyfFN0cmluZz59IFthM11cbiAgICovXG4gIGFkZChhMSwgYTIsIGEzKSB7XG4gICAgY29uc3QgaXNBbmltID0gaXNPYmooYTIpO1xuICAgIGNvbnN0IGlzVGltZXIgPSBpc09iaihhMSk7XG4gICAgaWYgKGlzQW5pbSB8fCBpc1RpbWVyKSB7XG4gICAgICB0aGlzLl9oYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgICBpZiAoaXNBbmltKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUGFyYW1zID0gLyoqIEB0eXBlIHtBbmltYXRpb25QYXJhbXN9ICovKGEyKTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGZ1bmN0aW9uIGZvciBjaGlsZHJlbiBzdGFnZ2VyIHBvc2l0aW9uc1xuICAgICAgICBpZiAoaXNGbmMoYTMpKSB7XG4gICAgICAgICAgY29uc3Qgc3RhZ2dlcmVkUG9zaXRpb24gPSBhMztcbiAgICAgICAgICBjb25zdCBwYXJzZWRUYXJnZXRzQXJyYXkgPSBwYXJzZVRhcmdldHMoLyoqIEB0eXBlIHtUYXJnZXRzUGFyYW19ICovKGExKSk7XG4gICAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBkdXJhdGlvbiBiZWZvcmUgYWRkaW5nIG5ldyBjaGlsZHJlbiB0aGF0IHdpbGwgY2hhbmdlIHRoZSBkdXJhdGlvblxuICAgICAgICAgIGNvbnN0IHRsRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgIC8vIFN0b3JlIGluaXRpYWwgX2l0ZXJhdGlvbkR1cmF0aW9uIGJlZm9yZSBhZGRpbmcgbmV3IGNoaWxkcmVuIHRoYXQgd2lsbCBjaGFuZ2UgdGhlIGR1cmF0aW9uXG4gICAgICAgICAgY29uc3QgdGxJdGVyYXRpb25EdXJhdGlvbiA9IHRoaXMuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGlkIGluIG9yZGVyIHRvIGFkZCBzcGVjaWZpYyBpbmRleGVzIHRvIHRoZSBuZXcgYW5pbWF0aW9ucyBpZHNcbiAgICAgICAgICBjb25zdCBpZCA9IGNoaWxkUGFyYW1zLmlkO1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICAgICBjb25zdCBwYXJzZWRMZW5ndGggPSAocGFyc2VkVGFyZ2V0c0FycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VkVGFyZ2V0c0FycmF5LmZvckVhY2goKC8qKiBAdHlwZSB7VGFyZ2V0fSAqL3RhcmdldCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhcmFtZXRlciBvYmplY3QgZm9yIGVhY2ggc3RhZ2dlcmVkIGNoaWxkcmVuXG4gICAgICAgICAgICBjb25zdCBzdGFnZ2VyZWRDaGlsZFBhcmFtcyA9IHsgLi4uY2hpbGRQYXJhbXMgfTtcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgdGltZWxpbmUgaXRlcmF0aW9uIGJlZm9yZSBlYWNoIHN0YWdnZXIgdG8gcHJldmVudCB3cm9uZyBzdGFydCB2YWx1ZSBjYWxjdWxhdGlvblxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHRsRHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gdGxJdGVyYXRpb25EdXJhdGlvbjtcbiAgICAgICAgICAgIGlmICghaXNVbmQoaWQpKSBzdGFnZ2VyZWRDaGlsZFBhcmFtcy5pZCA9IGlkICsgJy0nICsgaTtcbiAgICAgICAgICAgIGFkZFRsQ2hpbGQoXG4gICAgICAgICAgICAgIHN0YWdnZXJlZENoaWxkUGFyYW1zLFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBwYXJzZVRpbWVsaW5lUG9zaXRpb24odGhpcywgc3RhZ2dlcmVkUG9zaXRpb24odGFyZ2V0LCBpLCBwYXJzZWRMZW5ndGgsIHRoaXMpKSxcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICBwYXJzZWRMZW5ndGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkVGxDaGlsZChcbiAgICAgICAgICAgIGNoaWxkUGFyYW1zLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHBhcnNlVGltZWxpbmVQb3NpdGlvbih0aGlzLCBhMyksXG4gICAgICAgICAgICAvKiogQHR5cGUge1RhcmdldHNQYXJhbX0gKi8oYTEpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0J3MgYSBUaW1lclxuICAgICAgICBhZGRUbENoaWxkKFxuICAgICAgICAgIC8qKiBAdHlwZSBUaW1lclBhcmFtcyAqLyhhMSksXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBwYXJzZVRpbWVsaW5lUG9zaXRpb24odGhpcyxhMiksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pbml0KDEpOyAvLyAxID0gaW50ZXJuYWxSZW5kZXJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7VGlja2FibGV9IFtzeW5jZWRdXG4gICAqIEBwYXJhbSB7VGltZWxpbmVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtnbG9iYWxUaGlzLkFuaW1hdGlvbn0gW3N5bmNlZF1cbiAgICogQHBhcmFtIHtUaW1lbGluZVBvc2l0aW9ufSBbcG9zaXRpb25dXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1dBQVBJQW5pbWF0aW9ufSBbc3luY2VkXVxuICAgKiBAcGFyYW0ge1RpbWVsaW5lUG9zaXRpb259IFtwb3NpdGlvbl1cbiAgICogQHJldHVybiB7dGhpc31cbiAgICpcbiAgICogQHBhcmFtIHtUaWNrYWJsZXxXQUFQSUFuaW1hdGlvbnxnbG9iYWxUaGlzLkFuaW1hdGlvbn0gW3N5bmNlZF1cbiAgICogQHBhcmFtIHtUaW1lbGluZVBvc2l0aW9ufSBbcG9zaXRpb25dXG4gICAqL1xuICBzeW5jKHN5bmNlZCwgcG9zaXRpb24pIHtcbiAgICBpZiAoaXNVbmQoc3luY2VkKSB8fCBzeW5jZWQgJiYgaXNVbmQoc3luY2VkLnBhdXNlKSkgcmV0dXJuIHRoaXM7XG4gICAgc3luY2VkLnBhdXNlKCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSArKC8qKiBAdHlwZSB7Z2xvYmFsVGhpcy5BbmltYXRpb259ICovKHN5bmNlZCkuZWZmZWN0ID8gLyoqIEB0eXBlIHtnbG9iYWxUaGlzLkFuaW1hdGlvbn0gKi8oc3luY2VkKS5lZmZlY3QuZ2V0VGltaW5nKCkuZHVyYXRpb24gOiAvKiogQHR5cGUge1RpY2thYmxlfSAqLyhzeW5jZWQpLmR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5hZGQoc3luY2VkLCB7IGN1cnJlbnRUaW1lOiBbMCwgZHVyYXRpb25dLCBkdXJhdGlvbiwgZWFzZTogJ2xpbmVhcicgfSwgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICAgKiBAcGFyYW0gIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAgICogQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0KHRhcmdldHMsIHBhcmFtZXRlcnMsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKHBhcmFtZXRlcnMpKSByZXR1cm4gdGhpcztcbiAgICBwYXJhbWV0ZXJzLmR1cmF0aW9uID0gbWluVmFsdWU7XG4gICAgcGFyYW1ldGVycy5jb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uVHlwZXMucmVwbGFjZTtcbiAgICByZXR1cm4gdGhpcy5hZGQodGFyZ2V0cywgcGFyYW1ldGVycywgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FsbGJhY2s8VGltZXI+fSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge1RpbWVsaW5lUG9zaXRpb259IFtwb3NpdGlvbl1cbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGNhbGwoY2FsbGJhY2ssIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKGNhbGxiYWNrKSB8fCBjYWxsYmFjayAmJiAhaXNGbmMoY2FsbGJhY2spKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gdGhpcy5hZGQoeyBkdXJhdGlvbjogMCwgb25Db21wbGV0ZTogKCkgPT4gY2FsbGJhY2sodGhpcykgfSwgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbE5hbWVcbiAgICogQHBhcmFtIHtUaW1lbGluZVBvc2l0aW9ufSBbcG9zaXRpb25dXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqL1xuICBsYWJlbChsYWJlbE5hbWUsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKGxhYmVsTmFtZSkgfHwgbGFiZWxOYW1lICYmICFpc1N0cihsYWJlbE5hbWUpKSByZXR1cm4gdGhpcztcbiAgICB0aGlzLmxhYmVsc1tsYWJlbE5hbWVdID0gcGFyc2VUaW1lbGluZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbcHJvcGVydHlOYW1lXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmVtb3ZlKHRhcmdldHMsIHByb3BlcnR5TmFtZSkge1xuICAgIHJlbW92ZSh0YXJnZXRzLCB0aGlzLCBwcm9wZXJ0eU5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gbmV3RHVyYXRpb25cbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHN0cmV0Y2gobmV3RHVyYXRpb24pIHtcbiAgICBjb25zdCBjdXJyZW50RHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGlmIChjdXJyZW50RHVyYXRpb24gPT09IG5vcm1hbGl6ZVRpbWUobmV3RHVyYXRpb24pKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB0aW1lU2NhbGUgPSBuZXdEdXJhdGlvbiAvIGN1cnJlbnREdXJhdGlvbjtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovY2hpbGQpID0+IGNoaWxkLnN0cmV0Y2goY2hpbGQuZHVyYXRpb24gKiB0aW1lU2NhbGUpKTtcbiAgICBmb3IgKGxldCBsYWJlbE5hbWUgaW4gbGFiZWxzKSBsYWJlbHNbbGFiZWxOYW1lXSAqPSB0aW1lU2NhbGU7XG4gICAgcmV0dXJuIHN1cGVyLnN0cmV0Y2gobmV3RHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnJlZnJlc2gpIGNoaWxkLnJlZnJlc2goKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmV2ZXJ0KCkge1xuICAgIHN1cGVyLnJldmVydCgpO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4gY2hpbGQucmV2ZXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gY2xlYW5JbmxpbmVTdHlsZXModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7Q2FsbGJhY2s8dGhpcz59IFtjYWxsYmFja11cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHRoZW4oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc3VwZXIudGhlbihjYWxsYmFjayk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVsaW5lUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm4ge1RpbWVsaW5lfVxuICovXG5jb25zdCBjcmVhdGVUaW1lbGluZSA9IHBhcmFtZXRlcnMgPT4gbmV3IFRpbWVsaW5lKHBhcmFtZXRlcnMpLmluaXQoKTtcblxuXG5cblxuY2xhc3MgQW5pbWF0YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICAgKiBAcGFyYW0ge0FuaW1hdGFibGVQYXJhbXN9IHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldHMsIHBhcmFtZXRlcnMpIHtcbiAgICBpZiAoc2NvcGUuY3VycmVudCkgc2NvcGUuY3VycmVudC5yZWdpc3Rlcih0aGlzKTtcbiAgICBjb25zdCBiZWdpbkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jYWxsYmFja3MuY29tcGxldGVkKSB0aGlzLmNhbGxiYWNrcy5yZXNldCgpO1xuICAgICAgdGhpcy5jYWxsYmFja3MucGxheSgpO1xuICAgIH07XG4gICAgY29uc3QgcGF1c2VIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLmNvbXBsZXRlZCkgcmV0dXJuO1xuICAgICAgbGV0IHBhdXNlZCA9IHRydWU7XG4gICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuYW5pbWF0aW9ucykge1xuICAgICAgICBjb25zdCBhbmltID0gdGhpcy5hbmltYXRpb25zW25hbWVdO1xuICAgICAgICBpZiAoIWFuaW0ucGF1c2VkICYmIHBhdXNlZCkge1xuICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi9cbiAgICBjb25zdCBnbG9iYWxQYXJhbXMgPSB7XG4gICAgICBvbkJlZ2luOiBiZWdpbkhhbmRsZXIsXG4gICAgICBvbkNvbXBsZXRlOiBwYXVzZUhhbmRsZXIsXG4gICAgICBvblBhdXNlOiBwYXVzZUhhbmRsZXIsXG4gICAgfTtcbiAgICAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi9cbiAgICBjb25zdCBjYWxsYmFja3NBbmltYXRpb25QYXJhbXMgPSB7IHY6IDEsIGF1dG9wbGF5OiBmYWxzZSB9O1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufG51bGx9ICovXG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIGlmIChpc1VuZCh0YXJnZXRzKSB8fCBpc1VuZChwYXJhbWV0ZXJzKSkgcmV0dXJuO1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSBwYXJhbWV0ZXJzW3Byb3BOYW1lXTtcbiAgICAgIGlmIChpc0tleShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAnb24nKSkge1xuICAgICAgICBjYWxsYmFja3NBbmltYXRpb25QYXJhbXNbcHJvcE5hbWVdID0gcGFyYW1WYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbFBhcmFtc1twcm9wTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBKU0FuaW1hdGlvbih7IHY6IDAgfSwgY2FsbGJhY2tzQW5pbWF0aW9uUGFyYW1zKTtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgIGNvbnN0IGlzT2JqVmFsdWUgPSBpc09iaihwcm9wVmFsdWUpO1xuICAgICAgLyoqIEB0eXBlIHtUd2VlblBhcmFtc09wdGlvbnN9ICovXG4gICAgICBsZXQgcHJvcFBhcmFtcyA9IHt9O1xuICAgICAgbGV0IHRvID0gJys9MCc7XG4gICAgICBpZiAoaXNPYmpWYWx1ZSkge1xuICAgICAgICBjb25zdCB1bml0ID0gcHJvcFZhbHVlLnVuaXQ7XG4gICAgICAgIGlmIChpc1N0cih1bml0KSkgdG8gKz0gdW5pdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BQYXJhbXMuZHVyYXRpb24gPSBwcm9wVmFsdWU7XG4gICAgICB9XG4gICAgICBwcm9wUGFyYW1zW3Byb3BOYW1lXSA9IGlzT2JqVmFsdWUgPyBtZXJnZU9iamVjdHMoeyB0byB9LCBwcm9wVmFsdWUpIDogdG87XG4gICAgICBjb25zdCBhbmltUGFyYW1zID0gbWVyZ2VPYmplY3RzKGdsb2JhbFBhcmFtcywgcHJvcFBhcmFtcyk7XG4gICAgICBhbmltUGFyYW1zLmNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlO1xuICAgICAgYW5pbVBhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zW3Byb3BOYW1lXSA9IG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLCBhbmltUGFyYW1zLCBudWxsLCAwLCBmYWxzZSkuaW5pdCgpO1xuICAgICAgaWYgKCF0aGlzLnRhcmdldHMubGVuZ3RoKSB0aGlzLnRhcmdldHMucHVzaCguLi5hbmltYXRpb24udGFyZ2V0cyk7XG4gICAgICAvKiogQHR5cGUge0FuaW1hdGFibGVQcm9wZXJ0eX0gKi9cbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gKHRvLCBkdXJhdGlvbiwgZWFzZSkgPT4ge1xuICAgICAgICBjb25zdCB0d2VlbiA9IC8qKiBAdHlwZSB7VHdlZW59ICovKGFuaW1hdGlvbi5faGVhZCk7XG4gICAgICAgIGlmIChpc1VuZCh0bykgJiYgdHdlZW4pIHtcbiAgICAgICAgICBjb25zdCBudW1iZXJzID0gdHdlZW4uX251bWJlcnM7XG4gICAgICAgICAgaWYgKG51bWJlcnMgJiYgbnVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHdlZW4uX21vZGlmaWVyKHR3ZWVuLl9udW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oYW5pbWF0aW9uLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi90d2VlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQXJyKHRvKSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKHRvKS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kKHR3ZWVuLl9udW1iZXJzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXJzW2ldID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuLl9tb2RpZmllcih0d2Vlbi5fbnVtYmVyc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgdHdlZW4uX3RvTnVtYmVyc1tpXSA9IHRvW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXIgPSAvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW4uX21vZGlmaWVyKHR3ZWVuLl9udW1iZXIpKTtcbiAgICAgICAgICAgICAgdHdlZW4uX3RvTnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNVbmQoZWFzZSkpIHR3ZWVuLl9lYXNlID0gcGFyc2VFYXNpbmdzKGVhc2UpO1xuICAgICAgICAgICAgdHdlZW4uX2N1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWlzVW5kKGR1cmF0aW9uKSkgYW5pbWF0aW9uLnN0cmV0Y2goZHVyYXRpb24pO1xuICAgICAgICAgIGFuaW1hdGlvbi5yZXNldCgxKS5yZXN1bWUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gdGhpcy5hbmltYXRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vb3A7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNbcHJvcE5hbWVdLnJldmVydCgpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRhcmdldHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5jYWxsYmFja3MpIHRoaXMuY2FsbGJhY2tzLnJldmVydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEBwYXJhbSB7QW5pbWF0YWJsZVBhcmFtc30gcGFyYW1ldGVyc1xuICogQHJldHVybiB7QW5pbWF0YWJsZU9iamVjdH1cbiAqL1xuY29uc3QgY3JlYXRlQW5pbWF0YWJsZSA9ICh0YXJnZXRzLCBwYXJhbWV0ZXJzKSA9PiAvKiogQHR5cGUge0FuaW1hdGFibGVPYmplY3R9ICovIChuZXcgQW5pbWF0YWJsZSh0YXJnZXRzLCBwYXJhbWV0ZXJzKSk7XG5cblxuXG5cbi8qXG4gKiBTcHJpbmcgZWFzZSBzb2x2ZXIgYWRhcHRlZCBmcm9tIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG4gKiBXZWJraXQgQ29weXJpZ2h0IMKpIDIwMTYgQXBwbGUgSW5jXG4gKi9cblxuY29uc3QgbWF4U3ByaW5nUGFyYW1WYWx1ZSA9IEsgKiAxMDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcHJpbmdQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFzcz0xXSAtIE1hc3MsIGRlZmF1bHQgMVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdGlmZm5lc3M9MTAwXSAtIFN0aWZmbmVzcywgZGVmYXVsdCAxMDBcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGFtcGluZz0xMF0gLSBEYW1waW5nLCBkZWZhdWx0IDEwXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3ZlbG9jaXR5PTBdIC0gSW5pdGlhbCB2ZWxvY2l0eSwgZGVmYXVsdCAwXG4gKi9cbmNsYXNzIFNwcmluZyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1NwcmluZ1BhcmFtc30gW3BhcmFtZXRlcnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICB0aGlzLnRpbWVTdGVwID0gLjAyOyAvLyBJbnRlcnZhbCBmZWQgdG8gdGhlIHNvbHZlciB0byBjYWxjdWxhdGUgZHVyYXRpb25cbiAgICB0aGlzLnJlc3RUaHJlc2hvbGQgPSAuMDAwNTsgLy8gVmFsdWVzIGJlbG93IHRoaXMgdGhyZXNob2xkIGFyZSBjb25zaWRlcmVkIHJlc3RpbmcgcG9zaXRpb25cbiAgICB0aGlzLnJlc3REdXJhdGlvbiA9IDIwMDsgLy8gRHVyYXRpb24gaW4gbXMgdXNlZCB0byBjaGVjayBpZiB0aGUgc3ByaW5nIGlzIHJlc3RpbmcgYWZ0ZXIgcmVhY2hpbmcgcmVzdFRocmVzaG9sZFxuICAgIHRoaXMubWF4RHVyYXRpb24gPSA2MDAwMDsgLy8gVGhlIG1heGltdW0gYWxsb3dlZCBzcHJpbmcgZHVyYXRpb24gaW4gbXMgKGRlZmF1bHQgMSBtaW4pXG4gICAgdGhpcy5tYXhSZXN0U3RlcHMgPSB0aGlzLnJlc3REdXJhdGlvbiAvIHRoaXMudGltZVN0ZXAgLyBLOyAvLyBIb3cgbWFueSBzdGVwcyBhbGxvd2VkIGFmdGVyIHJlYWNoaW5nIHJlc3RUaHJlc2hvbGQgYmVmb3JlIHN0b3BwaW5nIHRoZSBkdXJhdGlvbiBjYWxjdWxhdGlvblxuICAgIHRoaXMubWF4SXRlcmF0aW9ucyA9IHRoaXMubWF4RHVyYXRpb24gLyB0aGlzLnRpbWVTdGVwIC8gSzsgLy8gQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIGl0ZXJhdGlvbnMgYWxsb3dlZCBiYXNlZCBvbiBtYXhEdXJhdGlvblxuICAgIHRoaXMubSA9IGNsYW1wKHNldFZhbHVlKHBhcmFtZXRlcnMubWFzcywgMSksIDAsIG1heFNwcmluZ1BhcmFtVmFsdWUpO1xuICAgIHRoaXMucyA9IGNsYW1wKHNldFZhbHVlKHBhcmFtZXRlcnMuc3RpZmZuZXNzLCAxMDApLCAxLCBtYXhTcHJpbmdQYXJhbVZhbHVlKTtcbiAgICB0aGlzLmQgPSBjbGFtcChzZXRWYWx1ZShwYXJhbWV0ZXJzLmRhbXBpbmcsIDEwKSwgLjEsIG1heFNwcmluZ1BhcmFtVmFsdWUpO1xuICAgIHRoaXMudiA9IGNsYW1wKHNldFZhbHVlKHBhcmFtZXRlcnMudmVsb2NpdHksIDApLCAtbWF4U3ByaW5nUGFyYW1WYWx1ZSwgbWF4U3ByaW5nUGFyYW1WYWx1ZSk7XG4gICAgdGhpcy53MCA9IDA7XG4gICAgdGhpcy56ZXRhID0gMDtcbiAgICB0aGlzLndkID0gMDtcbiAgICB0aGlzLmIgPSAwO1xuICAgIHRoaXMuc29sdmVyRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gICAgdGhpcy5lYXNlID0gdCA9PiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDogdGhpcy5zb2x2ZSh0ICogdGhpcy5zb2x2ZXJEdXJhdGlvbik7XG4gIH1cblxuICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICBzb2x2ZSh0aW1lKSB7XG4gICAgY29uc3QgeyB6ZXRhLCB3MCwgd2QsIGIgfSA9IHRoaXM7XG4gICAgbGV0IHQgPSB0aW1lO1xuICAgIGlmICh6ZXRhIDwgMSkge1xuICAgICAgdCA9IGV4cCgtdCAqIHpldGEgKiB3MCkgKiAoMSAqIGNvcyh3ZCAqIHQpICsgYiAqIHNpbih3ZCAqIHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdCA9ICgxICsgYiAqIHQpICogZXhwKC10ICogdzApO1xuICAgIH1cbiAgICByZXR1cm4gMSAtIHQ7XG4gIH1cblxuICBjb21wdXRlKCkge1xuICAgIGNvbnN0IHsgbWF4UmVzdFN0ZXBzLCBtYXhJdGVyYXRpb25zLCByZXN0VGhyZXNob2xkLCB0aW1lU3RlcCwgbSwgZCwgcywgdiB9ID0gdGhpcztcbiAgICBjb25zdCB3MCA9IHRoaXMudzAgPSBjbGFtcChzcXJ0KHMgLyBtKSwgbWluVmFsdWUsIEspO1xuICAgIGNvbnN0IHpldGEgPSB0aGlzLnpldGEgPSBkIC8gKDIgKiBzcXJ0KHMgKiBtKSk7XG4gICAgY29uc3Qgd2QgPSB0aGlzLndkID0gemV0YSA8IDEgPyB3MCAqIHNxcnQoMSAtIHpldGEgKiB6ZXRhKSA6IDA7XG4gICAgdGhpcy5iID0gemV0YSA8IDEgPyAoemV0YSAqIHcwICsgLXYpIC8gd2QgOiAtdiArIHcwO1xuICAgIGxldCBzb2x2ZXJUaW1lID0gMDtcbiAgICBsZXQgcmVzdFN0ZXBzID0gMDtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgd2hpbGUgKHJlc3RTdGVwcyA8IG1heFJlc3RTdGVwcyAmJiBpdGVyYXRpb25zIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgaWYgKGFicygxIC0gdGhpcy5zb2x2ZShzb2x2ZXJUaW1lKSkgPCByZXN0VGhyZXNob2xkKSB7XG4gICAgICAgIHJlc3RTdGVwcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdFN0ZXBzID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc29sdmVyRHVyYXRpb24gPSBzb2x2ZXJUaW1lO1xuICAgICAgc29sdmVyVGltZSArPSB0aW1lU3RlcDtcbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICB9XG4gICAgdGhpcy5kdXJhdGlvbiA9IHJvdW5kKHRoaXMuc29sdmVyRHVyYXRpb24gKiBLLCAwKSAqIGdsb2JhbHMudGltZVNjYWxlO1xuICB9XG5cbiAgZ2V0IG1hc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubTtcbiAgfVxuXG4gIHNldCBtYXNzKHYpIHtcbiAgICB0aGlzLm0gPSBjbGFtcChzZXRWYWx1ZSh2LCAxKSwgMCwgbWF4U3ByaW5nUGFyYW1WYWx1ZSk7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gIH1cblxuICBnZXQgc3RpZmZuZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnM7XG4gIH1cblxuICBzZXQgc3RpZmZuZXNzKHYpIHtcbiAgICB0aGlzLnMgPSBjbGFtcChzZXRWYWx1ZSh2LCAxMDApLCAxLCBtYXhTcHJpbmdQYXJhbVZhbHVlKTtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgfVxuXG4gIGdldCBkYW1waW5nKCkge1xuICAgIHJldHVybiB0aGlzLmQ7XG4gIH1cblxuICBzZXQgZGFtcGluZyh2KSB7XG4gICAgdGhpcy5kID0gY2xhbXAoc2V0VmFsdWUodiwgMTApLCAuMSwgbWF4U3ByaW5nUGFyYW1WYWx1ZSk7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gIH1cblxuICBnZXQgdmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudjtcbiAgfVxuXG4gIHNldCB2ZWxvY2l0eSh2KSB7XG4gICAgdGhpcy52ID0gY2xhbXAoc2V0VmFsdWUodiwgMCksIC1tYXhTcHJpbmdQYXJhbVZhbHVlLCBtYXhTcHJpbmdQYXJhbVZhbHVlKTtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ByaW5nUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm5zIHtTcHJpbmd9XG4gKi9cbmNvbnN0IGNyZWF0ZVNwcmluZyA9IChwYXJhbWV0ZXJzKSA9PiBuZXcgU3ByaW5nKHBhcmFtZXRlcnMpO1xuXG5cblxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR9IGVcbiAqL1xuY29uc3QgcHJldmVudERlZmF1bHQgPSBlID0+IHtcbiAgaWYgKGUuY2FuY2VsYWJsZSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuY2xhc3MgRE9NUHJveHkge1xuICAvKiogQHBhcmFtIHtPYmplY3R9IGVsICovXG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY2xhc3NMaXN0ID0ge1xuICAgICAgYWRkOiBub29wLFxuICAgICAgcmVtb3ZlOiBub29wLFxuICAgIH07XG4gIH1cblxuICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuZWwueCB8fCAwIH07XG4gIHNldCB4KHYpIHsgdGhpcy5lbC54ID0gdjsgfTtcblxuICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuZWwueSB8fCAwIH07XG4gIHNldCB5KHYpIHsgdGhpcy5lbC55ID0gdjsgfTtcblxuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLmVsLndpZHRoIHx8IDAgfTtcbiAgc2V0IHdpZHRoKHYpIHsgdGhpcy5lbC53aWR0aCA9IHY7IH07XG5cbiAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuZWwuaGVpZ2h0IHx8IDAgfTtcbiAgc2V0IGhlaWdodCh2KSB7IHRoaXMuZWwuaGVpZ2h0ID0gdjsgfTtcblxuICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdGhpcy55LFxuICAgICAgcmlnaHQ6IHRoaXMueCxcbiAgICAgIGJvdHRvbTogdGhpcy55ICsgdGhpcy5oZWlnaHQsXG4gICAgICBsZWZ0OiB0aGlzLnggKyB0aGlzLndpZHRoLFxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBUcmFuc2Zvcm1zIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NVGFyZ2V0fERPTVByb3h5fSAkZWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCRlbCkge1xuICAgIHRoaXMuJGVsID0gJGVsO1xuICAgIHRoaXMuaW5saW5lVHJhbnNmb3JtcyA9IFtdO1xuICAgIHRoaXMucG9pbnQgPSBuZXcgRE9NUG9pbnQoKTtcbiAgICB0aGlzLmludmVyc2VkTWF0cml4ID0gdGhpcy5nZXRNYXRyaXgoKS5pbnZlcnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7RE9NUG9pbnR9XG4gICAqL1xuICBub3JtYWxpemVQb2ludCh4LCB5KSB7XG4gICAgdGhpcy5wb2ludC54ID0geDtcbiAgICB0aGlzLnBvaW50LnkgPSB5O1xuICAgIHJldHVybiB0aGlzLnBvaW50Lm1hdHJpeFRyYW5zZm9ybSh0aGlzLmludmVyc2VkTWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgVHJhdmVyc2VQYXJlbnRzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtET01UYXJnZXR9ICRlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gaVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmF2ZXJzZVBhcmVudHNDYWxsYmFja30gY2JcbiAgICovXG4gIHRyYXZlcnNlVXAoY2IpIHtcbiAgICBsZXQgJGVsID0gLyoqIEB0eXBlIHtET01UYXJnZXR8RG9jdW1lbnR9ICovKHRoaXMuJGVsLnBhcmVudEVsZW1lbnQpLCBpID0gMDtcbiAgICB3aGlsZSAoJGVsICYmICRlbCAhPT0gZG9jKSB7XG4gICAgICBjYigvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oJGVsKSwgaSk7XG4gICAgICAkZWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oJGVsLnBhcmVudEVsZW1lbnQpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGdldE1hdHJpeCgpIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgRE9NTWF0cml4KCk7XG4gICAgdGhpcy50cmF2ZXJzZVVwKCRlbCA9PiB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1WYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUoJGVsKS50cmFuc2Zvcm07XG4gICAgICBpZiAodHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZWxNYXRyaXggPSBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybVZhbHVlKTtcbiAgICAgICAgbWF0cml4LnByZU11bHRpcGx5U2VsZihlbE1hdHJpeCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLnRyYXZlcnNlVXAoKCRlbCwgaSkgPT4ge1xuICAgICAgdGhpcy5pbmxpbmVUcmFuc2Zvcm1zW2ldID0gJGVsLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICRlbC5zdHlsZS50cmFuc2Zvcm0gPSAnbm9uZSc7XG4gICAgfSk7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy50cmF2ZXJzZVVwKCgkZWwsIGkpID0+IHtcbiAgICAgIGNvbnN0IGN0ID0gdGhpcy5pbmxpbmVUcmFuc2Zvcm1zW2ldO1xuICAgICAgaWYgKGN0ID09PSAnJykge1xuICAgICAgICAkZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zZm9ybScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsLnN0eWxlLnRyYW5zZm9ybSA9IGN0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtBcnJheTxOdW1iZXI+fERPTVRhcmdldFNlbGVjdG9yfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXN9IFRcbiAqIEBwYXJhbSB7VCB8ICgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IFQpfSB2YWx1ZVxuICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZVxuICogQHJldHVybiB7VH1cbiAqL1xuY29uc3QgcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlciA9ICh2YWx1ZSwgZHJhZ2dhYmxlKSA9PiB2YWx1ZSAmJiBpc0ZuYyh2YWx1ZSkgPyAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkoZHJhZ2dhYmxlKSA6IHZhbHVlO1xuXG5sZXQgekluZGV4ID0gMDtcblxuY2xhc3MgRHJhZ2dhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRcbiAgICogQHBhcmFtIHtEcmFnZ2FibGVQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIGlmIChzY29wZS5jdXJyZW50KSBzY29wZS5jdXJyZW50LnJlZ2lzdGVyKHRoaXMpO1xuICAgIGNvbnN0IHBhcmFtWCA9IHBhcmFtZXRlcnMueDtcbiAgICBjb25zdCBwYXJhbVkgPSBwYXJhbWV0ZXJzLnk7XG4gICAgY29uc3QgdHJpZ2dlciA9IHBhcmFtZXRlcnMudHJpZ2dlcjtcbiAgICBjb25zdCBtb2RpZmllciA9IHBhcmFtZXRlcnMubW9kaWZpZXI7XG4gICAgY29uc3QgZWFzZSA9IHBhcmFtZXRlcnMucmVsZWFzZUVhc2U7XG4gICAgY29uc3QgY3VzdG9tRWFzZSA9IGVhc2UgJiYgcGFyc2VFYXNpbmdzKGVhc2UpO1xuICAgIGNvbnN0IGhhc1NwcmluZyA9ICFpc1VuZChlYXNlKSAmJiAhaXNVbmQoLyoqIEB0eXBlIHtTcHJpbmd9ICovKGVhc2UpLmVhc2UpO1xuICAgIGNvbnN0IHhQcm9wID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKGlzT2JqKHBhcmFtWCkgJiYgIWlzVW5kKC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhwYXJhbVgpLm1hcFRvKSA/IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhwYXJhbVgpLm1hcFRvIDogJ3RyYW5zbGF0ZVgnKTtcbiAgICBjb25zdCB5UHJvcCA9IC8qKiBAdHlwZSB7U3RyaW5nfSAqLyhpc09iaihwYXJhbVkpICYmICFpc1VuZCgvKiogQHR5cGUge09iamVjdH0gKi8ocGFyYW1ZKS5tYXBUbykgPyAvKiogQHR5cGUge09iamVjdH0gKi8ocGFyYW1ZKS5tYXBUbyA6ICd0cmFuc2xhdGVZJyk7XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbWV0ZXJzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgdGhpcy5jb250YWluZXJBcnJheSA9IGlzQXJyKGNvbnRhaW5lcikgPyBjb250YWluZXIgOiBudWxsO1xuICAgIHRoaXMuJGNvbnRhaW5lciA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGNvbnRhaW5lciAmJiAhdGhpcy5jb250YWluZXJBcnJheSA/IHBhcnNlVGFyZ2V0cygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oY29udGFpbmVyKSlbMF0gOiBkb2MuYm9keSk7XG4gICAgdGhpcy51c2VXaW4gPSB0aGlzLiRjb250YWluZXIgPT09IGRvYy5ib2R5O1xuICAgIC8qKiBAdHlwZSB7V2luZG93IHwgSFRNTEVsZW1lbnR9ICovXG4gICAgdGhpcy4kc2Nyb2xsQ29udGFpbmVyID0gdGhpcy51c2VXaW4gPyB3aW4gOiB0aGlzLiRjb250YWluZXI7XG4gICAgdGhpcy4kdGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oaXNPYmoodGFyZ2V0KSA/IG5ldyBET01Qcm94eSh0YXJnZXQpIDogcGFyc2VUYXJnZXRzKHRhcmdldClbMF0pO1xuICAgIHRoaXMuJHRyaWdnZXIgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhwYXJzZVRhcmdldHModHJpZ2dlciA/IHRyaWdnZXIgOiB0YXJnZXQpWzBdKTtcbiAgICB0aGlzLmZpeGVkID0gZ2V0VGFyZ2V0VmFsdWUodGhpcy4kdGFyZ2V0LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJztcbiAgICAvLyBSZWZyZXNoYWJsZSBwYXJhbWV0ZXJzXG4gICAgdGhpcy5pc0ZpbmVQb2ludGVyID0gdHJ1ZTtcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuY29udGFpbmVyUGFkZGluZyA9IFswLCAwLCAwLCAwXTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmNvbnRhaW5lckZyaWN0aW9uID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnJlbGVhc2VDb250YWluZXJGcmljdGlvbiA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ8QXJyYXk8TnVtYmVyPn0gKi9cbiAgICB0aGlzLnNuYXBYID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcnxBcnJheTxOdW1iZXI+fSAqL1xuICAgIHRoaXMuc25hcFkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsVGhyZXNob2xkID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmRyYWdTcGVlZCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5tYXhWZWxvY2l0eSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5taW5WZWxvY2l0eSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy52ZWxvY2l0eU11bHRpcGxpZXIgPSAwO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXN9ICovXG4gICAgdGhpcy5jdXJzb3IgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge1NwcmluZ30gKi9cbiAgICB0aGlzLnJlbGVhc2VYU3ByaW5nID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGVhc2UpIDogY3JlYXRlU3ByaW5nKHtcbiAgICAgIG1hc3M6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZU1hc3MsIDEpLFxuICAgICAgc3RpZmZuZXNzOiBzZXRWYWx1ZShwYXJhbWV0ZXJzLnJlbGVhc2VTdGlmZm5lc3MsIDgwKSxcbiAgICAgIGRhbXBpbmc6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZURhbXBpbmcsIDIwKSxcbiAgICB9KTtcbiAgICAvKiogQHR5cGUge1NwcmluZ30gKi9cbiAgICB0aGlzLnJlbGVhc2VZU3ByaW5nID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGVhc2UpIDogY3JlYXRlU3ByaW5nKHtcbiAgICAgIG1hc3M6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZU1hc3MsIDEpLFxuICAgICAgc3RpZmZuZXNzOiBzZXRWYWx1ZShwYXJhbWV0ZXJzLnJlbGVhc2VTdGlmZm5lc3MsIDgwKSxcbiAgICAgIGRhbXBpbmc6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZURhbXBpbmcsIDIwKSxcbiAgICB9KTtcbiAgICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMucmVsZWFzZUVhc2UgPSBjdXN0b21FYXNlIHx8IGVhc2VzLm91dFF1aW50O1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmhhc1JlbGVhc2VTcHJpbmcgPSBoYXNTcHJpbmc7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uR3JhYiA9IHBhcmFtZXRlcnMub25HcmFiIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uRHJhZyA9IHBhcmFtZXRlcnMub25EcmFnIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uUmVsZWFzZSA9IHBhcmFtZXRlcnMub25SZWxlYXNlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uVXBkYXRlID0gcGFyYW1ldGVycy5vblVwZGF0ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblNldHRsZSA9IHBhcmFtZXRlcnMub25TZXR0bGUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25TbmFwID0gcGFyYW1ldGVycy5vblNuYXAgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25SZXNpemUgPSBwYXJhbWV0ZXJzLm9uUmVzaXplIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uQWZ0ZXJSZXNpemUgPSBwYXJhbWV0ZXJzLm9uQWZ0ZXJSZXNpemUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5kaXNhYmxlZCA9IFswLCAwXTtcbiAgICAvKiogQHR5cGUge0FuaW1hdGFibGVQYXJhbXN9ICovXG4gICAgY29uc3QgYW5pbWF0YWJsZVBhcmFtcyA9IHt9O1xuICAgIGlmIChtb2RpZmllcikgYW5pbWF0YWJsZVBhcmFtcy5tb2RpZmllciA9IG1vZGlmaWVyO1xuICAgIGlmIChpc1VuZChwYXJhbVgpIHx8IHBhcmFtWCA9PT0gdHJ1ZSkge1xuICAgICAgYW5pbWF0YWJsZVBhcmFtc1t4UHJvcF0gPSAwO1xuICAgIH0gZWxzZSBpZiAoaXNPYmoocGFyYW1YKSkge1xuICAgICAgY29uc3QgcGFyYW1YT2JqZWN0ID0gLyoqIEB0eXBlIHtEcmFnZ2FibGVBeGlzUGFyYW19ICovKHBhcmFtWCk7XG4gICAgICBjb25zdCBhbmltYXRhYmxlWFBhcmFtcyA9IHt9O1xuICAgICAgaWYgKHBhcmFtWE9iamVjdC5tb2RpZmllcikgYW5pbWF0YWJsZVhQYXJhbXMubW9kaWZpZXIgPSBwYXJhbVhPYmplY3QubW9kaWZpZXI7XG4gICAgICBpZiAocGFyYW1YT2JqZWN0LmNvbXBvc2l0aW9uKSBhbmltYXRhYmxlWFBhcmFtcy5jb21wb3NpdGlvbiA9IHBhcmFtWE9iamVjdC5jb21wb3NpdGlvbjtcbiAgICAgIGFuaW1hdGFibGVQYXJhbXNbeFByb3BdID0gYW5pbWF0YWJsZVhQYXJhbXM7XG4gICAgfSBlbHNlIGlmIChwYXJhbVggPT09IGZhbHNlKSB7XG4gICAgICBhbmltYXRhYmxlUGFyYW1zW3hQcm9wXSA9IDA7XG4gICAgICB0aGlzLmRpc2FibGVkWzBdID0gMTtcbiAgICB9XG4gICAgaWYgKGlzVW5kKHBhcmFtWSkgfHwgcGFyYW1ZID09PSB0cnVlKSB7XG4gICAgICBhbmltYXRhYmxlUGFyYW1zW3lQcm9wXSA9IDA7XG4gICAgfSBlbHNlIGlmIChpc09iaihwYXJhbVkpKSB7XG4gICAgICBjb25zdCBwYXJhbVlPYmplY3QgPSAvKiogQHR5cGUge0RyYWdnYWJsZUF4aXNQYXJhbX0gKi8ocGFyYW1ZKTtcbiAgICAgIGNvbnN0IGFuaW1hdGFibGVZUGFyYW1zID0ge307XG4gICAgICBpZiAocGFyYW1ZT2JqZWN0Lm1vZGlmaWVyKSBhbmltYXRhYmxlWVBhcmFtcy5tb2RpZmllciA9IHBhcmFtWU9iamVjdC5tb2RpZmllcjtcbiAgICAgIGlmIChwYXJhbVlPYmplY3QuY29tcG9zaXRpb24pIGFuaW1hdGFibGVZUGFyYW1zLmNvbXBvc2l0aW9uID0gcGFyYW1ZT2JqZWN0LmNvbXBvc2l0aW9uO1xuICAgICAgYW5pbWF0YWJsZVBhcmFtc1t5UHJvcF0gPSBhbmltYXRhYmxlWVBhcmFtcztcbiAgICB9IGVsc2UgaWYgKHBhcmFtWSA9PT0gZmFsc2UpIHtcbiAgICAgIGFuaW1hdGFibGVQYXJhbXNbeVByb3BdID0gMDtcbiAgICAgIHRoaXMuZGlzYWJsZWRbMV0gPSAxO1xuICAgIH1cbiAgICAvKiogQHR5cGUge0FuaW1hdGFibGVPYmplY3R9ICovXG4gICAgdGhpcy5hbmltYXRlID0gLyoqIEB0eXBlIHtBbmltYXRhYmxlT2JqZWN0fSAqLyhuZXcgQW5pbWF0YWJsZSh0aGlzLiR0YXJnZXQsIGFuaW1hdGFibGVQYXJhbXMpKTtcbiAgICAvLyBJbnRlcm5hbCBwcm9wc1xuICAgIHRoaXMueFByb3AgPSB4UHJvcDtcbiAgICB0aGlzLnlQcm9wID0geVByb3A7XG4gICAgdGhpcy5kZXN0WCA9IDA7XG4gICAgdGhpcy5kZXN0WSA9IDA7XG4gICAgdGhpcy5kZWx0YVggPSAwO1xuICAgIHRoaXMuZGVsdGFZID0gMDtcbiAgICB0aGlzLnNjcm9sbCA9IHt4OiAwLCB5OiAwfTtcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuY29vcmRzID0gW3RoaXMueCwgdGhpcy55LCAwLCAwXTsgLy8geCwgeSwgdGVtcCB4LCB0ZW1wIHlcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5zbmFwcGVkID0gWzAsIDBdOyAvLyB4LCB5XG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMucG9pbnRlciA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTsgLy8geDEsIHkxLCB4MiwgeTIsIHRlbXAgeDEsIHRlbXAgeTEsIHRlbXAgeDIsIHRlbXAgeTJcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5zY3JvbGxWaWV3ID0gWzAsIDBdOyAvLyB3LCBoXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLmRyYWdBcmVhID0gWzAsIDAsIDAsIDBdOyAvLyB4LCB5LCB3LCBoXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLmNvbnRhaW5lckJvdW5kcyA9IFstbWF4VmFsdWUsIG1heFZhbHVlLCBtYXhWYWx1ZSwgLW1heFZhbHVlXTsgLy8gdCwgciwgYiwgbFxuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5zY3JvbGxCb3VuZHMgPSBbMCwgMCwgMCwgMF07IC8vIHQsIHIsIGIsIGxcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMudGFyZ2V0Qm91bmRzID0gWzAsIDAsIDAsIDBdOyAvLyB0LCByLCBiLCBsXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMud2luZG93ID0gWzAsIDBdOyAvLyB3LCBoXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrID0gWzAsIDAsIDBdO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnZlbG9jaXR5VGltZSA9IG5vdygpO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy5jdXJzb3JTdHlsZXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL1xuICAgIHRoaXMuYm9keVN0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLnRhcmdldFN0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLnRvdWNoQWN0aW9uU3R5bGVzID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgVHJhbnNmb3Jtcyh0aGlzLiR0YXJnZXQpO1xuICAgIHRoaXMub3ZlcnNob290Q29vcmRzID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5vdmVyc2hvb3RUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgb25VcGRhdGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYW51YWwgPSB0cnVlO1xuICAgICAgICAvLyBVc2UgYSBkdXJhdGlvbiBvZiAxIHRvIHByZXZlbnQgdGhlIGFuaW1hdGFibGUgZnJvbSBjb21wbGV0aW5nIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgaXNzdWVzIHdpdGggb25TZXR0bGUoKVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWFuZ2Fybmllci9hbmltZS9pc3N1ZXMvMTA0NVxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWRbMF0pIHRoaXMuYW5pbWF0ZVt0aGlzLnhQcm9wXSh0aGlzLm92ZXJzaG9vdENvb3Jkcy54LCAxKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkWzFdKSB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0odGhpcy5vdmVyc2hvb3RDb29yZHMueSwgMSk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLm1hbnVhbCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWRbMF0pIHRoaXMuYW5pbWF0ZVt0aGlzLnhQcm9wXSh0aGlzLm92ZXJzaG9vdENvb3Jkcy54LCAwKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkWzFdKSB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0odGhpcy5vdmVyc2hvb3RDb29yZHMueSwgMCk7XG4gICAgICB9LFxuICAgIH0sIG51bGwsIDApLmluaXQoKTtcbiAgICB0aGlzLnVwZGF0ZVRpY2tlciA9IG5ldyBUaW1lcih7IGF1dG9wbGF5OiBmYWxzZSwgb25VcGRhdGU6ICgpID0+IHRoaXMudXBkYXRlKCkgfSwgbnVsbCwwLCkuaW5pdCgpO1xuICAgIHRoaXMuY29udGFpbmVkID0gIWlzVW5kKGNvbnRhaW5lcik7XG4gICAgdGhpcy5tYW51YWwgPSBmYWxzZTtcbiAgICB0aGlzLmdyYWJiZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5hY3RpdmVQcm9wID0gdGhpcy5kaXNhYmxlZFsxXSA/IHhQcm9wIDogeVByb3A7XG4gICAgdGhpcy5hbmltYXRlLmNhbGxiYWNrcy5vblJlbmRlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc1VwZGF0ZWQgPSB0aGlzLnVwZGF0ZWQ7XG4gICAgICBjb25zdCBoYXNNb3ZlZCA9IHRoaXMuZ3JhYmJlZCAmJiBoYXNVcGRhdGVkO1xuICAgICAgY29uc3QgaGFzUmVsZWFzZWQgPSAhaGFzTW92ZWQgJiYgdGhpcy5yZWxlYXNlZDtcbiAgICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgICAgY29uc3QgZHggPSB4IC0gdGhpcy5jb29yZHNbMl07XG4gICAgICBjb25zdCBkeSA9IHkgLSB0aGlzLmNvb3Jkc1szXTtcbiAgICAgIHRoaXMuZGVsdGFYID0gZHg7XG4gICAgICB0aGlzLmRlbHRhWSA9IGR5O1xuICAgICAgdGhpcy5jb29yZHNbMl0gPSB4O1xuICAgICAgdGhpcy5jb29yZHNbM10gPSB5O1xuICAgICAgLy8gQ2hlY2sgaWYgZHggb3IgZHkgYXJlIG5vdCAwIHRvIGNoZWNrIGlmIHRoZSBkcmFnZ2FibGUgaGFzIGFjdHVhbGx5IG1vdmVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWFuZ2Fybmllci9hbmltZS9pc3N1ZXMvMTAzMlxuICAgICAgaWYgKGhhc1VwZGF0ZWQgJiYgKGR4IHx8IGR5KSkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlKHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNSZWxlYXNlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZVZlbG9jaXR5KGR4LCBkeSk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBhdGFuMihkeSwgZHgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hbmltYXRlLmNhbGxiYWNrcy5vbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKCghdGhpcy5ncmFiYmVkICYmIHRoaXMucmVsZWFzZWQpKSB7XG4gICAgICAgIC8vIFNldCByZWxlYXNlZCB0byBmYWxzZSBiZWZvcmUgY2FsbGluZyBvblNldHRsZSB0byBhdm9pZCByZWN1cnNpb25cbiAgICAgICAgdGhpcy5yZWxlYXNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm1hbnVhbCkge1xuICAgICAgICB0aGlzLmRlbHRhWCA9IDA7XG4gICAgICAgIHRoaXMuZGVsdGFZID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlTdGFja1swXSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlTdGFja1sxXSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlTdGFja1syXSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5vblNldHRsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVzaXplVGlja2VyID0gbmV3IFRpbWVyKHtcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgIGR1cmF0aW9uOiAxNTAgKiBnbG9iYWxzLnRpbWVTY2FsZSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIHRoaXMub25BZnRlclJlc2l6ZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgfSkuaW5pdCgpO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZVRpY2tlci5yZXN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVuYWJsZSgpO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRjb250YWluZXIpO1xuICAgIGlmICghaXNPYmoodGFyZ2V0KSkgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuJHRhcmdldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSBkeFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGR5XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGNvbXB1dGVWZWxvY2l0eShkeCwgZHkpIHtcbiAgICBjb25zdCBwcmV2VGltZSA9IHRoaXMudmVsb2NpdHlUaW1lO1xuICAgIGNvbnN0IGN1clRpbWUgPSBub3coKTtcbiAgICBjb25zdCBlbGFwc2VkID0gY3VyVGltZSAtIHByZXZUaW1lO1xuICAgIGlmIChlbGFwc2VkIDwgMTcpIHJldHVybiB0aGlzLnZlbG9jaXR5O1xuICAgIHRoaXMudmVsb2NpdHlUaW1lID0gY3VyVGltZTtcbiAgICBjb25zdCB2ZWxvY2l0eVN0YWNrID0gdGhpcy52ZWxvY2l0eVN0YWNrO1xuICAgIGNvbnN0IHZNdWwgPSB0aGlzLnZlbG9jaXR5TXVsdGlwbGllcjtcbiAgICBjb25zdCBtaW5WID0gdGhpcy5taW5WZWxvY2l0eTtcbiAgICBjb25zdCBtYXhWID0gdGhpcy5tYXhWZWxvY2l0eTtcbiAgICBjb25zdCB2aSA9IHRoaXMudmVsb2NpdHlTdGFja0luZGV4O1xuICAgIHZlbG9jaXR5U3RhY2tbdmldID0gcm91bmQoY2xhbXAoKHNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gZWxhcHNlZCkgKiB2TXVsLCBtaW5WLCBtYXhWKSwgNSk7XG4gICAgY29uc3QgdmVsb2NpdHkgPSBtYXgodmVsb2NpdHlTdGFja1swXSwgdmVsb2NpdHlTdGFja1sxXSwgdmVsb2NpdHlTdGFja1syXSk7XG4gICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gKHZpICsgMSkgJSAzO1xuICAgIHJldHVybiB2ZWxvY2l0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gIHhcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbXV0ZVVwZGF0ZUNhbGxiYWNrXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0WCh4LCBtdXRlVXBkYXRlQ2FsbGJhY2sgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkWzBdKSByZXR1cm47XG4gICAgY29uc3QgdiA9IHJvdW5kKHgsIDUpO1xuICAgIHRoaXMub3ZlcnNob290VGlja2VyLnBhdXNlKCk7XG4gICAgdGhpcy5tYW51YWwgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlZCA9ICFtdXRlVXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5kZXN0WCA9IHY7XG4gICAgdGhpcy5zbmFwcGVkWzBdID0gc25hcCh2LCB0aGlzLnNuYXBYKTtcbiAgICB0aGlzLmFuaW1hdGVbdGhpcy54UHJvcF0odiwgMCk7XG4gICAgdGhpcy5tYW51YWwgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gIHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbXV0ZVVwZGF0ZUNhbGxiYWNrXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0WSh5LCBtdXRlVXBkYXRlQ2FsbGJhY2sgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkWzFdKSByZXR1cm47XG4gICAgY29uc3QgdiA9IHJvdW5kKHksIDUpO1xuICAgIHRoaXMub3ZlcnNob290VGlja2VyLnBhdXNlKCk7XG4gICAgdGhpcy5tYW51YWwgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlZCA9ICFtdXRlVXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5kZXN0WSA9IHY7XG4gICAgdGhpcy5zbmFwcGVkWzFdID0gc25hcCh2LCB0aGlzLnNuYXBZKTtcbiAgICB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0odiwgMCk7XG4gICAgdGhpcy5tYW51YWwgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCB4KCkge1xuICAgIHJldHVybiByb3VuZCgvKiogQHR5cGUge051bWJlcn0gKi8odGhpcy5hbmltYXRlW3RoaXMueFByb3BdKCkpLCBnbG9iYWxzLnByZWNpc2lvbik7XG4gIH1cblxuICBzZXQgeCh4KSB7XG4gICAgdGhpcy5zZXRYKHgsIGZhbHNlKTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiByb3VuZCgvKiogQHR5cGUge051bWJlcn0gKi8odGhpcy5hbmltYXRlW3RoaXMueVByb3BdKCkpLCBnbG9iYWxzLnByZWNpc2lvbik7XG4gIH1cblxuICBzZXQgeSh5KSB7XG4gICAgdGhpcy5zZXRZKHksIGZhbHNlKTtcbiAgfVxuXG4gIGdldCBwcm9ncmVzc1goKSB7XG4gICAgcmV0dXJuIG1hcFJhbmdlKHRoaXMueCwgdGhpcy5jb250YWluZXJCb3VuZHNbM10sIHRoaXMuY29udGFpbmVyQm91bmRzWzFdLCAwLCAxKTtcbiAgfVxuXG4gIHNldCBwcm9ncmVzc1goeCkge1xuICAgIHRoaXMuc2V0WChtYXBSYW5nZSh4LCAwLCAxLCB0aGlzLmNvbnRhaW5lckJvdW5kc1szXSwgdGhpcy5jb250YWluZXJCb3VuZHNbMV0pLCBmYWxzZSk7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3NZKCkge1xuICAgIHJldHVybiBtYXBSYW5nZSh0aGlzLnksIHRoaXMuY29udGFpbmVyQm91bmRzWzBdLCB0aGlzLmNvbnRhaW5lckJvdW5kc1syXSwgMCwgMSk7XG4gIH1cblxuICBzZXQgcHJvZ3Jlc3NZKHkpIHtcbiAgICB0aGlzLnNldFkobWFwUmFuZ2UoeSwgMCwgMSwgdGhpcy5jb250YWluZXJCb3VuZHNbMF0sIHRoaXMuY29udGFpbmVyQm91bmRzWzJdKSwgZmFsc2UpO1xuICB9XG5cbiAgdXBkYXRlU2Nyb2xsQ29vcmRzKCkge1xuICAgIGNvbnN0IHN4ID0gcm91bmQodGhpcy51c2VXaW4gPyB3aW4uc2Nyb2xsWCA6IHRoaXMuJGNvbnRhaW5lci5zY3JvbGxMZWZ0LCAwKTtcbiAgICBjb25zdCBzeSA9IHJvdW5kKHRoaXMudXNlV2luID8gd2luLnNjcm9sbFkgOiB0aGlzLiRjb250YWluZXIuc2Nyb2xsVG9wLCAwKTtcbiAgICBjb25zdCBbIGNwdCwgY3ByLCBjcGIsIGNwbCBdID0gdGhpcy5jb250YWluZXJQYWRkaW5nO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuc2Nyb2xsVGhyZXNob2xkO1xuICAgIHRoaXMuc2Nyb2xsLnggPSBzeDtcbiAgICB0aGlzLnNjcm9sbC55ID0gc3k7XG4gICAgdGhpcy5zY3JvbGxCb3VuZHNbMF0gPSBzeSAtIHRoaXMudGFyZ2V0Qm91bmRzWzBdICsgY3B0IC0gdGhyZXNob2xkO1xuICAgIHRoaXMuc2Nyb2xsQm91bmRzWzFdID0gc3ggLSB0aGlzLnRhcmdldEJvdW5kc1sxXSAtIGNwciArIHRocmVzaG9sZDtcbiAgICB0aGlzLnNjcm9sbEJvdW5kc1syXSA9IHN5IC0gdGhpcy50YXJnZXRCb3VuZHNbMl0gLSBjcGIgKyB0aHJlc2hvbGQ7XG4gICAgdGhpcy5zY3JvbGxCb3VuZHNbM10gPSBzeCAtIHRoaXMudGFyZ2V0Qm91bmRzWzNdICsgY3BsIC0gdGhyZXNob2xkO1xuICB9XG5cbiAgdXBkYXRlQm91bmRpbmdWYWx1ZXMoKSB7XG4gICAgY29uc3QgJGNvbnRhaW5lciA9IHRoaXMuJGNvbnRhaW5lcjtcbiAgICAvLyBSZXR1cm4gZWFybHkgaWYgbm8gJGNvbnRhaW5lciBkZWZpbmVkIHRvIHByZXZlbnRzIGVycm9yIHdoZW4gcmVhZGluZyBzY3JvbGxXaWR0aCAvIHNjcm9sbEhlaWdodFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWxpYW5nYXJuaWVyL2FuaW1lL2lzc3Vlcy8xMDY0XG4gICAgaWYgKCEkY29udGFpbmVyKSByZXR1cm47XG4gICAgY29uc3QgY3ggPSB0aGlzLng7XG4gICAgY29uc3QgY3kgPSB0aGlzLnk7XG4gICAgY29uc3QgY3gyID0gdGhpcy5jb29yZHNbMl07XG4gICAgY29uc3QgY3kyID0gIHRoaXMuY29vcmRzWzNdO1xuICAgIC8vIFByZXZlbnRzIGludGVyZmVyaW5nIHdpdGggdGhlIHNjcm9sbCBhcmVhIGluIGNhc2VzIHRoZSB0YXJnZXQgaXMgb3V0c2lkZSBvZiB0aGUgY29udGFpbmVyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0ZW1wIGNvb3JkcyBhcmUgYWxzbyBhZGp1c2V0IHRvIHByZXZlbnRzIHdyb25nIGRlbHRhIGNhbGN1bGF0aW9uIG9uIHVwZGF0ZXNcbiAgICB0aGlzLmNvb3Jkc1syXSA9IDA7XG4gICAgdGhpcy5jb29yZHNbM10gPSAwO1xuICAgIHRoaXMuc2V0WCgwLCB0cnVlKTtcbiAgICB0aGlzLnNldFkoMCwgdHJ1ZSk7XG4gICAgdGhpcy50cmFuc2Zvcm1zLnJlbW92ZSgpO1xuICAgIGNvbnN0IGl3ID0gdGhpcy53aW5kb3dbMF0gPSB3aW4uaW5uZXJXaWR0aDtcbiAgICBjb25zdCBpaCA9IHRoaXMud2luZG93WzFdID0gd2luLmlubmVySGVpZ2h0O1xuICAgIGNvbnN0IHV3ID0gdGhpcy51c2VXaW47XG4gICAgY29uc3Qgc3cgPSAkY29udGFpbmVyLnNjcm9sbFdpZHRoO1xuICAgIGNvbnN0IHNoID0gJGNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgY29uc3QgZnggPSB0aGlzLmZpeGVkO1xuICAgIGNvbnN0IHRyYW5zZm9ybUNvbnRhaW5lclJlY3QgPSAkY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IFsgY3B0LCBjcHIsIGNwYiwgY3BsIF0gPSB0aGlzLmNvbnRhaW5lclBhZGRpbmc7XG4gICAgdGhpcy5kcmFnQXJlYVswXSA9IHV3ID8gMCA6IHRyYW5zZm9ybUNvbnRhaW5lclJlY3QubGVmdDtcbiAgICB0aGlzLmRyYWdBcmVhWzFdID0gdXcgPyAwIDogdHJhbnNmb3JtQ29udGFpbmVyUmVjdC50b3A7XG4gICAgdGhpcy5zY3JvbGxWaWV3WzBdID0gdXcgPyBjbGFtcChzdywgaXcsIHN3KSA6IHN3O1xuICAgIHRoaXMuc2Nyb2xsVmlld1sxXSA9IHV3ID8gY2xhbXAoc2gsIGloLCBzaCkgOiBzaDtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH0gPSAkY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuZHJhZ0FyZWFbMl0gPSByb3VuZCh1dyA/IGNsYW1wKHdpZHRoLCBpdywgaXcpIDogd2lkdGgsIDApO1xuICAgIHRoaXMuZHJhZ0FyZWFbM10gPSByb3VuZCh1dyA/IGNsYW1wKGhlaWdodCwgaWgsIGloKSA6IGhlaWdodCwgMCk7XG4gICAgY29uc3QgY29udGFpbmVyT3ZlcmZsb3cgPSBnZXRUYXJnZXRWYWx1ZSgkY29udGFpbmVyLCAnb3ZlcmZsb3cnKTtcbiAgICBjb25zdCB2aXNpYmxlT3ZlcmZsb3cgPSBjb250YWluZXJPdmVyZmxvdyA9PT0gJ3Zpc2libGUnO1xuICAgIGNvbnN0IGhpZGRlbk92ZXJmbG93ID0gY29udGFpbmVyT3ZlcmZsb3cgPT09ICdoaWRkZW4nO1xuICAgIHRoaXMuY2FuU2Nyb2xsID0gZnggPyBmYWxzZSA6XG4gICAgICB0aGlzLmNvbnRhaW5lZCAmJlxuICAgICAgKCgkY29udGFpbmVyID09PSBkb2MuYm9keSAmJiB2aXNpYmxlT3ZlcmZsb3cpIHx8ICghaGlkZGVuT3ZlcmZsb3cgJiYgIXZpc2libGVPdmVyZmxvdykpICYmXG4gICAgICAoc3cgPiB0aGlzLmRyYWdBcmVhWzJdICsgY3BsIC0gY3ByIHx8IHNoID4gdGhpcy5kcmFnQXJlYVszXSArIGNwdCAtIGNwYikgJiZcbiAgICAgICghdGhpcy5jb250YWluZXJBcnJheSB8fCAodGhpcy5jb250YWluZXJBcnJheSAmJiAhaXNBcnIodGhpcy5jb250YWluZXJBcnJheSkpKTtcbiAgICBpZiAodGhpcy5jb250YWluZWQpIHtcbiAgICAgIGNvbnN0IHN4ID0gdGhpcy5zY3JvbGwueDtcbiAgICAgIGNvbnN0IHN5ID0gdGhpcy5zY3JvbGwueTtcbiAgICAgIGNvbnN0IGNhblNjcm9sbCA9IHRoaXMuY2FuU2Nyb2xsO1xuICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRoaXMuJHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGhpZGRlbkxlZnQgPSBjYW5TY3JvbGwgPyB1dyA/IDAgOiAkY29udGFpbmVyLnNjcm9sbExlZnQgOiAwO1xuICAgICAgY29uc3QgaGlkZGVuVG9wID0gY2FuU2Nyb2xsID8gdXcgPyAwIDogJGNvbnRhaW5lci5zY3JvbGxUb3AgOiAwO1xuICAgICAgY29uc3QgaGlkZGVuUmlnaHQgPSBjYW5TY3JvbGwgPyB0aGlzLnNjcm9sbFZpZXdbMF0gLSBoaWRkZW5MZWZ0IC0gd2lkdGggOiAwO1xuICAgICAgY29uc3QgaGlkZGVuQm90dG9tID0gY2FuU2Nyb2xsID8gdGhpcy5zY3JvbGxWaWV3WzFdIC0gaGlkZGVuVG9wIC0gaGVpZ2h0IDogMDtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzBdID0gcm91bmQoKHRhcmdldFJlY3QudG9wICsgc3kpIC0gKHV3ID8gMCA6IHRvcCksIDApO1xuICAgICAgdGhpcy50YXJnZXRCb3VuZHNbMV0gPSByb3VuZCgodGFyZ2V0UmVjdC5yaWdodCArIHN4KSAtICh1dyA/IGl3IDogcmlnaHQpLCAwKTtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzJdID0gcm91bmQoKHRhcmdldFJlY3QuYm90dG9tICsgc3kpIC0gKHV3ID8gaWggOiBib3R0b20pLCAwKTtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzNdID0gcm91bmQoKHRhcmdldFJlY3QubGVmdCArIHN4KSAtICh1dyA/IDAgOiBsZWZ0KSwgMCk7XG4gICAgICBpZiAodGhpcy5jb250YWluZXJBcnJheSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSA9IHRoaXMuY29udGFpbmVyQXJyYXlbMF0gKyBjcHQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzFdID0gdGhpcy5jb250YWluZXJBcnJheVsxXSAtIGNwcjtcbiAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZHNbMl0gPSB0aGlzLmNvbnRhaW5lckFycmF5WzJdIC0gY3BiO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1szXSA9IHRoaXMuY29udGFpbmVyQXJyYXlbM10gKyBjcGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSA9IC1yb3VuZCh0YXJnZXRSZWN0LnRvcCAtIChmeCA/IGNsYW1wKHRvcCwgMCwgaWgpIDogdG9wKSArIGhpZGRlblRvcCAtIGNwdCwgMCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzFdID0gLXJvdW5kKHRhcmdldFJlY3QucmlnaHQgLSAoZnggPyBjbGFtcChyaWdodCwgMCwgaXcpIDogcmlnaHQpIC0gaGlkZGVuUmlnaHQgKyBjcHIsIDApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1syXSA9IC1yb3VuZCh0YXJnZXRSZWN0LmJvdHRvbSAtIChmeCA/IGNsYW1wKGJvdHRvbSwgMCwgaWgpIDogYm90dG9tKSAtIGhpZGRlbkJvdHRvbSArIGNwYiwgMCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzNdID0gLXJvdW5kKHRhcmdldFJlY3QubGVmdCAtIChmeCA/IGNsYW1wKGxlZnQsIDAsIGl3KSA6IGxlZnQpICsgaGlkZGVuTGVmdCAtIGNwbCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3Jtcy5yZXZlcnQoKTtcbiAgICAvLyBSZXN0b3JlIGNvb3JkaW5hdGVzXG4gICAgdGhpcy5jb29yZHNbMl0gPSBjeDI7XG4gICAgdGhpcy5jb29yZHNbM10gPSBjeTI7XG4gICAgdGhpcy5zZXRYKGN4LCB0cnVlKTtcbiAgICB0aGlzLnNldFkoY3ksIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0FycmF5fSBib3VuZHNcbiAgICogQHBhcmFtICB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBpc091dE9mQm91bmRzKGJvdW5kcywgeCwgeSkge1xuICAgIC8vIFJldHVybnMgMCBpZiBub3QgT0IsIDEgaWYgeCBpcyBPQiwgMiBpZiB5IGlzIE9CLCAzIGlmIGJvdGggeCBhbmQgeSBhcmUgT0JcbiAgICBpZiAoIXRoaXMuY29udGFpbmVkKSByZXR1cm4gMDtcbiAgICBjb25zdCBbIGJ0LCBiciwgYmIsIGJsIF0gPSBib3VuZHM7XG4gICAgY29uc3QgWyBkeCwgZHkgXSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgY29uc3Qgb2J4ID0gIWR4ICYmIHggPCBibCB8fCAhZHggJiYgeCA+IGJyO1xuICAgIGNvbnN0IG9ieSA9ICFkeSAmJiB5IDwgYnQgfHwgIWR5ICYmIHkgPiBiYjtcbiAgICByZXR1cm4gb2J4ICYmICFvYnkgPyAxIDogIW9ieCAmJiBvYnkgPyAyIDogb2J4ICYmIG9ieSA/IDMgOiAwO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtZXRlcnM7XG4gICAgY29uc3QgcGFyYW1YID0gcGFyYW1zLng7XG4gICAgY29uc3QgcGFyYW1ZID0gcGFyYW1zLnk7XG4gICAgY29uc3QgY29udGFpbmVyID0gcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuY29udGFpbmVyLCB0aGlzKTtcbiAgICBjb25zdCBjcCA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLmNvbnRhaW5lclBhZGRpbmcsIHRoaXMpIHx8IDA7XG4gICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovKGlzQXJyKGNwKSA/IGNwIDogW2NwLCBjcCwgY3AsIGNwXSk7XG4gICAgY29uc3QgY3ggPSB0aGlzLng7XG4gICAgY29uc3QgY3kgPSB0aGlzLnk7XG4gICAgY29uc3QgcGFyc2VkQ3Vyc29yU3R5bGVzID0gcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuY3Vyc29yLCB0aGlzKTtcbiAgICBjb25zdCBjdXJzb3JTdHlsZXMgPSB7IG9uSG92ZXI6ICdncmFiJywgb25HcmFiOiAnZ3JhYmJpbmcnIH07XG4gICAgaWYgKHBhcnNlZEN1cnNvclN0eWxlcykge1xuICAgICAgY29uc3QgeyBvbkhvdmVyLCBvbkdyYWIgfSA9IC8qKiBAdHlwZSB7RHJhZ2dhYmxlQ3Vyc29yUGFyYW1zfSAqLyhwYXJzZWRDdXJzb3JTdHlsZXMpO1xuICAgICAgaWYgKG9uSG92ZXIpIGN1cnNvclN0eWxlcy5vbkhvdmVyID0gb25Ib3ZlcjtcbiAgICAgIGlmIChvbkdyYWIpIGN1cnNvclN0eWxlcy5vbkdyYWIgPSBvbkdyYWI7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyQXJyYXkgPSBpc0Fycihjb250YWluZXIpID8gY29udGFpbmVyIDogbnVsbDtcbiAgICB0aGlzLiRjb250YWluZXIgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhjb250YWluZXIgJiYgIXRoaXMuY29udGFpbmVyQXJyYXkgPyBwYXJzZVRhcmdldHMoLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKGNvbnRhaW5lcikpWzBdIDogZG9jLmJvZHkpO1xuICAgIHRoaXMudXNlV2luID0gdGhpcy4kY29udGFpbmVyID09PSBkb2MuYm9keTtcbiAgICAvKiogQHR5cGUge1dpbmRvdyB8IEhUTUxFbGVtZW50fSAqL1xuICAgIHRoaXMuJHNjcm9sbENvbnRhaW5lciA9IHRoaXMudXNlV2luID8gd2luIDogdGhpcy4kY29udGFpbmVyO1xuICAgIHRoaXMuaXNGaW5lUG9pbnRlciA9IG1hdGNoTWVkaWEoJyhwb2ludGVyOmZpbmUpJykubWF0Y2hlcztcbiAgICB0aGlzLmNvbnRhaW5lclBhZGRpbmcgPSBzZXRWYWx1ZShjb250YWluZXJQYWRkaW5nLCBbMCwgMCwgMCwgMF0pO1xuICAgIHRoaXMuY29udGFpbmVyRnJpY3Rpb24gPSBjbGFtcChzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5jb250YWluZXJGcmljdGlvbiwgdGhpcyksIC44KSwgMCwgMSk7XG4gICAgdGhpcy5yZWxlYXNlQ29udGFpbmVyRnJpY3Rpb24gPSBjbGFtcChzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5yZWxlYXNlQ29udGFpbmVyRnJpY3Rpb24sIHRoaXMpLCB0aGlzLmNvbnRhaW5lckZyaWN0aW9uKSwgMCwgMSk7XG4gICAgdGhpcy5zbmFwWCA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIoaXNPYmoocGFyYW1YKSAmJiAhaXNVbmQocGFyYW1YLnNuYXApID8gcGFyYW1YLnNuYXAgOiBwYXJhbXMuc25hcCwgdGhpcyk7XG4gICAgdGhpcy5zbmFwWSA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIoaXNPYmoocGFyYW1ZKSAmJiAhaXNVbmQocGFyYW1ZLnNuYXApID8gcGFyYW1ZLnNuYXAgOiBwYXJhbXMuc25hcCwgdGhpcyk7XG4gICAgdGhpcy5zY3JvbGxTcGVlZCA9IHNldFZhbHVlKHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnNjcm9sbFNwZWVkLCB0aGlzKSwgMS41KTtcbiAgICB0aGlzLnNjcm9sbFRocmVzaG9sZCA9IHNldFZhbHVlKHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnNjcm9sbFRocmVzaG9sZCwgdGhpcyksIDIwKTtcbiAgICB0aGlzLmRyYWdTcGVlZCA9IHNldFZhbHVlKHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLmRyYWdTcGVlZCwgdGhpcyksIDEpO1xuICAgIHRoaXMubWluVmVsb2NpdHkgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5taW5WZWxvY2l0eSwgdGhpcyksIDApO1xuICAgIHRoaXMubWF4VmVsb2NpdHkgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5tYXhWZWxvY2l0eSwgdGhpcyksIDUwKTtcbiAgICB0aGlzLnZlbG9jaXR5TXVsdGlwbGllciA9IHNldFZhbHVlKHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnZlbG9jaXR5TXVsdGlwbGllciwgdGhpcyksIDEpO1xuICAgIHRoaXMuY3Vyc29yID0gcGFyc2VkQ3Vyc29yU3R5bGVzID09PSBmYWxzZSA/IGZhbHNlIDogY3Vyc29yU3R5bGVzO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdWYWx1ZXMoKTtcblxuICAgIC8vIGNvbnN0IG9iID0gdGhpcy5pc091dE9mQm91bmRzKHRoaXMuY29udGFpbmVyQm91bmRzLCB0aGlzLngsIHRoaXMueSk7XG4gICAgLy8gaWYgKG9iID09PSAxIHx8IG9iID09PSAzKSB0aGlzLnByb2dyZXNzWCA9IHB4O1xuICAgIC8vIGlmIChvYiA9PT0gMiB8fCBvYiA9PT0gMykgdGhpcy5wcm9ncmVzc1kgPSBweTtcblxuICAgIC8vIGlmICh0aGlzLmluaXRpYWxpemVkICYmIHRoaXMuY29udGFpbmVkKSB7XG4gICAgLy8gICBpZiAodGhpcy5wcm9ncmVzc1ggIT09IHB4KSB0aGlzLnByb2dyZXNzWCA9IHB4O1xuICAgIC8vICAgaWYgKHRoaXMucHJvZ3Jlc3NZICE9PSBweSkgdGhpcy5wcm9ncmVzc1kgPSBweTtcbiAgICAvLyB9XG5cbiAgICBjb25zdCBbIGJ0LCBiciwgYmIsIGJsIF0gPSB0aGlzLmNvbnRhaW5lckJvdW5kcztcbiAgICB0aGlzLnNldFgoY2xhbXAoY3gsIGJsLCBiciksIHRydWUpO1xuICAgIHRoaXMuc2V0WShjbGFtcChjeSwgYnQsIGJiKSwgdHJ1ZSk7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxDb29yZHMoKTtcbiAgICBpZiAodGhpcy5jYW5TY3JvbGwpIHtcbiAgICAgIGNvbnN0IFsgY3B0LCBjcHIsIGNwYiwgY3BsIF0gPSB0aGlzLmNvbnRhaW5lclBhZGRpbmc7XG4gICAgICBjb25zdCBbIHN3LCBzaCBdID0gdGhpcy5zY3JvbGxWaWV3O1xuICAgICAgY29uc3QgZGF3ID0gdGhpcy5kcmFnQXJlYVsyXTtcbiAgICAgIGNvbnN0IGRhaCA9IHRoaXMuZHJhZ0FyZWFbM107XG4gICAgICBjb25zdCBjc3ggPSB0aGlzLnNjcm9sbC54O1xuICAgICAgY29uc3QgY3N5ID0gdGhpcy5zY3JvbGwueTtcbiAgICAgIGNvbnN0IG5zdyA9IHRoaXMuJGNvbnRhaW5lci5zY3JvbGxXaWR0aDtcbiAgICAgIGNvbnN0IG5zaCA9IHRoaXMuJGNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICBjb25zdCBjc3cgPSB0aGlzLnVzZVdpbiA/IGNsYW1wKG5zdywgdGhpcy53aW5kb3dbMF0sIG5zdykgOiBuc3c7XG4gICAgICBjb25zdCBjc2ggPSB0aGlzLnVzZVdpbiA/IGNsYW1wKG5zaCwgdGhpcy53aW5kb3dbMV0sIG5zaCkgOiBuc2g7XG4gICAgICBjb25zdCBzd2QgPSBzdyAtIGNzdztcbiAgICAgIGNvbnN0IHNoZCA9IHNoIC0gY3NoO1xuICAgICAgLy8gSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBzY3JvbGxhcmVhIGRpbWVuc2lvbnMgY2hhbmdlcyBkdXJpbmcgZHJhZ1xuICAgICAgaWYgKHRoaXMuZHJhZ2dlZCAmJiBzd2QgPiAwKSB7XG4gICAgICAgIHRoaXMuY29vcmRzWzBdIC09IHN3ZDtcbiAgICAgICAgdGhpcy5zY3JvbGxWaWV3WzBdID0gY3N3O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZHJhZ2dlZCAmJiBzaGQgPiAwKSB7XG4gICAgICAgIHRoaXMuY29vcmRzWzFdIC09IHNoZDtcbiAgICAgICAgdGhpcy5zY3JvbGxWaWV3WzFdID0gY3NoO1xuICAgICAgfVxuICAgICAgLy8gSGFuZGxlIGF1dG9zY3JvbGwgd2hlbiB0YXJnZXQgaXMgYXQgdGhlIGVkZ2VzIG9mIHRoZSBzY3JvbGwgYm91bmRzXG4gICAgICBjb25zdCBzID0gdGhpcy5zY3JvbGxTcGVlZCAqIDEwO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5zY3JvbGxUaHJlc2hvbGQ7XG4gICAgICBjb25zdCBbIHgsIHkgXSA9IHRoaXMuY29vcmRzO1xuICAgICAgY29uc3QgWyBzdCwgc3IsIHNiLCBzbCBdID0gdGhpcy5zY3JvbGxCb3VuZHM7XG4gICAgICBjb25zdCB0ID0gcm91bmQoY2xhbXAoKHkgLSBzdCArIGNwdCkgLyB0aHJlc2hvbGQsIC0xLCAwKSAqIHMsIDApO1xuICAgICAgY29uc3QgciA9IHJvdW5kKGNsYW1wKCh4IC0gc3IgLSBjcHIpIC8gdGhyZXNob2xkLCAwLCAxKSAqIHMsIDApO1xuICAgICAgY29uc3QgYiA9IHJvdW5kKGNsYW1wKCh5IC0gc2IgLSBjcGIpIC8gdGhyZXNob2xkLCAwLCAxKSAqIHMsIDApO1xuICAgICAgY29uc3QgbCA9IHJvdW5kKGNsYW1wKCh4IC0gc2wgKyBjcGwpIC8gdGhyZXNob2xkLCAtMSwgMCkgKiBzLCAwKTtcbiAgICAgIGlmICh0IHx8IGIgfHwgbCB8fCByKSB7XG4gICAgICAgIGNvbnN0IFtueCwgbnldID0gdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgbGV0IHNjcm9sbFggPSBjc3g7XG4gICAgICAgIGxldCBzY3JvbGxZID0gY3N5O1xuICAgICAgICBpZiAoIW54KSB7XG4gICAgICAgICAgc2Nyb2xsWCA9IHJvdW5kKGNsYW1wKGNzeCArIChsIHx8IHIpLCAwLCBzdyAtIGRhdyksIDApO1xuICAgICAgICAgIHRoaXMuY29vcmRzWzBdIC09IGNzeCAtIHNjcm9sbFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFueSkge1xuICAgICAgICAgIHNjcm9sbFkgPSByb3VuZChjbGFtcChjc3kgKyAodCB8fCBiKSwgMCwgc2ggLSBkYWgpLCAwKTtcbiAgICAgICAgICB0aGlzLmNvb3Jkc1sxXSAtPSBjc3kgLSBzY3JvbGxZO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IFNhZmFyaSBtb2JpbGUgcmVxdWlyZXMgdG8gdXNlIGRpZmZlcmVudCBzY3JvbGwgbWV0aG9kcyBkZXBlbmRpbmcgaWYgdXNpbmcgdGhlIHdpbmRvdyBvciBub3RcbiAgICAgICAgaWYgKHRoaXMudXNlV2luKSB7XG4gICAgICAgICAgdGhpcy4kc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEJ5KC0oY3N4IC0gc2Nyb2xsWCksIC0oY3N5IC0gc2Nyb2xsWSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJHNjcm9sbENvbnRhaW5lci5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbIGN0LCBjciwgY2IsIGNsIF0gPSB0aGlzLmNvbnRhaW5lckJvdW5kcztcbiAgICBjb25zdCBbIHB4MSwgcHkxLCBweDIsIHB5MiwgcHgzLCBweTMgXSA9IHRoaXMucG9pbnRlcjtcbiAgICB0aGlzLmNvb3Jkc1swXSArPSAocHgxIC0gcHgzKSAqIHRoaXMuZHJhZ1NwZWVkO1xuICAgIHRoaXMuY29vcmRzWzFdICs9IChweTEgLSBweTMpICogdGhpcy5kcmFnU3BlZWQ7XG4gICAgdGhpcy5wb2ludGVyWzRdID0gcHgxO1xuICAgIHRoaXMucG9pbnRlcls1XSA9IHB5MTtcbiAgICBjb25zdCBbIGN4LCBjeSBdID0gdGhpcy5jb29yZHM7XG4gICAgY29uc3QgWyBzeCwgc3kgXSA9IHRoaXMuc25hcHBlZDtcbiAgICBjb25zdCBjZiA9ICgxIC0gdGhpcy5jb250YWluZXJGcmljdGlvbikgKiB0aGlzLmRyYWdTcGVlZDtcbiAgICB0aGlzLnNldFgoY3ggPiBjciA/IGNyICsgKGN4IC0gY3IpICogY2YgOiBjeCA8IGNsID8gY2wgKyAoY3ggLSBjbCkgKiBjZiA6IGN4LCBmYWxzZSk7XG4gICAgdGhpcy5zZXRZKGN5ID4gY2IgPyBjYiArIChjeSAtIGNiKSAqIGNmIDogY3kgPCBjdCA/IGN0ICsgKGN5IC0gY3QpICogY2YgOiBjeSwgZmFsc2UpO1xuICAgIHRoaXMuY29tcHV0ZVZlbG9jaXR5KHB4MSAtIHB4MywgcHkxIC0gcHkzKTtcbiAgICB0aGlzLmFuZ2xlID0gYXRhbjIocHkxIC0gcHkyLCBweDEgLSBweDIpO1xuICAgIGNvbnN0IFsgbnN4LCBuc3kgXSA9IHRoaXMuc25hcHBlZDtcbiAgICBpZiAobnN4ICE9PSBzeCAmJiB0aGlzLnNuYXBYIHx8IG5zeSAhPT0gc3kgJiYgdGhpcy5zbmFwWSkge1xuICAgICAgdGhpcy5vblNuYXAodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnVwZGF0ZVRpY2tlci5wYXVzZSgpO1xuICAgIHRoaXMub3ZlcnNob290VGlja2VyLnBhdXNlKCk7XG4gICAgLy8gUGF1c2VzIHRoZSBpbiBib3VuZHMgb25SZWxlYXNlIGFuaW1hdGlvbnNcbiAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMuYW5pbWF0ZS5hbmltYXRpb25zKSB0aGlzLmFuaW1hdGUuYW5pbWF0aW9uc1twcm9wXS5wYXVzZSgpO1xuICAgIHJlbW92ZSh0aGlzLCBudWxsLCAneCcpO1xuICAgIHJlbW92ZSh0aGlzLCBudWxsLCAneScpO1xuICAgIHJlbW92ZSh0aGlzLCBudWxsLCAncHJvZ3Jlc3NYJyk7XG4gICAgcmVtb3ZlKHRoaXMsIG51bGwsICdwcm9ncmVzc1knKTtcbiAgICByZW1vdmUodGhpcy5zY3JvbGwpOyAvLyBSZW1vdmVzIGFueSBhY3RpdmUgYW5pbWF0aW9ucyBvbiB0aGUgY29udGFpbmVyIHNjcm9sbFxuICAgIHJlbW92ZSh0aGlzLm92ZXJzaG9vdENvb3Jkcyk7IC8vIFJlbW92ZXMgYWN0aXZlIG92ZXJzaG9vdCBhbmltYXRpb25zXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbl1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtnYXBdXG4gICAqIEBwYXJhbSB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2Nyb2xsSW5WaWV3KGR1cmF0aW9uLCBnYXAgPSAwLCBlYXNlID0gZWFzZXMuaW5PdXRRdWFkKSB7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxDb29yZHMoKTtcbiAgICBjb25zdCB4ID0gdGhpcy5kZXN0WDtcbiAgICBjb25zdCB5ID0gdGhpcy5kZXN0WTtcbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLnNjcm9sbDtcbiAgICBjb25zdCBzY3JvbGxCb3VuZHMgPSB0aGlzLnNjcm9sbEJvdW5kcztcbiAgICBjb25zdCBjYW5TY3JvbGwgPSB0aGlzLmNhblNjcm9sbDtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyQXJyYXkgJiYgdGhpcy5pc091dE9mQm91bmRzKHNjcm9sbEJvdW5kcywgeCwgeSkpIHtcbiAgICAgIGNvbnN0IFsgc3QsIHNyLCBzYiwgc2wgXSA9IHNjcm9sbEJvdW5kcztcbiAgICAgIGNvbnN0IHQgPSByb3VuZChjbGFtcCh5IC0gc3QsIC1tYXhWYWx1ZSwgMCksIDApO1xuICAgICAgY29uc3QgciA9IHJvdW5kKGNsYW1wKHggLSBzciwgMCwgbWF4VmFsdWUpLCAwKTtcbiAgICAgIGNvbnN0IGIgPSByb3VuZChjbGFtcCh5IC0gc2IsIDAsIG1heFZhbHVlKSwgMCk7XG4gICAgICBjb25zdCBsID0gcm91bmQoY2xhbXAoeCAtIHNsLCAtbWF4VmFsdWUsIDApLCAwKTtcbiAgICAgIG5ldyBKU0FuaW1hdGlvbihzY3JvbGwsIHtcbiAgICAgICAgeDogcm91bmQoc2Nyb2xsLnggKyAobCA/IGwgLSBnYXAgOiByID8gciArIGdhcCA6IDApLCAwKSxcbiAgICAgICAgeTogcm91bmQoc2Nyb2xsLnkgKyAodCA/IHQgLSBnYXAgOiBiID8gYiArIGdhcCA6IDApLCAwKSxcbiAgICAgICAgZHVyYXRpb246IGlzVW5kKGR1cmF0aW9uKSA/IDM1MCAqIGdsb2JhbHMudGltZVNjYWxlIDogZHVyYXRpb24sXG4gICAgICAgIGVhc2UsXG4gICAgICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLiRzY3JvbGxDb250YWluZXIuc2Nyb2xsVG8oc2Nyb2xsLngsIHNjcm9sbC55KTtcbiAgICAgICAgfVxuICAgICAgfSkuaW5pdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmNhblNjcm9sbCA9IGNhblNjcm9sbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGhhbmRsZUhvdmVyKCkge1xuICAgIGlmICh0aGlzLmlzRmluZVBvaW50ZXIgJiYgdGhpcy5jdXJzb3IgJiYgIXRoaXMuY3Vyc29yU3R5bGVzKSB7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0cmlnZ2VyLCB7XG4gICAgICAgIGN1cnNvcjogLyoqIEB0eXBlIHtEcmFnZ2FibGVDdXJzb3JQYXJhbXN9ICovKHRoaXMuY3Vyc29yKS5vbkhvdmVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbZHVyYXRpb25dXG4gICAqIEBwYXJhbSAge051bWJlcn0gW2dhcF1cbiAgICogQHBhcmFtICB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgYW5pbWF0ZUluVmlldyhkdXJhdGlvbiwgZ2FwID0gMCwgZWFzZSA9IGVhc2VzLmluT3V0UXVhZCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdWYWx1ZXMoKTtcbiAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgY29uc3QgWyBjcHQsIGNwciwgY3BiLCBjcGwgXSA9IHRoaXMuY29udGFpbmVyUGFkZGluZztcbiAgICBjb25zdCBidCA9IHRoaXMuc2Nyb2xsLnkgLSB0aGlzLnRhcmdldEJvdW5kc1swXSArIGNwdCArIGdhcDtcbiAgICBjb25zdCBiciA9IHRoaXMuc2Nyb2xsLnggLSB0aGlzLnRhcmdldEJvdW5kc1sxXSAtIGNwciAtIGdhcDtcbiAgICBjb25zdCBiYiA9IHRoaXMuc2Nyb2xsLnkgLSB0aGlzLnRhcmdldEJvdW5kc1syXSAtIGNwYiAtIGdhcDtcbiAgICBjb25zdCBibCA9IHRoaXMuc2Nyb2xsLnggLSB0aGlzLnRhcmdldEJvdW5kc1szXSArIGNwbCArIGdhcDtcbiAgICBjb25zdCBvYiA9IHRoaXMuaXNPdXRPZkJvdW5kcyhbYnQsIGJyLCBiYiwgYmxdLCB4LCB5KTtcbiAgICBpZiAob2IpIHtcbiAgICAgIGNvbnN0IFsgZGlzYWJsZWRYLCBkaXNhYmxlZFkgXSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICBjb25zdCBkZXN0WCA9IGNsYW1wKHNuYXAoeCwgdGhpcy5zbmFwWCksIGJsLCBicik7XG4gICAgICBjb25zdCBkZXN0WSA9IGNsYW1wKHNuYXAoeSwgdGhpcy5zbmFwWSksIGJ0LCBiYik7XG4gICAgICBjb25zdCBkdXIgPSBpc1VuZChkdXJhdGlvbikgPyAzNTAgKiBnbG9iYWxzLnRpbWVTY2FsZSA6IGR1cmF0aW9uO1xuICAgICAgaWYgKCFkaXNhYmxlZFggJiYgKG9iID09PSAxIHx8IG9iID09PSAzKSkgdGhpcy5hbmltYXRlW3RoaXMueFByb3BdKGRlc3RYLCBkdXIsIGVhc2UpO1xuICAgICAgaWYgKCFkaXNhYmxlZFkgJiYgKG9iID09PSAyIHx8IG9iID09PSAzKSkgdGhpcy5hbmltYXRlW3RoaXMueVByb3BdKGRlc3RZLCBkdXIsIGVhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRG93bihlKSB7XG4gICAgY29uc3QgJGVUYXJnZXQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhlLnRhcmdldCk7XG4gICAgaWYgKHRoaXMuZ3JhYmJlZCB8fCAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICovKCRlVGFyZ2V0KS50eXBlID09PSAncmFuZ2UnKSByZXR1cm47XG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy5ncmFiYmVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1ZhbHVlcygpO1xuICAgIGNvbnN0IHRvdWNoZXMgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGUpLmNoYW5nZWRUb3VjaGVzO1xuICAgIGNvbnN0IGV2ZW50WCA9IHRvdWNoZXMgPyB0b3VjaGVzWzBdLmNsaWVudFggOiAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovKGUpLmNsaWVudFg7XG4gICAgY29uc3QgZXZlbnRZID0gdG91Y2hlcyA/IHRvdWNoZXNbMF0uY2xpZW50WSA6IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkuY2xpZW50WTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudHJhbnNmb3Jtcy5ub3JtYWxpemVQb2ludChldmVudFgsIGV2ZW50WSk7XG4gICAgY29uc3QgWyBjdCwgY3IsIGNiLCBjbCBdID0gdGhpcy5jb250YWluZXJCb3VuZHM7XG4gICAgY29uc3QgY2YgPSAoMSAtIHRoaXMuY29udGFpbmVyRnJpY3Rpb24pICogdGhpcy5kcmFnU3BlZWQ7XG4gICAgY29uc3QgY3ggPSB0aGlzLng7XG4gICAgY29uc3QgY3kgPSB0aGlzLnk7XG4gICAgdGhpcy5jb29yZHNbMF0gPSB0aGlzLmNvb3Jkc1syXSA9ICFjZiA/IGN4IDogY3ggPiBjciA/IGNyICsgKGN4IC0gY3IpIC8gY2YgOiBjeCA8IGNsID8gY2wgKyAoY3ggLSBjbCkgLyBjZiA6IGN4O1xuICAgIHRoaXMuY29vcmRzWzFdID0gdGhpcy5jb29yZHNbM10gPSAhY2YgPyBjeSA6IGN5ID4gY2IgPyBjYiArIChjeSAtIGNiKSAvIGNmIDogY3kgPCBjdCA/IGN0ICsgKGN5IC0gY3QpIC8gY2YgOiBjeTtcbiAgICB0aGlzLnBvaW50ZXJbMF0gPSB4O1xuICAgIHRoaXMucG9pbnRlclsxXSA9IHk7XG4gICAgdGhpcy5wb2ludGVyWzJdID0geDtcbiAgICB0aGlzLnBvaW50ZXJbM10gPSB5O1xuICAgIHRoaXMucG9pbnRlcls0XSA9IHg7XG4gICAgdGhpcy5wb2ludGVyWzVdID0geTtcbiAgICB0aGlzLnBvaW50ZXJbNl0gPSB4O1xuICAgIHRoaXMucG9pbnRlcls3XSA9IHk7XG4gICAgdGhpcy5kZWx0YVggPSAwO1xuICAgIHRoaXMuZGVsdGFZID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tbMF0gPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja1sxXSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrWzJdID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tJbmRleCA9IDA7XG4gICAgdGhpcy5hbmdsZSA9IDA7XG4gICAgaWYgKHRoaXMudGFyZ2V0U3R5bGVzKSB7XG4gICAgICB0aGlzLnRhcmdldFN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMudGFyZ2V0U3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeiA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhnZXRUYXJnZXRWYWx1ZSh0aGlzLiR0YXJnZXQsICd6SW5kZXgnLCBmYWxzZSkpO1xuICAgIHpJbmRleCA9ICh6ID4gekluZGV4ID8geiA6IHpJbmRleCkgKyAxO1xuICAgIHRoaXMudGFyZ2V0U3R5bGVzID0gc2V0VGFyZ2V0VmFsdWVzKHRoaXMuJHRhcmdldCwgeyB6SW5kZXggfSk7XG4gICAgaWYgKHRoaXMudHJpZ2dlclN0eWxlcykge1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzLnJldmVydCgpO1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3Vyc29yU3R5bGVzKSB7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuY3Vyc29yU3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGaW5lUG9pbnRlciAmJiB0aGlzLmN1cnNvcikge1xuICAgICAgdGhpcy5ib2R5U3R5bGVzID0gc2V0VGFyZ2V0VmFsdWVzKGRvYy5ib2R5LCB7XG4gICAgICAgIGN1cnNvcjogLyoqIEB0eXBlIHtEcmFnZ2FibGVDdXJzb3JQYXJhbXN9ICovKHRoaXMuY3Vyc29yKS5vbkdyYWJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnNjcm9sbEluVmlldygxMDAsIDAsIGVhc2VzLm91dCgzKSk7XG4gICAgdGhpcy5vbkdyYWIodGhpcyk7XG5cbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fFRvdWNoRXZlbnR9IGVcbiAgICovXG4gIGhhbmRsZU1vdmUoZSkge1xuICAgIGlmICghdGhpcy5ncmFiYmVkKSByZXR1cm47XG4gICAgY29uc3QgdG91Y2hlcyA9IC8qKiBAdHlwZSB7VG91Y2hFdmVudH0gKi8oZSkuY2hhbmdlZFRvdWNoZXM7XG4gICAgY29uc3QgZXZlbnRYID0gdG91Y2hlcyA/IHRvdWNoZXNbMF0uY2xpZW50WCA6IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkuY2xpZW50WDtcbiAgICBjb25zdCBldmVudFkgPSB0b3VjaGVzID8gdG91Y2hlc1swXS5jbGllbnRZIDogLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyhlKS5jbGllbnRZO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50cmFuc2Zvcm1zLm5vcm1hbGl6ZVBvaW50KGV2ZW50WCwgZXZlbnRZKTtcbiAgICBjb25zdCBtb3ZlZFggPSB4IC0gdGhpcy5wb2ludGVyWzZdO1xuICAgIGNvbnN0IG1vdmVkWSA9IHkgLSB0aGlzLnBvaW50ZXJbN107XG5cbiAgICBsZXQgJHBhcmVudCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGUudGFyZ2V0KTtcbiAgICBsZXQgaXNBdFRvcCA9IGZhbHNlO1xuICAgIGxldCBpc0F0Qm90dG9tID0gZmFsc2U7XG4gICAgbGV0IGNhblRvdWNoU2Nyb2xsID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodG91Y2hlcyAmJiAkcGFyZW50ICYmICRwYXJlbnQgIT09IHRoaXMuJHRyaWdnZXIpIHtcbiAgICAgIGNvbnN0IG92ZXJmbG93WSA9IGdldFRhcmdldFZhbHVlKCRwYXJlbnQsICdvdmVyZmxvdy15Jyk7XG4gICAgICBpZiAob3ZlcmZsb3dZICE9PSAnaGlkZGVuJyAmJiBvdmVyZmxvd1kgIT09ICd2aXNpYmxlJykge1xuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgfSA9ICRwYXJlbnQ7XG4gICAgICAgIGlmIChzY3JvbGxIZWlnaHQgPiBjbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICBjYW5Ub3VjaFNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgaXNBdFRvcCA9IHNjcm9sbFRvcCA8PSAzO1xuICAgICAgICAgIGlzQXRCb3R0b20gPSBzY3JvbGxUb3AgPj0gKHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodCkgLSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAkcGFyZW50ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oJHBhcmVudC5wYXJlbnROb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoY2FuVG91Y2hTY3JvbGwgJiYgKCghaXNBdFRvcCAmJiAhaXNBdEJvdHRvbSkgfHwgKGlzQXRUb3AgJiYgbW92ZWRZIDwgMCkgfHwgKGlzQXRCb3R0b20gJiYgbW92ZWRZID4gMCkpKSB7XG5cbiAgICAgIHRoaXMucG9pbnRlclswXSA9IHg7XG4gICAgICB0aGlzLnBvaW50ZXJbMV0gPSB5O1xuICAgICAgdGhpcy5wb2ludGVyWzJdID0geDtcbiAgICAgIHRoaXMucG9pbnRlclszXSA9IHk7XG4gICAgICB0aGlzLnBvaW50ZXJbNF0gPSB4O1xuICAgICAgdGhpcy5wb2ludGVyWzVdID0geTtcbiAgICAgIHRoaXMucG9pbnRlcls2XSA9IHg7XG4gICAgICB0aGlzLnBvaW50ZXJbN10gPSB5O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcHJldmVudERlZmF1bHQoZSk7XG5cbiAgICAgIC8vIE5lZWRlZCB0byBwcmV2ZW50cyBjbGljayBvbiBoYW5kbGVVcFxuICAgICAgaWYgKCF0aGlzLnRyaWdnZXJTdHlsZXMpIHRoaXMudHJpZ2dlclN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0cmlnZ2VyLCB7IHBvaW50ZXJFdmVudHM6ICdub25lJyB9KTtcbiAgICAgIC8vIE5lZWRlZCB0byBwcmV2ZW50IHBhZ2Ugc2Nyb2xsIHdoaWxlIGRyYWdnaW5nIG9uIHRvdWNoIGRldnZpY2VcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnREZWZhdWx0LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgdGhpcy4kdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50RGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cblxuICAgICAgaWYgKCghdGhpcy5kaXNhYmxlZFswXSAmJiBhYnMobW92ZWRYKSA+IDMpIHx8ICghdGhpcy5kaXNhYmxlZFsxXSAmJiBhYnMobW92ZWRZKSA+IDMpKSB7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUaWNrZXIucmVzdW1lKCk7XG4gICAgICAgIHRoaXMucG9pbnRlclsyXSA9IHRoaXMucG9pbnRlclswXTtcbiAgICAgICAgdGhpcy5wb2ludGVyWzNdID0gdGhpcy5wb2ludGVyWzFdO1xuICAgICAgICB0aGlzLnBvaW50ZXJbMF0gPSB4O1xuICAgICAgICB0aGlzLnBvaW50ZXJbMV0gPSB5O1xuICAgICAgICB0aGlzLmRyYWdnZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25EcmFnKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVVwKCkge1xuXG4gICAgaWYgKCF0aGlzLmdyYWJiZWQpIHJldHVybjtcblxuICAgIHRoaXMudXBkYXRlVGlja2VyLnBhdXNlKCk7XG5cbiAgICBpZiAodGhpcy50cmlnZ2VyU3R5bGVzKSB7XG4gICAgICB0aGlzLnRyaWdnZXJTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnRyaWdnZXJTdHlsZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJvZHlTdHlsZXMpIHtcbiAgICAgIHRoaXMuYm9keVN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuYm9keVN0eWxlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgWyBkaXNhYmxlZFgsIGRpc2FibGVkWSBdID0gdGhpcy5kaXNhYmxlZDtcbiAgICBjb25zdCBbIHB4MSwgcHkxLCBweDIsIHB5MiwgcHgzLCBweTMgXSA9IHRoaXMucG9pbnRlcjtcbiAgICBjb25zdCBbIGN0LCBjciwgY2IsIGNsIF0gPSB0aGlzLmNvbnRhaW5lckJvdW5kcztcbiAgICBjb25zdCBbIHN4LCBzeSBdID0gdGhpcy5zbmFwcGVkO1xuICAgIGNvbnN0IHNwcmluZ1ggPSB0aGlzLnJlbGVhc2VYU3ByaW5nO1xuICAgIGNvbnN0IHNwcmluZ1kgPSB0aGlzLnJlbGVhc2VZU3ByaW5nO1xuICAgIGNvbnN0IHJlbGVhc2VFYXNlID0gdGhpcy5yZWxlYXNlRWFzZTtcbiAgICBjb25zdCBoYXNSZWxlYXNlU3ByaW5nID0gdGhpcy5oYXNSZWxlYXNlU3ByaW5nO1xuICAgIGNvbnN0IG92ZXJzaG9vdENvb3JkcyA9IHRoaXMub3ZlcnNob290Q29vcmRzO1xuICAgIGNvbnN0IGN4ID0gdGhpcy54O1xuICAgIGNvbnN0IGN5ID0gdGhpcy55O1xuICAgIGNvbnN0IHB2ID0gdGhpcy5jb21wdXRlVmVsb2NpdHkocHgxIC0gcHgzLCBweTEgLSBweTMpO1xuICAgIGNvbnN0IHBhID0gdGhpcy5hbmdsZSA9IGF0YW4yKHB5MSAtIHB5MiwgcHgxIC0gcHgyKTtcbiAgICBjb25zdCBkcyA9IHB2ICogMTUwO1xuICAgIGNvbnN0IGNmID0gKDEgLSB0aGlzLnJlbGVhc2VDb250YWluZXJGcmljdGlvbikgKiB0aGlzLmRyYWdTcGVlZDtcbiAgICBjb25zdCBueCA9IGN4ICsgKGNvcyhwYSkgKiBkcyk7XG4gICAgY29uc3QgbnkgPSBjeSArIChzaW4ocGEpICogZHMpO1xuICAgIGNvbnN0IGJ4ID0gbnggPiBjciA/IGNyICsgKG54IC0gY3IpICogY2YgOiBueCA8IGNsID8gY2wgKyAobnggLSBjbCkgKiBjZiA6IG54O1xuICAgIGNvbnN0IGJ5ID0gbnkgPiBjYiA/IGNiICsgKG55IC0gY2IpICogY2YgOiBueSA8IGN0ID8gY3QgKyAobnkgLSBjdCkgKiBjZiA6IG55O1xuICAgIGNvbnN0IGR4ID0gdGhpcy5kZXN0WCA9IGNsYW1wKHJvdW5kKHNuYXAoYngsIHRoaXMuc25hcFgpLCA1KSwgY2wsIGNyKTtcbiAgICBjb25zdCBkeSA9IHRoaXMuZGVzdFkgPSBjbGFtcChyb3VuZChzbmFwKGJ5LCB0aGlzLnNuYXBZKSwgNSksIGN0LCBjYik7XG4gICAgY29uc3Qgb2IgPSB0aGlzLmlzT3V0T2ZCb3VuZHModGhpcy5jb250YWluZXJCb3VuZHMsIG54LCBueSk7XG5cbiAgICBsZXQgZHVyYXRpb25YID0gMDtcbiAgICBsZXQgZHVyYXRpb25ZID0gMDtcbiAgICBsZXQgZWFzZVggPSByZWxlYXNlRWFzZTtcbiAgICBsZXQgZWFzZVkgPSByZWxlYXNlRWFzZTtcbiAgICBsZXQgbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbiA9IDA7XG5cbiAgICBvdmVyc2hvb3RDb29yZHMueCA9IGN4O1xuICAgIG92ZXJzaG9vdENvb3Jkcy55ID0gY3k7XG5cbiAgICBpZiAoIWRpc2FibGVkWCkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uWCA9IGR4ID09PSBjciA/IGN4ID4gY3IgPyAtMSA6IDEgOiBjeCA8IGNsID8gLTEgOiAxO1xuICAgICAgY29uc3QgZGlzdGFuY2VYID0gcm91bmQoY3ggLSBkeCwgMCk7XG4gICAgICBzcHJpbmdYLnZlbG9jaXR5ID0gZGlzYWJsZWRZICYmIGhhc1JlbGVhc2VTcHJpbmcgPyBkaXN0YW5jZVggPyAoZHMgKiBkaXJlY3Rpb25YKSAvIGFicyhkaXN0YW5jZVgpIDogMCA6IHB2O1xuICAgICAgY29uc3QgeyBlYXNlLCBkdXJhdGlvbiwgcmVzdER1cmF0aW9uIH0gPSBzcHJpbmdYO1xuICAgICAgZHVyYXRpb25YID0gY3ggPT09IGR4ID8gMCA6IGhhc1JlbGVhc2VTcHJpbmcgPyBkdXJhdGlvbiA6IGR1cmF0aW9uIC0gKHJlc3REdXJhdGlvbiAqIGdsb2JhbHMudGltZVNjYWxlKTtcbiAgICAgIGlmIChoYXNSZWxlYXNlU3ByaW5nKSBlYXNlWCA9IGVhc2U7XG4gICAgICBpZiAoZHVyYXRpb25YID4gbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbikgbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbiA9IGR1cmF0aW9uWDtcbiAgICB9XG5cbiAgICBpZiAoIWRpc2FibGVkWSkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uWSA9IGR5ID09PSBjYiA/IGN5ID4gY2IgPyAtMSA6IDEgOiBjeSA8IGN0ID8gLTEgOiAxO1xuICAgICAgY29uc3QgZGlzdGFuY2VZID0gcm91bmQoY3kgLSBkeSwgMCk7XG4gICAgICBzcHJpbmdZLnZlbG9jaXR5ID0gZGlzYWJsZWRYICYmIGhhc1JlbGVhc2VTcHJpbmcgPyBkaXN0YW5jZVkgPyAoZHMgKiBkaXJlY3Rpb25ZKSAvIGFicyhkaXN0YW5jZVkpIDogMCA6IHB2O1xuICAgICAgY29uc3QgeyBlYXNlLCBkdXJhdGlvbiwgcmVzdER1cmF0aW9uIH0gPSBzcHJpbmdZO1xuICAgICAgZHVyYXRpb25ZID0gY3kgPT09IGR5ID8gMCA6IGhhc1JlbGVhc2VTcHJpbmcgPyBkdXJhdGlvbiA6IGR1cmF0aW9uIC0gKHJlc3REdXJhdGlvbiAqIGdsb2JhbHMudGltZVNjYWxlKTtcbiAgICAgIGlmIChoYXNSZWxlYXNlU3ByaW5nKSBlYXNlWSA9IGVhc2U7XG4gICAgICBpZiAoZHVyYXRpb25ZID4gbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbikgbG9uZ2VzdFJlbGVhc2VEdXJhdGlvbiA9IGR1cmF0aW9uWTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1JlbGVhc2VTcHJpbmcgJiYgb2IgJiYgY2YgJiYgKGR1cmF0aW9uWCB8fCBkdXJhdGlvblkpKSB7XG5cbiAgICAgICAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvblR5cGVzLmJsZW5kO1xuXG4gICAgICAgIG5ldyBKU0FuaW1hdGlvbihvdmVyc2hvb3RDb29yZHMsIHtcbiAgICAgICAgICB4OiB7IHRvOiBieCwgZHVyYXRpb246IGR1cmF0aW9uWCAqIC42NSB9LFxuICAgICAgICAgIHk6IHsgdG86IGJ5LCBkdXJhdGlvbjogZHVyYXRpb25ZICogLjY1IH0sXG4gICAgICAgICAgZWFzZTogcmVsZWFzZUVhc2UsXG4gICAgICAgICAgY29tcG9zaXRpb24sXG4gICAgICAgIH0pLmluaXQoKTtcblxuICAgICAgICBuZXcgSlNBbmltYXRpb24ob3ZlcnNob290Q29vcmRzLCB7XG4gICAgICAgICAgeDogeyB0bzogZHgsIGR1cmF0aW9uOiBkdXJhdGlvblggfSxcbiAgICAgICAgICB5OiB7IHRvOiBkeSwgZHVyYXRpb246IGR1cmF0aW9uWSB9LFxuICAgICAgICAgIGVhc2U6IHJlbGVhc2VFYXNlLFxuICAgICAgICAgIGNvbXBvc2l0aW9uLFxuICAgICAgICB9KS5pbml0KCk7XG5cbiAgICAgICAgdGhpcy5vdmVyc2hvb3RUaWNrZXIuc3RyZXRjaChtYXgoZHVyYXRpb25YLCBkdXJhdGlvblkpKS5yZXN0YXJ0KCk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAoIWRpc2FibGVkWCkgdGhpcy5hbmltYXRlW3RoaXMueFByb3BdKGR4LCBkdXJhdGlvblgsIGVhc2VYKTtcbiAgICAgIGlmICghZGlzYWJsZWRZKSB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0oZHksIGR1cmF0aW9uWSwgZWFzZVkpO1xuXG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxJblZpZXcobG9uZ2VzdFJlbGVhc2VEdXJhdGlvbiwgdGhpcy5zY3JvbGxUaHJlc2hvbGQsIHJlbGVhc2VFYXNlKTtcblxuICAgIGxldCBoYXNTbmFwcGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZHggIT09IHN4KSB7XG4gICAgICB0aGlzLnNuYXBwZWRbMF0gPSBkeDtcbiAgICAgIGlmICh0aGlzLnNuYXBYKSBoYXNTbmFwcGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZHkgIT09IHN5ICYmIHRoaXMuc25hcFkpIHtcbiAgICAgIHRoaXMuc25hcHBlZFsxXSA9IGR5O1xuICAgICAgaWYgKHRoaXMuc25hcFkpIGhhc1NuYXBwZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChoYXNTbmFwcGVkKSB0aGlzLm9uU25hcCh0aGlzKTtcblxuICAgIHRoaXMuZ3JhYmJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgdGhpcy5yZWxlYXNlZCA9IHRydWU7XG5cbiAgICAvLyBJdCdzIGltcG9ydGFudCB0byB0cmlnZ2VyIHRoZSBjYWxsYmFjayBhZnRlciB0aGUgcmVsZWFzZSBhbmltYXRpb25zIHRvIGJlIGFibGUgdG8gY2FuY2VsIHRoZW1cbiAgICB0aGlzLm9uUmVsZWFzZSh0aGlzKTtcblxuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbiAgICB0aGlzLiR0cmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHByZXZlbnREZWZhdWx0KTtcbiAgICB0aGlzLiR0cmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuXG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5yZXNpemVUaWNrZXIucGF1c2UoKTtcbiAgICB0aGlzLmdyYWJiZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICB0aGlzLnNldFgoMCwgdHJ1ZSk7XG4gICAgdGhpcy5zZXRZKDAsIHRydWUpO1xuICAgIHRoaXMuY29vcmRzWzBdID0gMDtcbiAgICB0aGlzLmNvb3Jkc1sxXSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzBdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbMV0gPSAwO1xuICAgIHRoaXMucG9pbnRlclsyXSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzNdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbNF0gPSAwO1xuICAgIHRoaXMucG9pbnRlcls1XSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzZdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbN10gPSAwO1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja1swXSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrWzFdID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tbMl0gPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gMDtcbiAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuJHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kaXNhYmxlZCcpO1xuICAgICAgdGhpcy50b3VjaEFjdGlvblN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0cmlnZ2VyLCB7XG4gICAgICAgIHRvdWNoQWN0aW9uOiB0aGlzLmRpc2FibGVkWzBdID8gJ3Bhbi14JyA6IHRoaXMuZGlzYWJsZWRbMV0gPyAncGFuLXknIDogJ25vbmUnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgdGhpcy4kdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmdyYWJiZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uU3R5bGVzLnJldmVydCgpO1xuICAgIGlmICh0aGlzLmN1cnNvclN0eWxlcykge1xuICAgICAgdGhpcy5jdXJzb3JTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnRyaWdnZXJTdHlsZXMpIHtcbiAgICAgIHRoaXMudHJpZ2dlclN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMudHJpZ2dlclN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmJvZHlTdHlsZXMpIHtcbiAgICAgIHRoaXMuYm9keVN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuYm9keVN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhcmdldFN0eWxlcykge1xuICAgICAgdGhpcy50YXJnZXRTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnRhcmdldFN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuJHRhcmdldC5jbGFzc0xpc3QuYWRkKCdpcy1kaXNhYmxlZCcpO1xuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMpO1xuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcyk7XG4gICAgdGhpcy4kdHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV2ZXJ0KCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB0aGlzLiR0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtZGlzYWJsZWQnKTtcbiAgICB0aGlzLnVwZGF0ZVRpY2tlci5yZXZlcnQoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFRpY2tlci5yZXZlcnQoKTtcbiAgICB0aGlzLnJlc2l6ZVRpY2tlci5yZXZlcnQoKTtcbiAgICB0aGlzLmFuaW1hdGUucmV2ZXJ0KCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLmhhbmRsZURvd24oLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyhlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICAgIHRoaXMuaGFuZGxlRG93bigvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLmhhbmRsZU1vdmUoLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyhlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKC8qKiBAdHlwZSB7VG91Y2hFdmVudH0gKi8oZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLmhhbmRsZVVwKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICB0aGlzLmhhbmRsZVVwKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG91Y2hjYW5jZWwnOlxuICAgICAgICB0aGlzLmhhbmRsZVVwKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2VlbnRlcic6XG4gICAgICAgIHRoaXMuaGFuZGxlSG92ZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3RzdGFydCc6XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0XG4gKiBAcGFyYW0ge0RyYWdnYWJsZVBhcmFtc30gW3BhcmFtZXRlcnNdXG4gKiBAcmV0dXJuIHtEcmFnZ2FibGV9XG4gKi9cbmNvbnN0IGNyZWF0ZURyYWdnYWJsZSA9ICh0YXJnZXQsIHBhcmFtZXRlcnMpID0+IG5ldyBEcmFnZ2FibGUodGFyZ2V0LCBwYXJhbWV0ZXJzKTtcblxuXG5cblxuY2xhc3MgU2NvcGUge1xuICAvKiogQHBhcmFtIHtTY29wZVBhcmFtc30gW3BhcmFtZXRlcnNdICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIGlmIChzY29wZS5jdXJyZW50KSBzY29wZS5jdXJyZW50LnJlZ2lzdGVyKHRoaXMpO1xuICAgIGNvbnN0IHJvb3RQYXJhbSA9IHBhcmFtZXRlcnMucm9vdDtcbiAgICAvKiogQHR5cGUge0RvY3VtZW50fERPTVRhcmdldH0gKi9cbiAgICBsZXQgcm9vdCA9IGRvYztcbiAgICBpZiAocm9vdFBhcmFtKSB7XG4gICAgICByb290ID0gLyoqIEB0eXBlIHtSZWFjdFJlZn0gKi8ocm9vdFBhcmFtKS5jdXJyZW50IHx8XG4gICAgICAgICAgICAgLyoqIEB0eXBlIHtBbmd1bGFyUmVmfSAqLyhyb290UGFyYW0pLm5hdGl2ZUVsZW1lbnQgfHxcbiAgICAgICAgICAgICBwYXJzZVRhcmdldHMoLyoqIEB0eXBlIHtET01UYXJnZXRTZWxlY3Rvcn0gKi8ocm9vdFBhcmFtKSlbMF0gfHxcbiAgICAgICAgICAgICBkb2M7XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlRGVmYXVsdHMgPSBwYXJhbWV0ZXJzLmRlZmF1bHRzO1xuICAgIGNvbnN0IGdsb2JhbERlZmF1bHQgPSBnbG9iYWxzLmRlZmF1bHRzO1xuICAgIGNvbnN0IG1lZGlhUXVlcmllcyA9IHBhcmFtZXRlcnMubWVkaWFRdWVyaWVzO1xuICAgIC8qKiBAdHlwZSB7RGVmYXVsdHNQYXJhbXN9ICovXG4gICAgdGhpcy5kZWZhdWx0cyA9IHNjb3BlRGVmYXVsdHMgPyBtZXJnZU9iamVjdHMoc2NvcGVEZWZhdWx0cywgZ2xvYmFsRGVmYXVsdCkgOiBnbG9iYWxEZWZhdWx0O1xuICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR8RE9NVGFyZ2V0fSAqL1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2s+fSAqL1xuICAgIHRoaXMuY29uc3RydWN0b3JzID0gW107XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTY29wZUNsZWFudXBDYWxsYmFjaz59ICovXG4gICAgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnMgPSBbXTtcbiAgICAvKiogQHR5cGUge0FycmF5PFJldmVydGlibGU+fSAqL1xuICAgIHRoaXMucmV2ZXJ0aWJsZXMgPSBbXTtcbiAgICAvKiogQHR5cGUge0FycmF5PFNjb3BlQ29uc3RydWN0b3JDYWxsYmFjayB8ICgoc2NvcGU6IHRoaXMpID0+IFRpY2thYmxlKT59ICovXG4gICAgdGhpcy5jb25zdHJ1Y3RvcnNPbmNlID0gW107XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTY29wZUNsZWFudXBDYWxsYmFjaz59ICovXG4gICAgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnNPbmNlID0gW107XG4gICAgLyoqIEB0eXBlIHtBcnJheTxSZXZlcnRpYmxlPn0gKi9cbiAgICB0aGlzLnJldmVydGlibGVzT25jZSA9IFtdO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLm9uY2UgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLm9uY2VJbmRleCA9IDA7XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBTY29wZU1ldGhvZD59ICovXG4gICAgdGhpcy5tZXRob2RzID0ge307XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBCb29sZWFuPn0gKi9cbiAgICB0aGlzLm1hdGNoZXMgPSB7fTtcbiAgICAvKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIE1lZGlhUXVlcnlMaXN0Pn0gKi9cbiAgICB0aGlzLm1lZGlhUXVlcnlMaXN0cyA9IHt9O1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgYW55Pn0gKi9cbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICBpZiAobWVkaWFRdWVyaWVzKSB7XG4gICAgICBmb3IgKGxldCBtcSBpbiBtZWRpYVF1ZXJpZXMpIHtcbiAgICAgICAgY29uc3QgX21xID0gd2luLm1hdGNoTWVkaWEobWVkaWFRdWVyaWVzW21xXSk7XG4gICAgICAgIHRoaXMubWVkaWFRdWVyeUxpc3RzW21xXSA9IF9tcTtcbiAgICAgICAgX21xLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JldmVydGlibGV9IHJldmVydGlibGVcbiAgICovXG4gIHJlZ2lzdGVyKHJldmVydGlibGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHRoaXMub25jZSA/IHRoaXMucmV2ZXJ0aWJsZXNPbmNlIDogdGhpcy5yZXZlcnRpYmxlcztcbiAgICBzdG9yZS5wdXNoKHJldmVydGlibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7U2NvcGVkQ2FsbGJhY2s8VD59IGNiXG4gICAqIEByZXR1cm4ge1R9XG4gICAqL1xuICBleGVjdXRlKGNiKSB7XG4gICAgbGV0IGFjdGl2ZVNjb3BlID0gc2NvcGUuY3VycmVudDtcbiAgICBsZXQgYWN0aXZlUm9vdCA9IHNjb3BlLnJvb3Q7XG4gICAgbGV0IGFjdGl2ZURlZmF1bHRzID0gZ2xvYmFscy5kZWZhdWx0cztcbiAgICBzY29wZS5jdXJyZW50ID0gdGhpcztcbiAgICBzY29wZS5yb290ID0gdGhpcy5yb290O1xuICAgIGdsb2JhbHMuZGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzO1xuICAgIGNvbnN0IG1xcyA9IHRoaXMubWVkaWFRdWVyeUxpc3RzO1xuICAgIGZvciAobGV0IG1xIGluIG1xcykgdGhpcy5tYXRjaGVzW21xXSA9IG1xc1ttcV0ubWF0Y2hlcztcbiAgICBjb25zdCByZXR1cm5lZCA9IGNiKHRoaXMpO1xuICAgIHNjb3BlLmN1cnJlbnQgPSBhY3RpdmVTY29wZTtcbiAgICBzY29wZS5yb290ID0gYWN0aXZlUm9vdDtcbiAgICBnbG9iYWxzLmRlZmF1bHRzID0gYWN0aXZlRGVmYXVsdHM7XG4gICAgcmV0dXJuIHJldHVybmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMub25jZUluZGV4ID0gMDtcbiAgICB0aGlzLmV4ZWN1dGUoKCkgPT4ge1xuICAgICAgbGV0IGkgPSB0aGlzLnJldmVydGlibGVzLmxlbmd0aDtcbiAgICAgIGxldCB5ID0gdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgdGhpcy5yZXZlcnRpYmxlc1tpXS5yZXZlcnQoKTtcbiAgICAgIHdoaWxlICh5LS0pIHRoaXMucmV2ZXJ0Q29uc3RydWN0b3JzW3ldKHRoaXMpO1xuICAgICAgdGhpcy5yZXZlcnRpYmxlcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuY29uc3RydWN0b3JzLmZvckVhY2goKC8qKiBAdHlwZSB7U2NvcGVDb25zdHJ1Y3RvckNhbGxiYWNrfSAqL2NvbnN0cnVjdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHJldmVydENvbnN0cnVjdG9yID0gY29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIGlmIChpc0ZuYyhyZXZlcnRDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICB0aGlzLnJldmVydENvbnN0cnVjdG9ycy5wdXNoKHJldmVydENvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhMVxuICAgKiBAcGFyYW0ge1Njb3BlTWV0aG9kfSBhMlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtTY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2t9IGExXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfFNjb3BlQ29uc3RydWN0b3JDYWxsYmFja30gYTFcbiAgICogQHBhcmFtIHtTY29wZU1ldGhvZH0gW2EyXVxuICAgKi9cbiAgYWRkKGExLCBhMikge1xuICAgIHRoaXMub25jZSA9IGZhbHNlO1xuICAgIGlmIChpc0ZuYyhhMSkpIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gLyoqIEB0eXBlIHtTY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2t9ICovKGExKTtcbiAgICAgIHRoaXMuY29uc3RydWN0b3JzLnB1c2goY29uc3RydWN0b3IpO1xuICAgICAgdGhpcy5leGVjdXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgaWYgKGlzRm5jKHJldmVydENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIHRoaXMucmV2ZXJ0Q29uc3RydWN0b3JzLnB1c2gocmV2ZXJ0Q29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZXRob2RzWy8qKiBAdHlwZSB7U3RyaW5nfSAqLyhhMSldID0gKC8qKiBAdHlwZSB7YW55fSAqLy4uLmFyZ3MpID0+IHRoaXMuZXhlY3V0ZSgoKSA9PiBhMiguLi5hcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2NvcGVDb25zdHJ1Y3RvckNhbGxiYWNrfSBzY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2tcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIGFkZE9uY2Uoc2NvcGVDb25zdHJ1Y3RvckNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbmNlID0gdHJ1ZTtcbiAgICBpZiAoaXNGbmMoc2NvcGVDb25zdHJ1Y3RvckNhbGxiYWNrKSkge1xuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5vbmNlSW5kZXgrKztcbiAgICAgIGNvbnN0IHRyYWNrZWQgPSB0aGlzLmNvbnN0cnVjdG9yc09uY2VbY3VycmVudEluZGV4XTtcbiAgICAgIGlmICh0cmFja2VkKSByZXR1cm4gdGhpcztcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gLyoqIEB0eXBlIHtTY29wZUNvbnN0cnVjdG9yQ2FsbGJhY2t9ICovKHNjb3BlQ29uc3RydWN0b3JDYWxsYmFjayk7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yc09uY2VbY3VycmVudEluZGV4XSA9IGNvbnN0cnVjdG9yO1xuICAgICAgdGhpcy5leGVjdXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgaWYgKGlzRm5jKHJldmVydENvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIHRoaXMucmV2ZXJ0Q29uc3RydWN0b3JzT25jZS5wdXNoKHJldmVydENvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAgeyhzY29wZTogdGhpcykgPT4gVGlja2FibGV9IGNiXG4gICAqIEByZXR1cm4ge1RpY2thYmxlfVxuICAgKi9cbiAga2VlcFRpbWUoY2IpIHtcbiAgICB0aGlzLm9uY2UgPSB0cnVlO1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMub25jZUluZGV4Kys7XG4gICAgY29uc3QgdHJhY2tlZCA9IC8qKiBAdHlwZSB7KHNjb3BlOiB0aGlzKSA9PiBUaWNrYWJsZX0gKi8odGhpcy5jb25zdHJ1Y3RvcnNPbmNlW2N1cnJlbnRJbmRleF0pO1xuICAgIGlmIChpc0ZuYyh0cmFja2VkKSkgcmV0dXJuIHRyYWNrZWQodGhpcyk7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSAvKiogQHR5cGUgeyhzY29wZTogdGhpcykgPT4gVGlja2FibGV9ICovKGNyZWF0ZVJlZnJlc2hhYmxlKGNiKSk7XG4gICAgdGhpcy5jb25zdHJ1Y3RvcnNPbmNlW2N1cnJlbnRJbmRleF0gPSBjb25zdHJ1Y3RvcjtcbiAgICBsZXQgdHJhY2tlZFRpY2thYmxlO1xuICAgIHRoaXMuZXhlY3V0ZSgoKSA9PiB7XG4gICAgICB0cmFja2VkVGlja2FibGUgPSBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhY2tlZFRpY2thYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnY2hhbmdlJzpcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldmVydCgpIHtcbiAgICBjb25zdCByZXZlcnRpYmxlcyA9IHRoaXMucmV2ZXJ0aWJsZXM7XG4gICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3JzID0gdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnM7XG4gICAgY29uc3QgcmV2ZXJ0aWJsZXNPbmNlID0gdGhpcy5yZXZlcnRpYmxlc09uY2U7XG4gICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3JzT25jZSA9IHRoaXMucmV2ZXJ0Q29uc3RydWN0b3JzT25jZTtcbiAgICBjb25zdCBtcXMgPSB0aGlzLm1lZGlhUXVlcnlMaXN0cztcbiAgICBsZXQgaSA9IHJldmVydGlibGVzLmxlbmd0aDtcbiAgICBsZXQgaiA9IHJldmVydENvbnN0cnVjdG9ycy5sZW5ndGg7XG4gICAgbGV0IGsgPSByZXZlcnRpYmxlc09uY2UubGVuZ3RoO1xuICAgIGxldCBsID0gcmV2ZXJ0Q29uc3RydWN0b3JzT25jZS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgcmV2ZXJ0aWJsZXNbaV0ucmV2ZXJ0KCk7XG4gICAgd2hpbGUgKGotLSkgcmV2ZXJ0Q29uc3RydWN0b3JzW2pdKHRoaXMpO1xuICAgIHdoaWxlIChrLS0pIHJldmVydGlibGVzT25jZVtrXS5yZXZlcnQoKTtcbiAgICB3aGlsZSAobC0tKSByZXZlcnRDb25zdHJ1Y3RvcnNPbmNlW2xdKHRoaXMpO1xuICAgIGZvciAobGV0IG1xIGluIG1xcykgbXFzW21xXS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzKTtcbiAgICByZXZlcnRpYmxlcy5sZW5ndGggPSAwO1xuICAgIHJldmVydENvbnN0cnVjdG9ycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29uc3RydWN0b3JzLmxlbmd0aCA9IDA7XG4gICAgcmV2ZXJ0aWJsZXNPbmNlLmxlbmd0aCA9IDA7XG4gICAgcmV2ZXJ0Q29uc3RydWN0b3JzT25jZS5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29uc3RydWN0b3JzT25jZS5sZW5ndGggPSAwO1xuICAgIHRoaXMub25jZUluZGV4ID0gMDtcbiAgICB0aGlzLm1hdGNoZXMgPSB7fTtcbiAgICB0aGlzLm1ldGhvZHMgPSB7fTtcbiAgICB0aGlzLm1lZGlhUXVlcnlMaXN0cyA9IHt9O1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTY29wZVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm4ge1Njb3BlfVxuICovXG5jb25zdCBjcmVhdGVTY29wZSA9IHBhcmFtcyA9PiBuZXcgU2NvcGUocGFyYW1zKTtcblxuLyoqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGdldE1heFZpZXdIZWlnaHQgPSAoKSA9PiB7XG4gIGNvbnN0ICRlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoJGVsKTtcbiAgJGVsLnN0eWxlLmhlaWdodCA9ICcxMDBsdmgnO1xuICBjb25zdCBoZWlnaHQgPSAkZWwub2Zmc2V0SGVpZ2h0O1xuICBkb2MuYm9keS5yZW1vdmVDaGlsZCgkZWwpO1xuICByZXR1cm4gaGVpZ2h0O1xufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUge1Njcm9sbFRocmVzaG9sZFZhbHVlfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxPYmplY3R9IFRcbiAqIEBwYXJhbSB7VCB8ICgob2JzZXJ2ZXI6IFNjcm9sbE9ic2VydmVyKSA9PiBUKX0gdmFsdWVcbiAqIEBwYXJhbSB7U2Nyb2xsT2JzZXJ2ZXJ9IHNjcm9sbGVyXG4gKiBAcmV0dXJuIHtUfVxuICovXG5jb25zdCBwYXJzZVNjcm9sbE9ic2VydmVyRnVuY3Rpb25QYXJhbWV0ZXIgPSAodmFsdWUsIHNjcm9sbGVyKSA9PiB2YWx1ZSAmJiBpc0ZuYyh2YWx1ZSkgPyAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkoc2Nyb2xsZXIpIDogdmFsdWU7XG5cbmNvbnN0IHNjcm9sbENvbnRhaW5lcnMgPSBuZXcgTWFwKCk7XG5cbmNsYXNzIFNjcm9sbENvbnRhaW5lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAkZWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCRlbCkge1xuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovXG4gICAgdGhpcy5lbGVtZW50ID0gJGVsO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnVzZVdpbiA9IHRoaXMuZWxlbWVudCA9PT0gZG9jLmJvZHk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy53aW5XaWR0aCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy53aW5IZWlnaHQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudG9wID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxYID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnNjcm9sbFkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMucHJldlNjcm9sbFggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMucHJldlNjcm9sbFkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsV2lkdGggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5iYWNrd2FyZFggPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5iYWNrd2FyZFkgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge1RpbWVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsVGlja2VyID0gbmV3IFRpbWVyKHtcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgIG9uQmVnaW46ICgpID0+IHRoaXMuZGF0YVRpbWVyLnJlc3VtZSgpLFxuICAgICAgb25VcGRhdGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgYmFja3dhcmRzID0gdGhpcy5iYWNrd2FyZFggfHwgdGhpcy5iYWNrd2FyZFk7XG4gICAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9jaGlsZCkgPT4gY2hpbGQuaGFuZGxlU2Nyb2xsKCksIGJhY2t3YXJkcyk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4gdGhpcy5kYXRhVGltZXIucGF1c2UoKVxuICAgIH0pLmluaXQoKTtcbiAgICAvKiogQHR5cGUge1RpbWVyfSAqL1xuICAgIHRoaXMuZGF0YVRpbWVyID0gbmV3IFRpbWVyKHtcbiAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgIGZyYW1lUmF0ZTogMzAsXG4gICAgICBvblVwZGF0ZTogc2VsZiA9PiB7XG4gICAgICAgIGNvbnN0IGR0ID0gc2VsZi5kZWx0YVRpbWU7XG4gICAgICAgIGNvbnN0IHB4ID0gdGhpcy5wcmV2U2Nyb2xsWDtcbiAgICAgICAgY29uc3QgcHkgPSB0aGlzLnByZXZTY3JvbGxZO1xuICAgICAgICBjb25zdCBueCA9IHRoaXMuc2Nyb2xsWDtcbiAgICAgICAgY29uc3QgbnkgPSB0aGlzLnNjcm9sbFk7XG4gICAgICAgIGNvbnN0IGR4ID0gcHggLSBueDtcbiAgICAgICAgY29uc3QgZHkgPSBweSAtIG55O1xuICAgICAgICB0aGlzLnByZXZTY3JvbGxYID0gbng7XG4gICAgICAgIHRoaXMucHJldlNjcm9sbFkgPSBueTtcbiAgICAgICAgaWYgKGR4KSB0aGlzLmJhY2t3YXJkWCA9IHB4ID4gbng7XG4gICAgICAgIGlmIChkeSkgdGhpcy5iYWNrd2FyZFkgPSBweSA+IG55O1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gcm91bmQoZHQgPiAwID8gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAvIGR0IDogMCwgNSk7XG4gICAgICB9XG4gICAgfSkuaW5pdCgpO1xuICAgIC8qKiBAdHlwZSB7VGltZXJ9ICovXG4gICAgdGhpcy5yZXNpemVUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgZHVyYXRpb246IDI1MCAqIGdsb2JhbHMudGltZVNjYWxlLFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVdpbmRvd0JvdW5kcygpO1xuICAgICAgICB0aGlzLnJlZnJlc2hTY3JvbGxPYnNlcnZlcnMoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwoKTtcbiAgICAgIH1cbiAgICB9KS5pbml0KCk7XG4gICAgLyoqIEB0eXBlIHtUaW1lcn0gKi9cbiAgICB0aGlzLndha2VUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgZHVyYXRpb246IDUwMCAqIGdsb2JhbHMudGltZVNjYWxlLFxuICAgICAgb25CZWdpbjogKCkgPT4ge1xuICAgICAgICB0aGlzLnNjcm9sbFRpY2tlci5yZXN1bWUoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGlja2VyLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfSkuaW5pdCgpO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9cbiAgICB0aGlzLl90YWlsID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIHRoaXMudXBkYXRlV2luZG93Qm91bmRzKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcbiAgICB0aGlzLnJlZnJlc2hTY3JvbGxPYnNlcnZlcnMoKTtcbiAgICB0aGlzLmhhbmRsZVNjcm9sbCgpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy5yZXNpemVUaWNrZXIucmVzdGFydCgpKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICAodGhpcy51c2VXaW4gPyB3aW4gOiB0aGlzLmVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMsIGZhbHNlKTtcbiAgfVxuXG4gIHVwZGF0ZVNjcm9sbENvb3JkcygpIHtcbiAgICBjb25zdCB1c2VXaW4gPSB0aGlzLnVzZVdpbjtcbiAgICBjb25zdCAkZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdGhpcy5zY3JvbGxYID0gcm91bmQodXNlV2luID8gd2luLnNjcm9sbFggOiAkZWwuc2Nyb2xsTGVmdCwgMCk7XG4gICAgdGhpcy5zY3JvbGxZID0gcm91bmQodXNlV2luID8gd2luLnNjcm9sbFkgOiAkZWwuc2Nyb2xsVG9wLCAwKTtcbiAgfVxuXG4gIHVwZGF0ZVdpbmRvd0JvdW5kcygpIHtcbiAgICB0aGlzLndpbldpZHRoID0gd2luLmlubmVyV2lkdGg7XG4gICAgdGhpcy53aW5IZWlnaHQgPSBnZXRNYXhWaWV3SGVpZ2h0KCk7XG4gIH1cblxuICB1cGRhdGVCb3VuZHMoKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCk7XG4gICAgY29uc3QgJGVsID0gdGhpcy5lbGVtZW50O1xuICAgIHRoaXMuc2Nyb2xsV2lkdGggPSAkZWwuc2Nyb2xsV2lkdGggKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5SaWdodCk7XG4gICAgdGhpcy5zY3JvbGxIZWlnaHQgPSAkZWwuc2Nyb2xsSGVpZ2h0ICsgcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICAgIHRoaXMudXBkYXRlV2luZG93Qm91bmRzKCk7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHRoaXMudXNlV2luKSB7XG4gICAgICB3aWR0aCA9IHRoaXMud2luV2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLndpbkhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWxSZWN0ID0gJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgd2lkdGggPSAkZWwuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSAkZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSBlbFJlY3QudG9wO1xuICAgICAgdGhpcy5sZWZ0ID0gZWxSZWN0LmxlZnQ7XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIHJlZnJlc2hTY3JvbGxPYnNlcnZlcnMoKSB7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqL2NoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQuX2RlYnVnKSB7XG4gICAgICAgIGNoaWxkLnJlbW92ZURlYnVnKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovY2hpbGQpID0+IHtcbiAgICAgIGNoaWxkLnJlZnJlc2goKTtcbiAgICAgIGlmIChjaGlsZC5fZGVidWcpIHtcbiAgICAgICAgY2hpbGQuZGVidWcoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy51cGRhdGVXaW5kb3dCb3VuZHMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIHRoaXMucmVmcmVzaFNjcm9sbE9ic2VydmVycygpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKCk7XG4gIH1cblxuICBoYW5kbGVTY3JvbGwoKSB7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxDb29yZHMoKTtcbiAgICB0aGlzLndha2VUaWNrZXIucmVzdGFydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV2ZXJ0KCkge1xuICAgIHRoaXMuc2Nyb2xsVGlja2VyLmNhbmNlbCgpO1xuICAgIHRoaXMuZGF0YVRpbWVyLmNhbmNlbCgpO1xuICAgIHRoaXMucmVzaXplVGlja2VyLmNhbmNlbCgpO1xuICAgIHRoaXMud2FrZVRpY2tlci5jYW5jZWwoKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAodGhpcy51c2VXaW4gPyB3aW4gOiB0aGlzLmVsZW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMpO1xuICAgIHNjcm9sbENvbnRhaW5lcnMuZGVsZXRlKHRoaXMuZWxlbWVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtTY3JvbGxDb250YWluZXJ9XG4gKi9cbmNvbnN0IHJlZ2lzdGVyQW5kR2V0U2Nyb2xsQ29udGFpbmVyID0gdGFyZ2V0ID0+IHtcbiAgY29uc3QgJGVsID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8odGFyZ2V0ID8gcGFyc2VUYXJnZXRzKHRhcmdldClbMF0gfHwgZG9jLmJvZHkgOiBkb2MuYm9keSk7XG4gIGxldCBzY3JvbGxDb250YWluZXIgPSBzY3JvbGxDb250YWluZXJzLmdldCgkZWwpO1xuICBpZiAoIXNjcm9sbENvbnRhaW5lcikge1xuICAgIHNjcm9sbENvbnRhaW5lciA9IG5ldyBTY3JvbGxDb250YWluZXIoJGVsKTtcbiAgICBzY3JvbGxDb250YWluZXJzLnNldCgkZWwsIHNjcm9sbENvbnRhaW5lcik7XG4gIH1cbiAgcmV0dXJuIHNjcm9sbENvbnRhaW5lcjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKiBAcGFyYW0ge051bWJlcnxzdHJpbmd9IHZcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW3VuZGVyXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvdmVyXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBjb252ZXJ0VmFsdWVUb1B4ID0gKCRlbCwgdiwgc2l6ZSwgdW5kZXIsIG92ZXIpID0+IHtcbiAgY29uc3QgY2xhbXBNaW4gPSB2ID09PSAnbWluJztcbiAgY29uc3QgY2xhbXBNYXggPSB2ID09PSAnbWF4JztcbiAgY29uc3QgdmFsdWUgPSB2ID09PSAndG9wJyB8fCB2ID09PSAnbGVmdCcgfHwgdiA9PT0gJ3N0YXJ0JyB8fCBjbGFtcE1pbiA/IDAgOlxuICAgICAgICAgICAgICAgIHYgPT09ICdib3R0b20nIHx8IHYgPT09ICdyaWdodCcgfHwgdiA9PT0gJ2VuZCcgfHwgY2xhbXBNYXggPyAnMTAwJScgOlxuICAgICAgICAgICAgICAgIHYgPT09ICdjZW50ZXInID8gJzUwJScgOlxuICAgICAgICAgICAgICAgIHY7XG4gIGNvbnN0IHsgbiwgdSB9ID0gZGVjb21wb3NlUmF3VmFsdWUodmFsdWUsIGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlKTtcbiAgbGV0IHB4ID0gbjtcbiAgaWYgKHUgPT09ICclJykge1xuICAgIHB4ID0gKG4gLyAxMDApICogc2l6ZTtcbiAgfSBlbHNlIGlmICh1KSB7XG4gICAgcHggPSBjb252ZXJ0VmFsdWVVbml0KCRlbCwgZGVjb21wb3NlZE9yaWdpbmFsVmFsdWUsICdweCcsIHRydWUpLm47XG4gIH1cbiAgaWYgKGNsYW1wTWF4ICYmIHVuZGVyIDwgMCkgcHggKz0gdW5kZXI7XG4gIGlmIChjbGFtcE1pbiAmJiBvdmVyID4gMCkgcHggKz0gb3ZlcjtcbiAgcmV0dXJuIHB4O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAkZWxcbiAqIEBwYXJhbSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9IHZcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW3VuZGVyXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvdmVyXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBwYXJzZUJvdW5kVmFsdWUgPSAoJGVsLCB2LCBzaXplLCB1bmRlciwgb3ZlcikgPT4ge1xuICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgbGV0IHZhbHVlO1xuICBpZiAoaXNTdHIodikpIHtcbiAgICBjb25zdCBtYXRjaGVkT3BlcmF0b3IgPSByZWxhdGl2ZVZhbHVlc0V4ZWNSZ3guZXhlYygvKiogQHR5cGUge1N0cmluZ30gKi8odikpO1xuICAgIGlmIChtYXRjaGVkT3BlcmF0b3IpIHtcbiAgICAgIGNvbnN0IHNwbGl0dGVyID0gbWF0Y2hlZE9wZXJhdG9yWzBdO1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSBzcGxpdHRlclswXTtcbiAgICAgIGNvbnN0IHNwbGl0dGVkID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHYpLnNwbGl0KHNwbGl0dGVyKTtcbiAgICAgIGNvbnN0IGNsYW1wTWluID0gc3BsaXR0ZWRbMF0gPT09ICdtaW4nO1xuICAgICAgY29uc3QgY2xhbXBNYXggPSBzcGxpdHRlZFswXSA9PT0gJ21heCc7XG4gICAgICBjb25zdCB2YWx1ZUFQeCA9IGNvbnZlcnRWYWx1ZVRvUHgoJGVsLCBzcGxpdHRlZFswXSwgc2l6ZSwgdW5kZXIsIG92ZXIpO1xuICAgICAgY29uc3QgdmFsdWVCUHggPSBjb252ZXJ0VmFsdWVUb1B4KCRlbCwgc3BsaXR0ZWRbMV0sIHNpemUsIHVuZGVyLCBvdmVyKTtcbiAgICAgIGlmIChjbGFtcE1pbikge1xuICAgICAgICBjb25zdCBtaW4gPSBnZXRSZWxhdGl2ZVZhbHVlKGNvbnZlcnRWYWx1ZVRvUHgoJGVsLCAnbWluJywgc2l6ZSksIHZhbHVlQlB4LCBvcGVyYXRvcik7XG4gICAgICAgIHZhbHVlID0gbWluIDwgdmFsdWVBUHggPyB2YWx1ZUFQeCA6IG1pbjtcbiAgICAgIH0gZWxzZSBpZiAoY2xhbXBNYXgpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gZ2V0UmVsYXRpdmVWYWx1ZShjb252ZXJ0VmFsdWVUb1B4KCRlbCwgJ21heCcsIHNpemUpLCB2YWx1ZUJQeCwgb3BlcmF0b3IpO1xuICAgICAgICB2YWx1ZSA9IG1heCA+IHZhbHVlQVB4ID8gdmFsdWVBUHggOiBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGdldFJlbGF0aXZlVmFsdWUodmFsdWVBUHgsIHZhbHVlQlB4LCBvcGVyYXRvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gY29udmVydFZhbHVlVG9QeCgkZWwsIHYsIHNpemUsIHVuZGVyLCBvdmVyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSAvKiogQHR5cGUge051bWJlcn0gKi8odik7XG4gIH1cbiAgcmV0dXJuIHJvdW5kKHZhbHVlLCAwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtKU0FuaW1hdGlvbn0gbGlua2VkXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuY29uc3QgZ2V0QW5pbWF0aW9uRG9tVGFyZ2V0ID0gbGlua2VkID0+IHtcbiAgbGV0ICRsaW5rZWRUYXJnZXQ7XG4gIGNvbnN0IGxpbmtlZFRhcmdldHMgPSBsaW5rZWQudGFyZ2V0cztcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5rZWRUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IGxpbmtlZFRhcmdldHNbaV07XG4gICAgaWYgKHRhcmdldFtpc0RvbVN5bWJvbF0pIHtcbiAgICAgICRsaW5rZWRUYXJnZXQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyh0YXJnZXQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiAkbGlua2VkVGFyZ2V0O1xufTtcblxubGV0IHNjcm9sbGVySW5kZXggPSAwO1xuXG5jb25zdCBkZWJ1Z0NvbG9ycyQxID0gWycjRkY0QjRCJywnI0ZGOTcxQicsJyNGRkM3MzAnLCcjRjlGNjQwJywnIzdBRkY1QScsJyMxOEZGNzQnLCcjMTdFMDlCJywnIzNDRkZFQycsJyMwNURCRTknLCcjMzNCM0YxJywnIzYzOENGOScsJyNDNTYzRkUnLCcjRkY0RkNGJywnI0Y5M0Y4QSddO1xuXG5jbGFzcyBTY3JvbGxPYnNlcnZlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Njcm9sbE9ic2VydmVyUGFyYW1zfSBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBpZiAoc2NvcGUuY3VycmVudCkgc2NvcGUuY3VycmVudC5yZWdpc3Rlcih0aGlzKTtcbiAgICBjb25zdCBzeW5jTW9kZSA9IHNldFZhbHVlKHBhcmFtZXRlcnMuc3luYywgJ3BsYXkgcGF1c2UnKTtcbiAgICBjb25zdCBlYXNlID0gc3luY01vZGUgPyBwYXJzZUVhc2luZ3MoLyoqIEB0eXBlIHtFYXNpbmdQYXJhbX0gKi8oc3luY01vZGUpKSA6IG51bGw7XG4gICAgY29uc3QgaXNMaW5lYXIgPSBzeW5jTW9kZSAmJiAoc3luY01vZGUgPT09ICdsaW5lYXInIHx8IHN5bmNNb2RlID09PSBub25lKTtcbiAgICBjb25zdCBpc0Vhc2UgPSBzeW5jTW9kZSAmJiAhKGVhc2UgPT09IG5vbmUgJiYgIWlzTGluZWFyKTtcbiAgICBjb25zdCBpc1Ntb290aCA9IHN5bmNNb2RlICYmIChpc051bShzeW5jTW9kZSkgfHwgc3luY01vZGUgPT09IHRydWUgfHwgaXNMaW5lYXIpO1xuICAgIGNvbnN0IGlzTWV0aG9kcyA9IHN5bmNNb2RlICYmIChpc1N0cihzeW5jTW9kZSkgJiYgIWlzRWFzZSAmJiAhaXNTbW9vdGgpO1xuICAgIGNvbnN0IHN5bmNNZXRob2RzID0gaXNNZXRob2RzID8gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHN5bmNNb2RlKS5zcGxpdCgnICcpLm1hcChcbiAgICAgICgvKiogQHR5cGUge1N0cmluZ30gKi9tKSA9PiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmtlZCA9IHRoaXMubGlua2VkO1xuICAgICAgICByZXR1cm4gbGlua2VkICYmIGxpbmtlZFttXSA/IGxpbmtlZFttXSgpIDogbnVsbDtcbiAgICAgIH1cbiAgICApIDogbnVsbDtcbiAgICBjb25zdCBiaURpclN5bmMgPSBpc01ldGhvZHMgJiYgc3luY01ldGhvZHMubGVuZ3RoID4gMjtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmluZGV4ID0gc2Nyb2xsZXJJbmRleCsrO1xuICAgIC8qKiBAdHlwZSB7U3RyaW5nfE51bWJlcn0gKi9cbiAgICB0aGlzLmlkID0gIWlzVW5kKHBhcmFtZXRlcnMuaWQpID8gcGFyYW1ldGVycy5pZCA6IHRoaXMuaW5kZXg7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxDb250YWluZXJ9ICovXG4gICAgdGhpcy5jb250YWluZXIgPSByZWdpc3RlckFuZEdldFNjcm9sbENvbnRhaW5lcihwYXJhbWV0ZXJzLmNvbnRhaW5lcik7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtUaWNrYWJsZXxXQUFQSUFuaW1hdGlvbn0gKi9cbiAgICB0aGlzLmxpbmtlZCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMucmVwZWF0ID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5ob3Jpem9udGFsID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFBhcmFtfFNjcm9sbFRocmVzaG9sZFZhbHVlfFNjcm9sbFRocmVzaG9sZENhbGxiYWNrfSAqL1xuICAgIHRoaXMuZW50ZXIgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2t9ICovXG4gICAgdGhpcy5sZWF2ZSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuc3luYyA9IGlzRWFzZSB8fCBpc1Ntb290aCB8fCAhIXN5bmNNZXRob2RzO1xuICAgIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gICAgdGhpcy5zeW5jRWFzZSA9IGlzRWFzZSA/IGVhc2UgOiBudWxsO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc3luY1Ntb290aCA9IGlzU21vb3RoID8gc3luY01vZGUgPT09IHRydWUgfHwgaXNMaW5lYXIgPyAxIDogLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHN5bmNNb2RlKSA6IG51bGw7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNFbnRlciA9IHN5bmNNZXRob2RzICYmICFiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMF0gPyBzeW5jTWV0aG9kc1swXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNMZWF2ZSA9IHN5bmNNZXRob2RzICYmICFiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMV0gPyBzeW5jTWV0aG9kc1sxXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNFbnRlckZvcndhcmQgPSBzeW5jTWV0aG9kcyAmJiBiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMF0gPyBzeW5jTWV0aG9kc1swXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNMZWF2ZUZvcndhcmQgPSBzeW5jTWV0aG9kcyAmJiBiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMV0gPyBzeW5jTWV0aG9kc1sxXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNFbnRlckJhY2t3YXJkID0gc3luY01ldGhvZHMgJiYgYmlEaXJTeW5jICYmIHN5bmNNZXRob2RzWzJdID8gc3luY01ldGhvZHNbMl0gOiBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25TeW5jTGVhdmVCYWNrd2FyZCA9IHN5bmNNZXRob2RzICYmIGJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1szXSA/IHN5bmNNZXRob2RzWzNdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uRW50ZXIgPSBwYXJhbWV0ZXJzLm9uRW50ZXIgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uTGVhdmUgPSBwYXJhbWV0ZXJzLm9uTGVhdmUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uRW50ZXJGb3J3YXJkID0gcGFyYW1ldGVycy5vbkVudGVyRm9yd2FyZCB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25MZWF2ZUZvcndhcmQgPSBwYXJhbWV0ZXJzLm9uTGVhdmVGb3J3YXJkIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vbkVudGVyQmFja3dhcmQgPSBwYXJhbWV0ZXJzLm9uRW50ZXJCYWNrd2FyZCB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25MZWF2ZUJhY2t3YXJkID0gcGFyYW1ldGVycy5vbkxlYXZlQmFja3dhcmQgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uVXBkYXRlID0gcGFyYW1ldGVycy5vblVwZGF0ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25TeW5jQ29tcGxldGUgPSBwYXJhbWV0ZXJzLm9uU3luY0NvbXBsZXRlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMucmV2ZXJ0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5iZWdhbiA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmlzSW5WaWV3ID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuZm9yY2VFbnRlciA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmhhc0VudGVyZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gICAgLy8gLyoqIEB0eXBlIHtBcnJheS48TnVtYmVyPn0gKi9cbiAgICAvLyB0aGlzLm9mZnNldHMgPSBbXTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5vZmZzZXRTdGFydCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5vZmZzZXRFbmQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMucHJldlByb2dyZXNzID0gMDtcbiAgICAvKiogQHR5cGUge0FycmF5fSAqL1xuICAgIHRoaXMudGhyZXNob2xkcyA9IFsnc3RhcnQnLCAnZW5kJywgJ2VuZCcsICdzdGFydCddO1xuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5jb29yZHMgPSBbMCwgMCwgMCwgMF07XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLmRlYnVnU3R5bGVzID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuICAgIHRoaXMuJGRlYnVnID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyUGFyYW1zfSAqL1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtZXRlcnM7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuX2RlYnVnID0gc2V0VmFsdWUocGFyYW1ldGVycy5kZWJ1ZywgZmFsc2UpO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgICBhZGRDaGlsZCh0aGlzLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgLy8gV2FpdCBmb3IgdGhlIG5leHQgZnJhbWUgdG8gYWRkIHRvIHRoZSBjb250YWluZXIgaW4gb3JkZXIgdG8gaGFuZGxlIGNhbGxzIHRvIGxpbmsoKVxuICAgIHN5bmMoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucmV2ZXJ0ZWQpIHJldHVybjtcbiAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8ocGFyc2VUYXJnZXRzKHBhcmFtZXRlcnMudGFyZ2V0KVswXSk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0IHx8IGRvYy5ib2R5O1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kZWJ1ZykgdGhpcy5kZWJ1ZygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlja2FibGV8V0FBUElBbmltYXRpb259IGxpbmtlZFxuICAgKi9cbiAgbGluayhsaW5rZWQpIHtcbiAgICBpZiAobGlua2VkKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdG8gcGF1c2UgdGhlIGxpbmtlZCBvYmplY3QgaW4gY2FzZSBpdCdzIGFkZGVkIGxhdGVyXG4gICAgICBsaW5rZWQucGF1c2UoKTtcbiAgICAgIHRoaXMubGlua2VkID0gbGlua2VkO1xuICAgICAgLy8gVHJ5IHRvIHVzZSBhIHRhcmdldCBvZiB0aGUgbGlua2VkIG9iamVjdCBpZiBubyB0YXJnZXQgcGFyYW1ldGVycyBzcGVjaWZpZWRcbiAgICAgIGlmICghdGhpcy5fcGFyYW1zLnRhcmdldCkge1xuICAgICAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuICAgICAgICBsZXQgJGxpbmtlZFRhcmdldDtcbiAgICAgICAgaWYgKCFpc1VuZCgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqLyhsaW5rZWQpLnRhcmdldHMpKSB7XG4gICAgICAgICAgJGxpbmtlZFRhcmdldCA9IGdldEFuaW1hdGlvbkRvbVRhcmdldCgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqLyhsaW5rZWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oLyoqIEB0eXBlIHtUaW1lbGluZX0gKi8obGlua2VkKSwgKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50YXJnZXRzICYmICEkbGlua2VkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICRsaW5rZWRUYXJnZXQgPSBnZXRBbmltYXRpb25Eb21UYXJnZXQoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8oY2hpbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjayB0byBib2R5IGlmIG5vIHRhcmdldCBmb3VuZFxuICAgICAgICB0aGlzLnRhcmdldCA9ICRsaW5rZWRUYXJnZXQgfHwgZG9jLmJvZHk7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCB2ZWxvY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXIudmVsb2NpdHk7XG4gIH1cblxuICBnZXQgYmFja3dhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbCA/IHRoaXMuY29udGFpbmVyLmJhY2t3YXJkWCA6IHRoaXMuY29udGFpbmVyLmJhY2t3YXJkWTtcbiAgfVxuXG4gIGdldCBzY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbCA/IHRoaXMuY29udGFpbmVyLnNjcm9sbFggOiB0aGlzLmNvbnRhaW5lci5zY3JvbGxZO1xuICB9XG5cbiAgZ2V0IHByb2dyZXNzKCkge1xuICAgIGNvbnN0IHAgPSAodGhpcy5zY3JvbGwgLSB0aGlzLm9mZnNldFN0YXJ0KSAvIHRoaXMuZGlzdGFuY2U7XG4gICAgcmV0dXJuIHAgPT09IEluZmluaXR5IHx8IGlzTmFOKHApID8gMCA6IHJvdW5kKGNsYW1wKHAsIDAsIDEpLCA2KTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgLy8gVGhpcyBmbGFnIGlzIHVzZWQgdG8gcHJldmVudCBydW5uaW5nIGhhbmRsZVNjcm9sbCgpIG91dHNpZGUgb2YgdGhpcy5yZWZyZXNoKCkgd2l0aCB2YWx1ZXMgbm90IGNhbGN1bGF0ZWRcbiAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMucmV2ZXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gICAgdGhpcy5yZXBlYXQgPSBzZXRWYWx1ZShwYXJzZVNjcm9sbE9ic2VydmVyRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnJlcGVhdCwgdGhpcyksIHRydWUpO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHNldFZhbHVlKHBhcnNlU2Nyb2xsT2JzZXJ2ZXJGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuYXhpcywgdGhpcyksICd5JykgPT09ICd4JztcbiAgICB0aGlzLmVudGVyID0gc2V0VmFsdWUocGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5lbnRlciwgdGhpcyksICdlbmQgc3RhcnQnKTtcbiAgICB0aGlzLmxlYXZlID0gc2V0VmFsdWUocGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5sZWF2ZSwgdGhpcyksICdzdGFydCBlbmQnKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVEZWJ1ZygpIHtcbiAgICBpZiAodGhpcy4kZGVidWcpIHtcbiAgICAgIHRoaXMuJGRlYnVnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZGVidWcpO1xuICAgICAgdGhpcy4kZGVidWcgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWJ1Z1N0eWxlcykge1xuICAgICAgdGhpcy5kZWJ1Z1N0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuJGRlYnVnID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWJ1ZygpIHtcbiAgICB0aGlzLnJlbW92ZURlYnVnKCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgY29uc3QgaXNIb3JpID0gdGhpcy5ob3Jpem9udGFsO1xuICAgIGNvbnN0ICRleGlzdGluZ0RlYnVnID0gY29udGFpbmVyLmVsZW1lbnQucXVlcnlTZWxlY3RvcignOnNjb3BlID4gLmFuaW1lanMtb25zY3JvbGwtZGVidWcnKTtcbiAgICBjb25zdCAkZGVidWcgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgJHRocmVzaG9sZHMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgJHRyaWdnZXJzID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbG9yID0gZGVidWdDb2xvcnMkMVt0aGlzLmluZGV4ICUgZGVidWdDb2xvcnMkMS5sZW5ndGhdO1xuICAgIGNvbnN0IHVzZVdpbiA9IGNvbnRhaW5lci51c2VXaW47XG4gICAgY29uc3QgY29udGFpbmVyV2lkdGggPSB1c2VXaW4gPyBjb250YWluZXIud2luV2lkdGggOiBjb250YWluZXIud2lkdGg7XG4gICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gdXNlV2luID8gY29udGFpbmVyLndpbkhlaWdodCA6IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgY29uc3Qgc2Nyb2xsV2lkdGggPSBjb250YWluZXIuc2Nyb2xsV2lkdGg7XG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gY29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5jb250YWluZXIud2lkdGggPiAzNjAgPyAzMjAgOiAyNjA7XG4gICAgY29uc3Qgb2ZmTGVmdCA9IGlzSG9yaSA/IDAgOiAxMDtcbiAgICBjb25zdCBvZmZUb3AgPSBpc0hvcmkgPyAxMCA6IDA7XG4gICAgY29uc3QgaGFsZiA9IGlzSG9yaSA/IDI0IDogc2l6ZSAvIDI7XG4gICAgY29uc3QgbGFiZWxIZWlnaHQgPSBpc0hvcmkgPyBoYWxmIDogMTU7XG4gICAgY29uc3QgbGFiZWxXaWR0aCA9IGlzSG9yaSA/IDYwIDogaGFsZjtcbiAgICBjb25zdCBsYWJlbFNpemUgPSBpc0hvcmkgPyBsYWJlbFdpZHRoIDogbGFiZWxIZWlnaHQ7XG4gICAgY29uc3QgcmVwZWF0ID0gaXNIb3JpID8gJ3JlcGVhdC14JyA6ICdyZXBlYXQteSc7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY29uc3QgZ3JhZGllbnRPZmZzZXQgPSB2ID0+IGlzSG9yaSA/ICcwcHggJysodikrJ3B4JyA6ICh2KSsncHgnKycgMnB4JztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjb25zdCBsaW5lQ1NTID0gKGMpID0+IGBsaW5lYXItZ3JhZGllbnQoJHtpc0hvcmkgPyA5MCA6IDB9ZGVnLCAke2N9IDJweCwgdHJhbnNwYXJlbnQgMXB4KWA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjb25zdCBiYXNlQ1NTID0gKHAsIGwsIHQsIHcsIGgpID0+IGBwb3NpdGlvbjoke3B9O2xlZnQ6JHtsfXB4O3RvcDoke3R9cHg7d2lkdGg6JHt3fXB4O2hlaWdodDoke2h9cHg7YDtcbiAgICAkZGVidWcuc3R5bGUuY3NzVGV4dCA9IGAke2Jhc2VDU1MoJ2Fic29sdXRlJywgb2ZmTGVmdCwgb2ZmVG9wLCBpc0hvcmkgPyBzY3JvbGxXaWR0aCA6IHNpemUsIGlzSG9yaSA/IHNpemUgOiBzY3JvbGxIZWlnaHQpfVxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB6LWluZGV4OiAke3RoaXMuY29udGFpbmVyLnpJbmRleCsrfTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBmbGV4LWRpcmVjdGlvbjogJHtpc0hvcmkgPyAnY29sdW1uJyA6ICdyb3cnfTtcbiAgICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMHB4IDFweCAwcHggcmdiYSgwLDAsMCwuNzUpKTtcbiAgICBgO1xuICAgICR0aHJlc2hvbGRzLnN0eWxlLmNzc1RleHQgPSBgJHtiYXNlQ1NTKCdzdGlja3knLCAwLCAwLCBpc0hvcmkgPyBjb250YWluZXJXaWR0aCA6IGhhbGYsIGlzSG9yaSA/IGhhbGYgOiBjb250YWluZXJIZWlnaHQpfWA7XG4gICAgaWYgKCEkZXhpc3RpbmdEZWJ1Zykge1xuICAgICAgJHRocmVzaG9sZHMuc3R5bGUuY3NzVGV4dCArPSBgYmFja2dyb3VuZDpcbiAgICAgICAgJHtsaW5lQ1NTKCcjRkZGRicpfSR7Z3JhZGllbnRPZmZzZXQoaGFsZi0xMCl9IC8gJHtpc0hvcmkgPyAnMTAwcHggMTAwcHgnIDogJzEwMHB4IDEwMHB4J30gJHtyZXBlYXR9LFxuICAgICAgICAke2xpbmVDU1MoJyNGRkY4Jyl9JHtncmFkaWVudE9mZnNldChoYWxmLTEwKX0gLyAke2lzSG9yaSA/ICcxMHB4IDEwcHgnIDogJzEwcHggMTBweCd9ICR7cmVwZWF0fTtcbiAgICAgIGA7XG4gICAgfVxuICAgICR0cmlnZ2Vycy5zdHlsZS5jc3NUZXh0ID0gYCR7YmFzZUNTUygncmVsYXRpdmUnLCAwLCAwLCBpc0hvcmkgPyBzY3JvbGxXaWR0aCA6IGhhbGYsIGlzSG9yaSA/IGhhbGYgOiBzY3JvbGxIZWlnaHQpfWA7XG4gICAgaWYgKCEkZXhpc3RpbmdEZWJ1Zykge1xuICAgICAgJHRyaWdnZXJzLnN0eWxlLmNzc1RleHQgKz0gYGJhY2tncm91bmQ6XG4gICAgICAgICR7bGluZUNTUygnI0ZGRkYnKX0ke2dyYWRpZW50T2Zmc2V0KDApfSAvICR7aXNIb3JpID8gJzEwMHB4IDEwcHgnIDogJzEwcHggMTAwcHgnfSAke3JlcGVhdH0sXG4gICAgICAgICR7bGluZUNTUygnI0ZGRjgnKX0ke2dyYWRpZW50T2Zmc2V0KDApfSAvICR7aXNIb3JpID8gJzEwcHggMHB4JyA6ICcwcHggMTBweCd9ICR7cmVwZWF0fTtcbiAgICAgIGA7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IFsnIGVudGVyOiAnLCAnIGxlYXZlOiAnXTtcbiAgICB0aGlzLmNvb3Jkcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICBjb25zdCBpc1ZpZXcgPSBpID4gMTtcbiAgICAgIGNvbnN0IHZhbHVlID0gKGlzVmlldyA/IDAgOiB0aGlzLm9mZnNldCkgKyB2O1xuICAgICAgY29uc3QgaXNUYWlsID0gaSAlIDI7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gdmFsdWUgPCBsYWJlbFNpemU7XG4gICAgICBjb25zdCBpc092ZXIgPSB2YWx1ZSA+IChpc1ZpZXcgPyBpc0hvcmkgPyBjb250YWluZXJXaWR0aCA6IGNvbnRhaW5lckhlaWdodCA6IGlzSG9yaSA/IHNjcm9sbFdpZHRoIDogc2Nyb2xsSGVpZ2h0KSAtIGxhYmVsU2l6ZTtcbiAgICAgIGNvbnN0IGlzRmxpcCA9IChpc1ZpZXcgPyBpc1RhaWwgJiYgIWlzRmlyc3QgOiAhaXNUYWlsICYmICFpc0ZpcnN0KSB8fCBpc092ZXI7XG4gICAgICBjb25zdCAkbGFiZWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb25zdCAkdGV4dCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IGRpclByb3AgPSBpc0hvcmkgPyBpc0ZsaXAgPyAncmlnaHQnIDogJ2xlZnQnIDogaXNGbGlwID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgIGNvbnN0IGZsaXBPZmZzZXQgPSBpc0ZsaXAgPyAoaXNIb3JpID8gbGFiZWxXaWR0aCA6IGxhYmVsSGVpZ2h0KSArICghaXNWaWV3ID8gaXNIb3JpID8gLTEgOiAtMiA6IGlzSG9yaSA/IC0xIDogaXNPdmVyID8gMCA6IC0yKSA6ICFpc1ZpZXcgPyBpc0hvcmkgPyAxIDogMCA6IGlzSG9yaSA/IDEgOiAwO1xuICAgICAgLy8gJHRleHQuaW5uZXJIVE1MID0gYCR7IWlzVmlldyA/ICcnIDogbGFiZWxzW2lzVGFpbF0gKyAnICd9JHt0aGlzLmlkfTogJHt0aGlzLnRocmVzaG9sZHNbaV19ICR7aXNWaWV3ID8gJycgOiBsYWJlbHNbaXNUYWlsXX1gO1xuICAgICAgJHRleHQuaW5uZXJIVE1MID0gYCR7dGhpcy5pZH0ke2xhYmVsc1tpc1RhaWxdfSR7dGhpcy50aHJlc2hvbGRzW2ldfWA7XG4gICAgICAkbGFiZWwuc3R5bGUuY3NzVGV4dCA9IGAke2Jhc2VDU1MoJ2Fic29sdXRlJywgMCwgMCwgbGFiZWxXaWR0aCwgbGFiZWxIZWlnaHQpfVxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogJHtpc0hvcmkgPyAnY29sdW1uJyA6ICdyb3cnfTtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LSR7aXNWaWV3ID8gJ3N0YXJ0JyA6ICdlbmQnfTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtJHtpc0ZsaXAgPyAnZW5kJyA6ICdzdGFydCd9O1xuICAgICAgICBib3JkZXItJHtkaXJQcm9wfTogMnB4ICR7aXNUYWlsID8gJ3NvbGlkJyA6ICdzb2xpZCd9ICR7Y29sb3J9O1xuICAgICAgYDtcbiAgICAgICR0ZXh0LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIG1heC13aWR0aDogJHsoc2l6ZSAvIDIpIC0gMTB9cHg7XG4gICAgICAgIGhlaWdodDogJHtsYWJlbEhlaWdodH07XG4gICAgICAgIG1hcmdpbi0ke2lzSG9yaSA/IGlzRmxpcCA/ICdyaWdodCcgOiAnbGVmdCcgOiBpc0ZsaXAgPyAnYm90dG9tJyA6ICd0b3AnfTogLTJweDtcbiAgICAgICAgcGFkZGluZzogMXB4O1xuICAgICAgICBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBtb25vc3BhY2U7XG4gICAgICAgIGZvbnQtc2l6ZTogMTBweDtcbiAgICAgICAgbGV0dGVyLXNwYWNpbmc6IC0uMDI1ZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiA5cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIHRleHQtYWxpZ246ICR7aXNIb3JpICYmIGlzRmxpcCB8fCAhaXNIb3JpICYmICFpc1ZpZXcgPyAncmlnaHQnIDogJ2xlZnQnfTtcbiAgICAgICAgd2hpdGUtc3BhY2U6IHByZTtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgIGNvbG9yOiAke2lzVGFpbCA/IGNvbG9yIDogJ3JnYmEoMCwwLDAsLjc1KSd9O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2lzVGFpbCA/ICdyZ2JhKDAsMCwwLC42NSknIDogY29sb3J9O1xuICAgICAgICBib3JkZXI6IDJweCBzb2xpZCAke2lzVGFpbCA/IGNvbG9yIDogJ3RyYW5zcGFyZW50J307XG4gICAgICAgIGJvcmRlci0ke2lzSG9yaSA/IGlzRmxpcCA/ICd0b3AtbGVmdCcgOiAndG9wLXJpZ2h0JyA6IGlzRmxpcCA/ICd0b3AtbGVmdCcgOiAnYm90dG9tLWxlZnQnfS1yYWRpdXM6IDVweDtcbiAgICAgICAgYm9yZGVyLSR7aXNIb3JpID8gaXNGbGlwID8gJ2JvdHRvbS1sZWZ0JyA6ICdib3R0b20tcmlnaHQnIDogaXNGbGlwID8gJ3RvcC1yaWdodCcgOiAnYm90dG9tLXJpZ2h0J30tcmFkaXVzOiA1cHg7XG4gICAgICBgO1xuICAgICAgJGxhYmVsLmFwcGVuZENoaWxkKCR0ZXh0KTtcbiAgICAgIGxldCBwb3NpdGlvbiA9IHZhbHVlIC0gZmxpcE9mZnNldCArIChpc0hvcmkgPyAxIDogMCk7XG4gICAgICAkbGFiZWwuc3R5bGVbaXNIb3JpID8gJ2xlZnQnIDogJ3RvcCddID0gYCR7cG9zaXRpb259cHhgO1xuICAgICAgLy8gJGxhYmVsLnN0eWxlW2lzSG9yaSA/ICdsZWZ0JyA6ICd0b3AnXSA9IHZhbHVlIC0gZmxpcE9mZnNldCArICghaXNGbGlwICYmIGlzRmlyc3QgJiYgIWlzVmlldyA/IDEgOiBpc0ZsaXAgPyAwIDogLTIpICsgJ3B4JztcbiAgICAgIChpc1ZpZXcgPyAkdGhyZXNob2xkcyA6ICR0cmlnZ2VycykuYXBwZW5kQ2hpbGQoJGxhYmVsKTtcbiAgICB9KTtcblxuICAgICRkZWJ1Zy5hcHBlbmRDaGlsZCgkdGhyZXNob2xkcyk7XG4gICAgJGRlYnVnLmFwcGVuZENoaWxkKCR0cmlnZ2Vycyk7XG4gICAgY29udGFpbmVyLmVsZW1lbnQuYXBwZW5kQ2hpbGQoJGRlYnVnKTtcblxuICAgIGlmICghJGV4aXN0aW5nRGVidWcpICRkZWJ1Zy5jbGFzc0xpc3QuYWRkKCdhbmltZWpzLW9uc2Nyb2xsLWRlYnVnJyk7XG4gICAgdGhpcy4kZGVidWcgPSAkZGVidWc7XG4gICAgY29uc3QgY29udGFpbmVyUG9zaXRpb24gPSBnZXRUYXJnZXRWYWx1ZShjb250YWluZXIuZWxlbWVudCwgJ3Bvc2l0aW9uJyk7XG4gICAgaWYgKGNvbnRhaW5lclBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgdGhpcy5kZWJ1Z1N0eWxlcyA9IHNldFRhcmdldFZhbHVlcyhjb250YWluZXIuZWxlbWVudCwgeyBwb3NpdGlvbjogJ3JlbGF0aXZlICd9KTtcbiAgICB9XG5cbiAgfVxuXG4gIHVwZGF0ZUJvdW5kcygpIHtcbiAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgIHRoaXMucmVtb3ZlRGVidWcoKTtcbiAgICB9XG4gICAgbGV0IHN0aWNreXM7XG4gICAgY29uc3QgJHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIGNvbnN0IGlzSG9yaSA9IHRoaXMuaG9yaXpvbnRhbDtcbiAgICBjb25zdCBsaW5rZWQgPSB0aGlzLmxpbmtlZDtcbiAgICBsZXQgbGlua2VkVGltZTtcbiAgICBsZXQgJGVsID0gJHRhcmdldDtcbiAgICAvLyBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgLy8gbGV0IG9mZnNldFkgPSAwO1xuICAgIC8vIGxldCAkb2Zmc2V0UGFyZW50ID0gJGVsO1xuICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gKi9cbiAgICBpZiAobGlua2VkKSB7XG4gICAgICBsaW5rZWRUaW1lID0gbGlua2VkLmN1cnJlbnRUaW1lO1xuICAgICAgbGlua2VkLnNlZWsoMCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qIE9sZCBpbXBsZW1lbnRhdGlvbiB0byBnZXQgb2Zmc2V0IGFuZCB0YXJnZXRTaXplIGJlZm9yZSBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL2p1bGlhbmdhcm5pZXIvYW5pbWUvaXNzdWVzLzEwMjFcbiAgICAvLyBjb25zdCBpc0NvbnRhaW5lclN0YXRpYyA9IGdldFRhcmdldFZhbHVlKGNvbnRhaW5lci5lbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycgPyBzZXRUYXJnZXRWYWx1ZXMoY29udGFpbmVyLmVsZW1lbnQsIHsgcG9zaXRpb246ICdyZWxhdGl2ZSAnfSkgOiBmYWxzZTtcbiAgICAvLyB3aGlsZSAoJGVsICYmICRlbCAhPT0gY29udGFpbmVyLmVsZW1lbnQgJiYgJGVsICE9PSBkb2MuYm9keSkge1xuICAgIC8vICAgY29uc3QgaXNTdGlja3kgPSBnZXRUYXJnZXRWYWx1ZSgkZWwsICdwb3NpdGlvbicpID09PSAnc3RpY2t5JyA/XG4gICAgLy8gICAgICAgICAgICAgICAgICAgIHNldFRhcmdldFZhbHVlcygkZWwsIHsgcG9zaXRpb246ICdzdGF0aWMnIH0pIDpcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgZmFsc2U7XG4gICAgLy8gICBpZiAoJGVsID09PSAkb2Zmc2V0UGFyZW50KSB7XG4gICAgLy8gICAgIG9mZnNldFggKz0gJGVsLm9mZnNldExlZnQgfHwgMDtcbiAgICAvLyAgICAgb2Zmc2V0WSArPSAkZWwub2Zmc2V0VG9wIHx8IDA7XG4gICAgLy8gICAgICRvZmZzZXRQYXJlbnQgPSAkZWwub2Zmc2V0UGFyZW50O1xuICAgIC8vICAgfVxuICAgIC8vICAgJGVsID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oJGVsLnBhcmVudEVsZW1lbnQpO1xuICAgIC8vICAgaWYgKGlzU3RpY2t5KSB7XG4gICAgLy8gICAgIGlmICghc3RpY2t5cykgc3RpY2t5cyA9IFtdO1xuICAgIC8vICAgICBzdGlja3lzLnB1c2goaXNTdGlja3kpO1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICAvLyBpZiAoaXNDb250YWluZXJTdGF0aWMpIGlzQ29udGFpbmVyU3RhdGljLnJldmVydCgpO1xuICAgIC8vIGNvbnN0IG9mZnNldCA9IGlzSG9yaSA/IG9mZnNldFggOiBvZmZzZXRZO1xuICAgIC8vIGNvbnN0IHRhcmdldFNpemUgPSBpc0hvcmkgPyAkdGFyZ2V0Lm9mZnNldFdpZHRoIDogJHRhcmdldC5vZmZzZXRIZWlnaHQ7XG5cbiAgICB3aGlsZSAoJGVsICYmICRlbCAhPT0gY29udGFpbmVyLmVsZW1lbnQgJiYgJGVsICE9PSBkb2MuYm9keSkge1xuICAgICAgY29uc3QgaXNTdGlja3kgPSBnZXRUYXJnZXRWYWx1ZSgkZWwsICdwb3NpdGlvbicpID09PSAnc3RpY2t5JyA/IHNldFRhcmdldFZhbHVlcygkZWwsIHsgcG9zaXRpb246ICdzdGF0aWMnIH0pIDogZmFsc2U7XG4gICAgICAkZWwgPSAkZWwucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChpc1N0aWNreSkge1xuICAgICAgICBpZiAoIXN0aWNreXMpIHN0aWNreXMgPSBbXTtcbiAgICAgICAgc3RpY2t5cy5wdXNoKGlzU3RpY2t5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVjdCA9ICR0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaXNIb3JpID8gcmVjdC5sZWZ0ICsgY29udGFpbmVyLnNjcm9sbFggLSBjb250YWluZXIubGVmdCA6IHJlY3QudG9wICsgY29udGFpbmVyLnNjcm9sbFkgLSBjb250YWluZXIudG9wO1xuICAgIGNvbnN0IHRhcmdldFNpemUgPSBpc0hvcmkgPyByZWN0LndpZHRoIDogcmVjdC5oZWlnaHQ7XG4gICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGlzSG9yaSA/IGNvbnRhaW5lci53aWR0aCA6IGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGlzSG9yaSA/IGNvbnRhaW5lci5zY3JvbGxXaWR0aCA6IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgY29uc3QgbWF4U2Nyb2xsID0gc2Nyb2xsU2l6ZSAtIGNvbnRhaW5lclNpemU7XG4gICAgY29uc3QgZW50ZXIgPSB0aGlzLmVudGVyO1xuICAgIGNvbnN0IGxlYXZlID0gdGhpcy5sZWF2ZTtcblxuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9ICovXG4gICAgbGV0IGVudGVyVGFyZ2V0ID0gJ3N0YXJ0JztcbiAgICAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFZhbHVlfSAqL1xuICAgIGxldCBsZWF2ZVRhcmdldCA9ICdlbmQnO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9ICovXG4gICAgbGV0IGVudGVyQ29udGFpbmVyID0gJ2VuZCc7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxUaHJlc2hvbGRWYWx1ZX0gKi9cbiAgICBsZXQgbGVhdmVDb250YWluZXIgPSAnc3RhcnQnO1xuXG4gICAgaWYgKGlzU3RyKGVudGVyKSkge1xuICAgICAgY29uc3Qgc3BsaXR0ZWQgPSAvKiogQHR5cGUge1N0cmluZ30gKi8oZW50ZXIpLnNwbGl0KCcgJyk7XG4gICAgICBlbnRlckNvbnRhaW5lciA9IHNwbGl0dGVkWzBdO1xuICAgICAgZW50ZXJUYXJnZXQgPSBzcGxpdHRlZC5sZW5ndGggPiAxID8gc3BsaXR0ZWRbMV0gOiBlbnRlclRhcmdldDtcbiAgICB9IGVsc2UgaWYgKGlzT2JqKGVudGVyKSkge1xuICAgICAgY29uc3QgZSA9IC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkUGFyYW19ICovKGVudGVyKTtcbiAgICAgIGlmICghaXNVbmQoZS5jb250YWluZXIpKSBlbnRlckNvbnRhaW5lciA9IGUuY29udGFpbmVyO1xuICAgICAgaWYgKCFpc1VuZChlLnRhcmdldCkpIGVudGVyVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgfSBlbHNlIGlmIChpc051bShlbnRlcikpIHtcbiAgICAgIGVudGVyQ29udGFpbmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKGVudGVyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHIobGVhdmUpKSB7XG4gICAgICBjb25zdCBzcGxpdHRlZCA9IC8qKiBAdHlwZSB7U3RyaW5nfSAqLyhsZWF2ZSkuc3BsaXQoJyAnKTtcbiAgICAgIGxlYXZlQ29udGFpbmVyID0gc3BsaXR0ZWRbMF07XG4gICAgICBsZWF2ZVRhcmdldCA9IHNwbGl0dGVkLmxlbmd0aCA+IDEgPyBzcGxpdHRlZFsxXSA6IGxlYXZlVGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAoaXNPYmoobGVhdmUpKSB7XG4gICAgICBjb25zdCB0ID0gLyoqIEB0eXBlIHtTY3JvbGxUaHJlc2hvbGRQYXJhbX0gKi8obGVhdmUpO1xuICAgICAgaWYgKCFpc1VuZCh0LmNvbnRhaW5lcikpIGxlYXZlQ29udGFpbmVyID0gdC5jb250YWluZXI7XG4gICAgICBpZiAoIWlzVW5kKHQudGFyZ2V0KSkgbGVhdmVUYXJnZXQgPSB0LnRhcmdldDtcbiAgICB9IGVsc2UgaWYgKGlzTnVtKGxlYXZlKSkge1xuICAgICAgbGVhdmVDb250YWluZXIgPSAvKiogQHR5cGUge051bWJlcn0gKi8obGVhdmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZEVudGVyVGFyZ2V0ID0gcGFyc2VCb3VuZFZhbHVlKCR0YXJnZXQsIGVudGVyVGFyZ2V0LCB0YXJnZXRTaXplKTtcbiAgICBjb25zdCBwYXJzZWRMZWF2ZVRhcmdldCA9IHBhcnNlQm91bmRWYWx1ZSgkdGFyZ2V0LCBsZWF2ZVRhcmdldCwgdGFyZ2V0U2l6ZSk7XG4gICAgY29uc3QgdW5kZXIgPSAocGFyc2VkRW50ZXJUYXJnZXQgKyBvZmZzZXQpIC0gY29udGFpbmVyU2l6ZTtcbiAgICBjb25zdCBvdmVyID0gKHBhcnNlZExlYXZlVGFyZ2V0ICsgb2Zmc2V0KSAtIG1heFNjcm9sbDtcbiAgICBjb25zdCBwYXJzZWRFbnRlckNvbnRhaW5lciA9IHBhcnNlQm91bmRWYWx1ZSgkdGFyZ2V0LCBlbnRlckNvbnRhaW5lciwgY29udGFpbmVyU2l6ZSwgdW5kZXIsIG92ZXIpO1xuICAgIGNvbnN0IHBhcnNlZExlYXZlQ29udGFpbmVyID0gcGFyc2VCb3VuZFZhbHVlKCR0YXJnZXQsIGxlYXZlQ29udGFpbmVyLCBjb250YWluZXJTaXplLCB1bmRlciwgb3Zlcik7XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSBwYXJzZWRFbnRlclRhcmdldCArIG9mZnNldCAtIHBhcnNlZEVudGVyQ29udGFpbmVyO1xuICAgIGNvbnN0IG9mZnNldEVuZCA9IHBhcnNlZExlYXZlVGFyZ2V0ICsgb2Zmc2V0IC0gcGFyc2VkTGVhdmVDb250YWluZXI7XG4gICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSBvZmZzZXRFbmQgLSBvZmZzZXRTdGFydDtcbiAgICAvLyB0aGlzLm9mZnNldHNbMF0gPSBvZmZzZXRYO1xuICAgIC8vIHRoaXMub2Zmc2V0c1sxXSA9IG9mZnNldFk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5vZmZzZXRTdGFydCA9IG9mZnNldFN0YXJ0O1xuICAgIHRoaXMub2Zmc2V0RW5kID0gb2Zmc2V0RW5kO1xuICAgIHRoaXMuZGlzdGFuY2UgPSBzY3JvbGxEZWx0YSA8PSAwID8gMCA6IHNjcm9sbERlbHRhO1xuICAgIHRoaXMudGhyZXNob2xkcyA9IFtlbnRlclRhcmdldCwgbGVhdmVUYXJnZXQsIGVudGVyQ29udGFpbmVyLCBsZWF2ZUNvbnRhaW5lcl07XG4gICAgdGhpcy5jb29yZHMgPSBbcGFyc2VkRW50ZXJUYXJnZXQsIHBhcnNlZExlYXZlVGFyZ2V0LCBwYXJzZWRFbnRlckNvbnRhaW5lciwgcGFyc2VkTGVhdmVDb250YWluZXJdO1xuICAgIGlmIChzdGlja3lzKSB7XG4gICAgICBzdGlja3lzLmZvckVhY2goc3RpY2t5ID0+IHN0aWNreS5yZXZlcnQoKSk7XG4gICAgfVxuICAgIGlmIChsaW5rZWQpIHtcbiAgICAgIGxpbmtlZC5zZWVrKGxpbmtlZFRpbWUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgIHRoaXMuZGVidWcoKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTY3JvbGwoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVhZHkpIHJldHVybjtcbiAgICBjb25zdCBsaW5rZWQgPSB0aGlzLmxpbmtlZDtcbiAgICBjb25zdCBzeW5jID0gdGhpcy5zeW5jO1xuICAgIGNvbnN0IHN5bmNFYXNlID0gdGhpcy5zeW5jRWFzZTtcbiAgICBjb25zdCBzeW5jU21vb3RoID0gdGhpcy5zeW5jU21vb3RoO1xuICAgIGNvbnN0IHNob3VsZFNlZWsgPSBsaW5rZWQgJiYgKHN5bmNFYXNlIHx8IHN5bmNTbW9vdGgpO1xuICAgIGNvbnN0IGlzSG9yaSA9IHRoaXMuaG9yaXpvbnRhbDtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLnNjcm9sbDtcbiAgICBjb25zdCBpc0JlZm9yZSA9IHNjcm9sbCA8PSB0aGlzLm9mZnNldFN0YXJ0O1xuICAgIGNvbnN0IGlzQWZ0ZXIgPSBzY3JvbGwgPj0gdGhpcy5vZmZzZXRFbmQ7XG4gICAgY29uc3QgaXNJblZpZXcgPSAhaXNCZWZvcmUgJiYgIWlzQWZ0ZXI7XG4gICAgY29uc3QgaXNPblRoZUVkZ2UgPSBzY3JvbGwgPT09IHRoaXMub2Zmc2V0U3RhcnQgfHwgc2Nyb2xsID09PSB0aGlzLm9mZnNldEVuZDtcbiAgICBjb25zdCBmb3JjZUVudGVyID0gIXRoaXMuaGFzRW50ZXJlZCAmJiBpc09uVGhlRWRnZTtcbiAgICBjb25zdCAkZGVidWcgPSB0aGlzLl9kZWJ1ZyAmJiB0aGlzLiRkZWJ1ZztcbiAgICBsZXQgaGFzVXBkYXRlZCA9IGZhbHNlO1xuICAgIGxldCBzeW5jQ29tcGxldGVkID0gZmFsc2U7XG4gICAgbGV0IHAgPSB0aGlzLnByb2dyZXNzO1xuXG4gICAgaWYgKGlzQmVmb3JlICYmIHRoaXMuYmVnYW4pIHtcbiAgICAgIHRoaXMuYmVnYW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocCA+IDAgJiYgIXRoaXMuYmVnYW4pIHtcbiAgICAgIHRoaXMuYmVnYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRTZWVrKSB7XG4gICAgICBjb25zdCBscCA9IGxpbmtlZC5wcm9ncmVzcztcbiAgICAgIGlmIChzeW5jU21vb3RoICYmIGlzTnVtKHN5bmNTbW9vdGgpKSB7XG4gICAgICAgIGlmICgvKiogQHR5cGUge051bWJlcn0gKi8oc3luY1Ntb290aCkgPCAxKSB7XG4gICAgICAgICAgY29uc3Qgc3RlcCA9IDAuMDAwMTtcbiAgICAgICAgICBjb25zdCBzbmFwID0gbHAgPCBwICYmIHAgPT09IDEgPyBzdGVwIDogbHAgPiBwICYmICFwID8gLXN0ZXAgOiAwO1xuICAgICAgICAgIHAgPSByb3VuZChsZXJwKGxwLCBwLCBpbnRlcnBvbGF0ZSguMDEsIC4yLCAvKiogQHR5cGUge051bWJlcn0gKi8oc3luY1Ntb290aCkpLCBmYWxzZSkgKyBzbmFwLCA2KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzeW5jRWFzZSkge1xuICAgICAgICBwID0gc3luY0Vhc2UocCk7XG4gICAgICB9XG4gICAgICBoYXNVcGRhdGVkID0gcCAhPT0gdGhpcy5wcmV2UHJvZ3Jlc3M7XG4gICAgICBzeW5jQ29tcGxldGVkID0gbHAgPT09IDE7XG4gICAgICBpZiAoaGFzVXBkYXRlZCAmJiAhc3luY0NvbXBsZXRlZCAmJiAoc3luY1Ntb290aCAmJiBscCkpIHtcbiAgICAgICAgY29udGFpbmVyLndha2VUaWNrZXIucmVzdGFydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkZGVidWcpIHtcbiAgICAgIGNvbnN0IHN0aWNreSA9IGlzSG9yaSA/IGNvbnRhaW5lci5zY3JvbGxZIDogY29udGFpbmVyLnNjcm9sbFg7XG4gICAgICAkZGVidWcuc3R5bGVbaXNIb3JpID8gJ3RvcCcgOiAnbGVmdCddID0gc3RpY2t5ICsgMTAgKyAncHgnO1xuICAgIH1cblxuICAgIC8vIFRyaWdnZXIgZW50ZXIgY2FsbGJhY2tzIGlmIGFscmVhZHkgaW4gdmlldyBvciB3aGVuIGVudGVyaW5nIHRoZSB2aWV3XG4gICAgaWYgKChpc0luVmlldyAmJiAhdGhpcy5pc0luVmlldykgfHwgKGZvcmNlRW50ZXIgJiYgIXRoaXMuZm9yY2VFbnRlciAmJiAhdGhpcy5oYXNFbnRlcmVkKSkge1xuICAgICAgaWYgKGlzSW5WaWV3KSB0aGlzLmlzSW5WaWV3ID0gdHJ1ZTtcbiAgICAgIGlmICghdGhpcy5mb3JjZUVudGVyIHx8ICF0aGlzLmhhc0VudGVyZWQpIHtcbiAgICAgICAgaWYgKCRkZWJ1ZyAmJiBpc0luVmlldykgJGRlYnVnLnN0eWxlLnpJbmRleCA9IGAke3RoaXMuY29udGFpbmVyLnpJbmRleCsrfWA7XG4gICAgICAgIHRoaXMub25TeW5jRW50ZXIodGhpcyk7XG4gICAgICAgIHRoaXMub25FbnRlcih0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuYmFja3dhcmQpIHtcbiAgICAgICAgICB0aGlzLm9uU3luY0VudGVyQmFja3dhcmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5vbkVudGVyQmFja3dhcmQodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vblN5bmNFbnRlckZvcndhcmQodGhpcyk7XG4gICAgICAgICAgdGhpcy5vbkVudGVyRm9yd2FyZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0VudGVyZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZm9yY2VFbnRlcikgdGhpcy5mb3JjZUVudGVyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJblZpZXcpIHtcbiAgICAgICAgdGhpcy5mb3JjZUVudGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzSW5WaWV3IHx8ICFpc0luVmlldyAmJiB0aGlzLmlzSW5WaWV3KSB7XG4gICAgICBoYXNVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVXBkYXRlZCkge1xuICAgICAgaWYgKHNob3VsZFNlZWspIGxpbmtlZC5zZWVrKGxpbmtlZC5kdXJhdGlvbiAqIHApO1xuICAgICAgdGhpcy5vblVwZGF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzSW5WaWV3ICYmIHRoaXMuaXNJblZpZXcpIHtcbiAgICAgIHRoaXMuaXNJblZpZXcgPSBmYWxzZTtcbiAgICAgIHRoaXMub25TeW5jTGVhdmUodGhpcyk7XG4gICAgICB0aGlzLm9uTGVhdmUodGhpcyk7XG4gICAgICBpZiAodGhpcy5iYWNrd2FyZCkge1xuICAgICAgICB0aGlzLm9uU3luY0xlYXZlQmFja3dhcmQodGhpcyk7XG4gICAgICAgIHRoaXMub25MZWF2ZUJhY2t3YXJkKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vblN5bmNMZWF2ZUZvcndhcmQodGhpcyk7XG4gICAgICAgIHRoaXMub25MZWF2ZUZvcndhcmQodGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoc3luYyAmJiAhc3luY1Ntb290aCkge1xuICAgICAgICBzeW5jQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocCA+PSAxICYmIHRoaXMuYmVnYW4gJiYgIXRoaXMuY29tcGxldGVkICYmIChzeW5jICYmIHN5bmNDb21wbGV0ZWQgfHwgIXN5bmMpKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICB0aGlzLm9uU3luY0NvbXBsZXRlKHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgaWYgKCghdGhpcy5yZXBlYXQgJiYgIWxpbmtlZCkgfHwgKCF0aGlzLnJlcGVhdCAmJiBsaW5rZWQgJiYgbGlua2VkLmNvbXBsZXRlZCkpIHtcbiAgICAgICAgdGhpcy5yZXZlcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocCA8IDEgJiYgdGhpcy5jb21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuY29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2UHJvZ3Jlc3MgPSBwO1xuICB9XG5cbiAgcmV2ZXJ0KCkge1xuICAgIGlmICh0aGlzLnJldmVydGVkKSByZXR1cm47XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgcmVtb3ZlQ2hpbGQoY29udGFpbmVyLCB0aGlzKTtcbiAgICBpZiAoIWNvbnRhaW5lci5faGVhZCkge1xuICAgICAgY29udGFpbmVyLnJldmVydCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVidWcpIHtcbiAgICAgIHRoaXMucmVtb3ZlRGVidWcoKTtcbiAgICB9XG4gICAgdGhpcy5yZXZlcnRlZCA9IHRydWU7XG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuXG4vKipcbiAqIEBwYXJhbSB7U2Nyb2xsT2JzZXJ2ZXJQYXJhbXN9IFtwYXJhbWV0ZXJzPXt9XVxuICogQHJldHVybiB7U2Nyb2xsT2JzZXJ2ZXJ9XG4gKi9cbmNvbnN0IG9uU2Nyb2xsID0gKHBhcmFtZXRlcnMgPSB7fSkgPT4gbmV3IFNjcm9sbE9ic2VydmVyKHBhcmFtZXRlcnMpO1xuXG5cblxuXG5jb25zdCBzZWdtZW50ZXIgPSAodHlwZW9mIEludGwgIT09ICd1bmRlZmluZWQnKSAmJiBJbnRsLlNlZ21lbnRlcjtcbmNvbnN0IHZhbHVlUmd4ID0gL1xce3ZhbHVlXFx9L2c7XG5jb25zdCBpbmRleFJneCA9IC9cXHtpXFx9L2c7XG5jb25zdCB3aGl0ZVNwYWNlR3JvdXBSZ3ggPSAvKFxccyspLztcbmNvbnN0IHdoaXRlU3BhY2VSZ3ggPSAvXlxccyskLztcbmNvbnN0IGxpbmVUeXBlID0gJ2xpbmUnO1xuY29uc3Qgd29yZFR5cGUgPSAnd29yZCc7XG5jb25zdCBjaGFyVHlwZSA9ICdjaGFyJztcbmNvbnN0IGRhdGFMaW5lID0gYGRhdGEtbGluZWA7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VnbWVudFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHNlZ21lbnRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2lzV29yZExpa2VdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZWdtZW50ZXJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oU3RyaW5nKTogSXRlcmFibGU8U2VnbWVudD59IHNlZ21lbnRcbiAqL1xuXG4vKiogQHR5cGUge1NlZ21lbnRlcn0gKi9cbmxldCB3b3JkU2VnbWVudGVyID0gbnVsbDtcbi8qKiBAdHlwZSB7U2VnbWVudGVyfSAqL1xubGV0IGdyYXBoZW1lU2VnbWVudGVyID0gbnVsbDtcbmxldCAkc3BsaXRUZW1wbGF0ZSA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtICB7U2VnbWVudH0gc2VnXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCBpc1NlZ21lbnRXb3JkTGlrZSA9IHNlZyA9PiB7XG4gIHJldHVybiBzZWcuaXNXb3JkTGlrZSB8fFxuICAgICAgICAgc2VnLnNlZ21lbnQgPT09ICcgJyB8fCAvLyBDb25zaWRlciBzcGFjZXMgYXMgd29yZHMgZmlyc3QsIHRoZW4gaGFuZGxlIHRoZW0gZGlmZnJlbnRseSBsYXRlclxuICAgICAgICAgaXNOdW0oK3NlZy5zZWdtZW50KTsgLy8gU2FmYXJpIGRvZXNuJ3QgY29uc2lkZXJzIG51bWJlcnMgYXMgd29yZHNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKi9cbmNvbnN0IHNldEFyaWFIaWRkZW4gPSAkZWwgPT4gJGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59XG4gKi9cbmNvbnN0IGdldEFsbFRvcExldmVsRWxlbWVudHMgPSAoJGVsLCB0eXBlKSA9PiBbLi4uLyoqIEB0eXBlIHsqfSAqLygkZWwucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtJHt0eXBlfV06bm90KFtkYXRhLSR7dHlwZX1dIFtkYXRhLSR7dHlwZX1dKWApKV07XG5cbmNvbnN0IGRlYnVnQ29sb3JzID0geyBsaW5lOiAnIzAwRDY3MicsIHdvcmQ6ICcjRkY0QjRCJywgY2hhcjogJyM1QTg3RkYnIH07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKi9cbmNvbnN0IGZpbHRlckVtcHR5RWxlbWVudHMgPSAkZWwgPT4ge1xuICBpZiAoISRlbC5jaGlsZEVsZW1lbnRDb3VudCAmJiAhJGVsLnRleHRDb250ZW50LnRyaW0oKSkge1xuICAgIGNvbnN0ICRwYXJlbnQgPSAkZWwucGFyZW50RWxlbWVudDtcbiAgICAkZWwucmVtb3ZlKCk7XG4gICAgaWYgKCRwYXJlbnQpIGZpbHRlckVtcHR5RWxlbWVudHMoJHBhcmVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gKiBAcGFyYW0ge1NldDxIVE1MRWxlbWVudD59IGJpblxuICogQHJldHVybnMge1NldDxIVE1MRWxlbWVudD59XG4gKi9cbmNvbnN0IGZpbHRlckxpbmVFbGVtZW50cyA9ICgkZWwsIGxpbmVJbmRleCwgYmluKSA9PiB7XG4gIGNvbnN0IGRhdGFMaW5lQXR0ciA9ICRlbC5nZXRBdHRyaWJ1dGUoZGF0YUxpbmUpO1xuICBpZiAoZGF0YUxpbmVBdHRyICE9PSBudWxsICYmICtkYXRhTGluZUF0dHIgIT09IGxpbmVJbmRleCB8fCAkZWwudGFnTmFtZSA9PT0gJ0JSJykgYmluLmFkZCgkZWwpO1xuICBsZXQgaSA9ICRlbC5jaGlsZEVsZW1lbnRDb3VudDtcbiAgd2hpbGUgKGktLSkgZmlsdGVyTGluZUVsZW1lbnRzKC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKCRlbC5jaGlsZHJlbltpXSksIGxpbmVJbmRleCwgYmluKTtcbiAgcmV0dXJuIGJpbjtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7J2xpbmUnfCd3b3JkJ3wnY2hhcid9IHR5cGVcbiAqIEBwYXJhbSAge3NwbGl0VGVtcGxhdGVQYXJhbXN9IHBhcmFtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBnZW5lcmF0ZVRlbXBsYXRlID0gKHR5cGUsIHBhcmFtcyA9IHt9KSA9PiB7XG4gIGxldCB0ZW1wbGF0ZSA9IGBgO1xuICBjb25zdCBjbGFzc1N0cmluZyA9IGlzU3RyKHBhcmFtcy5jbGFzcykgPyBgIGNsYXNzPVwiJHtwYXJhbXMuY2xhc3N9XCJgIDogJyc7XG4gIGNvbnN0IGNsb25lVHlwZSA9IHNldFZhbHVlKHBhcmFtcy5jbG9uZSwgZmFsc2UpO1xuICBjb25zdCB3cmFwVHlwZSA9IHNldFZhbHVlKHBhcmFtcy53cmFwLCBmYWxzZSk7XG4gIGNvbnN0IG92ZXJmbG93ID0gd3JhcFR5cGUgPyB3cmFwVHlwZSA9PT0gdHJ1ZSA/ICdjbGlwJyA6IHdyYXBUeXBlIDogY2xvbmVUeXBlID8gJ2NsaXAnIDogZmFsc2U7XG4gIGlmICh3cmFwVHlwZSkgdGVtcGxhdGUgKz0gYDxzcGFuJHtvdmVyZmxvdyA/IGAgc3R5bGU9XCJvdmVyZmxvdzoke292ZXJmbG93fTtcImAgOiAnJ30+YDtcbiAgdGVtcGxhdGUgKz0gYDxzcGFuJHtjbGFzc1N0cmluZ30ke2Nsb25lVHlwZSA/IGAgc3R5bGU9XCJwb3NpdGlvbjpyZWxhdGl2ZTtcImAgOiAnJ30gZGF0YS0ke3R5cGV9PVwie2l9XCI+YDtcbiAgaWYgKGNsb25lVHlwZSkge1xuICAgIGNvbnN0IGxlZnQgPSBjbG9uZVR5cGUgPT09ICdsZWZ0JyA/ICctMTAwJScgOiBjbG9uZVR5cGUgPT09ICdyaWdodCcgPyAnMTAwJScgOiAnMCc7XG4gICAgY29uc3QgdG9wID0gY2xvbmVUeXBlID09PSAndG9wJyA/ICctMTAwJScgOiBjbG9uZVR5cGUgPT09ICdib3R0b20nID8gJzEwMCUnIDogJzAnO1xuICAgIHRlbXBsYXRlICs9IGA8c3Bhbj57dmFsdWV9PC9zcGFuPmA7XG4gICAgdGVtcGxhdGUgKz0gYDxzcGFuIGluZXJ0IHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOiR7dG9wfTtsZWZ0OiR7bGVmdH07d2hpdGUtc3BhY2U6bm93cmFwO1wiPnt2YWx1ZX08L3NwYW4+YDtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSArPSBge3ZhbHVlfWA7XG4gIH1cbiAgdGVtcGxhdGUgKz0gYDwvc3Bhbj5gO1xuICBpZiAod3JhcFR5cGUpIHRlbXBsYXRlICs9IGA8L3NwYW4+YDtcbiAgcmV0dXJuIHRlbXBsYXRlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd8U3BsaXRGdW5jdGlvblZhbHVlfSBodG1sVGVtcGxhdGVcbiAqIEBwYXJhbSAge0FycmF5PEhUTUxFbGVtZW50Pn0gc3RvcmVcbiAqIEBwYXJhbSAge05vZGV8SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSAge0RvY3VtZW50RnJhZ21lbnR9ICRwYXJlbnRGcmFnbWVudFxuICogQHBhcmFtICB7J2xpbmUnfCd3b3JkJ3wnY2hhcid9IHR5cGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGRlYnVnXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbmVJbmRleFxuICogQHBhcmFtICB7TnVtYmVyfSBbd29yZEluZGV4XVxuICogQHBhcmFtICB7TnVtYmVyfSBbY2hhckluZGV4XVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmNvbnN0IHByb2Nlc3NIVE1MVGVtcGxhdGUgPSAoaHRtbFRlbXBsYXRlLCBzdG9yZSwgbm9kZSwgJHBhcmVudEZyYWdtZW50LCB0eXBlLCBkZWJ1ZywgbGluZUluZGV4LCB3b3JkSW5kZXgsIGNoYXJJbmRleCkgPT4ge1xuICBjb25zdCBpc0xpbmUgPSB0eXBlID09PSBsaW5lVHlwZTtcbiAgY29uc3QgaXNDaGFyID0gdHlwZSA9PT0gY2hhclR5cGU7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGBfJHt0eXBlfV9gO1xuICBjb25zdCB0ZW1wbGF0ZSA9IGlzRm5jKGh0bWxUZW1wbGF0ZSkgPyBodG1sVGVtcGxhdGUobm9kZSkgOiBodG1sVGVtcGxhdGU7XG4gIGNvbnN0IGRpc3BsYXlTdHlsZSA9IGlzTGluZSA/ICdibG9jaycgOiAnaW5saW5lLWJsb2NrJztcbiAgJHNwbGl0VGVtcGxhdGUuaW5uZXJIVE1MID0gdGVtcGxhdGVcbiAgICAucmVwbGFjZSh2YWx1ZVJneCwgYDxpIGNsYXNzPVwiJHtjbGFzc05hbWV9XCI+PC9pPmApXG4gICAgLnJlcGxhY2UoaW5kZXhSZ3gsIGAke2lzQ2hhciA/IGNoYXJJbmRleCA6IGlzTGluZSA/IGxpbmVJbmRleCA6IHdvcmRJbmRleH1gKTtcbiAgY29uc3QgJGNvbnRlbnQgPSAkc3BsaXRUZW1wbGF0ZS5jb250ZW50O1xuICBjb25zdCAkaGlnaGVzdFBhcmVudCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKCRjb250ZW50LmZpcnN0RWxlbWVudENoaWxkKTtcbiAgY29uc3QgJHNwbGl0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oJGNvbnRlbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtJHt0eXBlfV1gKSkgfHwgJGhpZ2hlc3RQYXJlbnQ7XG4gIGNvbnN0ICRyZXBsYWNhYmxlcyA9IC8qKiBAdHlwZSB7Tm9kZUxpc3RPZjxIVE1MRWxlbWVudD59ICovKCRjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYGkuJHtjbGFzc05hbWV9YCkpO1xuICBjb25zdCByZXBsYWNhYmxlc0xlbmd0aCA9ICRyZXBsYWNhYmxlcy5sZW5ndGg7XG4gIGlmIChyZXBsYWNhYmxlc0xlbmd0aCkge1xuICAgICRoaWdoZXN0UGFyZW50LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5U3R5bGU7XG4gICAgJHNwbGl0LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5U3R5bGU7XG4gICAgJHNwbGl0LnNldEF0dHJpYnV0ZShkYXRhTGluZSwgYCR7bGluZUluZGV4fWApO1xuICAgIGlmICghaXNMaW5lKSB7XG4gICAgICAkc3BsaXQuc2V0QXR0cmlidXRlKCdkYXRhLXdvcmQnLCBgJHt3b3JkSW5kZXh9YCk7XG4gICAgICBpZiAoaXNDaGFyKSAkc3BsaXQuc2V0QXR0cmlidXRlKCdkYXRhLWNoYXInLCBgJHtjaGFySW5kZXh9YCk7XG4gICAgfVxuICAgIGxldCBpID0gcmVwbGFjYWJsZXNMZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY29uc3QgJHJlcGxhY2UgPSAkcmVwbGFjYWJsZXNbaV07XG4gICAgICBjb25zdCAkY2xvc2VzdFBhcmVudCA9ICRyZXBsYWNlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAkY2xvc2VzdFBhcmVudC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheVN0eWxlO1xuICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAkY2xvc2VzdFBhcmVudC5pbm5lckhUTUwgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhub2RlKS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkY2xvc2VzdFBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSksICRyZXBsYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RvcmUucHVzaCgkc3BsaXQpO1xuICAgICRwYXJlbnRGcmFnbWVudC5hcHBlbmRDaGlsZCgkY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKGBUaGUgZXhwcmVzc2lvbiBcInt2YWx1ZX1cIiBpcyBtaXNzaW5nIGZyb20gdGhlIHByb3ZpZGVkIHRlbXBsYXRlLmApO1xuICB9XG4gIGlmIChkZWJ1ZykgJGhpZ2hlc3RQYXJlbnQuc3R5bGUub3V0bGluZSA9IGAxcHggZG90dGVkICR7ZGVidWdDb2xvcnNbdHlwZV19YDtcbiAgcmV0dXJuICRoaWdoZXN0UGFyZW50O1xufTtcblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgc3BsaXRzIHRleHQgaW50byB3b3JkcyBhbmQgd3JhcHMgdGhlbSBpbiBzcGFuIGVsZW1lbnRzIHdoaWxlIHByZXNlcnZpbmcgdGhlIG9yaWdpbmFsIEhUTUwgc3RydWN0dXJlLlxuICogQGNsYXNzXG4gKi9cbmNsYXNzIFRleHRTcGxpdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudHxOb2RlTGlzdHxTdHJpbmd8QXJyYXk8SFRNTEVsZW1lbnQ+fSB0YXJnZXRcbiAgICogQHBhcmFtICB7VGV4dFNwbGl0dGVyUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgcGFyYW1ldGVycyA9IHt9KSB7XG4gICAgLy8gT25seSBpbml0IHNlZ21lbnRlcnMgd2hlbiBuZWVkZWRcbiAgICBpZiAoIXdvcmRTZWdtZW50ZXIpIHdvcmRTZWdtZW50ZXIgPSBzZWdtZW50ZXIgPyBuZXcgc2VnbWVudGVyKFtdLCB7IGdyYW51bGFyaXR5OiB3b3JkVHlwZSB9KSA6IHtcbiAgICAgIHNlZ21lbnQ6ICh0ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgICAgIGNvbnN0IHdvcmRzID0gdGV4dC5zcGxpdCh3aGl0ZVNwYWNlR3JvdXBSZ3gpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHdvcmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSB3b3Jkc1tpXTtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICBpc1dvcmRMaWtlOiAhd2hpdGVTcGFjZVJneC50ZXN0KHNlZ21lbnQpLCAvLyBDb25zaWRlciBub24td2hpdGVzcGFjZSBhcyB3b3JkLWxpa2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWdyYXBoZW1lU2VnbWVudGVyKSBncmFwaGVtZVNlZ21lbnRlciA9IHNlZ21lbnRlciA/IG5ldyBzZWdtZW50ZXIoW10sIHsgZ3JhbnVsYXJpdHk6ICdncmFwaGVtZScgfSkgOiB7XG4gICAgICBzZWdtZW50OiB0ZXh0ID0+IFsuLi50ZXh0XS5tYXAoY2hhciA9PiAoeyBzZWdtZW50OiBjaGFyIH0pKVxuICAgIH07XG4gICAgaWYgKCEkc3BsaXRUZW1wbGF0ZSAmJiBpc0Jyb3dzZXIpICRzcGxpdFRlbXBsYXRlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKHNjb3BlLmN1cnJlbnQpIHNjb3BlLmN1cnJlbnQucmVnaXN0ZXIodGhpcyk7XG4gICAgY29uc3QgeyB3b3JkcywgY2hhcnMsIGxpbmVzLCBhY2Nlc3NpYmxlLCBpbmNsdWRlU3BhY2VzLCBkZWJ1ZyB9ID0gcGFyYW1ldGVycztcbiAgICBjb25zdCAkdGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oKHRhcmdldCA9IGlzQXJyKHRhcmdldCkgPyB0YXJnZXRbMF0gOiB0YXJnZXQpICYmIC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KS5ub2RlVHlwZSA/IHRhcmdldCA6IChnZXROb2RlTGlzdCh0YXJnZXQpIHx8IFtdKVswXSk7XG4gICAgY29uc3QgbGluZVBhcmFtcyA9IGxpbmVzID09PSB0cnVlID8ge30gOiBsaW5lcztcbiAgICBjb25zdCB3b3JkUGFyYW1zID0gd29yZHMgPT09IHRydWUgfHwgaXNVbmQod29yZHMpID8ge30gOiB3b3JkcztcbiAgICBjb25zdCBjaGFyUGFyYW1zID0gY2hhcnMgPT09IHRydWUgPyB7fSA6IGNoYXJzO1xuICAgIHRoaXMuZGVidWcgPSBzZXRWYWx1ZShkZWJ1ZywgZmFsc2UpO1xuICAgIHRoaXMuaW5jbHVkZVNwYWNlcyA9IHNldFZhbHVlKGluY2x1ZGVTcGFjZXMsIGZhbHNlKTtcbiAgICB0aGlzLmFjY2Vzc2libGUgPSBzZXRWYWx1ZShhY2Nlc3NpYmxlLCB0cnVlKTtcbiAgICB0aGlzLmxpbmVzT25seSA9IGxpbmVQYXJhbXMgJiYgKCF3b3JkUGFyYW1zICYmICFjaGFyUGFyYW1zKTtcbiAgICAvKiogQHR5cGUge1N0cmluZ3xmYWxzZXxTcGxpdEZ1bmN0aW9uVmFsdWV9ICovXG4gICAgdGhpcy5saW5lVGVtcGxhdGUgPSBpc09iaihsaW5lUGFyYW1zKSA/IGdlbmVyYXRlVGVtcGxhdGUobGluZVR5cGUsIC8qKiBAdHlwZSB7c3BsaXRUZW1wbGF0ZVBhcmFtc30gKi8obGluZVBhcmFtcykpIDogbGluZVBhcmFtcztcbiAgICAvKiogQHR5cGUge1N0cmluZ3xmYWxzZXxTcGxpdEZ1bmN0aW9uVmFsdWV9ICovXG4gICAgdGhpcy53b3JkVGVtcGxhdGUgPSBpc09iaih3b3JkUGFyYW1zKSB8fCB0aGlzLmxpbmVzT25seSA/IGdlbmVyYXRlVGVtcGxhdGUod29yZFR5cGUsIC8qKiBAdHlwZSB7c3BsaXRUZW1wbGF0ZVBhcmFtc30gKi8od29yZFBhcmFtcykpIDogd29yZFBhcmFtcztcbiAgICAvKiogQHR5cGUge1N0cmluZ3xmYWxzZXxTcGxpdEZ1bmN0aW9uVmFsdWV9ICovXG4gICAgdGhpcy5jaGFyVGVtcGxhdGUgPSBpc09iaihjaGFyUGFyYW1zKSA/IGdlbmVyYXRlVGVtcGxhdGUoY2hhclR5cGUsIC8qKiBAdHlwZSB7c3BsaXRUZW1wbGF0ZVBhcmFtc30gKi8oY2hhclBhcmFtcykpIDogY2hhclBhcmFtcztcbiAgICB0aGlzLiR0YXJnZXQgPSAkdGFyZ2V0O1xuICAgIHRoaXMuaHRtbCA9ICR0YXJnZXQgJiYgJHRhcmdldC5pbm5lckhUTUw7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMud29yZHMgPSBbXTtcbiAgICB0aGlzLmNoYXJzID0gW107XG4gICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgdGhpcy5lZmZlY3RzQ2xlYW51cHMgPSBbXTtcbiAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gbnVsbDtcbiAgICBjb25zdCBoYW5kbGVTcGxpdCA9ICgpID0+IHRoaXMuaHRtbCAmJiAobGluZVBhcmFtcyB8fCB3b3JkUGFyYW1zIHx8IGNoYXJQYXJhbXMpICYmIHRoaXMuc3BsaXQoKTtcbiAgICAvLyBNYWtlIHN1cmUgdGhpcyBpcyBkZWNsYXJlZCBiZWZvcmUgY2FsbGluZyBoYW5kbGVTcGxpdCgpIGluIGNhc2UgcmV2ZXJ0KCkgaXMgY2FsbGVkIGluc2lkZSBhbiBlZmZlY3QgY2FsbGJhY2tcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIC8vIFVzZSBhIHNldFRpbWVvdXQgaW5zdGVhZCBvZiBhIFRpbWVyIGZvciBiZXR0ZXIgdHJlZSBzaGFraW5nXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50V2lkdGggPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLygkdGFyZ2V0KS5vZmZzZXRXaWR0aDtcbiAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCA9PT0gdGhpcy53aWR0aCkgcmV0dXJuO1xuICAgICAgICB0aGlzLndpZHRoID0gY3VycmVudFdpZHRoO1xuICAgICAgICBoYW5kbGVTcGxpdCgpO1xuICAgICAgfSwgMTUwKTtcbiAgICB9KTtcbiAgICAvLyBPbmx5IGRlY2xhcmUgdGhlIGZvbnQgcmVhZHkgcHJvbWlzZSB3aGVuIHNwbGl0dGluZyBieSBsaW5lcyBhbmQgbm90IGFscmVheSBzcGxpdFxuICAgIGlmICh0aGlzLmxpbmVUZW1wbGF0ZSAmJiAhdGhpcy5yZWFkeSkge1xuICAgICAgZG9jLmZvbnRzLnJlYWR5LnRoZW4oaGFuZGxlU3BsaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTcGxpdCgpO1xuICAgIH1cbiAgICAkdGFyZ2V0ID8gdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKCR0YXJnZXQpIDogY29uc29sZS53YXJuKCdObyBUZXh0IFNwbGl0dGVyIHRhcmdldCBmb3VuZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHsoLi4uYXJnczogYW55W10pID0+IFRpY2thYmxlIHwgKCgpID0+IHZvaWQpfSBlZmZlY3RcbiAgICogQHJldHVybiB0aGlzXG4gICAqL1xuICBhZGRFZmZlY3QoZWZmZWN0KSB7XG4gICAgaWYgKCFpc0ZuYyhlZmZlY3QpKSByZXR1cm4gY29uc29sZS53YXJuKCdFZmZlY3QgbXVzdCByZXR1cm4gYSBmdW5jdGlvbi4nKTtcbiAgICBjb25zdCByZWZyZXNoYWJsZUVmZmVjdCA9IGNyZWF0ZVJlZnJlc2hhYmxlKGVmZmVjdCk7XG4gICAgdGhpcy5lZmZlY3RzLnB1c2gocmVmcmVzaGFibGVFZmZlY3QpO1xuICAgIGlmICh0aGlzLnJlYWR5KSB0aGlzLmVmZmVjdHNDbGVhbnVwc1t0aGlzLmVmZmVjdHMubGVuZ3RoIC0gMV0gPSByZWZyZXNoYWJsZUVmZmVjdCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldmVydCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IHRoaXMud29yZHMubGVuZ3RoID0gdGhpcy5jaGFycy5sZW5ndGggPSAwO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIC8vIE1ha2Ugc3VyZSB0byByZXZlcnQgdGhlIGVmZmVjdHMgYWZ0ZXIgZGlzY29ubmVjdGluZyB0aGUgcmVzaXplT2JzZXJ2ZXIgdG8gYXZvaWQgdHJpZ2dlcmluZyBpdCBpbiB0aGUgcHJvY2Vzc1xuICAgIHRoaXMuZWZmZWN0c0NsZWFudXBzLmZvckVhY2goY2xlYW51cCA9PiBpc0ZuYyhjbGVhbnVwKSA/IGNsZWFudXAodGhpcykgOiBjbGVhbnVwLnJldmVydCAmJiBjbGVhbnVwLnJldmVydCgpKTtcbiAgICB0aGlzLiR0YXJnZXQuaW5uZXJIVE1MID0gdGhpcy5odG1sO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHByb2Nlc3NlcyBhIG5vZGUgYW5kIGl0cyBjaGlsZHJlblxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIHNwbGl0Tm9kZShub2RlKSB7XG4gICAgY29uc3Qgd29yZFRlbXBsYXRlID0gdGhpcy53b3JkVGVtcGxhdGU7XG4gICAgY29uc3QgY2hhclRlbXBsYXRlID0gdGhpcy5jaGFyVGVtcGxhdGU7XG4gICAgY29uc3QgaW5jbHVkZVNwYWNlcyA9IHRoaXMuaW5jbHVkZVNwYWNlcztcbiAgICBjb25zdCBkZWJ1ZyA9IHRoaXMuZGVidWc7XG4gICAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIGlmIChub2RlVHlwZSA9PT0gMykge1xuICAgICAgY29uc3Qgbm9kZVRleHQgPSBub2RlLm5vZGVWYWx1ZTtcbiAgICAgIC8vIElmIHRoZSBub2RlVGV4dCBpcyBvbmx5IHdoaXRlc3BhY2UsIGxlYXZlIGl0IGFzIGlzXG4gICAgICBpZiAobm9kZVRleHQudHJpbSgpKSB7XG4gICAgICAgIGNvbnN0IHRlbXBXb3JkcyA9IFtdO1xuICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMud29yZHM7XG4gICAgICAgIGNvbnN0IGNoYXJzID0gdGhpcy5jaGFycztcbiAgICAgICAgY29uc3Qgd29yZFNlZ21lbnRzID0gd29yZFNlZ21lbnRlci5zZWdtZW50KG5vZGVUZXh0KTtcbiAgICAgICAgY29uc3QgJHdvcmRzRnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgcHJldlNlZyA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgd29yZFNlZ21lbnQgb2Ygd29yZFNlZ21lbnRzKSB7XG4gICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHdvcmRTZWdtZW50LnNlZ21lbnQ7XG4gICAgICAgICAgY29uc3QgaXNXb3JkTGlrZSA9IGlzU2VnbWVudFdvcmRMaWtlKHdvcmRTZWdtZW50KTtcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBzZWdtZW50IHNob3VsZCBiZSBhIG5ldyB3b3JkLCBmaXJzdCBzZWdtZW50IGFsd2F5cyBiZWNvbWVzIGEgbmV3IHdvcmRcbiAgICAgICAgICBpZiAoIXByZXZTZWcgfHwgKGlzV29yZExpa2UgJiYgKHByZXZTZWcgJiYgKGlzU2VnbWVudFdvcmRMaWtlKHByZXZTZWcpKSkpKSB7XG4gICAgICAgICAgICB0ZW1wV29yZHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT25seSBjb25jYXRlbmF0ZSBpZiBib3RoIGN1cnJlbnQgYW5kIHByZXZpb3VzIGFyZSBub24td29yZC1saWtlIGFuZCBkb24ndCBjb250YWluIHNwYWNlc1xuICAgICAgICAgICAgY29uc3QgbGFzdFdvcmRJbmRleCA9IHRlbXBXb3Jkcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgbGFzdFdvcmQgPSB0ZW1wV29yZHNbbGFzdFdvcmRJbmRleF07XG4gICAgICAgICAgICBpZiAoIWxhc3RXb3JkLmluY2x1ZGVzKCcgJykgJiYgIXNlZ21lbnQuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICAgICAgICB0ZW1wV29yZHNbbGFzdFdvcmRJbmRleF0gKz0gc2VnbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRlbXBXb3Jkcy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2U2VnID0gd29yZFNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRlbXBXb3Jkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB3b3JkID0gdGVtcFdvcmRzW2ldO1xuICAgICAgICAgIGlmICghd29yZC50cmltKCkpIHtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHdoaXRlc3BhY2Ugb25seSBpZiBpbmNsdWRlU3BhY2VzIGlzIGZhbHNlIGFuZCBpZiB0aGUgY3VycmVudCBzcGFjZSBpcyBub3QgdGhlIGZpcnN0IG5vZGVcbiAgICAgICAgICAgIGlmIChpICYmIGluY2x1ZGVTcGFjZXMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgJHdvcmRzRnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHdvcmQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV4dFdvcmQgPSB0ZW1wV29yZHNbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgaGFzV29yZEZvbGxvd2luZ1NwYWNlID0gaW5jbHVkZVNwYWNlcyAmJiBuZXh0V29yZCAmJiAhbmV4dFdvcmQudHJpbSgpO1xuICAgICAgICAgICAgY29uc3Qgd29yZFRvUHJvY2VzcyA9IHdvcmQ7XG4gICAgICAgICAgICBjb25zdCBjaGFyU2VnbWVudHMgPSBjaGFyVGVtcGxhdGUgPyBncmFwaGVtZVNlZ21lbnRlci5zZWdtZW50KHdvcmRUb1Byb2Nlc3MpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0ICRjaGFyc0ZyYWdtZW50ID0gY2hhclRlbXBsYXRlID8gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSA6IGRvYy5jcmVhdGVUZXh0Tm9kZShoYXNXb3JkRm9sbG93aW5nU3BhY2UgPyB3b3JkICsgJ1xceGEwJyA6IHdvcmQpO1xuICAgICAgICAgICAgaWYgKGNoYXJUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBjb25zdCBjaGFyU2VnbWVudHNBcnJheSA9IFsuLi5jaGFyU2VnbWVudHNdO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBjaGFyU2VnbWVudHNBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhclNlZ21lbnQgPSBjaGFyU2VnbWVudHNBcnJheVtqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0xhc3RDaGFyID0gaiA9PT0gamwgLSAxO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgY2hhcmFjdGVyIGFuZCBpbmNsdWRlU3BhY2VzIGlzIHRydWUgd2l0aCBhIGZvbGxvd2luZyBzcGFjZSwgYXBwZW5kIHRoZSBzcGFjZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJUZXh0ID0gaXNMYXN0Q2hhciAmJiBoYXNXb3JkRm9sbG93aW5nU3BhY2UgPyBjaGFyU2VnbWVudC5zZWdtZW50ICsgJ1xceGEwJyA6IGNoYXJTZWdtZW50LnNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgJGNoYXJOb2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKGNoYXJUZXh0KTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzSFRNTFRlbXBsYXRlKGNoYXJUZW1wbGF0ZSwgY2hhcnMsICRjaGFyTm9kZSwgLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLygkY2hhcnNGcmFnbWVudCksIGNoYXJUeXBlLCBkZWJ1ZywgLTEsIHdvcmRzLmxlbmd0aCwgY2hhcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdvcmRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBwcm9jZXNzSFRNTFRlbXBsYXRlKHdvcmRUZW1wbGF0ZSwgd29yZHMsICRjaGFyc0ZyYWdtZW50LCAkd29yZHNGcmFnbWVudCwgd29yZFR5cGUsIGRlYnVnLCAtMSwgd29yZHMubGVuZ3RoLCBjaGFycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAvLyBDaGFycyBlbGVtZW50cyBtdXN0IGJlIHJlLXBhcnNlZCBpbiB0aGUgc3BsaXQoKSBtZXRob2QgaWYgYm90aCB3b3JkcyBhbmQgY2hhcnMgYXJlIHBhcnNlZFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgJHdvcmRzRnJhZ21lbnQuYXBwZW5kQ2hpbGQoJGNoYXJzRnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHdvcmRzRnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHdvcmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgdGhlIG5leHQgaXRlcmF0aW9uIGlmIHdlIGluY2x1ZGVkIGEgc3BhY2VcbiAgICAgICAgICAgIGlmIChoYXNXb3JkRm9sbG93aW5nU3BhY2UpIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCgkd29yZHNGcmFnbWVudCwgbm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMSkge1xuICAgICAgLy8gQ29udmVydGluZyB0byBhbiBhcnJheSBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgY2hpbGROb2RlcyBwb3R0ZW50aWFsIG11dGF0aW9uXG4gICAgICBjb25zdCBjaGlsZE5vZGVzID0gLyoqIEB0eXBlIHtBcnJheTxOb2RlPn0gKi8oWy4uLi8qKiBAdHlwZSB7Kn0gKi8obm9kZS5jaGlsZE5vZGVzKV0pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykgdGhpcy5zcGxpdE5vZGUoY2hpbGROb2Rlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXJDYWNoZVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc3BsaXQoY2xlYXJDYWNoZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgJGVsID0gdGhpcy4kdGFyZ2V0O1xuICAgIGNvbnN0IGlzQ2FjaGVkID0gISF0aGlzLmNhY2hlICYmICFjbGVhckNhY2hlO1xuICAgIGNvbnN0IGxpbmVUZW1wbGF0ZSA9IHRoaXMubGluZVRlbXBsYXRlO1xuICAgIGNvbnN0IHdvcmRUZW1wbGF0ZSA9IHRoaXMud29yZFRlbXBsYXRlO1xuICAgIGNvbnN0IGNoYXJUZW1wbGF0ZSA9IHRoaXMuY2hhclRlbXBsYXRlO1xuICAgIGNvbnN0IGZvbnRzUmVhZHkgPSBkb2MuZm9udHMuc3RhdHVzICE9PSAnbG9hZGluZyc7XG4gICAgY29uc3QgY2FuU3BsaXRMaW5lcyA9IGxpbmVUZW1wbGF0ZSAmJiBmb250c1JlYWR5O1xuICAgIHRoaXMucmVhZHkgPSAhbGluZVRlbXBsYXRlIHx8IGZvbnRzUmVhZHk7XG4gICAgaWYgKGNhblNwbGl0TGluZXMgfHwgY2xlYXJDYWNoZSkge1xuICAgICAgLy8gTm8gbmVlZCB0byByZXZlcnQgZWZmZWN0cyBhbmltYXRpb25zIGhlcmUgc2luY2UgaXQncyBhbHJlYWR5IHRha2VuIGNhcmUgYnkgdGhlIHJlZnJlc2hhYmxlXG4gICAgICB0aGlzLmVmZmVjdHNDbGVhbnVwcy5mb3JFYWNoKGNsZWFudXAgPT4gaXNGbmMoY2xlYW51cCkgJiYgY2xlYW51cCh0aGlzKSk7XG4gICAgfVxuICAgIGlmICghaXNDYWNoZWQpIHtcbiAgICAgIGlmIChjbGVhckNhY2hlKSB7XG4gICAgICAgICRlbC5pbm5lckhUTUwgPSB0aGlzLmh0bWw7XG4gICAgICAgIHRoaXMud29yZHMubGVuZ3RoID0gdGhpcy5jaGFycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5zcGxpdE5vZGUoJGVsKTtcbiAgICAgIHRoaXMuY2FjaGUgPSAkZWwuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBpZiAoY2FuU3BsaXRMaW5lcykge1xuICAgICAgaWYgKGlzQ2FjaGVkKSAkZWwuaW5uZXJIVE1MID0gdGhpcy5jYWNoZTtcbiAgICAgIHRoaXMubGluZXMubGVuZ3RoID0gMDtcbiAgICAgIGlmICh3b3JkVGVtcGxhdGUpIHRoaXMud29yZHMgPSBnZXRBbGxUb3BMZXZlbEVsZW1lbnRzKCRlbCwgd29yZFR5cGUpO1xuICAgIH1cbiAgICAvLyBBbHdheXMgcmVwYXJzZSBjaGFyYWN0ZXJzIGFmdGVyIGEgbGluZSByZXNldCBvciBpZiBib3RoIHdvcmRzIGFuZCBjaGFycyBhcmUgYWN0aXZhdGVkXG4gICAgaWYgKGNoYXJUZW1wbGF0ZSAmJiAoY2FuU3BsaXRMaW5lcyB8fCB3b3JkVGVtcGxhdGUpKSB7XG4gICAgICB0aGlzLmNoYXJzID0gZ2V0QWxsVG9wTGV2ZWxFbGVtZW50cygkZWwsIGNoYXJUeXBlKTtcbiAgICB9XG4gICAgLy8gV29yZHMgYXJlIHVzZWQgd2hlbiBsaW5lcyBvbmx5IGFuZCBwcmlvcml0aXplZCBvdmVyIGNoYXJzXG4gICAgY29uc3QgZWxlbWVudHNBcnJheSA9IHRoaXMud29yZHMubGVuZ3RoID8gdGhpcy53b3JkcyA6IHRoaXMuY2hhcnM7XG4gICAgbGV0IHksIGxpbmVzQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZWxlbWVudHNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0ICRlbCA9IGVsZW1lbnRzQXJyYXlbaV07XG4gICAgICBjb25zdCB7IHRvcCwgaGVpZ2h0IH0gPSAkZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoeSAmJiB0b3AgLSB5ID4gaGVpZ2h0ICogLjUpIGxpbmVzQ291bnQrKztcbiAgICAgICRlbC5zZXRBdHRyaWJ1dGUoZGF0YUxpbmUsIGAke2xpbmVzQ291bnR9YCk7XG4gICAgICBjb25zdCBuZXN0ZWQgPSAkZWwucXVlcnlTZWxlY3RvckFsbChgWyR7ZGF0YUxpbmV9XWApO1xuICAgICAgbGV0IGMgPSBuZXN0ZWQubGVuZ3RoO1xuICAgICAgd2hpbGUgKGMtLSkgbmVzdGVkW2NdLnNldEF0dHJpYnV0ZShkYXRhTGluZSwgYCR7bGluZXNDb3VudH1gKTtcbiAgICAgIHkgPSB0b3A7XG4gICAgfVxuICAgIGlmIChjYW5TcGxpdExpbmVzKSB7XG4gICAgICBjb25zdCBsaW5lc0ZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBjbG9uZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGxpbmVJbmRleCA9IDA7IGxpbmVJbmRleCA8IGxpbmVzQ291bnQgKyAxOyBsaW5lSW5kZXgrKykge1xuICAgICAgICBjb25zdCAkY2xvbmUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLygkZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgZmlsdGVyTGluZUVsZW1lbnRzKCRjbG9uZSwgbGluZUluZGV4LCBuZXcgU2V0KCkpLmZvckVhY2goJGVsID0+IHtcbiAgICAgICAgICBjb25zdCAkcGFyZW50ID0gJGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgaWYgKCRwYXJlbnQpIHBhcmVudHMuYWRkKCRwYXJlbnQpO1xuICAgICAgICAgICRlbC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsb25lcy5wdXNoKCRjbG9uZSk7XG4gICAgICB9XG4gICAgICBwYXJlbnRzLmZvckVhY2goZmlsdGVyRW1wdHlFbGVtZW50cyk7XG4gICAgICBmb3IgKGxldCBjbG9uZUluZGV4ID0gMCwgY2xvbmVzTGVuZ3RoID0gY2xvbmVzLmxlbmd0aDsgY2xvbmVJbmRleCA8IGNsb25lc0xlbmd0aDsgY2xvbmVJbmRleCsrKSB7XG4gICAgICAgIHByb2Nlc3NIVE1MVGVtcGxhdGUobGluZVRlbXBsYXRlLCB0aGlzLmxpbmVzLCBjbG9uZXNbY2xvbmVJbmRleF0sIGxpbmVzRnJhZ21lbnQsIGxpbmVUeXBlLCB0aGlzLmRlYnVnLCBjbG9uZUluZGV4KTtcbiAgICAgIH1cbiAgICAgICRlbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICRlbC5hcHBlbmRDaGlsZChsaW5lc0ZyYWdtZW50KTtcbiAgICAgIGlmICh3b3JkVGVtcGxhdGUpIHRoaXMud29yZHMgPSBnZXRBbGxUb3BMZXZlbEVsZW1lbnRzKCRlbCwgd29yZFR5cGUpO1xuICAgICAgaWYgKGNoYXJUZW1wbGF0ZSkgdGhpcy5jaGFycyA9IGdldEFsbFRvcExldmVsRWxlbWVudHMoJGVsLCBjaGFyVHlwZSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgd29yZCB3cmFwcGVycyBhbmQgY2xlYXIgdGhlIHdvcmRzIGFycmF5IGlmIGxpbmVzIHNwbGl0IG9ubHlcbiAgICBpZiAodGhpcy5saW5lc09ubHkpIHtcbiAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy53b3JkcztcbiAgICAgIGxldCB3ID0gd29yZHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKHctLSkge1xuICAgICAgICBjb25zdCAkd29yZCA9IHdvcmRzW3ddO1xuICAgICAgICAkd29yZC5yZXBsYWNlV2l0aCgkd29yZC50ZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgICB3b3Jkcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY2Nlc3NpYmxlICYmIChjYW5TcGxpdExpbmVzIHx8ICFpc0NhY2hlZCkpIHtcbiAgICAgIGNvbnN0ICRhY2Nlc3NpYmxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIC8vIE1ha2UgdGhlIGFjY2Vzc2libGUgZWxlbWVudCB2aXN1YWxseS1oaWRkZW4gKGh0dHBzOi8vd3d3LnNjb3R0b2hhcmEubWUvYmxvZy8yMDE3LzA0LzE0L2luY2x1c2l2ZWx5LWhpZGRlbi5odG1sKVxuICAgICAgJGFjY2Vzc2libGUuc3R5bGUuY3NzVGV4dCA9IGBwb3NpdGlvbjphYnNvbHV0ZTtvdmVyZmxvdzpoaWRkZW47Y2xpcDpyZWN0KDAgMCAwIDApO2NsaXAtcGF0aDppbnNldCg1MCUpO3dpZHRoOjFweDtoZWlnaHQ6MXB4O3doaXRlLXNwYWNlOm5vd3JhcDtgO1xuICAgICAgLy8gJGFjY2Vzc2libGUuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgJGFjY2Vzc2libGUuaW5uZXJIVE1MID0gdGhpcy5odG1sO1xuICAgICAgJGVsLmluc2VydEJlZm9yZSgkYWNjZXNzaWJsZSwgJGVsLmZpcnN0Q2hpbGQpO1xuICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKHNldEFyaWFIaWRkZW4pO1xuICAgICAgdGhpcy53b3Jkcy5mb3JFYWNoKHNldEFyaWFIaWRkZW4pO1xuICAgICAgdGhpcy5jaGFycy5mb3JFYWNoKHNldEFyaWFIaWRkZW4pO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oJGVsKS5vZmZzZXRXaWR0aDtcbiAgICBpZiAoY2FuU3BsaXRMaW5lcyB8fCBjbGVhckNhY2hlKSB7XG4gICAgICB0aGlzLmVmZmVjdHMuZm9yRWFjaCgoZWZmZWN0LCBpKSA9PiB0aGlzLmVmZmVjdHNDbGVhbnVwc1tpXSA9IGVmZmVjdCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnNwbGl0KHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR8Tm9kZUxpc3R8U3RyaW5nfEFycmF5PEhUTUxFbGVtZW50Pn0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtUZXh0U3BsaXR0ZXJQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICogQHJldHVybiB7VGV4dFNwbGl0dGVyfVxuICovXG5jb25zdCBzcGxpdCA9ICh0YXJnZXQsIHBhcmFtZXRlcnMpID0+IG5ldyBUZXh0U3BsaXR0ZXIodGFyZ2V0LCBwYXJhbWV0ZXJzKTtcblxuY29uc3QgdGV4dCA9IHtcbiAgc3BsaXQsXG59O1xuXG5cblxuXG4vKipcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtTdGFnZ2VyUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybiB7U3RhZ2dlckZ1bmN0aW9uPE51bWJlcj59XG4gKi9cbi8qKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcGFyYW0ge1N0YWdnZXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb248U3RyaW5nPn1cbiAqL1xuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gdmFsXG4gKiBAcGFyYW0ge1N0YWdnZXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb248TnVtYmVyPn1cbiAqL1xuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7W1N0cmluZywgU3RyaW5nXX0gdmFsXG4gKiBAcGFyYW0ge1N0YWdnZXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb248U3RyaW5nPn1cbiAqL1xuLyoqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8W051bWJlciwgTnVtYmVyXXxbU3RyaW5nLCBTdHJpbmddfSB2YWwgVGhlIHN0YWdnZXJlZCB2YWx1ZSBvciByYW5nZVxuICogQHBhcmFtIHtTdGFnZ2VyUGFyYW1zfSBbcGFyYW1zXSBUaGUgc3RhZ2dlciBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb248TnVtYmVyfFN0cmluZz59XG4gKi9cbmNvbnN0IHN0YWdnZXIgPSAodmFsLCBwYXJhbXMgPSB7fSkgPT4ge1xuICBsZXQgdmFsdWVzID0gW107XG4gIGxldCBtYXhWYWx1ZSA9IDA7XG4gIGNvbnN0IGZyb20gPSBwYXJhbXMuZnJvbTtcbiAgY29uc3QgcmV2ZXJzZWQgPSBwYXJhbXMucmV2ZXJzZWQ7XG4gIGNvbnN0IGVhc2UgPSBwYXJhbXMuZWFzZTtcbiAgY29uc3QgaGFzRWFzaW5nID0gIWlzVW5kKGVhc2UpO1xuICBjb25zdCBoYXNTcHJpbmcgPSBoYXNFYXNpbmcgJiYgIWlzVW5kKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgY29uc3Qgc3RhZ2dlckVhc2UgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSA6IGhhc0Vhc2luZyA/IHBhcnNlRWFzaW5ncyhlYXNlKSA6IG51bGw7XG4gIGNvbnN0IGdyaWQgPSBwYXJhbXMuZ3JpZDtcbiAgY29uc3QgYXhpcyA9IHBhcmFtcy5heGlzO1xuICBjb25zdCBjdXN0b21Ub3RhbCA9IHBhcmFtcy50b3RhbDtcbiAgY29uc3QgZnJvbUZpcnN0ID0gaXNVbmQoZnJvbSkgfHwgZnJvbSA9PT0gMCB8fCBmcm9tID09PSAnZmlyc3QnO1xuICBjb25zdCBmcm9tQ2VudGVyID0gZnJvbSA9PT0gJ2NlbnRlcic7XG4gIGNvbnN0IGZyb21MYXN0ID0gZnJvbSA9PT0gJ2xhc3QnO1xuICBjb25zdCBmcm9tUmFuZG9tID0gZnJvbSA9PT0gJ3JhbmRvbSc7XG4gIGNvbnN0IGlzUmFuZ2UgPSBpc0Fycih2YWwpO1xuICBjb25zdCB1c2VQcm9wID0gcGFyYW1zLnVzZTtcbiAgY29uc3QgdmFsMSA9IGlzUmFuZ2UgPyBwYXJzZU51bWJlcih2YWxbMF0pIDogcGFyc2VOdW1iZXIodmFsKTtcbiAgY29uc3QgdmFsMiA9IGlzUmFuZ2UgPyBwYXJzZU51bWJlcih2YWxbMV0pIDogMDtcbiAgY29uc3QgdW5pdE1hdGNoID0gdW5pdHNFeGVjUmd4LmV4ZWMoKGlzUmFuZ2UgPyB2YWxbMV0gOiB2YWwpICsgZW1wdHlTdHJpbmcpO1xuICBjb25zdCBzdGFydCA9IHBhcmFtcy5zdGFydCB8fCAwICsgKGlzUmFuZ2UgPyB2YWwxIDogMCk7XG4gIGxldCBmcm9tSW5kZXggPSBmcm9tRmlyc3QgPyAwIDogaXNOdW0oZnJvbSkgPyBmcm9tIDogMDtcbiAgcmV0dXJuICh0YXJnZXQsIGksIHQsIHRsKSA9PiB7XG4gICAgY29uc3QgWyByZWdpc3RlcmVkVGFyZ2V0IF0gPSByZWdpc3RlclRhcmdldHModGFyZ2V0KTtcbiAgICBjb25zdCB0b3RhbCA9IGlzVW5kKGN1c3RvbVRvdGFsKSA/IHQgOiBjdXN0b21Ub3RhbDtcbiAgICBjb25zdCBjdXN0b21JbmRleCA9ICFpc1VuZCh1c2VQcm9wKSA/IGlzRm5jKHVzZVByb3ApID8gdXNlUHJvcChyZWdpc3RlcmVkVGFyZ2V0LCBpLCB0b3RhbCkgOiBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZShyZWdpc3RlcmVkVGFyZ2V0LCB1c2VQcm9wKSA6IGZhbHNlO1xuICAgIGNvbnN0IHN0YWdnZXJJbmRleCA9IGlzTnVtKGN1c3RvbUluZGV4KSB8fCBpc1N0cihjdXN0b21JbmRleCkgJiYgaXNOdW0oK2N1c3RvbUluZGV4KSA/ICtjdXN0b21JbmRleCA6IGk7XG4gICAgaWYgKGZyb21DZW50ZXIpIGZyb21JbmRleCA9ICh0b3RhbCAtIDEpIC8gMjtcbiAgICBpZiAoZnJvbUxhc3QpIGZyb21JbmRleCA9IHRvdGFsIC0gMTtcbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0b3RhbDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoIWdyaWQpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChhYnMoZnJvbUluZGV4IC0gaW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmcm9tWCA9ICFmcm9tQ2VudGVyID8gZnJvbUluZGV4ICUgZ3JpZFswXSA6IChncmlkWzBdIC0gMSkgLyAyO1xuICAgICAgICAgIGNvbnN0IGZyb21ZID0gIWZyb21DZW50ZXIgPyBmbG9vcihmcm9tSW5kZXggLyBncmlkWzBdKSA6IChncmlkWzFdIC0gMSkgLyAyO1xuICAgICAgICAgIGNvbnN0IHRvWCA9IGluZGV4ICUgZ3JpZFswXTtcbiAgICAgICAgICBjb25zdCB0b1kgPSBmbG9vcihpbmRleCAvIGdyaWRbMF0pO1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlWSA9IGZyb21ZIC0gdG9ZO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB2YWx1ZSA9IC1kaXN0YW5jZVg7XG4gICAgICAgICAgaWYgKGF4aXMgPT09ICd5JykgdmFsdWUgPSAtZGlzdGFuY2VZO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhWYWx1ZSA9IG1heCguLi52YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWdnZXJFYXNlKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHZhbCA9PiBzdGFnZ2VyRWFzZSh2YWwgLyBtYXhWYWx1ZSkgKiBtYXhWYWx1ZSk7XG4gICAgICBpZiAocmV2ZXJzZWQpIHZhbHVlcyA9IHZhbHVlcy5tYXAodmFsID0+IGF4aXMgPyAodmFsIDwgMCkgPyB2YWwgKiAtMSA6IC12YWwgOiBhYnMobWF4VmFsdWUgLSB2YWwpKTtcbiAgICAgIGlmIChmcm9tUmFuZG9tKSB2YWx1ZXMgPSBzaHVmZmxlKHZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnN0IHNwYWNpbmcgPSBpc1JhbmdlID8gKHZhbDIgLSB2YWwxKSAvIG1heFZhbHVlIDogdmFsMTtcbiAgICBjb25zdCBvZmZzZXQgPSB0bCA/IHBhcnNlVGltZWxpbmVQb3NpdGlvbih0bCwgaXNVbmQocGFyYW1zLnN0YXJ0KSA/IHRsLml0ZXJhdGlvbkR1cmF0aW9uIDogc3RhcnQpIDogLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHN0YXJ0KTtcbiAgICAvKiogQHR5cGUge1N0cmluZ3xOdW1iZXJ9ICovXG4gICAgbGV0IG91dHB1dCA9IG9mZnNldCArICgoc3BhY2luZyAqIHJvdW5kKHZhbHVlc1tzdGFnZ2VySW5kZXhdLCAyKSkgfHwgMCk7XG4gICAgaWYgKHBhcmFtcy5tb2RpZmllcikgb3V0cHV0ID0gcGFyYW1zLm1vZGlmaWVyKG91dHB1dCk7XG4gICAgaWYgKHVuaXRNYXRjaCkgb3V0cHV0ID0gYCR7b3V0cHV0fSR7dW5pdE1hdGNoWzJdfWA7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuZXhwb3J0IHsgQW5pbWF0YWJsZSwgRHJhZ2dhYmxlLCBKU0FuaW1hdGlvbiwgU2NvcGUsIFNjcm9sbE9ic2VydmVyLCBTcHJpbmcsIFRleHRTcGxpdHRlciwgVGltZWxpbmUsIFRpbWVyLCBXQUFQSUFuaW1hdGlvbiwgYW5pbWF0ZSwgY3JlYXRlQW5pbWF0YWJsZSwgY3JlYXRlRHJhZ2dhYmxlLCBjcmVhdGVTY29wZSwgY3JlYXRlU3ByaW5nLCBjcmVhdGVUaW1lbGluZSwgY3JlYXRlVGltZXIsIGVhc2VzLCBlbmdpbmUsIG9uU2Nyb2xsLCBzY3JvbGxDb250YWluZXJzLCBzdGFnZ2VyLCBzdmcsIHRleHQsIHV0aWxzLCB3YWFwaSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/animejs@4.1.4/node_modules/animejs/lib/anime.esm.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/.pnpm/next@15.1.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fmodules%2Flayout%2Fcomponents%2FSeasonalIcon.tsx%22%2C%22ids%22%3A%5B%22SeasonalIcon%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2Fgoogle%2Fga.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2Fgoogle%2Fgtm.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2F%40next%2Bthird-parties%4015.1.4_next%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0__react%4019.0.0%2Fnode_modules%2F%40next%2Fthird-parties%2Fdist%2FThirdPartyScriptEmbed.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fscript.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22modules%2Flayout%2Ffonts.ts%5C%22%2C%5C%22import%5C%22%3A%5C%22Red_Hat_Text%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22redHatText%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fsathira%2FProjects%2Fgrotto%2Fnode_modules%2F.pnpm%2Fnext%4015.1.4_react-dom%4019.0.0_react%4019.0.0__react%4019.0.0%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22modules%2Flayout%2Ffonts.ts%5C%22%2C%5C%22import%5C%22%3A%5C%22Red_Hat_Mono%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22redHatMono%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);